<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第九章：智能合约安全 - 区块链稳定币教程</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">稳定币教程</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">☰</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">首页</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">引言</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">章节</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">第1章：区块链基础</a>
                        <a href="chapter2.html" class="dropdown-item">第2章：稳定币分类</a>
                        <a href="chapter3.html" class="dropdown-item">第3章：ERC-20标准</a>
                        <a href="chapter4.html" class="dropdown-item">第4章：抵押型设计</a>
                        <a href="chapter5.html" class="dropdown-item">第5章：数学模型</a>
                        <a href="chapter6.html" class="dropdown-item">第6章：AMM集成</a>
                        <a href="chapter7.html" class="dropdown-item">第7章：借贷协议</a>
                        <a href="chapter8.html" class="dropdown-item">第8章：收益策略</a>
                        <a href="chapter9.html" class="dropdown-item">第9章：智能合约安全</a>
                        <a href="chapter10.html" class="dropdown-item">第10章：经济攻击</a>
                        <a href="chapter11.html" class="dropdown-item">第11章：未来方向</a>
                        <a href="chapter12.html" class="dropdown-item">第12章：生产部署</a>
                        <a href="chapter13.html" class="dropdown-item">第13章：生态集成</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="index.html#resources" class="nav-link">资源</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- 头部 -->
    <header id="top">
        <div class="container">
            <h1>第九章：智能合约安全</h1>
        </div>
    </header>
    
    <!-- 主要内容 -->
    <div class="container">
        <div class="chapter">
<h2>第九章：智能合约安全</h2>
        
        <p>经过前八章的学习，我们已经掌握了稳定币的设计原理、实现技术和各种应用场景。然而，所有这些努力都可能因为一个小小的安全漏洞而功亏一篑。本章将全面剖析智能合约安全，特别是稳定币系统特有的安全挑战。从经典的重入攻击到复杂的治理攻击，从代码审计技巧到形式化验证方法，我们将构建一个完整的安全防护体系。记住，在区块链世界中，代码即法律，而安全就是这部法律的守护者。</p>
        
        <div class="intro-box">
            <strong>本章概览：</strong>
            <ul>
                <li>稳定币安全威胁全景分析</li>
                <li>常见漏洞模式与防御措施</li>
                <li>安全开发生命周期与最佳实践</li>
                <li>高级安全模式（断路器、时间锁、多签）</li>
                <li>安全审计流程与自动化测试工具</li>
            </ul>
        </div>

        <h3 id="security-threats">9.1 稳定币安全威胁全景</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>🛡️ 安全：稳定币系统的生命线</h4>
            <p>在DeFi世界中，安全不是选项，而是必需品。一个小小的漏洞可能导致数百万美元的损失，更重要的是，它会永久性地破坏用户信任。稳定币作为DeFi的基础设施，其安全性要求更是严苛。</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>🎯 为什么稳定币安全格外重要：</h5>
                <ol>
                    <li><strong>系统性影响</strong>：稳定币是其他DeFi协议的基石</li>
                    <li><strong>价值集中</strong>：往往锁定巨额资金（数十亿美元）</li>
                    <li><strong>攻击动机强</strong>：稳定的价值使其成为理想攻击目标</li>
                    <li><strong>复杂度高</strong>：涉及预言机、治理、跨链等多个攻击面</li>
                </ol>
            </div>
        </div>
        
        <div class="info-box">
            <h4>📊 2023-2024年DeFi安全态势</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">统计项</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">2023年</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">2024年（截至Q3）</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">趋势</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>总损失金额</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$1.8B</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$1.2B</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📉 下降33%</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>攻击数量</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">425次</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">312次</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📉 减少</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>平均损失</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$4.2M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$3.8M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📉 略降</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>主要攻击类型</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">闪电贷（35%）</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">预言机操纵（42%）</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔄 变化</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>稳定币相关</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">12%的攻击</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">18%的攻击</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📈 上升</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>资金追回率</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">8%</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">15%</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📈 改善</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="warning-box">
            <h4>⚠️ 稳定币安全的独特挑战</h4>
            <ul>
                <li><strong>价格稳定机制</strong>：复杂的算法和反馈循环增加攻击面</li>
                <li><strong>多资产抵押</strong>：不同资产的风险特征需要综合考虑</li>
                <li><strong>跨协议依赖</strong>：与AMM、借贷协议的深度集成</li>
                <li><strong>治理复杂性</strong>：去中心化治理与安全性的平衡</li>
                <li><strong>监管压力</strong>：合规要求可能引入新的中心化风险</li>
            </ul>
        </div>
        
        <div class="theory-section">
            <h4>9.1.1 安全威胁分类体系</h4>
            <p>稳定币系统的安全威胁呈现多层次、多维度的特征：</p>
            
            <h5>1. 代码层面威胁</h5>
            <ul>
                <li><strong>重入攻击（Reentrancy）</strong>：外部调用期间的状态不一致</li>
                <li><strong>整数溢出/下溢</strong>：算术运算的边界条件错误</li>
                <li><strong>访问控制缺陷</strong>：权限管理不当导致的越权操作</li>
                <li><strong>逻辑错误</strong>：业务逻辑实现与设计不符</li>
                <li><strong>精度损失</strong>：不同小数位代币的转换错误</li>
                <li><strong>非标准ERC20处理</strong>：部分代币不返回布尔值</li>
            </ul>
            
            <h5>重入攻击详解</h5>
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 示例1：经典重入攻击
contract VulnerableVault {
    mapping(address => uint256) public balances;
    
    // 基础版漏洞：状态更新在外部调用之后
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // 危险：先转账，后更新状态
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        balances[msg.sender] -= amount;  // 攻击者可以在此之前再次调用withdraw
    }
}

// 修复版：检查-生效-交互模式
contract SecureVault {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external {
        // 检查
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // 生效：先更新状态
        balances[msg.sender] -= amount;
        
        // 交互：最后进行外部调用
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}

// 进阶版：只读重入攻击
contract ReadOnlyReentrancy {
    uint256 public totalShares;
    mapping(address => uint256) public shares;
    
    // 漏洞：在外部调用期间，totalShares可能不准确
    function withdraw() external {
        uint256 userShares = shares[msg.sender];
        require(userShares > 0, "No shares");
        
        // 计算份额价值
        uint256 value = (address(this).balance * userShares) / totalShares;
        
        // 更新状态
        shares[msg.sender] = 0;
        totalShares -= userShares;
        
        // 外部调用
        IExternalContract(externalContract).notifyWithdrawal(msg.sender, value);
        // 问题：如果notifyWithdrawal调用了getSharePrice()，
        // 它会看到更新后的totalShares，但余额还没有转出
        
        payable(msg.sender).transfer(value);
    }
    
    // 只读函数，但可能返回不一致的状态
    function getSharePrice() external view returns (uint256) {
        if (totalShares == 0) return 0;
        return address(this).balance / totalShares;
    }
}

// 完全修复版：使用ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract FullySecureVault is ReentrancyGuard {
    mapping(address => uint256) public shares;
    uint256 public totalShares;
    
    function withdraw() external nonReentrant {
        uint256 userShares = shares[msg.sender];
        require(userShares > 0, "No shares");
        
        uint256 value = (address(this).balance * userShares) / totalShares;
        
        shares[msg.sender] = 0;
        totalShares -= userShares;
        
        // nonReentrant修饰符保护所有外部调用
        IExternalContract(externalContract).notifyWithdrawal(msg.sender, value);
        payable(msg.sender).transfer(value);
    }
}</code></pre>
                </div>
            </div>
            
            <h5>2. 架构层面威胁</h5>
            <ul>
                <li><strong>预言机操纵</strong>：价格源被恶意控制</li>
                <li><strong>治理攻击</strong>：通过治理机制窃取控制权</li>
                <li><strong>跨链桥漏洞</strong>：跨链通信的安全薄弱点</li>
                <li><strong>组合性风险</strong>：与其他协议交互产生的新风险</li>
            </ul>
            
            <h5>3. 经济层面威胁</h5>
            <ul>
                <li><strong>闪电贷攻击</strong>：利用原子性交易进行价格操纵</li>
                <li><strong>MEV攻击</strong>：矿工/验证者的交易排序攻击</li>
                <li><strong>银行挤兑</strong>：大规模赎回导致的流动性危机</li>
                <li><strong>死亡螺旋</strong>：负反馈循环导致的系统崩溃</li>
            </ul>
        </div>

        <div class="practice-section">
            <h4>9.1.2 历史攻击案例分析</h4>
            
            <div class="example-box" style="background-color: #fee2e2; margin: 20px 0;">
                <h4>💥 重大稳定币安全事件时间线</h4>
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background-color: #fef3c7;">
                            <th style="border: 1px solid #f59e0b; padding: 12px;">时间</th>
                            <th style="border: 1px solid #f59e0b; padding: 12px;">项目</th>
                            <th style="border: 1px solid #f59e0b; padding: 12px;">损失</th>
                            <th style="border: 1px solid #f59e0b; padding: 12px;">攻击类型</th>
                            <th style="border: 1px solid #f59e0b; padding: 12px;">关键教训</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">2022.05</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;"><strong>UST/Luna</strong></td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">$60B</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">死亡螺旋</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">纯算法稳定币的脆弱性</td>
                        </tr>
                        <tr style="background-color: #fef9e7;">
                            <td style="border: 1px solid #f59e0b; padding: 12px;">2023.03</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;"><strong>USDC</strong></td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">脱锚13%</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">银行风险</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">中心化储备的系统性风险</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">2023.07</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;"><strong>crvUSD</strong></td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">$70M</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">重入攻击</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">编译器漏洞的连锁效应</td>
                        </tr>
                        <tr style="background-color: #fef9e7;">
                            <td style="border: 1px solid #f59e0b; padding: 12px;">2024.01</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;"><strong>Platypus</strong></td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">$8.5M</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">闪电贷</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">紧急提款机制的漏洞</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">2024.04</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;"><strong>某算法稳定币</strong></td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">$12M</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">预言机操纵</td>
                            <td style="border: 1px solid #f59e0b; padding: 12px;">单一价格源的危险</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="tip-box">
                <p><strong>🔍 深度分析要点：</strong>每个攻击案例都暴露了特定的系统性弱点。理解这些弱点不仅帮助我们构建更安全的系统，也让我们认识到安全是一个持续演进的过程。</p>
            </div>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 案例1：UST/Luna 死亡螺旋（2022年5月）
// 攻击向量：大规模UST抛售 → Luna增发 → 价格下跌 → 更多增发
contract TerraUSDVulnerability {
    // 问题：算法稳定机制依赖单一资产价值
    // Luna价格下跌时，需要增发更多Luna来维持UST锚定
    
    function mint(uint256 ustAmount) external {
        uint256 lunaPrice = getOraclePrice();
        // 致命缺陷：无增发上限，无熔断机制
        uint256 lunaToMint = ustAmount / lunaPrice;
        _mintLuna(msg.sender, lunaToMint);
    }
}

// 案例2：Euler Finance 攻击（2023年3月，损失1.97亿美元）
contract EulerVulnerability {
    // 问题：donate功能与杠杆机制的组合漏洞
    
    function donateToReserves(uint256 amount) external {
        // 缺陷：未检查donate后的健康因子
        reserves += amount;
        // 攻击者通过donate操作破坏了会计系统
    }
    
    function liquidate(address borrower) external {
        // 清算逻辑依赖被操纵的储备金数据
        uint256 collateral = getCollateralValue(borrower);
        // 导致不当清算
    }
}

// 案例3：Platypus Finance 攻击（2023年2月，损失850万美元）
contract PlatypusVulnerability {
    mapping(address => uint256) public balances;
    
    // 问题：紧急提款功能的逻辑错误
    function emergencyWithdraw() external {
        uint256 amount = balances[msg.sender];
        // 致命错误：使用了错误的余额计算
        // 应该考虑负债，但只检查了资产
        _transfer(msg.sender, amount);
        balances[msg.sender] = 0;
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h4>9.1.3 MEV攻击与防护</h4>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>⚡ MEV：区块链的暗黑森林</h4>
            <p>MEV（最大可提取价值）代表着区块链中的"暗黑森林"法则。在这个世界里，每一笔交易都可能成为猎物，而MEV搜索者就是潜伏在黑暗中的猎人。对于稳定币系统，MEV攻击可能导致用户损失、系统不稳定甚至协议崩溃。</p>
        </div>
        
        <div class="warning-box">
            <p><strong>MEV（最大可提取价值）</strong>是对任何链上金融系统（尤其是稳定币）的巨大威胁。MEV机器人可以通过重新排序、插入或审查交易来获利。</p>
        </div>
        
        <div class="info-box">
            <h4>🎯 常见MEV攻击类型与稳定币影响</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">攻击类型</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">攻击原理</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">稳定币影响</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">防护难度</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>三明治攻击</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">前置+后置交易夹击用户</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">铸造/赎回滑点损失</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中等</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>抢先交易</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">复制并抢先执行获利交易</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">套利机会被夺取</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟢 较易</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>尾随攻击</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">在大额交易后立即反向交易</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">价格操纵风险</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中等</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>清算抢跑</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">抢先执行有利可图的清算</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">清算激励机制失效</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 困难</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>时间强盗</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">重组区块获取MEV</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">交易最终性风险</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 极难</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="example-box" style="background-color: #fef3c7; margin: 20px 0;">
            <h4>💰 MEV数据洞察（2024年）</h4>
            <ul>
                <li><strong>每日MEV总额</strong>：$2-5M（以太坊主网）</li>
                <li><strong>稳定币相关MEV</strong>：占总MEV的15-20%</li>
                <li><strong>最大单笔MEV</strong>：$8.1M（Curve池套利）</li>
                <li><strong>平均三明治攻击损失</strong>：交易额的0.3-0.5%</li>
                <li><strong>受影响用户比例</strong>：大额交易的35%+</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header">
                Solidity 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// MEV三明治攻击示例
contract VulnerableStablecoinSwap {
    IUniswapV2Router public router;
    IERC20 public stablecoin;
    
    // 漏洞：直接在DEX上交易，容易被MEV攻击
    function swapStablecoinForETH(uint256 amount) external {
        stablecoin.transferFrom(msg.sender, address(this), amount);
        stablecoin.approve(address(router), amount);
        
        address[] memory path = new address[](2);
        path[0] = address(stablecoin);
        path[1] = router.WETH();
        
        // MEV机器人可以：
        // 1. 前置交易：在用户交易前买入ETH
        // 2. 用户交易执行，推高ETH价格
        // 3. 后置交易：卖出ETH获利
        router.swapExactTokensForETH(
            amount,
            0,  // 没有滑点保护
            path,
            msg.sender,
            block.timestamp
        );
    }
}

// MEV防护方案
contract MEVProtectedStablecoinSwap {
    using SafeERC20 for IERC20;
    
    IUniswapV2Router public immutable router;
    IERC20 public immutable stablecoin;
    
    // 防护措施1：提交-揭示模式
    mapping(address => bytes32) private commitments;
    mapping(address => uint256) private commitTimestamps;
    
    function commitSwap(bytes32 commitment) external {
        commitments[msg.sender] = commitment;
        commitTimestamps[msg.sender] = block.timestamp;
    }
    
    function executeSwap(
        uint256 amount,
        uint256 minAmountOut,
        uint256 deadline,
        uint256 nonce
    ) external {
        // 验证承诺
        require(
            block.timestamp >= commitTimestamps[msg.sender] + 1 minutes,
            "Too early"
        );
        
        bytes32 commitment = keccak256(abi.encodePacked(
            msg.sender,
            amount,
            minAmountOut,
            deadline,
            nonce
        ));
        require(commitments[msg.sender] == commitment, "Invalid commitment");
        
        // 清除承诺
        delete commitments[msg.sender];
        delete commitTimestamps[msg.sender];
        
        // 防护措施2：滑点保护
        require(deadline >= block.timestamp, "Expired");
        
        stablecoin.safeTransferFrom(msg.sender, address(this), amount);
        stablecoin.safeApprove(address(router), amount);
        
        address[] memory path = new address[](2);
        path[0] = address(stablecoin);
        path[1] = router.WETH();
        
        uint256[] memory amounts = router.swapExactTokensForETH(
            amount,
            minAmountOut,  // 滑点保护
            path,
            msg.sender,
            deadline
        );
        
        emit SwapExecuted(msg.sender, amount, amounts[1]);
    }
    
    // 防护措施3：使用私有交易池
    function privateSwap(
        uint256 amount,
        uint256 minAmountOut,
        bytes calldata signature
    ) external {
        // 通过Flashbots或其他私有RPC提交
        // 验证签名确保只有授权的builder可以包含此交易
        // ...
    }
}

// 防护措施4：批量拍卖机制
contract BatchAuctionSwap {
    struct Order {
        address user;
        uint256 amountIn;
        uint256 minAmountOut;
    }
    
    Order[] public pendingOrders;
    uint256 public auctionEndTime;
    
    function submitOrder(uint256 amountIn, uint256 minAmountOut) external {
        require(block.timestamp < auctionEndTime, "Auction ended");
        
        pendingOrders.push(Order({
            user: msg.sender,
            amountIn: amountIn,
            minAmountOut: minAmountOut
        }));
        
        stablecoin.transferFrom(msg.sender, address(this), amountIn);
    }
    
    function executeBatch() external {
        require(block.timestamp >= auctionEndTime, "Auction not ended");
        
        // 所有订单同时执行，消除MEV机会
        uint256 totalAmountIn = 0;
        for (uint i = 0; i < pendingOrders.length; i++) {
            totalAmountIn += pendingOrders[i].amountIn;
        }
        
        // 执行单次大交易
        uint256 totalAmountOut = _performSwap(totalAmountIn);
        
        // 按比例分配
        for (uint i = 0; i < pendingOrders.length; i++) {
            Order memory order = pendingOrders[i];
            uint256 amountOut = (totalAmountOut * order.amountIn) / totalAmountIn;
            
            require(amountOut >= order.minAmountOut, "Slippage");
            payable(order.user).transfer(amountOut);
        }
        
        delete pendingOrders;
    }
}</code></pre>
            </div>
        </div>
        
        <h4>9.1.4 签名重放攻击与EIP-712</h4>
        
        <p>对于支持permit功能（EIP-2612）的稳定币，签名重放攻击是一个重要威胁：</p>
        
        <div class="code-block">
            <div class="code-header">
                Solidity 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// EIP-712结构化数据签名
contract SecurePermitStablecoin is ERC20, EIP712 {
    // EIP-2612 permit
    mapping(address => uint256) public nonces;
    
    bytes32 private constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );
    
    constructor() ERC20("Secure Stablecoin", "SSTBL") 
        EIP712("Secure Stablecoin", "1") {}
    
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // 防护措施1：检查截止时间
        require(block.timestamp <= deadline, "Expired");
        
        // 防护措施2：使用nonce防止重放
        uint256 currentNonce = nonces[owner]++;
        
        // 防护措施3：使用EIP-712结构化数据
        bytes32 structHash = keccak256(abi.encode(
            PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            currentNonce,
            deadline
        ));
        
        bytes32 hash = _hashTypedDataV4(structHash);
        
        // 验证签名
        address signer = ECDSA.recover(hash, v, r, s);
        require(signer == owner, "Invalid signature");
        
        _approve(owner, spender, value);
    }
    
    // 防护措施4：domain separator防止跨链重放
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparatorV4();
    }
}

// 错误示例：没有防护的permit
contract VulnerablePermit {
    mapping(address => mapping(address => uint256)) public allowances;
    
    // 漏洞：没有nonce，签名可以被重放
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        bytes32 hash = keccak256(abi.encodePacked(
            owner,
            spender,
            value
        ));
        
        address signer = ecrecover(hash, v, r, s);
        require(signer == owner, "Invalid signature");
        
        // 攻击者可以重放这个签名多次
        allowances[owner][spender] = value;
    }
}

// 高级防护：支持取消和批量permit
contract AdvancedPermit is SecurePermitStablecoin {
    mapping(bytes32 => bool) public cancelledPermits;
    
    // 允许用户取消未使用的permit
    function cancelPermit(
        address spender,
        uint256 value,
        uint256 deadline,
        uint256 nonce
    ) external {
        bytes32 permitId = keccak256(abi.encodePacked(
            msg.sender,
            spender,
            value,
            deadline,
            nonce
        ));
        
        cancelledPermits[permitId] = true;
        emit PermitCancelled(permitId);
    }
    
    // 批量permit以节省gas
    function batchPermit(
        address[] calldata owners,
        address[] calldata spenders,
        uint256[] calldata values,
        uint256[] calldata deadlines,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) external {
        require(
            owners.length == spenders.length &&
            owners.length == values.length &&
            owners.length == deadlines.length &&
            owners.length == vs.length &&
            owners.length == rs.length &&
            owners.length == ss.length,
            "Length mismatch"
        );
        
        for (uint i = 0; i < owners.length; i++) {
            permit(
                owners[i],
                spenders[i],
                values[i],
                deadlines[i],
                vs[i],
                rs[i],
                ss[i]
            );
        }
    }
}</code></pre>
            </div>
        </div>

        <h4>9.1.5 逻辑漏洞（Logic Bugs）</h4>
        <p>逻辑漏洞是审计中发现最多的问题类别，通常源于业务逻辑的实现错误。</p>
        
        <div class="code-block collapsible">
            <div class="code-header" onclick="toggleCode(this)">
                <span class="toggle-icon">▼</span>
                <span>状态机设计缺陷示例</span>
            </div>
            <pre class="collapsed"><code class="language-solidity">// 错误的奖励计算逻辑
contract FlawedRewardSystem {
    mapping(address => uint256) public stakes;
    mapping(address => uint256) public lastClaimTime;
    uint256 public rewardRate = 100; // 每秒奖励率
    
    // 漏洞：未考虑质押金额变化的时间点
    function claimRewards() external {
        uint256 timePassed = block.timestamp - lastClaimTime[msg.sender];
        // 错误：使用当前质押金额计算历史奖励
        uint256 rewards = stakes[msg.sender] * rewardRate * timePassed;
        lastClaimTime[msg.sender] = block.timestamp;
        // 转账奖励...
    }
    
    function stake(uint256 amount) external {
        // 漏洞：未在质押前结算之前的奖励
        stakes[msg.sender] += amount;
        // 用户可以在claim前大量质押，获取不当奖励
    }
}

// 正确实现
contract SecureRewardSystem {
    struct UserInfo {
        uint256 amount;
        uint256 rewardDebt;
    }
    
    mapping(address => UserInfo) public userInfo;
    uint256 public accRewardPerShare;
    uint256 public lastRewardTime;
    
    modifier update() {
        if (block.timestamp > lastRewardTime) {
            uint256 timePassed = block.timestamp - lastRewardTime;
            accRewardPerShare += (rewardRate * timePassed * 1e12) / totalStaked;
            lastRewardTime = block.timestamp;
        }
        _;
    }
    
    function stake(uint256 amount) external update {
        UserInfo storage user = userInfo[msg.sender];
        // 先结算之前的奖励
        if (user.amount > 0) {
            uint256 pending = (user.amount * accRewardPerShare / 1e12) - user.rewardDebt;
            // 转账pending奖励
        }
        user.amount += amount;
        user.rewardDebt = user.amount * accRewardPerShare / 1e12;
    }
}</code></pre>
        </div>

        <h4>9.1.6 精度损失（Precision Loss）</h4>
        <p>在处理不同精度代币时，不正确的乘除顺序会导致严重的资金损失。</p>
        
        <div class="code-block collapsible">
            <div class="code-header" onclick="toggleCode(this)">
                <span class="toggle-icon">▼</span>
                <span>精度损失漏洞示例</span>
            </div>
            <pre class="collapsed"><code class="language-solidity">// 精度损失示例
contract PrecisionLossExample {
    // USDC: 6 decimals, DAI: 18 decimals
    uint256 constant USDC_DECIMALS = 6;
    uint256 constant DAI_DECIMALS = 18;
    
    // 错误：先除后乘导致精度损失
    function convertUSDCToDAI_Wrong(uint256 usdcAmount, uint256 price) 
        public pure returns (uint256) {
        // price格式：1 USDC = price DAI (18 decimals)
        // 错误：整数除法会丢失精度
        return (usdcAmount / 10**USDC_DECIMALS) * price;
    }
    
    // 正确：先乘后除，保持精度
    function convertUSDCToDAI_Correct(uint256 usdcAmount, uint256 price) 
        public pure returns (uint256) {
        // 使用缩放因子避免溢出
        return (usdcAmount * price) / 10**USDC_DECIMALS;
    }
    
    // 高级：使用定点数学库
    using FixedPoint for uint256;
    
    function convertWithFixedPoint(uint256 usdcAmount, uint256 price) 
        public pure returns (uint256) {
        // 转换为定点数进行计算
        uint256 scaledAmount = usdcAmount.mul(10**(18 - USDC_DECIMALS));
        return scaledAmount.mulDiv(price, FixedPoint.Q112);
    }
}

// 实际案例：清算计算精度问题
contract LiquidationPrecision {
    uint256 constant LIQUIDATION_PENALTY = 11000; // 110% (basis points)
    uint256 constant BASIS_POINTS = 10000;
    
    // 错误：连续除法导致精度损失
    function calculateLiquidationAmount_Wrong(
        uint256 debt,
        uint256 collateralPrice,
        uint256 debtPrice
    ) public pure returns (uint256) {
        // 错误顺序：每次除法都会损失精度
        return debt * LIQUIDATION_PENALTY / BASIS_POINTS 
               * debtPrice / collateralPrice;
    }
    
    // 正确：优化运算顺序
    function calculateLiquidationAmount_Correct(
        uint256 debt,
        uint256 collateralPrice,
        uint256 debtPrice
    ) public pure returns (uint256) {
        // 先做所有乘法，最后做除法
        return (debt * LIQUIDATION_PENALTY * debtPrice) 
               / (BASIS_POINTS * collateralPrice);
    }
}</code></pre>
        </div>

        <h3 id="stablecoin-risks">9.2 稳定币特定风险</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>🎯 稳定币的独特攻击面</h4>
            <p>稳定币不同于普通的DeFi协议，其核心目标是维持价格稳定。这个看似简单的目标，在去中心化环境中却面临着独特而复杂的安全挑战。从预言机操纵到治理攻击，从闪电贷套利到跨链桥漏洞，每一个环节都可能成为攻击者的突破口。</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>🔍 稳定币安全的核心悖论：</h5>
                <ul>
                    <li><strong>稳定性 vs 去中心化</strong>：越稳定往往意味着越中心化</li>
                    <li><strong>效率 vs 安全性</strong>：高效的稳定机制可能引入新的风险</li>
                    <li><strong>透明性 vs 可攻击性</strong>：公开的算法容易被分析和攻击</li>
                    <li><strong>创新 vs 可靠性</strong>：新机制未经时间检验</li>
                </ul>
            </div>
        </div>
        
        <div class="info-box">
            <h4>📊 稳定币风险矩阵</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">风险类别</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">法币抵押型</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">加密抵押型</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">算法型</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">混合型</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>预言机风险</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟢 低</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 高</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 极高</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>银行挤兑</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 极高</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>治理攻击</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟢 低</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 高</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>监管风险</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 高</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟢 低</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>技术复杂度</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟢 低</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 高</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 极高</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <h4>9.2.1 价格操纵与预言机攻击</h4>
        <p>稳定币系统高度依赖准确的价格信息，这使其成为预言机攻击的主要目标。</p>
        
        <div class="warning-box">
            <h4>⚠️ 预言机攻击的致命性</h4>
            <p>对于稳定币系统，预言机提供的价格数据直接影响：</p>
            <ul>
                <li><strong>抵押率计算</strong>：错误的价格可能导致不当清算或铸造</li>
                <li><strong>稳定机制</strong>：算法稳定币依赖准确价格调整供应</li>
                <li><strong>清算阈值</strong>：操纵价格可触发大规模清算</li>
                <li><strong>套利机会</strong>：价格偏差创造不当获利空间</li>
            </ul>
        </div>
        
        <div class="code-block collapsible">
            <div class="code-header" onclick="toggleCode(this)">
                <span class="toggle-icon">▼</span>
                <span>预言机操纵防护实现</span>
            </div>
            <pre class="collapsed"><code class="language-solidity">// 多预言机聚合器
contract RobustPriceOracle {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;
    }
    
    mapping(address => PriceData) public chainlinkPrices;
    mapping(address => PriceData) public uniswapTWAP;
    mapping(address => PriceData) public internalPrices;
    
    uint256 constant PRICE_FRESHNESS = 3600; // 1小时
    uint256 constant MAX_DEVIATION = 300; // 3%
    
    function getPrice(address token) external view returns (uint256) {
        PriceData memory chainlink = chainlinkPrices[token];
        PriceData memory twap = uniswapTWAP[token];
        PriceData memory internal = internalPrices[token];
        
        // 检查价格新鲜度
        require(block.timestamp - chainlink.timestamp <= PRICE_FRESHNESS, "Stale chainlink");
        require(block.timestamp - twap.timestamp <= PRICE_FRESHNESS, "Stale TWAP");
        
        // 计算中位数价格
        uint256 medianPrice = _getMedian(chainlink.price, twap.price, internal.price);
        
        // 检查价格偏离
        require(_checkDeviation(chainlink.price, medianPrice), "Chainlink deviation");
        require(_checkDeviation(twap.price, medianPrice), "TWAP deviation");
        
        return medianPrice;
    }
    
    function _checkDeviation(uint256 price, uint256 reference) private pure returns (bool) {
        uint256 deviation = price > reference ? 
            ((price - reference) * 10000) / reference :
            ((reference - price) * 10000) / reference;
        return deviation <= MAX_DEVIATION;
    }
}</code></pre>
        </div>

        <h4>9.2.2 闪电贷攻击深度分析</h4>
        <p>闪电贷本身不是漏洞，而是原子性的资本放大器。真正的风险在于协议的状态依赖和价格计算逻辑。</p>
        
        <div class="example-box" style="background-color: #fef3c7; margin: 20px 0;">
            <h4>💡 闪电贷攻击的本质</h4>
            <p>闪电贷让任何人都能在一个交易内临时获得巨额资金。这打破了传统金融的资本门槛，但也为攻击者提供了前所未有的能力。</p>
            
            <div style="background-color: #fef9e7; padding: 15px; border-radius: 8px;">
                <h5>攻击三要素：</h5>
                <ol>
                    <li><strong>资本放大</strong>：从0到数亿美元的瞬时资本</li>
                    <li><strong>原子性保证</strong>：要么全部成功，要么全部回滚</li>
                    <li><strong>协议弱点</strong>：依赖即时状态的价格或逻辑</li>
                </ol>
            </div>
        </div>
        
        <div class="info-box">
            <h4>📊 2023-2024年闪电贷攻击统计</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">攻击特征</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">数量/金额</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">占比</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">趋势</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>总攻击次数</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">147次</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">35%的DeFi攻击</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📈 上升</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>总损失金额</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$482M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">27%的总损失</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📈 增长</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>平均借款额</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$156M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">-</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📈 增大</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>最常见目标</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">价格预言机</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">68%</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">→ 稳定</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>稳定币相关</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">31次</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">21%</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">📈 增加</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="tip-box">
            <p><strong>🛡️ 防御关键：</strong>永远不要依赖同一区块内的即时状态。使用时间加权平均价格（TWAP）、延迟更新或其他抗操纵机制。</p>
        </div>
        
        <div class="code-block collapsible">
            <div class="code-header" onclick="toggleCode(this)">
                <span class="toggle-icon">▼</span>
                <span>完整的闪电贷攻击示例</span>
            </div>
            <pre class="collapsed"><code class="language-solidity">// 易受攻击的稳定币协议
contract VulnerableStablecoin {
    IUniswapV2Pair public collateralPair; // ETH/USDC
    mapping(address => uint256) public collateral;
    mapping(address => uint256) public debt;
    
    // 漏洞：使用即时价格，没有TWAP保护
    function getCollateralValue(address user) public view returns (uint256) {
        (uint112 reserve0, uint112 reserve1,) = collateralPair.getReserves();
        uint256 price = uint256(reserve1) * 1e18 / uint256(reserve0);
        return collateral[user] * price / 1e18;
    }
    
    function liquidate(address user) external {
        require(getCollateralValue(user) < debt[user] * 11 / 10, "Not undercollateralized");
        // 清算逻辑...
    }
}

// 攻击合约
contract FlashLoanAttack {
    IFlashLoanProvider flashLoan;
    VulnerableStablecoin target;
    IUniswapV2Router router;
    
    function executeAttack() external {
        // 1. 借入大量USDC
        flashLoan.flashLoan(address(this), USDC, 10_000_000e6);
    }
    
    function onFlashLoan(uint256 amount) external {
        // 2. 在Uniswap上砸盘，操纵价格
        IERC20(USDC).approve(address(router), amount);
        address[] memory path = new address[](2);
        path[0] = USDC;
        path[1] = WETH;
        
        // 大量卖出USDC，压低ETH/USDC价格
        router.swapExactTokensForTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );
        
        // 3. 触发清算
        address victim = 0x...; // 目标用户
        target.liquidate(victim);
        
        // 4. 恢复价格
        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));
        IERC20(WETH).approve(address(router), wethBalance);
        path[0] = WETH;
        path[1] = USDC;
        
        router.swapExactTokensForTokens(
            wethBalance,
            amount, // 确保能还款
            path,
            address(this),
            block.timestamp
        );
        
        // 5. 归还闪电贷
        IERC20(USDC).transfer(address(flashLoan), amount + fee);
        
        // 6. 提取利润
        // ...
    }
}

// 防护措施：使用TWAP
contract SecureStablecoin {
    using UniswapV2OracleLibrary for IUniswapV2Pair;
    
    uint32 public constant TWAP_PERIOD = 1800; // 30分钟
    
    struct Observation {
        uint32 timestamp;
        uint224 priceCumulative;
    }
    
    mapping(address => Observation) public observations;
    
    function updatePrice(address pair) external {
        uint32 currentTime = uint32(block.timestamp);
        uint224 priceCumulative = uint224(IUniswapV2Pair(pair).price0CumulativeLast());
        
        Observation storage obs = observations[pair];
        uint32 timeElapsed = currentTime - obs.timestamp;
        
        if (timeElapsed >= TWAP_PERIOD) {
            obs.timestamp = currentTime;
            obs.priceCumulative = priceCumulative;
        }
    }
    
    function getTWAPPrice(address pair) public view returns (uint256) {
        Observation memory obs = observations[pair];
        uint32 timeElapsed = uint32(block.timestamp) - obs.timestamp;
        
        require(timeElapsed >= TWAP_PERIOD, "TWAP period not elapsed");
        
        uint224 currentCumulative = uint224(IUniswapV2Pair(pair).price0CumulativeLast());
        
        return (currentCumulative - obs.priceCumulative) / timeElapsed;
    }
}</code></pre>
        </div>

        <h4>9.2.3 治理攻击与经济操纵</h4>
        <p>稳定币的治理机制可能被恶意提案或经济激励操纵。</p>
        
        <div class="code-block collapsible">
            <div class="code-header" onclick="toggleCode(this)">
                <span class="toggle-icon">▼</span>
                <span>治理攻击防护</span>
            </div>
            <pre class="collapsed"><code class="language-solidity">// 安全的治理实现
contract SecureGovernance {
    uint256 public constant PROPOSAL_THRESHOLD = 100000e18; // 10万代币
    uint256 public constant VOTING_PERIOD = 3 days;
    uint256 public constant EXECUTION_DELAY = 2 days;
    uint256 public constant QUORUM = 4; // 4%的总供应量
    
    struct Proposal {
        address proposer;
        address[] targets;
        uint256[] values;
        bytes[] calldatas;
        uint256 startBlock;
        uint256 endBlock;
        uint256 forVotes;
        uint256 againstVotes;
        bool canceled;
        bool executed;
        mapping(address => bool) hasVoted;
    }
    
    mapping(uint256 => Proposal) public proposals;
    
    // 防止闪电贷治理攻击
    modifier noFlashLoan() {
        uint256 balanceBefore = governanceToken.balanceOf(msg.sender);
        _;
        require(
            governanceToken.balanceOf(msg.sender) >= balanceBefore,
            "Flash loan governance attack detected"
        );
    }
    
    // 投票权快照机制
    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public returns (uint256) {
        require(
            governanceToken.getPastVotes(msg.sender, block.number - 1) >= PROPOSAL_THRESHOLD,
            "Below proposal threshold"
        );
        
        // 创建提案...
    }
    
    // 时间锁执行
    function execute(uint256 proposalId) public {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.forVotes > proposal.againstVotes, "Proposal defeated");
        require(
            proposal.forVotes >= (governanceToken.totalSupply() * QUORUM) / 100,
            "Quorum not reached"
        );
        require(
            block.timestamp >= proposal.endBlock + EXECUTION_DELAY,
            "Execution delay not met"
        );
        
        // 执行提案...
    }
}</code></pre>
        </div>

        <h4>9.2.4 跨链桥风险</h4>
        <p>跨链稳定币面临额外的安全挑战，包括桥合约漏洞和跨链消息验证。</p>
        
        <div class="code-block collapsible">
            <div class="code-header" onclick="toggleCode(this)">
                <span class="toggle-icon">▼</span>
                <span>跨链安全实现</span>
            </div>
            <pre class="collapsed"><code class="language-solidity">// LayerZero集成的安全实现
contract CrossChainStablecoin is OFT {
    mapping(uint16 => uint256) public chainSupply;
    uint256 public maxSupplyPerChain = 100_000_000e18;
    
    // 防止跨链铸造攻击
    function _creditTo(
        uint16 _srcChainId,
        address _toAddress,
        uint256 _amount
    ) internal override returns (uint256) {
        // 检查链供应量限制
        require(
            chainSupply[_srcChainId] + _amount <= maxSupplyPerChain,
            "Chain supply limit exceeded"
        );
        
        chainSupply[_srcChainId] += _amount;
        
        return super._creditTo(_srcChainId, _toAddress, _amount);
    }
    
    // 验证跨链消息
    function _blockingLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal override {
        // 验证源链地址
        require(
            _srcAddress.length == trustedRemoteLookup[_srcChainId].length &&
            keccak256(_srcAddress) == keccak256(trustedRemoteLookup[_srcChainId]),
            "Invalid source"
        );
        
        // 防重放攻击
        require(!processedNonces[_srcChainId][_nonce], "Nonce already processed");
        processedNonces[_srcChainId][_nonce] = true;
        
        super._blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);
    }
}</code></pre>
        </div>

        <h3 id="secure-development">9.3 安全开发生命周期</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>🔐 安全不是事后补救，而是设计之初</h4>
            <p>安全开发生命周期（SDLC）是构建安全稳定币系统的基石。它不是在代码写完后"打补丁"，而是从架构设计的第一天就融入每一个决策中。</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>🎯 SDLC的五个关键阶段：</h5>
                <ol>
                    <li><strong>需求分析</strong>：识别安全需求和威胁模型</li>
                    <li><strong>设计</strong>：应用安全设计原则和模式</li>
                    <li><strong>实现</strong>：遵循安全编码规范</li>
                    <li><strong>测试</strong>：全面的安全测试和审计</li>
                    <li><strong>维护</strong>：持续监控和应急响应</li>
                </ol>
            </div>
        </div>
        
        <div class="info-box">
            <h4>📊 安全开发成本效益分析</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">阶段</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">发现漏洞成本</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">修复成本</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">相对倍数</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>设计阶段</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$1,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$1,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">1x</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>开发阶段</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$5,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$10,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">10x</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>测试阶段</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$15,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$50,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">50x</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>审计阶段</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$50,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$100,000</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">100x</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>生产环境</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$0（被黑客发现）</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$1M-$100M+</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">1000x+</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="warning-box">
            <h4>⚠️ 常见的安全开发误区</h4>
            <ul>
                <li><strong>"我们以后再加安全功能"</strong> - 安全必须从一开始就内置</li>
                <li><strong>"审计会发现所有问题"</strong> - 审计只是最后一道防线</li>
                <li><strong>"使用知名库就安全了"</strong> - 错误的集成同样危险</li>
                <li><strong>"测试网没问题就行"</strong> - 主网环境完全不同</li>
                <li><strong>"代码开源会暴露漏洞"</strong> - 透明性实际上提高安全性</li>
            </ul>
        </div>
        
        <div class="theory-section">
            <h4>9.3.1 安全设计原则</h4>
            
            <h5>1. 最小权限原则（Principle of Least Privilege）</h5>
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 正确的权限设计
contract SecureStablecoin {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");
    
    // 细粒度的角色分离
    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), "Unauthorized");
        _;
    }
    
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE) 
        whenNotPaused 
    {
        _mint(to, amount);
    }
    
    // 时间锁保护的关键操作
    uint256 public constant TIMELOCK_DURATION = 48 hours;
    mapping(bytes32 => uint256) public timelockProposals;
    
    function proposeNewMinter(address newMinter) external onlyRole(DEFAULT_ADMIN_ROLE) {
        bytes32 proposalId = keccak256(abi.encodePacked("ADD_MINTER", newMinter));
        timelockProposals[proposalId] = block.timestamp + TIMELOCK_DURATION;
    }
}</code></pre>
                </div>
            </div>
            
            <h5>2. 防御性编程（Defensive Programming）</h5>
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract DefensiveStablecoin {
    using SafeMath for uint256;
    
    // 状态变量的显式初始化
    bool private initialized = false;
    uint256 public constant MAX_SUPPLY = 1e12 * 1e18; // 1万亿上限
    
    // 防重入保护
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    uint256 private reentrancyStatus = NOT_ENTERED;
    
    modifier nonReentrant() {
        require(reentrancyStatus != ENTERED, "ReentrancyGuard: reentrant call");
        reentrancyStatus = ENTERED;
        _;
        reentrancyStatus = NOT_ENTERED;
    }
    
    // 输入验证
    function transfer(address to, uint256 amount) public returns (bool) {
        require(to != address(0), "Transfer to zero address");
        require(to != address(this), "Transfer to contract itself");
        require(amount > 0, "Transfer amount must be positive");
        require(amount <= balanceOf(msg.sender), "Insufficient balance");
        
        _transfer(msg.sender, to, amount);
        return true;
    }
    
    // 检查-影响-交互模式（CEI）
    function withdraw(uint256 amount) external nonReentrant {
        // 检查
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // 影响（先更新状态）
        balances[msg.sender] = balances[msg.sender].sub(amount);
        totalSupply = totalSupply.sub(amount);
        
        // 交互（最后进行外部调用）
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}</code></pre>
                </div>
            </div>
        </div>

        <h4>9.3.2 形式化验证</h4>
        
        <div class="theory-section">
            <p>形式化验证使用数学方法证明代码的正确性：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 使用 SMTChecker 和断言进行形式化验证
contract FormallyVerifiedStablecoin {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    
    // 不变量：所有余额之和等于总供应量
    function invariant_totalSupply() private view {
        uint256 sum = 0;
        // 注意：实际中需要遍历所有地址
        // 这里用断言表示概念
        assert(sum == totalSupply);
    }
    
    function transfer(address to, uint256 amount) public {
        require(to != address(0));
        
        uint256 oldFromBalance = balances[msg.sender];
        uint256 oldToBalance = balances[to];
        
        require(oldFromBalance >= amount);
        
        balances[msg.sender] = oldFromBalance - amount;
        balances[to] = oldToBalance + amount;
        
        // 后置条件验证
        assert(balances[msg.sender] == oldFromBalance - amount);
        assert(balances[to] == oldToBalance + amount);
        
        // 保持不变量
        invariant_totalSupply();
    }
}

// 规范语言示例（用注释表示）
contract Specification {
    /// @custom:formal-verification
    /// @pre balances[msg.sender] >= amount
    /// @post balances[msg.sender] == old(balances[msg.sender]) - amount
    /// @post balances[to] == old(balances[to]) + amount
    /// @post totalSupply == old(totalSupply)
    function transfer(address to, uint256 amount) external;
}</code></pre>
                </div>
            </div>
        </div>

        <h3 id="advanced-patterns">9.4 高级安全模式</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>🛡️ 构建多层防御体系</h4>
            <p>高级安全模式是稳定币系统的"保险丝"和"防火墙"。它们不是为了阻止正常运作，而是在异常情况下保护系统和用户资产。就像现代建筑的防震设计，这些模式让系统在极端情况下也能优雅降级而非彻底崩溃。</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>🎯 三层防御架构：</h5>
                <ol>
                    <li><strong>预防层</strong>：访问控制、输入验证、状态检查</li>
                    <li><strong>检测层</strong>：异常监控、断路器、限流器</li>
                    <li><strong>响应层</strong>：紧急暂停、资金冻结、治理介入</li>
                </ol>
            </div>
        </div>
        
        <div class="info-box">
            <h4>📊 高级安全模式对比</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">安全模式</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">主要功能</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">适用场景</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">实现复杂度</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>断路器（Circuit Breaker）</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">自动暂停异常操作</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">价格异常、大额转账</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中等</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>时间锁（Timelock）</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">延迟执行关键操作</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">参数更改、升级</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟢 简单</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>多签（Multi-sig）</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">多方共同决策</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">金库管理、紧急响应</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟡 中等</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>限流器（Rate Limiter）</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">限制操作频率</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">防止DoS、限制提取</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🟢 简单</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>代理升级</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">合约逻辑更新</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">修复漏洞、功能升级</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">🔴 复杂</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="example-box" style="background-color: #fef3c7; margin: 20px 0;">
            <h4>💡 实战案例：MakerDAO的紧急关停系统</h4>
            <p>MakerDAO的紧急关停（Emergency Shutdown）是断路器模式的典范：</p>
            <ul>
                <li><strong>触发条件</strong>：治理投票、预言机失效、系统性攻击</li>
                <li><strong>执行过程</strong>：
                    <ol>
                        <li>冻结所有CDP操作</li>
                        <li>固定所有资产价格</li>
                        <li>允许用户按最终价格赎回</li>
                    </ol>
                </li>
                <li><strong>保护效果</strong>：即使在最坏情况下也能保护用户资产</li>
                <li><strong>实际使用</strong>：从未触发，但其存在本身就是威慑</li>
            </ul>
        </div>
        
        <div class="practice-section">
            <h4>9.4.1 断路器模式（Circuit Breaker）</h4>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract CircuitBreakerStablecoin {
    // 多级断路器状态
    enum CircuitState { NORMAL, RESTRICTED, PAUSED, EMERGENCY }
    CircuitState public circuitState = CircuitState.NORMAL;
    
    // 自动触发条件
    uint256 public constant PRICE_DEVIATION_THRESHOLD = 500; // 5%
    uint256 public constant VOLUME_SPIKE_THRESHOLD = 10; // 10x normal
    uint256 public constant RAPID_MINT_THRESHOLD = 1e9 * 1e18; // 10亿
    
    // 监控指标
    uint256 public dailyMintVolume;
    uint256 public lastResetTimestamp;
    uint256 public priceDeviationCount;
    
    modifier circuitBreakerCheck() {
        _updateCircuitState();
        
        if (circuitState == CircuitState.PAUSED) {
            revert("System paused");
        } else if (circuitState == CircuitState.EMERGENCY) {
            revert("Emergency shutdown");
        } else if (circuitState == CircuitState.RESTRICTED) {
            // 限制模式下的特殊逻辑
            require(msg.value <= 1000 * 1e18, "Transaction limit exceeded");
        }
        _;
    }
    
    function _updateCircuitState() private {
        // 重置每日计数器
        if (block.timestamp > lastResetTimestamp + 1 days) {
            dailyMintVolume = 0;
            lastResetTimestamp = block.timestamp;
            priceDeviationCount = 0;
        }
        
        // 检查价格偏离
        uint256 currentPrice = getOraclePrice();
        uint256 targetPrice = 1e18; // $1
        uint256 deviation = currentPrice > targetPrice ? 
            currentPrice - targetPrice : targetPrice - currentPrice;
            
        if (deviation * 10000 / targetPrice > PRICE_DEVIATION_THRESHOLD) {
            priceDeviationCount++;
            
            if (priceDeviationCount > 3) {
                circuitState = CircuitState.RESTRICTED;
            }
            if (priceDeviationCount > 5) {
                circuitState = CircuitState.PAUSED;
            }
        }
        
        // 检查铸造量
        if (dailyMintVolume > RAPID_MINT_THRESHOLD) {
            circuitState = CircuitState.EMERGENCY;
            emit EmergencyShutdown(block.timestamp, dailyMintVolume);
        }
    }
    
    // 恢复机制
    function proposeRecovery() external onlyRole(GUARDIAN_ROLE) {
        require(circuitState != CircuitState.NORMAL, "System already normal");
        
        // 创建恢复提案，需要多签或DAO投票
        bytes32 proposalId = keccak256(abi.encodePacked("RECOVERY", block.timestamp));
        _createProposal(proposalId, ProposalType.RECOVERY);
    }
}</code></pre>
                </div>
            </div>
        </div>

        <h4>9.3.2 升级模式与代理合约安全</h4>
        
        <div class="warning-box">
            <p><strong>警告</strong>：许多稳定币依赖可升级代理合约结构。不当的升级机制可能导致权限滥用、初始化漏洞或存储冲突。</p>
        </div>
        
        <div class="theory-section">
            <p>安全的升级机制对于修复漏洞至关重要，但也引入了新的攻击面：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 透明代理模式（OpenZeppelin标准）
contract TransparentUpgradeableProxy {
    // EIP-1967 标准存储槽
    bytes32 private constant _IMPLEMENTATION_SLOT = 
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    bytes32 private constant _ADMIN_SLOT = 
        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    
    modifier ifAdmin() {
        if (msg.sender == _getAdmin()) {
            _;
        } else {
            _fallback();
        }
    }
    
    function upgradeTo(address newImplementation) external ifAdmin {
        _authorizeUpgrade(newImplementation);
        _upgradeToAndCall(newImplementation, bytes(""), false);
    }
    
    function _authorizeUpgrade(address newImplementation) internal {
        // 安全检查
        require(newImplementation != address(0), "Invalid implementation");
        require(newImplementation.code.length > 0, "Implementation not contract");
        
        // 可选：检查新实现的初始化状态
        (bool success, bytes memory data) = newImplementation.staticcall(
            abi.encodeWithSignature("proxiableUUID()")
        );
        require(success && data.length == 32, "Not UUPS compliant");
    }
}

// UUPS模式（更gas高效但风险更高）
contract UUPSUpgradeable {
    function _authorizeUpgrade(address newImplementation) internal virtual;
    
    function upgradeTo(address newImplementation) external {
        _authorizeUpgrade(newImplementation);
        
        // 关键安全检查：防止升级到恶意合约
        require(
            bytes32(newImplementation.codehash) != bytes32(0),
            "New implementation must be contract"
        );
        
        // 检查存储布局兼容性
        _checkStorageLayout(newImplementation);
        
        // 执行升级
        assembly {
            sstore(_IMPLEMENTATION_SLOT, newImplementation)
        }
    }
    
    function _checkStorageLayout(address newImplementation) private view {
        // 使用storage gap确保升级安全
        uint256[50] private __gap;
        
        // 验证关键存储变量的位置
        // 这需要链下工具支持
    }
}</code></pre>
                </div>
            </div>
            
            <h4>9.4.3 升级机制安全（2024最佳实践）</h4>
            <p>可升级合约在提供灵活性的同时也引入了新的安全风险。UUPS相比透明代理在gas效率上有优势，但需要更谨慎的实现。</p>
            
            <div class="code-block collapsible">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">▼</span>
                    <span>UUPS升级模式安全实现</span>
                </div>
                <pre class="collapsed"><code class="language-solidity">// 使用OpenZeppelin的UUPS模式
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";

contract StablecoinV1 is UUPSUpgradeable, AccessControlUpgradeable {
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    
    // 存储变量顺序很重要！
    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;
    
    // 防止实现合约被初始化
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(address admin) public initializer {
        __UUPSUpgradeable_init();
        __AccessControl_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(UPGRADER_ROLE, admin);
        
        // 关键：分离升级权限和操作权限
        _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(UPGRADER_ROLE, UPGRADER_ROLE); // 只有UPGRADER才能管理UPGRADER
    }
    
    // 限制升级权限
    function _authorizeUpgrade(address newImplementation) 
        internal 
        override 
        onlyRole(UPGRADER_ROLE) 
    {
        // 可选：添加额外的升级条件检查
        require(!paused(), "Cannot upgrade while paused");
        
        // 可选：验证新实现的合约代码
        require(
            IUpgradeableBeacon(newImplementation).implementation() != address(0),
            "Invalid implementation"
        );
    }
}

// 时间锁治理合约
contract StablecoinGovernance {
    uint256 constant TIMELOCK_DURATION = 2 days;
    
    struct UpgradeProposal {
        address newImplementation;
        uint256 proposedAt;
        bool executed;
    }
    
    mapping(uint256 => UpgradeProposal) public proposals;
    uint256 public proposalCount;
    
    function proposeUpgrade(address newImplementation) external onlyRole(PROPOSER_ROLE) {
        proposals[proposalCount++] = UpgradeProposal({
            newImplementation: newImplementation,
            proposedAt: block.timestamp,
            executed: false
        });
        
        emit UpgradeProposed(proposalCount - 1, newImplementation);
    }
    
    function executeUpgrade(uint256 proposalId) external onlyRole(EXECUTOR_ROLE) {
        UpgradeProposal storage proposal = proposals[proposalId];
        require(!proposal.executed, "Already executed");
        require(
            block.timestamp >= proposal.proposedAt + TIMELOCK_DURATION,
            "Timelock not passed"
        );
        
        proposal.executed = true;
        
        // 执行升级
        UUPSUpgradeable(stablecoin).upgradeTo(proposal.newImplementation);
    }
}</code></pre>
            </div>

            <h4>9.4.4 多签与时间锁实现</h4>
            <p>生产环境必须使用多签钱包和时间锁来管理关键操作，避免单点故障。</p>
            
            <div class="code-block collapsible">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">▼</span>
                    <span>生产级多签时间锁实现</span>
                </div>
                <pre class="collapsed"><code class="language-solidity">// 集成Gnosis Safe的多签治理
contract StablecoinMultisigGovernance {
    IGnosisSafe public immutable multisig;
    IStablecoin public immutable stablecoin;
    
    // 不同操作的时间锁
    uint256 constant PARAM_CHANGE_DELAY = 1 days;
    uint256 constant UPGRADE_DELAY = 3 days;
    uint256 constant EMERGENCY_DELAY = 6 hours;
    
    enum OperationType {
        PARAM_CHANGE,
        UPGRADE,
        EMERGENCY_PAUSE
    }
    
    struct Operation {
        OperationType opType;
        bytes data;
        uint256 scheduledTime;
        bool executed;
    }
    
    mapping(bytes32 => Operation) public operations;
    
    modifier onlyMultisig() {
        require(msg.sender == address(multisig), "Only multisig");
        _;
    }
    
    function scheduleOperation(
        OperationType opType,
        bytes calldata data
    ) external onlyMultisig returns (bytes32) {
        uint256 delay = getDelay(opType);
        bytes32 id = keccak256(abi.encode(opType, data, block.timestamp));
        
        operations[id] = Operation({
            opType: opType,
            data: data,
            scheduledTime: block.timestamp + delay,
            executed: false
        });
        
        emit OperationScheduled(id, opType, block.timestamp + delay);
        return id;
    }
    
    function executeOperation(bytes32 id) external {
        Operation storage op = operations[id];
        require(!op.executed, "Already executed");
        require(block.timestamp >= op.scheduledTime, "Too early");
        
        op.executed = true;
        
        if (op.opType == OperationType.PARAM_CHANGE) {
            (address target, bytes memory callData) = abi.decode(op.data, (address, bytes));
            (bool success,) = target.call(callData);
            require(success, "Param change failed");
        } else if (op.opType == OperationType.UPGRADE) {
            address newImpl = abi.decode(op.data, (address));
            UUPSUpgradeable(address(stablecoin)).upgradeTo(newImpl);
        } else if (op.opType == OperationType.EMERGENCY_PAUSE) {
            Pausable(address(stablecoin)).pause();
        }
        
        emit OperationExecuted(id);
    }
    
    // 紧急取消（需要更高的多签阈值）
    function cancelOperation(bytes32 id) external onlyMultisig {
        require(multisig.getThreshold() >= 4, "Need higher threshold for cancel");
        delete operations[id];
        emit OperationCancelled(id);
    }
}

// 角色基础的权限管理
contract RoleBasedStablecoin {
    using EnumerableSet for EnumerableSet.AddressSet;
    
    // 细粒度角色定义
    bytes32 public constant MINTER_ROLE = keccak256("MINTER");
    bytes32 public constant BURNER_ROLE = keccak256("BURNER");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER");
    bytes32 public constant ORACLE_UPDATER_ROLE = keccak256("ORACLE_UPDATER");
    bytes32 public constant FEE_MANAGER_ROLE = keccak256("FEE_MANAGER");
    bytes32 public constant RISK_MANAGER_ROLE = keccak256("RISK_MANAGER");
    
    // 每个角色的成员限制
    mapping(bytes32 => uint256) public roleMaxMembers;
    mapping(bytes32 => EnumerableSet.AddressSet) private roleMembers;
    
    constructor() {
        // 设置角色成员上限
        roleMaxMembers[MINTER_ROLE] = 3;
        roleMaxMembers[BURNER_ROLE] = 3;
        roleMaxMembers[PAUSER_ROLE] = 5;
        roleMaxMembers[ORACLE_UPDATER_ROLE] = 2;
        roleMaxMembers[FEE_MANAGER_ROLE] = 2;
        roleMaxMembers[RISK_MANAGER_ROLE] = 3;
    }
    
    function grantRole(bytes32 role, address account) public override {
        require(
            roleMembers[role].length() < roleMaxMembers[role],
            "Role member limit reached"
        );
        
        super.grantRole(role, account);
        roleMembers[role].add(account);
        
        // 发送事件用于监控
        emit RoleGranted(role, account, msg.sender);
    }
    
    // 批量操作需要多个角色确认
    mapping(bytes32 => mapping(address => bool)) public batchOperationApprovals;
    uint256 constant BATCH_APPROVAL_THRESHOLD = 2;
    
    function approveBatchMint(bytes32 operationId) external onlyRole(MINTER_ROLE) {
        batchOperationApprovals[operationId][msg.sender] = true;
    }
    
    function executeBatchMint(
        address[] calldata recipients,
        uint256[] calldata amounts,
        bytes32 operationId
    ) external onlyRole(MINTER_ROLE) {
        // 检查批准数量
        uint256 approvals = 0;
        for (uint256 i = 0; i < roleMembers[MINTER_ROLE].length(); i++) {
            if (batchOperationApprovals[operationId][roleMembers[MINTER_ROLE].at(i)]) {
                approvals++;
            }
        }
        
        require(approvals >= BATCH_APPROVAL_THRESHOLD, "Insufficient approvals");
        
        // 执行批量铸造
        for (uint256 i = 0; i < recipients.length; i++) {
            _mint(recipients[i], amounts[i]);
        }
        
        // 清理批准记录
        for (uint256 i = 0; i < roleMembers[MINTER_ROLE].length(); i++) {
            delete batchOperationApprovals[operationId][roleMembers[MINTER_ROLE].at(i)];
        }
    }
}</code></pre>
            </div>
        </div>

        <h3 id="audit-testing">9.5 安全审计与测试</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>🔍 审计：最后的守门人</h4>
            <p>安全审计不是找到所有漏洞的银弹，而是一个系统性的验证过程。它结合了自动化工具、人工审查、数学证明和实战测试，为智能合约部署前提供最后一道防线。</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>🎯 现代审计的四大支柱：</h5>
                <ol>
                    <li><strong>自动化扫描</strong>：静态分析、符号执行、形式化验证</li>
                    <li><strong>人工审查</strong>：业务逻辑、边缘案例、架构设计</li>
                    <li><strong>模糊测试</strong>：随机输入、属性测试、差分测试</li>
                    <li><strong>实战演练</strong>：白帽攻击、Bug赏金、竞争审计</li>
                </ol>
            </div>
        </div>
        
        <div class="info-box">
            <p><strong>2024年最新工具</strong>：Foundry已成为现代智能合约安全开发的基石，其内置的Fuzz Testing和符号执行能力是检测边缘案例的关键。</p>
            
            <h4>📊 主流审计工具对比（2024版）</h4>
            <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">工具/服务</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">类型</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">优势</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">成本</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>Foundry</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">开发框架</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">快速、模糊测试、符号执行</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">免费</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>Slither</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">静态分析</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">快速扫描、低误报率</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">免费</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>Mythril</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">符号执行</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">深度分析、复杂漏洞</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">免费</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>Certora</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">形式化验证</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">数学证明、高置信度</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$$$</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>Code4rena</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">竞争审计</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">多人审查、实战经验</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$50k+</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>Immunefi</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">Bug赏金</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">持续保护、白帽激励</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">按漏洞付费</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="warning-box">
            <h4>⚠️ 审计的局限性</h4>
            <ul>
                <li><strong>时间快照</strong>：审计只针对特定版本的代码</li>
                <li><strong>假设条件</strong>：基于审计时的环境和依赖</li>
                <li><strong>人为因素</strong>：审计师的经验和专注度影响结果</li>
                <li><strong>未知未知</strong>：新型攻击手法可能未被考虑</li>
                <li><strong>组合复杂性</strong>：与其他协议交互的风险难以完全评估</li>
            </ul>
        </div>
        
        <div class="practice-section">
            <h4>9.5.1 自动化安全测试框架</h4>
            
            <div class="code-block">
                <div class="code-header">
                    JavaScript 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-javascript">// Foundry测试框架示例
// test/StablecoinSecurity.t.sol
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/Stablecoin.sol";

contract StablecoinSecurityTest is Test {
    Stablecoin public stablecoin;
    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");
    
    function setUp() public {
        stablecoin = new Stablecoin();
        
        // 初始化测试环境
        deal(address(stablecoin), victim, 1000e18);
        vm.label(attacker, "Attacker");
        vm.label(victim, "Victim");
    }
    
    // 模糊测试：检测整数溢出
    function testFuzz_NoOverflow(uint256 amount1, uint256 amount2) public {
        vm.assume(amount1 < type(uint256).max / 2);
        vm.assume(amount2 < type(uint256).max / 2);
        
        uint256 totalSupplyBefore = stablecoin.totalSupply();
        
        vm.prank(address(this));
        stablecoin.mint(attacker, amount1);
        stablecoin.mint(attacker, amount2);
        
        assertEq(
            stablecoin.totalSupply(),
            totalSupplyBefore + amount1 + amount2,
            "Total supply calculation error"
        );
    }
    
    // 不变量测试
    function invariant_totalSupplyEqualsBalances() public {
        uint256 totalBalances = 0;
        address[] memory holders = stablecoin.getAllHolders();
        
        for (uint i = 0; i < holders.length; i++) {
            totalBalances += stablecoin.balanceOf(holders[i]);
        }
        
        assertEq(totalBalances, stablecoin.totalSupply(), 
            "Invariant violated: sum of balances != totalSupply");
    }
    
    // 重入攻击测试
    function test_ReentrancyProtection() public {
        ReentrancyAttacker attacker = new ReentrancyAttacker(address(stablecoin));
        
        deal(address(stablecoin), address(attacker), 1000e18);
        
        vm.expectRevert("ReentrancyGuard: reentrant call");
        attacker.attack();
    }
    
    // 权限提升测试
    function test_UnauthorizedAccess() public {
        vm.startPrank(attacker);
        
        vm.expectRevert("Unauthorized");
        stablecoin.mint(attacker, 1000e18);
        
        vm.expectRevert("Unauthorized");
        stablecoin.pause();
        
        vm.expectRevert("Unauthorized");
        stablecoin.updateOracle(attacker);
        
        vm.stopPrank();
    }
}

// 使用Echidna进行属性测试
contract EchidnaTest {
    Stablecoin stablecoin;
    
    constructor() {
        stablecoin = new Stablecoin();
    }
    
    // Echidna将尝试使这个函数返回false
    function echidna_balance_under_supply() public view returns (bool) {
        return stablecoin.balanceOf(msg.sender) <= stablecoin.totalSupply();
    }
    
    function echidna_no_self_mint() public view returns (bool) {
        return stablecoin.balanceOf(address(stablecoin)) == 0;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>9.5.2 静态分析工具集成</h4>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># 自动化安全扫描脚本
import subprocess
import json
import os
from typing import List, Dict, Any

class SecurityAnalyzer:
    def __init__(self, contract_path: str):
        self.contract_path = contract_path
        self.results = {}
    
    def run_slither(self) -> Dict[str, Any]:
        """运行Slither静态分析"""
        try:
            result = subprocess.run(
                ['slither', self.contract_path, '--json', 'slither-report.json'],
                capture_output=True,
                text=True
            )
            
            with open('slither-report.json', 'r') as f:
                data = json.load(f)
            
            # 分析严重性
            issues = {
                'high': [],
                'medium': [],
                'low': [],
                'informational': []
            }
            
            for detector in data.get('results', {}).get('detectors', []):
                severity = detector['impact']
                issues[severity].append({
                    'check': detector['check'],
                    'description': detector['description'],
                    'elements': len(detector['elements'])
                })
            
            self.results['slither'] = issues
            return issues
            
        except Exception as e:
            print(f"Slither analysis failed: {e}")
            return {}
    
    def run_mythril(self) -> Dict[str, Any]:
        """运行Mythril符号执行"""
        try:
            result = subprocess.run(
                ['myth', 'analyze', self.contract_path, '-o', 'json'],
                capture_output=True,
                text=True
            )
            
            data = json.loads(result.stdout)
            
            issues = []
            for issue in data.get('issues', []):
                issues.append({
                    'title': issue['title'],
                    'severity': issue['severity'],
                    'description': issue['description'],
                    'function': issue.get('function', 'Unknown')
                })
            
            self.results['mythril'] = issues
            return issues
            
        except Exception as e:
            print(f"Mythril analysis failed: {e}")
            return {}
    
    def check_known_vulnerabilities(self) -> List[Dict[str, str]]:
        """检查已知漏洞模式"""
        vulnerabilities = []
        
        with open(self.contract_path, 'r') as f:
            content = f.read()
        
        # 检查危险模式
        patterns = {
            'tx.origin': 'Using tx.origin for authentication',
            'selfdestruct': 'Contract contains selfdestruct',
            'delegatecall': 'Unsafe delegatecall usage',
            'block.timestamp': 'Timestamp dependence',
            '.call{value:': 'Low-level call with value',
            'ecrecover': 'Signature malleability risk'
        }
        
        for pattern, description in patterns.items():
            if pattern in content:
                vulnerabilities.append({
                    'pattern': pattern,
                    'risk': description,
                    'severity': 'medium'
                })
        
        self.results['patterns'] = vulnerabilities
        return vulnerabilities
    
    def generate_report(self) -> str:
        """生成安全报告"""
        report = ["# 智能合约安全分析报告\n"]
        
        # Slither结果
        if 'slither' in self.results:
            report.append("## Slither分析结果\n")
            for severity, issues in self.results['slither'].items():
                if issues:
                    report.append(f"### {severity.upper()} ({len(issues)})")
                    for issue in issues:
                        report.append(f"- {issue['check']}: {issue['description']}")
            report.append("")
        
        # Mythril结果
        if 'mythril' in self.results:
            report.append("## Mythril分析结果\n")
            for issue in self.results['mythril']:
                report.append(f"### {issue['severity']}: {issue['title']}")
                report.append(f"- Function: {issue['function']}")
                report.append(f"- {issue['description']}\n")
        
        # 模式检查
        if 'patterns' in self.results:
            report.append("## 危险模式检测\n")
            for vuln in self.results['patterns']:
                report.append(f"- **{vuln['pattern']}**: {vuln['risk']}")
        
        return '\n'.join(report)

# 使用示例
analyzer = SecurityAnalyzer('contracts/Stablecoin.sol')
analyzer.run_slither()
analyzer.run_mythril()
analyzer.check_known_vulnerabilities()

report = analyzer.generate_report()
with open('security-report.md', 'w') as f:
    f.write(report)</code></pre>
                </div>
            </div>
            
            <h4>9.5.2 形式化验证（2024工具链）</h4>
            <p>形式化验证通过数学证明来验证代码的正确性。Certora Prover和Halmos是当前主流工具。</p>
            
            <div class="code-block collapsible">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">▼</span>
                    <span>Certora规范示例</span>
                </div>
                <pre class="collapsed"><code class="language-javascript">// stablecoin.spec - Certora验证规范
methods {
    balanceOf(address) returns (uint256) envfree
    totalSupply() returns (uint256) envfree
    collateralOf(address) returns (uint256) envfree
    debtOf(address) returns (uint256) envfree
}

// 不变量1：总供应量等于所有用户余额之和
ghost mapping(address => uint256) ghostBalances {
    init_state axiom forall address a. ghostBalances[a] == 0;
}

ghost uint256 ghostTotalSupply {
    init_state axiom ghostTotalSupply == 0;
}

hook Sstore _balances[KEY address a] uint256 newBalance (uint256 oldBalance) STORAGE {
    ghostTotalSupply = ghostTotalSupply - ghostBalances[a] + newBalance;
    ghostBalances[a] = newBalance;
}

invariant totalSupplyIntegrity()
    ghostTotalSupply == totalSupply()

// 不变量2：用户不能铸造无抵押的稳定币
invariant collateralizationRequirement(address user)
    debtOf(user) > 0 => collateralOf(user) * getPrice() >= debtOf(user) * 150 / 100

// 规则：清算必须改善系统健康度
rule liquidationImproveHealth {
    address liquidator;
    address user;
    
    uint256 systemHealthBefore = getSystemHealth();
    
    liquidate(e, user);
    
    uint256 systemHealthAfter = getSystemHealth();
    
    assert systemHealthAfter >= systemHealthBefore;
}

// 规则：转账不改变总供应量
rule transferPreservesTotalSupply {
    address from;
    address to;
    uint256 amount;
    
    uint256 totalBefore = totalSupply();
    
    transfer(e, from, to, amount);
    
    uint256 totalAfter = totalSupply();
    
    assert totalBefore == totalAfter;
}</code></pre>
            </div>
            
            <h4>9.5.3 模糊测试（Foundry Fuzzing）</h4>
            <p>使用Foundry的内置模糊测试功能，通过大量随机输入寻找边缘案例。</p>
            
            <div class="code-block collapsible">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">▼</span>
                    <span>Foundry属性测试示例</span>
                </div>
                <pre class="collapsed"><code class="language-solidity">// test/StablecoinInvariants.t.sol
contract StablecoinInvariantTest is Test {
    Stablecoin stablecoin;
    MockOracle oracle;
    
    // 定义系统不变量
    function invariant_totalSupplyEqualsSum() public {
        uint256 sum = 0;
        address[] memory users = stablecoin.getAllUsers();
        
        for (uint i = 0; i < users.length; i++) {
            sum += stablecoin.balanceOf(users[i]);
        }
        
        assertEq(stablecoin.totalSupply(), sum);
    }
    
    function invariant_allDebtsCollateralized() public {
        address[] memory users = stablecoin.getAllUsers();
        
        for (uint i = 0; i < users.length; i++) {
            uint256 debt = stablecoin.debtOf(users[i]);
            if (debt > 0) {
                uint256 collateralValue = stablecoin.getCollateralValue(users[i]);
                assertGe(collateralValue * 100, debt * 150); // 150% 抵押率
            }
        }
    }
    
    // 有状态模糊测试
    function testFuzz_liquidationScenarios(
        uint256 collateralAmount,
        uint256 debtAmount,
        uint256 priceDropPercent
    ) public {
        // 限制输入范围
        collateralAmount = bound(collateralAmount, 1 ether, 1000 ether);
        debtAmount = bound(debtAmount, 100e18, 10000e18);
        priceDropPercent = bound(priceDropPercent, 1, 50);
        
        // 设置场景
        address user = address(0x1);
        vm.startPrank(user);
        
        // 抵押并借出
        stablecoin.deposit{value: collateralAmount}();
        uint256 maxBorrow = stablecoin.getMaxBorrow(user);
        if (debtAmount <= maxBorrow) {
            stablecoin.borrow(debtAmount);
            
            // 模拟价格下跌
            uint256 newPrice = oracle.getPrice() * (100 - priceDropPercent) / 100;
            oracle.setPrice(newPrice);
            
            // 检查清算逻辑
            if (stablecoin.getHealthFactor(user) < 1e18) {
                vm.stopPrank();
                vm.prank(address(0x2));
                stablecoin.liquidate(user);
                
                // 验证清算后状态
                assertLe(stablecoin.debtOf(user), debtAmount / 2);
            }
        }
    }
}</code></pre>
            </div>
            
            <h4>9.5.4 AI驱动的安全分析（2024前沿）</h4>
            <p>利用大型语言模型和机器学习技术增强智能合约安全分析能力。</p>
            
            <div class="code-block collapsible">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">▼</span>
                    <span>AI安全分析工具集成</span>
                </div>
                <pre class="collapsed"><code class="language-python"># AI驱动的智能合约审计系统
import openai
import torch
from transformers import AutoModel, AutoTokenizer
import ast
import re
from typing import List, Dict, Tuple

class AIContractAnalyzer:
    def __init__(self):
        self.vulnerability_patterns = self.load_vulnerability_dataset()
        self.model = self.load_security_model()
        
    def analyze_contract_with_llm(self, contract_code: str) -> Dict[str, Any]:
        """使用LLM分析合约代码"""
        prompt = f"""
        分析以下Solidity智能合约的安全性，特别关注：
        1. 重入攻击风险
        2. 整数溢出/下溢
        3. 访问控制问题
        4. 逻辑错误
        5. Gas优化机会
        
        合约代码：
        ```solidity
        {contract_code}
        ```
        
        请提供详细的安全分析报告。
        """
        
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "你是一个专业的智能合约安全审计专家。"},
                {"role": "user", "content": prompt}
            ],
            temperature=0.1
        )
        
        return self.parse_llm_response(response.choices[0].message.content)
    
    def detect_vulnerability_patterns(self, contract_code: str) -> List[Dict]:
        """使用机器学习模型检测漏洞模式"""
        # 将代码转换为特征向量
        features = self.extract_code_features(contract_code)
        
        # 使用预训练模型预测
        with torch.no_grad():
            predictions = self.model(features)
            
        vulnerabilities = []
        for idx, prob in enumerate(predictions):
            if prob > 0.8:  # 高置信度阈值
                vuln_type = self.vulnerability_patterns[idx]
                vulnerabilities.append({
                    'type': vuln_type['name'],
                    'severity': vuln_type['severity'],
                    'confidence': float(prob),
                    'recommendation': vuln_type['fix']
                })
        
        return vulnerabilities
    
    def extract_code_features(self, contract_code: str) -> torch.Tensor:
        """提取代码特征用于ML模型"""
        features = []
        
        # 函数调用模式
        external_calls = len(re.findall(r'\.call\(|\.delegatecall\(|\.transfer\(', contract_code))
        features.append(external_calls)
        
        # 状态变量修改
        state_changes = len(re.findall(r'\s=\s', contract_code))
        features.append(state_changes)
        
        # 条件检查
        requires = len(re.findall(r'require\(|assert\(', contract_code))
        features.append(requires)
        
        # 循环复杂度
        loops = len(re.findall(r'for\s*\(|while\s*\(', contract_code))
        features.append(loops)
        
        # 更多特征提取...
        
        return torch.tensor(features, dtype=torch.float32)
    
    def generate_security_score(self, vulnerabilities: List[Dict]) -> float:
        """生成安全评分"""
        if not vulnerabilities:
            return 100.0
        
        severity_weights = {
            'critical': 25,
            'high': 15,
            'medium': 10,
            'low': 5,
            'informational': 2
        }
        
        total_penalty = sum(
            severity_weights.get(v['severity'], 0) * v['confidence'] 
            for v in vulnerabilities
        )
        
        return max(0, 100 - total_penalty)

# 集成到CI/CD流程
class SecurityPipeline:
    def __init__(self):
        self.ai_analyzer = AIContractAnalyzer()
        self.traditional_tools = ['slither', 'mythril', 'echidna']
        
    async def run_comprehensive_audit(self, contract_path: str) -> Dict:
        """运行全面的安全审计"""
        results = {
            'ai_analysis': {},
            'static_analysis': {},
            'fuzzing_results': {},
            'formal_verification': {}
        }
        
        # 1. AI分析
        with open(contract_path, 'r') as f:
            code = f.read()
        
        results['ai_analysis'] = self.ai_analyzer.analyze_contract_with_llm(code)
        vulnerabilities = self.ai_analyzer.detect_vulnerability_patterns(code)
        results['ai_analysis']['ml_vulnerabilities'] = vulnerabilities
        results['ai_analysis']['security_score'] = self.ai_analyzer.generate_security_score(vulnerabilities)
        
        # 2. 传统工具分析（并行执行）
        import asyncio
        traditional_results = await asyncio.gather(
            self.run_slither_async(contract_path),
            self.run_mythril_async(contract_path),
            self.run_echidna_async(contract_path)
        )
        
        # 3. 综合分析结果
        results['combined_score'] = self.calculate_combined_score(results)
        results['recommendations'] = self.generate_recommendations(results)
        
        return results</code></pre>
            </div>
            
            <h4>9.5.5 审计报告最佳实践</h4>
            <p>专业的安全审计报告应包含完整的威胁模型、测试方法和修复建议。</p>
            
            <div class="info-box">
                <p><strong>2024审计标准</strong>：现代审计流程应结合自动化工具、形式化验证和人工审查。重点关注经济模型安全性和跨链交互风险。</p>
            </div>
        </div>

        <h3 id="monitoring-response">9.6 实时监控与应急响应</h3>
        
        <div class="theory-section">
            <h4>9.6.1 链上监控系统</h4>
            
            <div class="code-block">
                <div class="code-header">
                    TypeScript 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// 实时监控系统
import { ethers } from 'ethers';
import { WebhookClient } from 'discord.js';
import { Defender } from '@openzeppelin/defender-sdk';

class StablecoinMonitor {
    private provider: ethers.Provider;
    private contract: ethers.Contract;
    private alerts: WebhookClient;
    private defender: Defender;
    
    // 监控阈值
    private readonly LARGE_TRANSFER_THRESHOLD = ethers.parseEther('1000000'); // 100万
    private readonly PRICE_DEVIATION_THRESHOLD = 0.02; // 2%
    private readonly UNUSUAL_GAS_MULTIPLIER = 3;
    
    constructor(config: MonitorConfig) {
        this.provider = new ethers.JsonRpcProvider(config.rpcUrl);
        this.contract = new ethers.Contract(
            config.contractAddress,
            config.abi,
            this.provider
        );
        this.alerts = new WebhookClient({ url: config.webhookUrl });
        this.defender = new Defender(config.defenderCredentials);
    }
    
    async startMonitoring() {
        // 监控大额转账
        this.contract.on('Transfer', async (from, to, value, event) => {
            if (value > this.LARGE_TRANSFER_THRESHOLD) {
                await this.alertLargeTransfer(from, to, value, event);
            }
            
            // 检查可疑模式
            await this.checkSuspiciousPatterns(from, to, value);
        });
        
        // 监控价格偏离
        setInterval(() => this.checkPriceDeviation(), 60000); // 每分钟
        
        // 监控异常Gas使用
        this.provider.on('block', async (blockNumber) => {
            await this.checkGasAnomalies(blockNumber);
        });
        
        // 监控合约暂停事件
        this.contract.on('Paused', async (account) => {
            await this.alertEmergency('Contract Paused', {
                by: account,
                timestamp: new Date().toISOString()
            });
        });
    }
    
    private async checkSuspiciousPatterns(
        from: string, 
        to: string, 
        value: bigint
    ) {
        // 检查闪电贷模式
        const fromCode = await this.provider.getCode(from);
        const toCode = await this.provider.getCode(to);
        
        if (fromCode !== '0x' && toCode !== '0x') {
            // 两个合约之间的大额转账
            const block = await this.provider.getBlock('latest');
            const recentTxs = await this.getRecentTransactions(from, 10);
            
            // 检查循环模式
            const hasCircularPattern = recentTxs.some(tx => 
                tx.to?.toLowerCase() === to.toLowerCase() &&
                tx.from.toLowerCase() === from.toLowerCase()
            );
            
            if (hasCircularPattern) {
                await this.alertSuspicious('Potential Flash Loan Attack', {
                    from,
                    to,
                    value: ethers.formatEther(value),
                    pattern: 'circular transfers detected'
                });
            }
        }
        
        // 检查新创建的合约
        const toAge = await this.getContractAge(to);
        if (toCode !== '0x' && toAge < 3600) { // 小于1小时
            await this.alertSuspicious('Transfer to New Contract', {
                contract: to,
                age: `${toAge} seconds`,
                value: ethers.formatEther(value)
            });
        }
    }
    
    private async checkPriceDeviation() {
        try {
            const oraclePrice = await this.contract.getOraclePrice();
            const targetPrice = ethers.parseEther('1'); // $1
            
            const deviation = Number(
                ((oraclePrice - targetPrice) * 10000n) / targetPrice
            ) / 10000;
            
            if (Math.abs(deviation) > this.PRICE_DEVIATION_THRESHOLD) {
                await this.alertPriceDeviation(deviation, oraclePrice);
                
                // 自动触发防御措施
                if (Math.abs(deviation) > 0.05) { // 5%
                    await this.triggerEmergencyAction('pause');
                }
            }
        } catch (error) {
            console.error('Price check failed:', error);
        }
    }
    
    private async triggerEmergencyAction(action: string) {
        // 使用OpenZeppelin Defender执行紧急操作
        try {
            const response = await this.defender.relaySigner.sendTransaction({
                to: this.contract.address,
                data: this.contract.interface.encodeFunctionData(action),
                speed: 'fast',
                gasLimit: 100000
            });
            
            await this.alertEmergency(`Emergency ${action} triggered`, {
                txHash: response.hash,
                reason: 'Automatic protection activated'
            });
        } catch (error) {
            console.error('Emergency action failed:', error);
        }
    }
    
    private async alertLargeTransfer(
        from: string, 
        to: string, 
        value: bigint, 
        event: any
    ) {
        const embed = {
            title: '⚠️ Large Transfer Detected',
            color: 0xFFCC00,
            fields: [
                { name: 'From', value: from, inline: true },
                { name: 'To', value: to, inline: true },
                { name: 'Amount', value: `${ethers.formatEther(value)} tokens` },
                { name: 'Transaction', value: event.transactionHash },
                { name: 'Block', value: event.blockNumber.toString() }
            ],
            timestamp: new Date().toISOString()
        };
        
        await this.alerts.send({ embeds: [embed] });
    }
}

// 应急响应计划
class IncidentResponse {
    private readonly actions = {
        'price-deviation': ['pause-minting', 'increase-fees', 'alert-team'],
        'large-withdrawal': ['check-reserves', 'prepare-liquidity', 'monitor-closely'],
        'smart-contract-exploit': ['pause-all', 'snapshot-state', 'prepare-upgrade'],
        'oracle-failure': ['switch-oracle', 'use-twap', 'manual-override']
    };
    
    async executeResponsePlan(incidentType: string, severity: 'low' | 'medium' | 'high' | 'critical') {
        const plan = this.actions[incidentType] || ['alert-team'];
        
        for (const action of plan) {
            await this.executeAction(action, severity);
        }
    }
    
    private async executeAction(action: string, severity: string) {
        console.log(`Executing ${action} for ${severity} incident`);
        // 实现具体的响应动作
    }
}</code></pre>
                </div>
            </div>
        </div>

        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">💻</span>
                <h4>练习9.1：实现安全的稳定币合约</h4>
            </div>
            <p>实现一个包含以下安全特性的稳定币合约：</p>
            <ol>
                <li>多签名控制的铸造权限</li>
                <li>自动断路器（价格偏离超过3%自动暂停）</li>
                <li>防重入保护</li>
                <li>升级机制（使用UUPS模式）</li>
                <li>紧急暂停功能</li>
            </ol>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案</button>
            <div class="answer-content">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">solidity</span>
                    </div>
                    <div class="code-content">
                        <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract SecureStablecoin is 
    ERC20Upgradeable,
    PausableUpgradeable,
    AccessControlUpgradeable,
    ReentrancyGuardUpgradeable,
    UUPSUpgradeable 
{
    // 角色定义
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");
    
    // 多签名相关
    struct MintProposal {
        address to;
        uint256 amount;
        uint256 approvals;
        uint256 timestamp;
        bool executed;
        mapping(address => bool) hasApproved;
    }
    
    mapping(uint256 => MintProposal) public mintProposals;
    uint256 public proposalCounter;
    uint256 public constant REQUIRED_APPROVALS = 2;
    uint256 public constant PROPOSAL_TIMEOUT = 48 hours;
    
    // 断路器相关
    uint256 public constant PRICE_DEVIATION_THRESHOLD = 300; // 3%
    uint256 public lastPriceUpdateTime;
    uint256 public currentPrice;
    uint256 public priceDeviationCount;
    bool public circuitBreakerActive;
    
    // 事件
    event MintProposed(uint256 indexed proposalId, address to, uint256 amount);
    event MintApproved(uint256 indexed proposalId, address approver);
    event MintExecuted(uint256 indexed proposalId, address to, uint256 amount);
    event CircuitBreakerActivated(uint256 price, uint256 deviation);
    event PriceUpdated(uint256 newPrice, uint256 timestamp);
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize() public initializer {
        __ERC20_init("Secure Stablecoin", "SSTABLE");
        __Pausable_init();
        __AccessControl_init();
        __ReentrancyGuard_init();
        __UUPSUpgradeable_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, msg.sender);
        
        currentPrice = 1e18; // $1
        lastPriceUpdateTime = block.timestamp;
    }
    
    // 多签名铸造
    function proposeMint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE) 
        returns (uint256) 
    {
        uint256 proposalId = proposalCounter++;
        
        MintProposal storage proposal = mintProposals[proposalId];
        proposal.to = to;
        proposal.amount = amount;
        proposal.timestamp = block.timestamp;
        proposal.approvals = 1;
        proposal.hasApproved[msg.sender] = true;
        
        emit MintProposed(proposalId, to, amount);
        return proposalId;
    }
    
    function approveMint(uint256 proposalId) 
        external 
        onlyRole(MINTER_ROLE) 
    {
        MintProposal storage proposal = mintProposals[proposalId];
        
        require(!proposal.executed, "Already executed");
        require(!proposal.hasApproved[msg.sender], "Already approved");
        require(
            block.timestamp <= proposal.timestamp + PROPOSAL_TIMEOUT,
            "Proposal expired"
        );
        
        proposal.hasApproved[msg.sender] = true;
        proposal.approvals++;
        
        emit MintApproved(proposalId, msg.sender);
        
        if (proposal.approvals >= REQUIRED_APPROVALS) {
            _executeMint(proposalId);
        }
    }
    
    function _executeMint(uint256 proposalId) private {
        MintProposal storage proposal = mintProposals[proposalId];
        
        require(!proposal.executed, "Already executed");
        proposal.executed = true;
        
        _mint(proposal.to, proposal.amount);
        emit MintExecuted(proposalId, proposal.to, proposal.amount);
    }
    
    // 价格更新与断路器
    function updatePrice(uint256 newPrice) 
        external 
        onlyRole(ORACLE_ROLE) 
    {
        require(newPrice > 0, "Invalid price");
        
        uint256 targetPrice = 1e18; // $1
        uint256 deviation = newPrice > targetPrice ? 
            ((newPrice - targetPrice) * 10000) / targetPrice :
            ((targetPrice - newPrice) * 10000) / targetPrice;
        
        if (deviation > PRICE_DEVIATION_THRESHOLD) {
            priceDeviationCount++;
            
            if (!circuitBreakerActive) {
                circuitBreakerActive = true;
                _pause();
                emit CircuitBreakerActivated(newPrice, deviation);
            }
        } else {
            // 价格恢复正常
            if (priceDeviationCount > 0) {
                priceDeviationCount--;
            }
            
            if (circuitBreakerActive && priceDeviationCount == 0) {
                circuitBreakerActive = false;
                _unpause();
            }
        }
        
        currentPrice = newPrice;
        lastPriceUpdateTime = block.timestamp;
        emit PriceUpdated(newPrice, block.timestamp);
    }
    
    // 覆盖transfer函数添加断路器检查
    function transfer(address to, uint256 amount) 
        public 
        override 
        whenNotPaused 
        nonReentrant 
        returns (bool) 
    {
        // 检查价格更新时间
        require(
            block.timestamp - lastPriceUpdateTime < 1 hours,
            "Price oracle stale"
        );
        
        return super.transfer(to, amount);
    }
    
    // 紧急功能
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }
    
    function unpause() external onlyRole(PAUSER_ROLE) {
        require(!circuitBreakerActive, "Circuit breaker active");
        _unpause();
    }
    
    // UUPS升级授权
    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyRole(UPGRADER_ROLE)
    {
        // 可以添加额外的升级检查
        require(newImplementation != address(0), "Invalid implementation");
    }
    
    // 紧急提取（仅限管理员，用于极端情况）
    function emergencyWithdraw(address token) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(paused(), "Not in emergency");
        
        if (token == address(0)) {
            payable(msg.sender).transfer(address(this).balance);
        } else {
            IERC20(token).transfer(
                msg.sender, 
                IERC20(token).balanceOf(address(this))
            );
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">🔍</span>
                <h4>练习9.2：安全审计实战</h4>
            </div>
            <p>对以下存在漏洞的稳定币合约进行安全审计，找出所有安全问题并提供修复方案：</p>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-language">solidity</span>
                </div>
                <div class="code-content">
                    <pre><code class="language-solidity">contract VulnerableStablecoin {
    mapping(address => uint256) public balances;
    mapping(address => bool) public minters;
    address public owner;
    uint256 public totalSupply;
    
    constructor() {
        owner = msg.sender;
    }
    
    function mint(address to, uint256 amount) external {
        require(minters[msg.sender], "Not minter");
        balances[to] += amount;
        totalSupply += amount;
    }
    
    function transfer(address to, uint256 amount) external {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        if (to.code.length > 0) {
            (bool success,) = to.call(
                abi.encodeWithSignature("onTokenReceived(address,uint256)", msg.sender, amount)
            );
        }
    }
    
    function addMinter(address minter) external {
        require(msg.sender == owner);
        minters[minter] = true;
    }
    
    function updateOwner(address newOwner) external {
        require(msg.sender == owner);
        owner = newOwner;
    }
}</code></pre>
                </div>
            </div>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案</button>
            <div class="answer-content">
                <h5>发现的安全问题：</h5>
                <ol>
                    <li><strong>重入攻击漏洞</strong>：transfer函数在更新余额后进行外部调用</li>
                    <li><strong>整数溢出</strong>：mint函数中的加法操作未检查溢出</li>
                    <li><strong>权限管理缺陷</strong>：单点故障，owner权限过大</li>
                    <li><strong>缺少事件日志</strong>：关键操作没有事件记录</li>
                    <li><strong>外部调用未检查返回值</strong>：call调用结果被忽略</li>
                    <li><strong>没有暂停机制</strong>：紧急情况下无法停止合约</li>
                </ol>
                
                <h5>修复后的合约：</h5>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">solidity</span>
                    </div>
                    <div class="code-content">
                        <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract SecureStablecoinV2 is ReentrancyGuard, AccessControl, Pausable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    
    // 事件
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Mint(address indexed to, uint256 amount);
    event MinterAdded(address indexed minter);
    event MinterRemoved(address indexed minter);
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
    }
    
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE) 
        whenNotPaused 
    {
        require(to != address(0), "Mint to zero address");
        require(amount > 0, "Amount must be positive");
        
        // 使用checked math (Solidity 0.8+自动检查)
        balances[to] += amount;
        totalSupply += amount;
        
        emit Mint(to, amount);
        emit Transfer(address(0), to, amount);
    }
    
    function transfer(address to, uint256 amount) 
        external 
        nonReentrant 
        whenNotPaused 
        returns (bool) 
    {
        require(to != address(0), "Transfer to zero address");
        require(to != address(this), "Transfer to contract itself");
        require(amount > 0, "Amount must be positive");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // CEI模式：先更新状态
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        
        // 安全的外部调用（如果需要）
        if (to.code.length > 0) {
            try ITokenReceiver(to).onTokenReceived(msg.sender, amount) returns (bool success) {
                require(success, "Token receiver failed");
            } catch {
                revert("Token receiver reverted");
            }
        }
        
        return true;
    }
    
    function addMinter(address minter) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(minter != address(0), "Invalid minter address");
        grantRole(MINTER_ROLE, minter);
        emit MinterAdded(minter);
    }
    
    function removeMinter(address minter) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        revokeRole(MINTER_ROLE, minter);
        emit MinterRemoved(minter);
    }
    
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }
    
    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }
}

interface ITokenReceiver {
    function onTokenReceived(address from, uint256 amount) external returns (bool);
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <h3>本章总结</h3>
        
        <div class="tip-box">
            <p><strong>🎯 记住：</strong>在区块链世界中，部署即定律，漏洞即判决。一行错误的代码可能导致数百万美元的损失，而且这种损失通常是不可逆的。安全不是成本，而是投资。</p>
        </div>
        
        <div class="summary-box">
            <h4>关键要点：</h4>
            <ul>
                <li><strong>安全是持续的过程</strong>：从设计到部署到运维的全生命周期</li>
                <li><strong>多层防御</strong>：代码安全 + 架构安全 + 经济安全</li>
                <li><strong>自动化工具</strong>：静态分析、动态测试、形式化验证相结合</li>
                <li><strong>应急准备</strong>：断路器、暂停机制、升级路径必不可少</li>
                <li><strong>社区协作</strong>：bug赏金、安全审计、事件披露的重要性</li>
            </ul>
            
            <h4>最佳实践检查清单：</h4>
            <ul>
                <li>☑️ 使用经过审计的标准库（OpenZeppelin）</li>
                <li>☑️ 实施多重签名和时间锁</li>
                <li>☑️ 部署前进行全面的安全审计</li>
                <li>☑️ 建立实时监控和告警系统</li>
                <li>☑️ 准备应急响应计划</li>
                <li>☑️ 保持代码简洁，避免过度复杂</li>
                <li>☑️ 定期更新依赖和安全补丁</li>
            </ul>
            
            <h4>安全学习路线图：</h4>
            <div style="background-color: #f0f9ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <ol>
                    <li><strong>基础阶段（1-2个月）</strong>
                        <ul>
                            <li>学习常见漏洞模式（SWC Registry）</li>
                            <li>掌握安全开发工具（Foundry、Slither）</li>
                            <li>阅读经典审计报告</li>
                        </ul>
                    </li>
                    <li><strong>进阶阶段（3-6个月）</strong>
                        <ul>
                            <li>参与CTF比赛（Ethernaut、Damn Vulnerable DeFi）</li>
                            <li>学习形式化验证基础</li>
                            <li>分析真实攻击案例</li>
                        </ul>
                    </li>
                    <li><strong>专业阶段（6个月+）</strong>
                        <ul>
                            <li>参与竞争审计（Code4rena、Sherlock）</li>
                            <li>构建自动化安全工具</li>
                            <li>研究新型攻击向量</li>
                        </ul>
                    </li>
                </ol>
            </div>
            
            <h4>下一步行动：</h4>
            <p>掌握了安全基础后，下一章我们将深入探讨经济攻击——这是稳定币面临的另一类重大威胁。我们将学习如何识别和防御各种经济操纵手段，构建更加稳健的经济模型。</p>
        </div>
    
            
            <!-- 章节导航 -->
            <div class="chapter-nav">
                <a href="chapter8.html">← 第8章</a>
                <a href="chapter10.html">第10章 →</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>