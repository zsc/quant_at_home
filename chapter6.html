<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬å…­ç« ï¼šAMMé›†æˆ - åŒºå—é“¾ç¨³å®šå¸æ•™ç¨‹</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">ç¨³å®šå¸æ•™ç¨‹</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">â˜°</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">é¦–é¡µ</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">å¼•è¨€</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">ç« èŠ‚</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">ç¬¬1ç« ï¼šåŒºå—é“¾åŸºç¡€</a>
                        <a href="chapter2.html" class="dropdown-item">ç¬¬2ç« ï¼šç¨³å®šå¸åˆ†ç±»</a>
                        <a href="chapter3.html" class="dropdown-item">ç¬¬3ç« ï¼šERC-20æ ‡å‡†</a>
                        <a href="chapter4.html" class="dropdown-item">ç¬¬4ç« ï¼šæŠµæŠ¼å‹è®¾è®¡</a>
                        <a href="chapter5.html" class="dropdown-item">ç¬¬5ç« ï¼šæ•°å­¦æ¨¡å‹</a>
                        <a href="chapter6.html" class="dropdown-item">ç¬¬6ç« ï¼šAMMé›†æˆ</a>
                        <a href="chapter7.html" class="dropdown-item">ç¬¬7ç« ï¼šå€Ÿè´·åè®®</a>
                        <a href="chapter8.html" class="dropdown-item">ç¬¬8ç« ï¼šæ”¶ç›Šç­–ç•¥</a>
                        <a href="chapter9.html" class="dropdown-item">ç¬¬9ç« ï¼šæ™ºèƒ½åˆçº¦å®‰å…¨</a>
                        <a href="chapter10.html" class="dropdown-item">ç¬¬10ç« ï¼šç»æµæ”»å‡»</a>
                        <a href="chapter11.html" class="dropdown-item">ç¬¬11ç« ï¼šæœªæ¥æ–¹å‘</a>
                        <a href="chapter12.html" class="dropdown-item">ç¬¬12ç« ï¼šç”Ÿäº§éƒ¨ç½²</a>
                        <a href="chapter13.html" class="dropdown-item">ç¬¬13ç« ï¼šç”Ÿæ€é›†æˆ</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="#resources" class="nav-link">èµ„æº</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- å¤´éƒ¨ -->
    <header id="top">
        <div class="container">
            <h1>ç¬¬å…­ç« ï¼šAMMé›†æˆ</h1>
        </div>
    </header>
    
    <!-- ä¸»è¦å†…å®¹ -->
    <div class="container">
        <div class="chapter">
<h2>ç¬¬å…­ç« ï¼šAMMé›†æˆä¸æµåŠ¨æ€§ç®¡ç†</h2>
        
        <p>ç¨³å®šå¸çš„ä»·å€¼ç¨³å®šç¦»ä¸å¼€å……è¶³çš„å¸‚åœºæµåŠ¨æ€§ã€‚æœ¬ç« å°†æ¢è®¨ç¨³å®šå¸å¦‚ä½•ä¸è‡ªåŠ¨åšå¸‚å•†ï¼ˆAMMï¼‰åè®®æ·±åº¦é›†æˆï¼Œåˆ›é€ é«˜æ•ˆçš„äº¤æ˜“å¸‚åœºã€‚æˆ‘ä»¬å°†ä»æœ€åŸºç¡€çš„æ’å®šä¹˜ç§¯æ¨¡å‹å‡ºå‘ï¼Œæ·±å…¥åˆ†æCurveçš„StableSwapç®—æ³•å¦‚ä½•ä¸ºç¨³å®šå¸å¯¹æä¾›è¶…ä½æ»‘ç‚¹äº¤æ˜“ï¼Œæ¢è®¨Uniswap V3çš„é›†ä¸­æµåŠ¨æ€§å¦‚ä½•æå‡èµ„æœ¬æ•ˆç‡ã€‚é€šè¿‡ç†è§£è¿™äº›AMMæœºåˆ¶çš„æ•°å­¦åŸç†å’Œå®ç°ç»†èŠ‚ï¼Œæ‚¨å°†å­¦ä¼šå¦‚ä½•ä¸ºè‡ªå·±çš„ç¨³å®šå¸é¡¹ç›®è®¾è®¡æœ€ä¼˜çš„æµåŠ¨æ€§ç­–ç•¥ï¼Œç”šè‡³æ„å»ºä¸“é—¨çš„ç¨³å®šå¸AMMåè®®ã€‚</p>
        
        <div class="intro-box">
            <strong>æœ¬ç« æ¦‚è§ˆï¼š</strong>
            <ul>
                <li>è‡ªåŠ¨åšå¸‚å•†ï¼ˆAMMï¼‰åŸºç¡€åŸç†ä¸æ•°å­¦æ¨¡å‹</li>
                <li>Uniswap V2/V3åœ¨ç¨³å®šå¸äº¤æ˜“ä¸­çš„åº”ç”¨</li>
                <li>Curve StableSwapç®—æ³•æ·±åº¦è§£æ</li>
                <li>é›†ä¸­æµåŠ¨æ€§ä¸ç¨³å®šå¸å¯¹ä¼˜åŒ–</li>
                <li>å®æˆ˜ï¼šæ„å»ºä¸“é—¨çš„ç¨³å®šå¸AMM</li>
            </ul>
        </div>
        
        <div class="tip-box">
            <strong>ğŸ¯ ç« èŠ‚ç›®æ ‡ï¼š</strong>
            <p>æœ¬ç« å°†æ·±å…¥æ¢è®¨ç¨³å®šå¸å¦‚ä½•ä¸å„ç§AMMåè®®é›†æˆï¼Œç†è§£ä¸åŒAMMæ¨¡å‹å¯¹ç¨³å®šå¸äº¤æ˜“çš„å½±å“ï¼Œå¹¶å­¦ä¹ å¦‚ä½•è®¾è®¡å’Œä¼˜åŒ–ç¨³å®šå¸ä¸“ç”¨çš„æµåŠ¨æ€§æ± ã€‚å¯¹äºèµ„æ·±å¼€å‘è€…ï¼Œæˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨æ•°å­¦åŸç†ã€Gasä¼˜åŒ–å’ŒMEVé˜²æŠ¤ã€‚</p>
        </div>

        <h3>6.1 AMMåŸºç¡€åŸç†ä¸ç¨³å®šå¸ç‰¹æ€§</h3>
        
        <h4>6.1.1 ä»æ’å®šä¹˜ç§¯åˆ°æ’å®šå’Œï¼šç†è®ºå¼ åŠ›çš„å»ºç«‹</h4>
        <p>è¦ç†è§£ç¨³å®šå¸AMMçš„è®¾è®¡å“²å­¦ï¼Œæˆ‘ä»¬éœ€è¦ä»ä¸¤ä¸ªæç«¯æ¨¡å‹å¼€å§‹ï¼š</p>
        
        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <h5>1. æ’å®šä¹˜ç§¯æ¨¡å‹ï¼ˆConstant Productï¼‰</h5>
            <p style="text-align: center; font-size: 1.2em;">x Â· y = k</p>
            <ul>
                <li><strong>ä¼˜ç‚¹ï¼š</strong>æ°¸è¿œæœ‰æµåŠ¨æ€§ï¼Œä»·æ ¼å¯ä»¥ä»0åˆ°âˆ</li>
                <li><strong>ç¼ºç‚¹ï¼š</strong>å³ä½¿æ˜¯ç¨³å®šå¸ä¹‹é—´çš„å°é¢äº¤æ˜“ä¹Ÿæœ‰æ˜¾è‘—æ»‘ç‚¹</li>
                <li><strong>èµ„æœ¬æ•ˆç‡ï¼š</strong>æä½ - 99%çš„æµåŠ¨æ€§å¤‡ç”¨åœ¨0.9ä»¥ä¸‹æˆ–1.1ä»¥ä¸Šçš„ä»·æ ¼åŒºé—´</li>
            </ul>
            
            <h5>2. æ’å®šå’Œæ¨¡å‹ï¼ˆConstant Sumï¼‰</h5>
            <p style="text-align: center; font-size: 1.2em;">x + y = k</p>
            <ul>
                <li><strong>ä¼˜ç‚¹ï¼š</strong>é›¶æ»‘ç‚¹ï¼Œå®Œç¾çš„1:1å…‘æ¢</li>
                <li><strong>ç¼ºç‚¹ï¼š</strong>ä¼šå®Œå…¨è€—å°½å…¶ä¸­ä¸€ç§èµ„äº§ï¼Œæ— æ³•åº”å¯¹ä»·æ ¼åç¦»</li>
                <li><strong>è‡´å‘½ç¼ºé™·ï¼š</strong>ä¸€æ—¦å‡ºç°å¾®å°çš„ä»·æ ¼å·®å¼‚ï¼Œå¥—åˆ©è€…ä¼šç¬é—´æ¸…ç©º"å¥½"èµ„äº§</li>
            </ul>
        </div>
        
        <div class="info-box">
            <h5>ğŸ¯ æ ¸å¿ƒè®¾è®¡æŒ‘æˆ˜</h5>
            <p><strong>ç¨³å®šå¸AMMçš„æœ¬è´¨æ˜¯åœ¨ä¸¤ä¸ªæç«¯ä¹‹é—´å¯»æ‰¾å¹³è¡¡ï¼š</strong></p>
            <ul>
                <li>æˆ‘ä»¬æƒ³è¦æ’å®šå’Œæ¨¡å‹çš„<strong>ä½æ»‘ç‚¹</strong>ï¼ˆåœ¨é”šå®šä»·æ ¼é™„è¿‘ï¼‰</li>
                <li>æˆ‘ä»¬éœ€è¦æ’å®šä¹˜ç§¯æ¨¡å‹çš„<strong>æ— é™æµåŠ¨æ€§</strong>ï¼ˆé˜²æ­¢æ± å­è¢«æŠ½å¹²ï¼‰</li>
            </ul>
            <p>è¿™ä¸ªç†è®ºå¼ åŠ›æ¨åŠ¨äº†ä»Uniswap V3åˆ°Curve StableSwapçš„æ‰€æœ‰åˆ›æ–°ã€‚</p>
        </div>
        
        <h4>6.1.2 ç¨³å®šå¸AMMçš„ç‰¹æ®Šéœ€æ±‚</h4>
        <div class="tip">
            ğŸ’¡ <strong>ç¨³å®šå¸äº¤æ˜“çš„ä¸‰å¤§æ ¸å¿ƒéœ€æ±‚ï¼š</strong>
            <ol>
                <li><strong>æä½æ»‘ç‚¹åŒºé—´ï¼š</strong>åœ¨0.999-1.001èŒƒå›´å†…ï¼Œæ»‘ç‚¹åº”æ¥è¿‘é›¶</li>
                <li><strong>é«˜èµ„æœ¬æ•ˆç‡ï¼š</strong>80%+çš„æµåŠ¨æ€§åº”é›†ä¸­åœ¨Â±1%çš„ä»·æ ¼èŒƒå›´å†…</li>
                <li><strong>è„±é”šéŸ§æ€§ï¼š</strong>å½“ç¨³å®šå¸è„±é”šæ—¶ï¼Œåè®®åº”å¹³æ»‘è¿‡æ¸¡è€Œéçªç„¶å´©æºƒ</li>
            </ol>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">é‡åŒ–åˆ†æï¼šä¸åŒAMMæ¨¡å‹çš„æ•ˆç‡å¯¹æ¯” <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># ç¨³å®šå¸AMMæ•ˆç‡å¯¹æ¯”åˆ†æ
import numpy as np
import matplotlib.pyplot as plt

class AMMComparison:
    def __init__(self):
        self.k = 1000000  # åˆå§‹æµåŠ¨æ€§
        
    def constant_product_price(self, x):
        """æ’å®šä¹˜ç§¯: x*y = k"""
        return self.k / x
    
    def constant_sum_price(self, x):
        """æ’å®šå’Œ: x+y = k (ä»·æ ¼å§‹ç»ˆä¸º1)"""
        return 1.0 if x < self.k else float('inf')
    
    def stableswap_price(self, x, A=100):
        """ç®€åŒ–çš„StableSwapä»·æ ¼å‡½æ•°"""
        # è¿™æ˜¯ä¸€ä¸ªè¿‘ä¼¼ï¼Œå®é™…è®¡ç®—æ›´å¤æ‚
        n = 2  # ä¸¤ç§èµ„äº§
        y = self.k - x  # è¿‘ä¼¼
        
        # åœ¨å¹³è¡¡ç‚¹é™„è¿‘è¡¨ç°åƒæ’å®šå’Œ
        # åœ¨æç«¯æƒ…å†µä¸‹è¡¨ç°åƒæ’å®šä¹˜ç§¯
        balance_point = self.k / n
        deviation = abs(x - balance_point) / balance_point
        
        # æ··åˆæƒé‡
        sum_weight = A / (A + deviation * 100)
        product_weight = 1 - sum_weight
        
        # æ··åˆä»·æ ¼
        sum_price = 1.0
        product_price = self.constant_product_price(x)
        
        return sum_weight * sum_price + product_weight * product_price
    
    def calculate_slippage(self, model, trade_size, initial_x=500000):
        """è®¡ç®—ä¸åŒäº¤æ˜“è§„æ¨¡çš„æ»‘ç‚¹"""
        if model == 'product':
            y_before = self.constant_product_price(initial_x)
            y_after = self.constant_product_price(initial_x + trade_size)
            # å®é™…è·å¾—çš„y
            y_received = initial_x * y_before - (initial_x + trade_size) * y_after
        elif model == 'sum':
            y_received = trade_size  # 1:1å…‘æ¢
        else:  # stableswap
            # ç®€åŒ–è®¡ç®—
            price_impact = self.stableswap_price(initial_x + trade_size) - 1
            y_received = trade_size * (1 - abs(price_impact))
            
        ideal_output = trade_size  # ç†æƒ³çš„1:1å…‘æ¢
        slippage = (ideal_output - y_received) / ideal_output * 100
        
        return max(0, slippage)
    
    def visualize_comparison(self):
        """å¯è§†åŒ–ä¸åŒæ¨¡å‹çš„è¡¨ç°"""
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
        
        # 1. ä»·æ ¼æ›²çº¿å¯¹æ¯”
        x_range = np.linspace(100000, 900000, 1000)
        
        # æ’å®šä¹˜ç§¯ä»·æ ¼
        cp_prices = [self.constant_product_price(x) for x in x_range]
        # StableSwapä»·æ ¼ (ä¸åŒAå€¼)
        ss_prices_low = [self.stableswap_price(x, A=10) for x in x_range]
        ss_prices_med = [self.stableswap_price(x, A=100) for x in x_range]
        ss_prices_high = [self.stableswap_price(x, A=1000) for x in x_range]
        
        ax1.plot(x_range/500000, cp_prices, label='Constant Product', linewidth=2)
        ax1.plot(x_range/500000, ss_prices_low, label='StableSwap (A=10)', linewidth=2)
        ax1.plot(x_range/500000, ss_prices_med, label='StableSwap (A=100)', linewidth=2)
        ax1.plot(x_range/500000, ss_prices_high, label='StableSwap (A=1000)', linewidth=2)
        ax1.axhline(y=1, color='black', linestyle='--', alpha=0.5, label='Constant Sum')
        
        ax1.set_xlabel('Pool Balance (x/balance_point)')
        ax1.set_ylabel('Price (y/x)')
        ax1.set_title('Price Curves Comparison')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.set_ylim(0, 3)
        
        # 2. æ»‘ç‚¹åˆ†æ
        trade_sizes = np.logspace(2, 5, 50)  # 100åˆ°100,000
        
        cp_slippages = [self.calculate_slippage('product', size) for size in trade_sizes]
        ss_slippages = [self.calculate_slippage('stableswap', size) for size in trade_sizes]
        
        ax2.loglog(trade_sizes, cp_slippages, label='Constant Product', linewidth=2)
        ax2.loglog(trade_sizes, ss_slippages, label='StableSwap (A=100)', linewidth=2)
        
        ax2.set_xlabel('Trade Size')
        ax2.set_ylabel('Slippage (%)')
        ax2.set_title('Slippage vs Trade Size')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

# è¿è¡Œåˆ†æ
analyzer = AMMComparison()
analyzer.visualize_comparison()

# è®¡ç®—å…·ä½“æ•°å€¼
print("$10,000 äº¤æ˜“çš„æ»‘ç‚¹å¯¹æ¯”:")
print(f"Constant Product: {analyzer.calculate_slippage('product', 10000):.3f}%")
print(f"StableSwap: {analyzer.calculate_slippage('stableswap', 10000):.3f}%")
print(f"Constant Sum: {analyzer.calculate_slippage('sum', 10000):.3f}%")</code></pre>
            </div>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">åŸºç¡€AMMæ¥å£å®šä¹‰ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IAMM {
    // è·å–æŠ¥ä»·
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);
    
    // äº¤æ¢ä»£å¸
    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;
    
    // æ·»åŠ æµåŠ¨æ€§
    function mint(address to) external returns (uint256 liquidity);
    
    // ç§»é™¤æµåŠ¨æ€§
    function burn(address to) external returns (uint256 amount0, uint256 amount1);
    
    // è·å–å‚¨å¤‡é‡
    function getReserves() external view returns (
        uint112 reserve0,
        uint112 reserve1,
        uint32 blockTimestampLast
    );
}

// ç¨³å®šå¸AMMç‰¹æœ‰æ¥å£
interface IStableSwap {
    // è·å–è™šæ‹Ÿä»·æ ¼ï¼ˆè¡¡é‡LPä»£å¸ä»·å€¼ï¼‰
    function get_virtual_price() external view returns (uint256);
    
    // è®¡ç®—ä¸€ä¸ªä»£å¸æ¢å¦ä¸€ä¸ªä»£å¸
    function get_dy(
        int128 i,
        int128 j,
        uint256 dx
    ) external view returns (uint256);
    
    // åŠ¨æ€è´¹ç”¨
    function dynamic_fee(
        int128 i,
        int128 j
    ) external view returns (uint256);
}</code></pre>
            </div>
        </div>

        <h3>6.2 Uniswap V2/V3é›†æˆç­–ç•¥</h3>
        
        <div class="info-box">
            <strong>ğŸ¦„ Uniswapçš„æ¼”è¿›å²ï¼š</strong>
            <ul>
                <li><strong>V1 (2018)ï¼š</strong>ETH-ERC20äº¤æ˜“å¯¹ï¼Œæ¦‚å¿µéªŒè¯</li>
                <li><strong>V2 (2020)ï¼š</strong>ä»»æ„ERC20å¯¹ï¼Œé—ªç”µäº¤æ¢ï¼Œæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼(TWAP)</li>
                <li><strong>V3 (2021)ï¼š</strong>é›†ä¸­æµåŠ¨æ€§ï¼Œèµ„æœ¬æ•ˆç‡æå‡4000å€ï¼ŒNFTå¤´å¯¸</li>
                <li><strong>V4 (2024)ï¼š</strong>Hooksç³»ç»Ÿï¼Œå…è®¸è‡ªå®šä¹‰AMMé€»è¾‘</li>
            </ul>
            <p>æ¯æ¬¡è¿­ä»£éƒ½ä¸ºç¨³å®šå¸äº¤æ˜“å¸¦æ¥æ–°çš„å¯èƒ½æ€§ã€‚</p>
        </div>
        
        <h4>6.2.1 Uniswap V2ç¨³å®šå¸æ± åˆ†æ</h4>
        <p>è™½ç„¶Uniswap V2ä¸æ˜¯ä¸ºç¨³å®šå¸ä¼˜åŒ–çš„ï¼Œä½†ç”±äºå…¶ç®€å•æ€§å’Œå¹¿æ³«é‡‡ç”¨ï¼Œè®¸å¤šç¨³å®šå¸å¯¹ä»åœ¨V2ä¸Šäº¤æ˜“ã€‚è®©æˆ‘ä»¬é‡åŒ–å…¶ä½æ•ˆæ€§ï¼š</p>
        
        <div class="example-box">
            <strong>ğŸ’° å®é™…æ¡ˆä¾‹ - DAI/USDCæ± çš„æ¼”å˜ï¼š</strong>
            <p>DAI/USDCæ˜¯Uniswap V2ä¸Šæœ€æ—©çš„ä¸»è¦ç¨³å®šå¸æ± ä¹‹ä¸€ï¼š</p>
            <ul>
                <li><strong>2020å¹´5æœˆï¼š</strong>TVL $500ä¸‡ï¼Œæ—¥äº¤æ˜“é‡$100ä¸‡</li>
                <li><strong>2021å¹´é«˜å³°ï¼š</strong>TVL $1.5äº¿ï¼Œä½†èµ„æœ¬æ•ˆç‡ä»…8%</li>
                <li><strong>V3è¿ç§»åï¼š</strong>ç›¸åŒäº¤æ˜“é‡ä»…éœ€$2000ä¸‡TVL</li>
                <li><strong>æ•™è®­ï¼š</strong>V2çš„æ’å®šä¹˜ç§¯æ¨¡å‹å¯¹ç¨³å®šå¸å¯¹æå…¶ä½æ•ˆ</li>
            </ul>
        </div>
        
        <div class="info-box">
            <h5>ğŸ“Š V2èµ„æœ¬æ•ˆç‡çš„é‡åŒ–åˆ†æ</h5>
            <p>ä»¥USDC/DAIæ± ä¸ºä¾‹ï¼ˆå‡è®¾å‡è¡¡çŠ¶æ€å„æœ‰$50Mï¼‰ï¼š</p>
            <ul>
                <li>ä»·æ ¼åœ¨0.99-1.01ä¹‹é—´çš„æµåŠ¨æ€§ï¼šä»…å æ€»æµåŠ¨æ€§çš„<strong>2%</strong></li>
                <li>ä»·æ ¼åœ¨0.95-1.05ä¹‹é—´çš„æµåŠ¨æ€§ï¼šçº¦å <strong>10%</strong></li>
                <li>å‰©ä½™90%çš„æµåŠ¨æ€§å¤‡ç”¨åœ¨å‡ ä¹ä¸å¯èƒ½è§¦åŠçš„ä»·æ ¼åŒºé—´</li>
            </ul>
            <p><strong>ç»“æœï¼š</strong>$100Mçš„TVLä¸­ï¼Œåªæœ‰$2Måœ¨æ—¥å¸¸äº¤æ˜“ä¸­è¢«æœ‰æ•ˆåˆ©ç”¨</p>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Uniswap V2ç¨³å®šå¸å¯¹å®ç° <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract UniswapV2StablecoinPair {
    using SafeMath for uint256;
    
    uint256 private constant MINIMUM_LIQUIDITY = 10**3;
    uint256 private constant FEE_DENOMINATOR = 10000;
    uint256 private constant FEE_NUMERATOR = 30; // 0.3%è´¹ç”¨
    
    uint112 private reserve0;
    uint112 private reserve1;
    uint32 private blockTimestampLast;
    
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast;
    
    // è·å–æŠ¥ä»·ï¼ˆè€ƒè™‘è´¹ç”¨ï¼‰
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 amountOut) {
        require(amountIn > 0, "INSUFFICIENT_INPUT_AMOUNT");
        require(reserveIn > 0 && reserveOut > 0, "INSUFFICIENT_LIQUIDITY");
        
        uint256 amountInWithFee = amountIn.mul(FEE_DENOMINATOR - FEE_NUMERATOR);
        uint256 numerator = amountInWithFee.mul(reserveOut);
        uint256 denominator = reserveIn.mul(FEE_DENOMINATOR).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
    
    // ä»·æ ¼å½±å“è®¡ç®—ï¼ˆå¯¹ç¨³å®šå¸å°¤å…¶é‡è¦ï¼‰
    function calculatePriceImpact(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 priceImpact) {
        uint256 amountOut = getAmountOut(amountIn, reserveIn, reserveOut);
        
        // ç†æƒ³æƒ…å†µä¸‹1:1å…‘æ¢
        uint256 idealOut = amountIn;
        
        // è®¡ç®—ä»·æ ¼å½±å“ï¼ˆåŸºç‚¹ï¼‰
        if (idealOut > amountOut) {
            priceImpact = (idealOut - amountOut).mul(10000) / idealOut;
        }
    }
    
    // ä¼˜åŒ–çš„äº¤æ¢å‡½æ•°ï¼ˆå¸¦æ»‘ç‚¹ä¿æŠ¤ï¼‰
    function swapWithSlippageProtection(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        uint256 maxSlippage // åŸºç‚¹
    ) external {
        require(amount0Out > 0 || amount1Out > 0, "INSUFFICIENT_OUTPUT_AMOUNT");
        (uint112 _reserve0, uint112 _reserve1,) = getReserves();
        require(amount0Out < _reserve0 && amount1Out < _reserve1, "INSUFFICIENT_LIQUIDITY");
        
        uint256 balance0;
        uint256 balance1;
        {
            address _token0 = token0;
            address _token1 = token1;
            require(to != _token0 && to != _token1, "INVALID_TO");
            
            if (amount0Out > 0) IERC20(_token0).transfer(to, amount0Out);
            if (amount1Out > 0) IERC20(_token1).transfer(to, amount1Out);
            
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
        
        uint256 amount0In = balance0 > _reserve0 - amount0Out ? 
            balance0 - (_reserve0 - amount0Out) : 0;
        uint256 amount1In = balance1 > _reserve1 - amount1Out ? 
            balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, "INSUFFICIENT_INPUT_AMOUNT");
        
        // æ»‘ç‚¹æ£€æŸ¥
        uint256 priceImpact = calculatePriceImpact(
            amount0In > 0 ? amount0In : amount1In,
            amount0In > 0 ? _reserve0 : _reserve1,
            amount0In > 0 ? _reserve1 : _reserve0
        );
        require(priceImpact <= maxSlippage, "SLIPPAGE_TOO_HIGH");
        
        // Kå€¼æ£€æŸ¥
        {
            uint256 balance0Adjusted = balance0.mul(FEE_DENOMINATOR).sub(
                amount0In.mul(FEE_NUMERATOR)
            );
            uint256 balance1Adjusted = balance1.mul(FEE_DENOMINATOR).sub(
                amount1In.mul(FEE_NUMERATOR)
            );
            require(
                balance0Adjusted.mul(balance1Adjusted) >= 
                uint256(_reserve0).mul(_reserve1).mul(FEE_DENOMINATOR**2),
                "K"
            );
        }
        
        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.2.2 Uniswap V3é›†ä¸­æµåŠ¨æ€§ä¼˜åŒ–</h4>
        <p>Uniswap V3çš„é›†ä¸­æµåŠ¨æ€§æ˜¯ä¸€æŠŠåŒåˆƒå‰‘ - å®ƒæå¤§æå‡äº†èµ„æœ¬æ•ˆç‡ï¼Œä½†ä¹Ÿå¼•å…¥äº†æ–°çš„é£é™©ç»´åº¦ï¼š</p>
        
        <div class="tip-box">
            <strong>ğŸ“Š é›†ä¸­æµåŠ¨æ€§çš„æ”¶ç›Šä¸é£é™©ï¼š</strong>
            <table style="width: 100%; margin-top: 1rem;">
                <tr style="background: #f0f4f8;">
                    <th style="padding: 0.5rem; border: 1px solid #ddd;">ç»´åº¦</th>
                    <th style="padding: 0.5rem; border: 1px solid #ddd;">ä¼˜åŠ¿</th>
                    <th style="padding: 0.5rem; border: 1px solid #ddd;">é£é™©</th>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">èµ„æœ¬æ•ˆç‡</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">æå‡10-100å€</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">éœ€è¦ä¸»åŠ¨ç®¡ç†</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">æ— å¸¸æŸå¤±</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">èŒƒå›´å†…æ”¶ç›Šæ›´é«˜</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">è„±é”šæ—¶ILæ”¾å¤§5-10å€</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">è´¹ç”¨æ”¶ç›Š</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">é›†ä¸­è·å–90%+è´¹ç”¨</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">ä»·æ ¼ç¦»å¼€èŒƒå›´æ”¶ç›Šä¸º0</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">Gasæˆæœ¬</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">å•æ¬¡æ“ä½œé«˜æ•ˆ</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">é¢‘ç¹å†å¹³è¡¡æˆæœ¬é«˜</td>
                </tr>
            </table>
        </div>
        
        <div class="info-box">
            <h5>âš ï¸ ç¨³å®šå¸è„±é”šæ—¶çš„V3é£é™©åˆ†æ</h5>
            <p>å‡è®¾USDC/DAIæ± ï¼ŒLPåœ¨[0.999, 1.001]èŒƒå›´æä¾›æµåŠ¨æ€§ï¼š</p>
            <ul>
                <li>æ­£å¸¸æƒ…å†µï¼šæ•è·95%+çš„äº¤æ˜“è´¹ç”¨ï¼ŒILæ¥è¿‘0</li>
                <li>DAIè„±é”šè‡³0.998ï¼šæ•´ä¸ªä»“ä½100%è½¬æ¢ä¸ºDAIï¼ˆè´¬å€¼èµ„äº§ï¼‰</li>
                <li>æŸå¤±è®¡ç®—ï¼šç›¸æ¯”æŒæœ‰50/50ï¼ŒæŸå¤±æ”¾å¤§è‡³åŸæ¥çš„<strong>50å€</strong></li>
                <li>æ¢å¤å›°éš¾ï¼šå³ä½¿ä»·æ ¼æ¢å¤ï¼Œä¹Ÿéœ€è¦ä¸»åŠ¨å†å¹³è¡¡æ‰èƒ½æ¢å¤åŸå§‹æ¯”ä¾‹</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Uniswap V3ç¨³å®šå¸æµåŠ¨æ€§ç®¡ç† <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract UniswapV3StablecoinManager {
    using TickMath for int24;
    using FullMath for uint256;
    
    INonfungiblePositionManager public immutable positionManager;
    IUniswapV3Pool public immutable pool;
    
    struct StablecoinPosition {
        uint256 tokenId;
        int24 tickLower;
        int24 tickUpper;
        uint128 liquidity;
        uint256 token0Deposited;
        uint256 token1Deposited;
    }
    
    // è®¡ç®—ç¨³å®šå¸å¯¹çš„æœ€ä¼˜ä»·æ ¼èŒƒå›´
    function calculateOptimalRange(
        uint256 currentPrice,
        uint256 rangeWidthBips // åŸºç‚¹ï¼Œå¦‚100 = 1%
    ) public pure returns (int24 tickLower, int24 tickUpper) {
        require(rangeWidthBips > 0 && rangeWidthBips < 10000, "Invalid range width");
        
        // è®¡ç®—ä»·æ ¼è¾¹ç•Œ
        uint256 priceLower = currentPrice * (10000 - rangeWidthBips / 2) / 10000;
        uint256 priceUpper = currentPrice * (10000 + rangeWidthBips / 2) / 10000;
        
        // è½¬æ¢ä¸ºtick
        tickLower = TickMath.getTickAtSqrtRatio(
            uint160(sqrt(priceLower << 96))
        );
        tickUpper = TickMath.getTickAtSqrtRatio(
            uint160(sqrt(priceUpper << 96))
        );
        
        // ç¡®ä¿tickç¬¦åˆé—´è·è¦æ±‚
        int24 tickSpacing = pool.tickSpacing();
        tickLower = (tickLower / tickSpacing) * tickSpacing;
        tickUpper = ((tickUpper / tickSpacing) + 1) * tickSpacing;
    }
    
    // åˆ›å»ºé›†ä¸­æµåŠ¨æ€§å¤´å¯¸
    function createConcentratedPosition(
        uint256 amount0Desired,
        uint256 amount1Desired,
        uint256 rangeWidthBips,
        uint256 deadline
    ) external returns (
        uint256 tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    ) {
        // è·å–å½“å‰ä»·æ ¼
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
        uint256 currentPrice = uint256(sqrtPriceX96) ** 2 >> 192;
        
        // è®¡ç®—æœ€ä¼˜èŒƒå›´
        (int24 tickLower, int24 tickUpper) = calculateOptimalRange(
            currentPrice,
            rangeWidthBips
        );
        
        // æ‰¹å‡†ä»£å¸
        IERC20(pool.token0()).approve(address(positionManager), amount0Desired);
        IERC20(pool.token1()).approve(address(positionManager), amount1Desired);
        
        // åˆ›å»ºå¤´å¯¸
        INonfungiblePositionManager.MintParams memory params = 
            INonfungiblePositionManager.MintParams({
                token0: pool.token0(),
                token1: pool.token1(),
                fee: pool.fee(),
                tickLower: tickLower,
                tickUpper: tickUpper,
                amount0Desired: amount0Desired,
                amount1Desired: amount1Desired,
                amount0Min: amount0Desired * 995 / 1000, // 0.5%æ»‘ç‚¹
                amount1Min: amount1Desired * 995 / 1000,
                recipient: msg.sender,
                deadline: deadline
            });
        
        (tokenId, liquidity, amount0, amount1) = positionManager.mint(params);
        
        emit PositionCreated(tokenId, tickLower, tickUpper, liquidity);
    }
    
    // è‡ªåŠ¨å†å¹³è¡¡ç­–ç•¥
    function rebalancePosition(
        uint256 tokenId,
        uint256 targetRangeWidthBips
    ) external {
        // è·å–å½“å‰å¤´å¯¸ä¿¡æ¯
        (,, address token0, address token1, uint24 fee, int24 tickLower, 
         int24 tickUpper, uint128 liquidity,,,,) = positionManager.positions(tokenId);
        
        require(liquidity > 0, "Position has no liquidity");
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å†å¹³è¡¡
        (uint160 sqrtPriceX96, int24 currentTick,,,,,) = pool.slot0();
        
        if (currentTick < tickLower || currentTick > tickUpper) {
            // æ”¶é›†æ‰€æœ‰è´¹ç”¨å’ŒæµåŠ¨æ€§
            INonfungiblePositionManager.CollectParams memory collectParams = 
                INonfungiblePositionManager.CollectParams({
                    tokenId: tokenId,
                    recipient: address(this),
                    amount0Max: type(uint128).max,
                    amount1Max: type(uint128).max
                });
            
            (uint256 amount0Collected, uint256 amount1Collected) = 
                positionManager.collect(collectParams);
            
            // ç§»é™¤æ—§æµåŠ¨æ€§
            INonfungiblePositionManager.DecreaseLiquidityParams memory decreaseParams = 
                INonfungiblePositionManager.DecreaseLiquidityParams({
                    tokenId: tokenId,
                    liquidity: liquidity,
                    amount0Min: 0,
                    amount1Min: 0,
                    deadline: block.timestamp
                });
            
            positionManager.decreaseLiquidity(decreaseParams);
            
            // åˆ›å»ºæ–°å¤´å¯¸
            createConcentratedPosition(
                amount0Collected,
                amount1Collected,
                targetRangeWidthBips,
                block.timestamp
            );
            
            // é”€æ¯æ—§NFT
            positionManager.burn(tokenId);
        }
    }
    
    // è®¡ç®—æ— å¸¸æŸå¤±ï¼ˆå¯¹ç¨³å®šå¸å¾ˆé‡è¦ï¼‰
    function calculateImpermanentLoss(
        uint256 price0Start,
        uint256 price0End,
        uint256 amount0Start,
        uint256 amount1Start
    ) public pure returns (uint256 lossPercentage) {
        // IL = 2 * sqrt(price_ratio) / (1 + price_ratio) - 1
        uint256 priceRatio = price0End * 1e18 / price0Start;
        uint256 sqrtPriceRatio = sqrt(priceRatio * 1e18);
        
        uint256 poolValue = 2 * sqrtPriceRatio / (1e18 + priceRatio);
        
        if (poolValue < 1e18) {
            lossPercentage = (1e18 - poolValue) * 10000 / 1e18; // åŸºç‚¹
        }
    }
    
    function sqrt(uint256 x) private pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}</code></pre>
            </div>
        </div>

        <h3>6.3 Curve StableSwapæ·±åº¦è§£æ</h3>
        
        <h4>6.3.1 StableSwapä¸å˜é‡çš„æ•°å­¦æ¨å¯¼</h4>
        <p>Curveçš„å¤©æ‰ä¹‹å¤„åœ¨äºåˆ›é€ äº†ä¸€ä¸ªåœ¨æ’å®šå’Œä¸æ’å®šç§¯ä¹‹é—´ä¼˜é›…è¿‡æ¸¡çš„æ··åˆä¸å˜é‡ï¼š</p>
        
        <div style="background: #e0e7ff; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <h5>ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼StableSwapå…¬å¼</h5>
            <p><strong>1. èµ·ç‚¹ï¼šä¸¤ä¸ªæç«¯çš„æ··åˆ</strong></p>
            <p>æ’å®šå’Œï¼šÎ£x<sub>i</sub> = Dï¼ˆé›¶æ»‘ç‚¹ä½†ä¼šè€—å°½ï¼‰</p>
            <p>æ’å®šç§¯ï¼šÎ (x<sub>i</sub>/n) = (D/n)<sup>n</sup>ï¼ˆæ— é™æµåŠ¨æ€§ä½†é«˜æ»‘ç‚¹ï¼‰</p>
            
            <p><strong>2. æ··åˆä¸å˜é‡ï¼š</strong></p>
            <p style="text-align: center; font-size: 1.2em; margin: 1rem 0;">
                Ï‡Â·Î£x<sub>i</sub> + Î (x<sub>i</sub>) = Ï‡Â·D + (D/n)<sup>n</sup>
            </p>
            <p>å…¶ä¸­Ï‡æ˜¯æ··åˆå‚æ•°ï¼Œæ§åˆ¶ä¸¤ç§æ¨¡å‹çš„æƒé‡</p>
            
            <p><strong>3. å¼•å…¥æ”¾å¤§ç³»æ•°Aï¼š</strong></p>
            <p>ä»¤Ï‡ = An<sup>n</sup>ï¼Œå¾—åˆ°æœ€ç»ˆçš„StableSwapä¸å˜é‡ï¼š</p>
            <p style="text-align: center; font-size: 1.2em; background: #fff; padding: 1rem; border-radius: 4px;">
                An<sup>n</sup>Î£x<sub>i</sub> + D = ADn<sup>n</sup> + D<sup>n+1</sup>/(n<sup>n</sup>Î x<sub>i</sub>)
            </p>
        </div>
        
        <div class="tip">
            ğŸ’¡ <strong>æ”¾å¤§ç³»æ•°Açš„ç›´è§‚ç†è§£ï¼š</strong>
            <ul>
                <li>A â†’ 0ï¼šå…¬å¼é€€åŒ–ä¸ºæ’å®šä¹˜ç§¯ï¼ˆç±»ä¼¼Uniswapï¼‰</li>
                <li>A â†’ âˆï¼šå…¬å¼è¶‹è¿‘æ’å®šå’Œï¼ˆå®Œç¾çš„ç¨³å®šå¸äº¤æ¢ï¼‰</li>
                <li>A = 100ï¼šå®è·µä¸­çš„å¹³è¡¡ç‚¹ï¼Œåœ¨Â±2%èŒƒå›´å†…æä¾›æä½æ»‘ç‚¹</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">StableSwapæ›²çº¿å¯è§†åŒ–ä¸å‚æ•°å½±å“åˆ†æ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># Curve StableSwapå¯è§†åŒ–åˆ†æ
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import newton

class StableSwapVisualization:
    def __init__(self, n_coins=2):
        self.n = n_coins
        self.precision = 10**18
        
    def get_D(self, xp, amp):
        """è®¡ç®—Då€¼ - StableSwapçš„æ ¸å¿ƒ"""
        S = sum(xp)
        if S == 0:
            return 0
            
        D = S
        Ann = amp * self.n
        
        for _ in range(255):
            D_P = D
            for x in xp:
                D_P = D_P * D // (x * self.n)
            Dprev = D
            D = (Ann * S // amp + D_P * self.n) * D // ((Ann - amp) * D // amp + (self.n + 1) * D_P)
            
            if abs(D - Dprev) <= 1:
                break
                
        return D
    
    def get_y(self, i, j, x, xp, amp):
        """ç»™å®šxè®¡ç®—y - äº¤æ˜“çš„æ ¸å¿ƒè®¡ç®—"""
        D = self.get_D(xp, amp)
        
        S_ = sum(xp) - xp[i] - xp[j] + x
        c = D
        Ann = amp * self.n
        
        for k in range(self.n):
            if k != i and k != j:
                c = c * D // (xp[k] * self.n)
        c = c * D * amp // (Ann * self.n)
        
        b = S_ + D * amp // Ann
        y_prev = 0
        y = D
        
        for _ in range(255):
            y_prev = y
            y = (y * y + c) // (2 * y + b - D)
            if abs(y - y_prev) <= 1:
                break
                
        return y
    
    def visualize_curves(self):
        """å¯è§†åŒ–ä¸åŒAå€¼ä¸‹çš„ä»·æ ¼æ›²çº¿"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # åˆå§‹æ± å­ï¼šå¹³è¡¡çŠ¶æ€
        initial_balance = 1000000
        
        # 1. ä»·æ ¼æ›²çº¿å¯¹æ¯”
        ax = axes[0, 0]
        x_range = np.linspace(0.1 * initial_balance, 1.9 * initial_balance, 1000)
        
        for A in [0.1, 1, 10, 100, 1000]:
            prices = []
            for x in x_range:
                xp = [int(x), initial_balance]
                y = self.get_y(0, 1, int(x), xp, int(A * 100))
                # è®¡ç®—è¾¹é™…ä»·æ ¼ dy/dx
                price = (initial_balance - y) / (x - initial_balance) if x != initial_balance else 1
                prices.append(price)
            
            ax.plot(x_range / initial_balance, prices, label=f'A={A}', linewidth=2)
        
        ax.axhline(y=1, color='black', linestyle='--', alpha=0.3)
        ax.set_xlabel('ç›¸å¯¹å‚¨å¤‡é‡ (x/xâ‚€)')
        ax.set_ylabel('ä»·æ ¼ (dy/dx)')
        ax.set_title('ä¸åŒAå€¼ä¸‹çš„ä»·æ ¼æ›²çº¿')
        ax.legend()
        ax.grid(True, alpha=0.3)
        ax.set_ylim(0, 2)
        
        # 2. èµ„æœ¬æ•ˆç‡åˆ†æ
        ax = axes[0, 1]
        A_values = [1, 10, 50, 100, 500, 1000]
        effective_liquidity = []
        
        for A in A_values:
            # è®¡ç®—Â±1%ä»·æ ¼èŒƒå›´å†…çš„æœ‰æ•ˆæµåŠ¨æ€§æ¯”ä¾‹
            total_liquidity = 2 * initial_balance
            x_1pct = initial_balance * 0.99
            x_2pct = initial_balance * 1.01
            
            # åœ¨è¿™ä¸ªèŒƒå›´å†…å¯äº¤æ˜“çš„é‡
            tradeable = (x_2pct - x_1pct) / total_liquidity * 100
            effective_liquidity.append(tradeable)
        
        ax.bar(range(len(A_values)), effective_liquidity, color='skyblue', edgecolor='navy')
        ax.set_xticks(range(len(A_values)))
        ax.set_xticklabels([f'A={A}' for A in A_values])
        ax.set_ylabel('æœ‰æ•ˆæµåŠ¨æ€§æ¯”ä¾‹ (%)')
        ax.set_title('Â±1%ä»·æ ¼èŒƒå›´å†…çš„èµ„æœ¬æ•ˆç‡')
        ax.grid(True, alpha=0.3, axis='y')
        
        # 3. æ»‘ç‚¹åˆ†æ
        ax = axes[1, 0]
        trade_sizes = np.logspace(2, 6, 50)  # $100 åˆ° $1M
        
        for A in [10, 100, 1000]:
            slippages = []
            for size in trade_sizes:
                # è®¡ç®—äº¤æ˜“äº§ç”Ÿçš„æ»‘ç‚¹
                xp = [initial_balance, initial_balance]
                y_out = initial_balance - self.get_y(0, 1, initial_balance + int(size), xp, int(A * 100))
                slippage = (size - y_out) / size * 10000  # åŸºç‚¹
                slippages.append(slippage)
            
            ax.loglog(trade_sizes, slippages, label=f'A={A}', linewidth=2)
        
        ax.set_xlabel('äº¤æ˜“è§„æ¨¡ ($)')
        ax.set_ylabel('æ»‘ç‚¹ (åŸºç‚¹)')
        ax.set_title('äº¤æ˜“è§„æ¨¡ vs æ»‘ç‚¹')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # 4. Aå‚æ•°çš„é£é™©æ”¶ç›Šæƒè¡¡
        ax = axes[1, 1]
        A_range = np.logspace(0, 3, 100)
        
        # è®¡ç®—ä¸åŒæŒ‡æ ‡
        capital_efficiency = []
        depeg_risk = []
        
        for A in A_range:
            # èµ„æœ¬æ•ˆç‡ï¼š1%èŒƒå›´å†…çš„æ·±åº¦
            eff = min(100, A / 10)  # ç®€åŒ–æ¨¡å‹
            capital_efficiency.append(eff)
            
            # è„±é”šé£é™©ï¼šæ± å­è€—å°½é€Ÿåº¦
            risk = 100 / (1 + A / 100)  # ç®€åŒ–æ¨¡å‹
            depeg_risk.append(risk)
        
        ax2 = ax.twinx()
        
        line1 = ax.plot(A_range, capital_efficiency, 'b-', label='èµ„æœ¬æ•ˆç‡', linewidth=2)
        line2 = ax2.plot(A_range, depeg_risk, 'r-', label='è„±é”šé£é™©', linewidth=2)
        
        ax.set_xlabel('æ”¾å¤§ç³»æ•° A')
        ax.set_ylabel('èµ„æœ¬æ•ˆç‡ (%)', color='b')
        ax2.set_ylabel('è„±é”šé£é™©æŒ‡æ•°', color='r')
        ax.set_xscale('log')
        ax.set_title('Aå‚æ•°çš„é£é™©æ”¶ç›Šæƒè¡¡')
        
        lines = line1 + line2
        labels = [l.get_label() for l in lines]
        ax.legend(lines, labels, loc='center right')
        
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig
    
    def simulate_depeg_scenario(self, A=100, depeg_percent=5):
        """æ¨¡æ‹Ÿè„±é”šåœºæ™¯ä¸‹çš„æ± å­è¡Œä¸º"""
        initial = 1000000
        results = {
            'price': [],
            'pool_ratio': [],
            'trade_size': []
        }
        
        # æ¨¡æ‹Ÿé€æ­¥è„±é”š
        current_x = initial
        current_y = initial
        
        for step in range(100):
            # å¥—åˆ©è€…å–å‡ºè´¬å€¼èµ„äº§
            trade_size = initial * 0.01  # æ¯æ¬¡1%
            
            xp = [current_x, current_y]
            new_y = self.get_y(0, 1, current_x + trade_size, xp, int(A * 100))
            
            received = current_y - new_y
            current_x += trade_size
            current_y = new_y
            
            # è®¡ç®—ä»·æ ¼
            price = received / trade_size
            pool_ratio = current_x / (current_x + current_y)
            
            results['price'].append(price)
            results['pool_ratio'].append(pool_ratio)
            results['trade_size'].append(step * trade_size)
            
            if price < (1 - depeg_percent/100):
                break
                
        return results

# è¿è¡Œå¯è§†åŒ–
visualizer = StableSwapVisualization()
visualizer.visualize_curves()

# æ¨¡æ‹Ÿè„±é”šåœºæ™¯
depeg_results = visualizer.simulate_depeg_scenario(A=100, depeg_percent=5)
print(f"5%è„±é”šæ—¶ï¼Œæ± å­ä¸­ç¨³å®šèµ„äº§æ¯”ä¾‹ï¼š{(1-depeg_results['pool_ratio'][-1])*100:.1f}%")</code></pre>
            </div>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Curve StableSwapæ ¸å¿ƒå®ç° <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract StableSwap {
    uint256 private constant A_PRECISION = 100;
    uint256 private constant PRECISION = 1e18;
    uint256 private constant FEE_DENOMINATOR = 1e10;
    
    uint256 public immutable N_COINS;
    uint256 public A;  // æ”¾å¤§ç³»æ•°
    uint256 public fee = 4000000; // 0.04%
    uint256 public admin_fee = 5000000000; // 50%çš„è´¹ç”¨å½’åè®®
    
    uint256[] public balances;
    uint256 public totalSupply;
    
    // è®¡ç®—Då€¼ï¼ˆç‰›é¡¿æ³•ï¼‰
    function get_D(uint256[] memory xp, uint256 amp) private pure returns (uint256) {
        uint256 S = 0;
        uint256 Dprev = 0;
        
        for (uint256 i = 0; i < xp.length; i++) {
            S += xp[i];
        }
        if (S == 0) return 0;
        
        uint256 D = S;
        uint256 Ann = amp * xp.length;
        
        for (uint256 i = 0; i < 255; i++) {
            uint256 D_P = D;
            for (uint256 j = 0; j < xp.length; j++) {
                D_P = D_P * D / (xp[j] * xp.length);
            }
            Dprev = D;
            D = (Ann * S / A_PRECISION + D_P * xp.length) * D / 
                ((Ann - A_PRECISION) * D / A_PRECISION + (xp.length + 1) * D_P);
            
            if (D > Dprev) {
                if (D - Dprev <= 1) break;
            } else {
                if (Dprev - D <= 1) break;
            }
        }
        return D;
    }
    
    // è®¡ç®—äº¤æ¢åçš„ä½™é¢ï¼ˆç‰›é¡¿æ³•ï¼‰
    function get_y(
        uint256 i,
        uint256 j,
        uint256 x,
        uint256[] memory xp_
    ) private view returns (uint256) {
        require(i != j, "Same coin");
        require(j < N_COINS, "j too large");
        require(i < N_COINS, "i too large");
        
        uint256 amp = A;
        uint256 D = get_D(xp_, amp);
        
        uint256 S_ = 0;
        uint256 _x = 0;
        uint256 y_prev = 0;
        uint256 c = D;
        uint256 Ann = amp * N_COINS;
        
        for (uint256 k = 0; k < N_COINS; k++) {
            if (k == i) {
                _x = x;
            } else if (k != j) {
                _x = xp_[k];
            } else {
                continue;
            }
            S_ += _x;
            c = c * D / (_x * N_COINS);
        }
        
        c = c * D * A_PRECISION / (Ann * N_COINS);
        uint256 b = S_ + D * A_PRECISION / Ann;
        uint256 y = D;
        
        for (uint256 k = 0; k < 255; k++) {
            y_prev = y;
            y = (y * y + c) / (2 * y + b - D);
            if (y > y_prev) {
                if (y - y_prev <= 1) break;
            } else {
                if (y_prev - y <= 1) break;
            }
        }
        return y;
    }
    
    // è®¡ç®—è¾“å‡ºé‡‘é¢ï¼ˆå«åŠ¨æ€è´¹ç”¨ï¼‰
    function get_dy(
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256) {
        uint256[] memory xp = _xp();
        
        uint256 x = xp[i] + dx;
        uint256 y = get_y(i, j, x, xp);
        uint256 dy = xp[j] - y - 1;
        
        // åŠ¨æ€è´¹ç”¨è®¡ç®—
        uint256 _fee = fee * N_COINS / (4 * (N_COINS - 1));
        
        // æ ¹æ®æ± å­å¹³è¡¡åº¦è°ƒæ•´è´¹ç”¨
        uint256 balanced_fee = _calculate_balanced_fee(xp, i, j);
        _fee = _fee * balanced_fee / FEE_DENOMINATOR;
        
        return dy - dy * _fee / FEE_DENOMINATOR;
    }
    
    // åŠ¨æ€è´¹ç”¨ï¼šæ± å­è¶Šä¸å¹³è¡¡ï¼Œè´¹ç”¨è¶Šé«˜
    function _calculate_balanced_fee(
        uint256[] memory xp,
        uint256 i,
        uint256 j
    ) private pure returns (uint256) {
        uint256 sum = 0;
        for (uint256 k = 0; k < xp.length; k++) {
            sum += xp[k];
        }
        
        uint256 avg = sum / xp.length;
        uint256 imbalance = 0;
        
        // è®¡ç®—ä¸å¹³è¡¡åº¦
        for (uint256 k = 0; k < xp.length; k++) {
            uint256 diff = xp[k] > avg ? xp[k] - avg : avg - xp[k];
            imbalance += diff * PRECISION / avg;
        }
        
        // è´¹ç”¨å€æ•°ï¼š1xåˆ°4x
        return FEE_DENOMINATOR + imbalance * 3;
    }
    
    // æ‰§è¡Œäº¤æ¢
    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy,
        address receiver
    ) external returns (uint256) {
        require(i != j, "Same coin");
        require(dx > 0, "dx = 0");
        
        uint256[] memory old_balances = balances;
        uint256[] memory xp = _xp_mem(old_balances);
        
        // è½¬å…¥ä»£å¸
        IERC20(coins[i]).transferFrom(msg.sender, address(this), dx);
        
        uint256 x = xp[i] + dx;
        uint256 y = get_y(i, j, x, xp);
        
        uint256 dy = xp[j] - y - 1; // -1ä»¥é˜²èˆå…¥é”™è¯¯
        uint256 dy_fee = dy * fee / FEE_DENOMINATOR;
        
        // åŠ¨æ€è´¹ç”¨
        uint256 balanced_fee = _calculate_balanced_fee(xp, i, j);
        dy_fee = dy_fee * balanced_fee / FEE_DENOMINATOR;
        
        dy = dy - dy_fee;
        require(dy >= min_dy, "Slippage");
        
        // æ›´æ–°ä½™é¢
        balances[i] = old_balances[i] + dx;
        balances[j] = old_balances[j] - dy;
        
        // è½¬å‡ºä»£å¸
        IERC20(coins[j]).transfer(receiver, dy);
        
        emit TokenExchange(msg.sender, i, dx, j, dy);
        
        return dy;
    }
    
    // æ·»åŠ æµåŠ¨æ€§ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
    function add_liquidity(
        uint256[] memory amounts,
        uint256 min_mint_amount
    ) external returns (uint256) {
        require(amounts.length == N_COINS, "Invalid amounts");
        
        uint256[] memory fees = new uint256[](N_COINS);
        uint256 _fee = fee * N_COINS / (4 * (N_COINS - 1));
        uint256 amp = A;
        
        uint256 token_supply = totalSupply;
        uint256[] memory old_balances = balances;
        uint256 D0 = 0;
        
        if (token_supply > 0) {
            D0 = get_D(_xp_mem(old_balances), amp);
        }
        
        uint256[] memory new_balances = new uint256[](N_COINS);
        
        for (uint256 i = 0; i < N_COINS; i++) {
            if (token_supply == 0) {
                require(amounts[i] > 0, "Initial deposit requires all coins");
            }
            
            // è½¬å…¥ä»£å¸
            if (amounts[i] > 0) {
                IERC20(coins[i]).transferFrom(msg.sender, address(this), amounts[i]);
            }
            
            new_balances[i] = old_balances[i] + amounts[i];
        }
        
        uint256 D1 = get_D(_xp_mem(new_balances), amp);
        require(D1 > D0, "D1 <= D0");
        
        uint256 mint_amount = 0;
        
        if (token_supply == 0) {
            mint_amount = D1;
        } else {
            // è®¡ç®—ç†æƒ³ä½™é¢
            uint256[] memory ideal_balance = new uint256[](N_COINS);
            uint256 difference = 0;
            
            for (uint256 i = 0; i < N_COINS; i++) {
                ideal_balance[i] = D1 * old_balances[i] / D0;
                uint256 diff = ideal_balance[i] > new_balances[i] ? 
                    ideal_balance[i] - new_balances[i] : 
                    new_balances[i] - ideal_balance[i];
                difference += diff;
            }
            
            // æ ¹æ®ä¸å¹³è¡¡ç¨‹åº¦æ”¶è´¹
            if (difference > 0) {
                _fee = _fee * N_COINS * difference / D1;
            }
            
            mint_amount = token_supply * (D1 - D0) / D0;
            
            // æ‰£é™¤è´¹ç”¨
            mint_amount = mint_amount - mint_amount * _fee / FEE_DENOMINATOR;
        }
        
        require(mint_amount >= min_mint_amount, "Slippage");
        
        // æ›´æ–°çŠ¶æ€
        for (uint256 i = 0; i < N_COINS; i++) {
            balances[i] = new_balances[i];
        }
        
        totalSupply += mint_amount;
        _mint(msg.sender, mint_amount);
        
        emit AddLiquidity(msg.sender, amounts, fees, D1, token_supply + mint_amount);
        
        return mint_amount;
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.3.2 Curve V2ï¼šåŠ¨æ€è°ƒæ•´çš„è‡ªé€‚åº”AMM</h4>
        <p>Curve V2ï¼ˆä¹Ÿç§°ä¸ºTricryptoï¼‰æ˜¯DeFiä¸­æœ€å…ˆè¿›çš„AMMè®¾è®¡ä¹‹ä¸€ï¼Œå®ƒå¼•å…¥äº†è‡ªé€‚åº”æœºåˆ¶æ¥å¤„ç†æ³¢åŠ¨èµ„äº§ï¼š</p>
        
        <div class="info-box">
            <h5>ğŸš€ Curve V2çš„é©å‘½æ€§åˆ›æ–°</h5>
            <ul>
                <li><strong>å†…éƒ¨é¢„è¨€æœºï¼š</strong>ä½¿ç”¨EMAï¼ˆæŒ‡æ•°ç§»åŠ¨å¹³å‡ï¼‰è¿½è¸ª"çœŸå®"å¸‚åœºä»·æ ¼</li>
                <li><strong>åŠ¨æ€æ”¾å¤§ç³»æ•°ï¼š</strong>æ ¹æ®å¸‚åœºæ¡ä»¶è‡ªåŠ¨è°ƒæ•´Aå€¼</li>
                <li><strong>åŠ¨æ€è´¹ç”¨ï¼š</strong>æ± å­å¤±è¡¡æ—¶æé«˜è´¹ç”¨ï¼Œå¹³è¡¡æ—¶é™ä½è´¹ç”¨</li>
                <li><strong>Kå€¼é‡å®šä»·ï¼š</strong>é€šè¿‡è°ƒæ•´Kå€¼æ¿€åŠ±å¥—åˆ©è€…æ¢å¤å¹³è¡¡</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Curve V2è‡ªé€‚åº”æœºåˆ¶å®ç° <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract CurveV2Pool {
    // V2æ ¸å¿ƒå‚æ•°
    uint256 public A;           // åŸºç¡€æ”¾å¤§ç³»æ•°
    uint256 public gamma;       // é£é™©å‚æ•°ï¼ˆæ§åˆ¶æ›²ç‡ï¼‰
    uint256 public mid_fee;     // åŸºç¡€è´¹ç”¨
    uint256 public out_fee;     // æœ€å¤§è´¹ç”¨
    uint256 public fee_gamma;   // è´¹ç”¨è°ƒæ•´é€Ÿåº¦
    
    // å†…éƒ¨é¢„è¨€æœºçŠ¶æ€
    uint256 public price_oracle;    // EMAä»·æ ¼
    uint256 public price_scale;     // å½“å‰æ± å†…ä»·æ ¼
    uint256 public last_prices_timestamp;
    
    // åŠ¨æ€Aå’Œgamma
    uint256 public future_A;
    uint256 public future_gamma;
    uint256 public future_time;
    
    // è®¡ç®—åŠ¨æ€è´¹ç”¨
    function dynamic_fee() public view returns (uint256) {
        // è·å–å½“å‰ä»·æ ¼åç¦»åº¦
        uint256 xp0 = balances[0] * PRECISION / price_scale;
        uint256 xp1 = balances[1] * PRECISION;
        
        // ç†æƒ³å¹³è¡¡ç‚¹
        uint256 ideal_balance = (xp0 + xp1) / 2;
        
        // è®¡ç®—ä¸å¹³è¡¡åº¦
        uint256 imbalance = xp0 > xp1 ? 
            (xp0 - ideal_balance) * PRECISION / ideal_balance :
            (ideal_balance - xp1) * PRECISION / ideal_balance;
            
        // åŠ¨æ€è´¹ç”¨ = mid_fee + (out_fee - mid_fee) * imbalance^fee_gamma
        uint256 fee = mid_fee;
        if (imbalance > 0) {
            // ä½¿ç”¨è¿‘ä¼¼çš„å¹‚å‡½æ•°è®¡ç®—
            uint256 fee_multiplier = pow_approx(imbalance, fee_gamma);
            fee = mid_fee + (out_fee - mid_fee) * fee_multiplier / PRECISION;
        }
        
        return fee;
    }
    
    // æ›´æ–°å†…éƒ¨é¢„è¨€æœº
    function tweak_price(
        uint256 A_gamma,
        uint256 new_price_scale,
        uint256 K0_prev
    ) internal {
        // æ—¶é—´è¡°å‡å› å­
        uint256 time_since = block.timestamp - last_prices_timestamp;
        uint256 alpha = exp_decay(time_since);
        
        // æ›´æ–°EMAä»·æ ¼
        price_oracle = (price_oracle * alpha + new_price_scale * (PRECISION - alpha)) / PRECISION;
        
        // å½“ä»·æ ¼åç¦»è¿‡å¤§æ—¶ï¼Œè°ƒæ•´Kå€¼
        uint256 price_deviation = new_price_scale > price_oracle ?
            (new_price_scale - price_oracle) * PRECISION / price_oracle :
            (price_oracle - new_price_scale) * PRECISION / price_oracle;
            
        if (price_deviation > allowed_extra_profit) {
            // é‡æ–°å®šä»·Kå€¼ï¼Œæ¿€åŠ±å¥—åˆ©
            K0 = K0 * (PRECISION + adjustment_step) / PRECISION;
        }
        
        price_scale = new_price_scale;
        last_prices_timestamp = block.timestamp;
        
        emit PriceOracleUpdated(price_oracle, price_scale);
    }
    
    // è‡ªé€‚åº”å‚æ•°è°ƒæ•´
    function update_parameters(
        uint256 _future_A,
        uint256 _future_gamma,
        uint256 _future_time
    ) external onlyOwner {
        require(_future_time > block.timestamp + MIN_RAMP_TIME, "Too soon");
        
        // é™åˆ¶å‚æ•°å˜åŒ–å¹…åº¦
        require(_future_A > A / 10 && _future_A < A * 10, "A change too large");
        require(_future_gamma > gamma / 10 && _future_gamma < gamma * 10, "gamma change too large");
        
        future_A = _future_A;
        future_gamma = _future_gamma;
        future_time = _future_time;
        
        emit ParametersUpdateScheduled(_future_A, _future_gamma, _future_time);
    }
    
    // è·å–å½“å‰æœ‰æ•ˆå‚æ•°ï¼ˆçº¿æ€§æ’å€¼ï¼‰
    function get_A_gamma() public view returns (uint256 A_effective, uint256 gamma_effective) {
        uint256 t = block.timestamp;
        
        if (t < future_time) {
            // çº¿æ€§è¿‡æ¸¡
            uint256 elapsed = t - initial_time;
            uint256 total_time = future_time - initial_time;
            
            A_effective = initial_A + (future_A - initial_A) * elapsed / total_time;
            gamma_effective = initial_gamma + (future_gamma - initial_gamma) * elapsed / total_time;
        } else {
            A_effective = future_A;
            gamma_effective = future_gamma;
        }
    }
    
    // é˜²æ­¢ä»·æ ¼æ“çºµçš„å»¶è¿Ÿæœºåˆ¶
    function claim_admin_fees() external {
        require(block.timestamp > last_claim_time + MIN_CLAIM_INTERVAL, "Too frequent");
        
        // åªæœ‰å½“ä»·æ ¼ç¨³å®šæ—¶æ‰èƒ½æå–è´¹ç”¨
        uint256 price_threshold = PRECISION * 2 / 100; // 2%
        require(
            abs_diff(price_scale, price_oracle) < price_threshold,
            "Price not stable"
        );
        
        // è®¡ç®—å¹¶è½¬ç§»ç®¡ç†è´¹
        uint256 admin_share = calculate_admin_fees();
        _transfer_fees(admin_share);
        
        last_claim_time = block.timestamp;
    }
}</code></pre>
            </div>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">V2å‚æ•°ä¼˜åŒ–çš„AI/MLæ–¹æ³• <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># ä½¿ç”¨å¼ºåŒ–å­¦ä¹ ä¼˜åŒ–Curve V2å‚æ•°
import numpy as np
import torch
import torch.nn as nn
from collections import deque

class CurveV2Optimizer:
    """åŸºäºæ·±åº¦å¼ºåŒ–å­¦ä¹ çš„Curve V2å‚æ•°ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.state_dim = 10  # å¸‚åœºçŠ¶æ€ç»´åº¦
        self.action_dim = 4   # A, gamma, mid_fee, out_fee
        
        # ç­–ç•¥ç½‘ç»œ
        self.policy_net = nn.Sequential(
            nn.Linear(self.state_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, self.action_dim),
            nn.Sigmoid()  # è¾“å‡º0-1èŒƒå›´
        )
        
        # ç»éªŒå›æ”¾
        self.memory = deque(maxlen=10000)
        
    def get_market_state(self, pool_data):
        """æå–å¸‚åœºçŠ¶æ€ç‰¹å¾"""
        state = []
        
        # 1. ä»·æ ¼åç¦»åº¦
        price_deviation = abs(pool_data['price_scale'] - pool_data['price_oracle']) / pool_data['price_oracle']
        state.append(price_deviation)
        
        # 2. æ± å­ä¸å¹³è¡¡åº¦
        total = sum(pool_data['balances'])
        imbalance = max(pool_data['balances']) / total - 0.5
        state.append(imbalance)
        
        # 3. å†å²æ³¢åŠ¨ç‡ï¼ˆ24hï¼‰
        volatility = np.std(pool_data['price_history'][-96:]) / np.mean(pool_data['price_history'][-96:])
        state.append(volatility)
        
        # 4. äº¤æ˜“é‡è¶‹åŠ¿
        volume_ma_short = np.mean(pool_data['volume_history'][-24:])
        volume_ma_long = np.mean(pool_data['volume_history'][-168:])
        volume_trend = volume_ma_short / (volume_ma_long + 1e-8) - 1
        state.append(volume_trend)
        
        # 5. è´¹ç”¨æ”¶ç›Šç‡
        fee_apr = pool_data['fees_24h'] * 365 / pool_data['tvl']
        state.append(fee_apr)
        
        # 6. æ— å¸¸æŸå¤±ä¼°è®¡
        il_estimate = self.estimate_impermanent_loss(pool_data)
        state.append(il_estimate)
        
        # 7-10. å…¶ä»–å¸‚åœºæŒ‡æ ‡
        state.extend([
            pool_data['gas_price_gwei'] / 100,  # æ ‡å‡†åŒ–gasä»·æ ¼
            pool_data['market_fear_greed'] / 100,  # å¸‚åœºæƒ…ç»ª
            pool_data['competing_pools_tvl'] / pool_data['tvl'],  # ç«äº‰æ€åŠ¿
            pool_data['arbitrage_volume'] / pool_data['total_volume']  # å¥—åˆ©å æ¯”
        ])
        
        return np.array(state, dtype=np.float32)
    
    def predict_optimal_params(self, market_state):
        """é¢„æµ‹æœ€ä¼˜å‚æ•°"""
        with torch.no_grad():
            state_tensor = torch.FloatTensor(market_state).unsqueeze(0)
            raw_output = self.policy_net(state_tensor)
            
            # å°†ç½‘ç»œè¾“å‡ºæ˜ å°„åˆ°å®é™…å‚æ•°èŒƒå›´
            params = {
                'A': int(10 + raw_output[0, 0].item() * 990),  # 10-1000
                'gamma': int(1e14 + raw_output[0, 1].item() * 9e14),  # 0.0001-0.001
                'mid_fee': int(1e6 + raw_output[0, 2].item() * 4e6),  # 0.01%-0.05%
                'out_fee': int(1e7 + raw_output[0, 3].item() * 9e7)   # 0.1%-1%
            }
            
        return params
    
    def simulate_parameter_impact(self, pool_state, new_params, horizon=24):
        """æ¨¡æ‹Ÿå‚æ•°å˜æ›´çš„å½±å“"""
        results = {
            'revenue': [],
            'il': [],
            'volume': [],
            'price_stability': []
        }
        
        # è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ
        for _ in range(100):
            sim_pool = self.create_pool_copy(pool_state)
            sim_pool.update_parameters(new_params)
            
            for hour in range(horizon):
                # æ¨¡æ‹Ÿå¸‚åœºæ´»åŠ¨
                trades = self.generate_random_trades()
                
                for trade in trades:
                    revenue = sim_pool.execute_trade(trade)
                    results['revenue'].append(revenue)
                
                # è®°å½•æŒ‡æ ‡
                results['il'].append(sim_pool.calculate_il())
                results['volume'].append(sim_pool.get_volume())
                results['price_stability'].append(sim_pool.get_price_stability())
        
        # è®¡ç®—é¢„æœŸæ”¶ç›Š
        expected_performance = {
            'revenue': np.mean(results['revenue']),
            'il': np.mean(results['il']),
            'volume': np.mean(results['volume']),
            'sharpe_ratio': self.calculate_sharpe_ratio(results)
        }
        
        return expected_performance
    
    def auto_tune_parameters(self, pool_address):
        """è‡ªåŠ¨è°ƒå‚ä¸»å¾ªç¯"""
        pool = CurveV2Pool(pool_address)
        
        while True:
            # è·å–å½“å‰å¸‚åœºçŠ¶æ€
            pool_data = pool.get_current_data()
            market_state = self.get_market_state(pool_data)
            
            # é¢„æµ‹æœ€ä¼˜å‚æ•°
            optimal_params = self.predict_optimal_params(market_state)
            
            # æ¨¡æ‹Ÿå½±å“
            impact = self.simulate_parameter_impact(pool_data, optimal_params)
            
            # å†³ç­–ï¼šæ˜¯å¦æ›´æ–°å‚æ•°
            if impact['sharpe_ratio'] > pool_data['current_sharpe'] * 1.1:
                # é¢„æœŸæ€§èƒ½æå‡10%ä»¥ä¸Šï¼Œæ‰§è¡Œæ›´æ–°
                print(f"Updating parameters: {optimal_params}")
                pool.schedule_parameter_update(optimal_params)
                
                # è®°å½•ç»“æœç”¨äºå­¦ä¹ 
                self.memory.append({
                    'state': market_state,
                    'action': optimal_params,
                    'reward': None  # å°†åœ¨æœªæ¥å¡«å……å®é™…ç»“æœ
                })
            
            # ç­‰å¾…ä¸‹ä¸€ä¸ªå‘¨æœŸ
            time.sleep(3600)  # æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡

# ä½¿ç”¨ç¤ºä¾‹
optimizer = CurveV2Optimizer()
optimizer.auto_tune_parameters("0x...")  # Curve V2æ± åœ°å€</code></pre>
            </div>
        </div>

        <h3>6.4 é«˜çº§AMMä¼˜åŒ–ç­–ç•¥</h3>
        
        <h4>6.4.1 æ··åˆAMMè®¾è®¡</h4>
        <p>ç»“åˆä¸åŒAMMæ¨¡å‹çš„ä¼˜ç‚¹ï¼Œä¸ºç¨³å®šå¸åˆ›é€ æ›´é«˜æ•ˆçš„äº¤æ˜“ç¯å¢ƒï¼š</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">æ··åˆAMMå®ç° <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract HybridStableSwap {
    // ç»“åˆCurveå’ŒUniswap V3çš„ä¼˜ç‚¹
    
    uint256 private constant CURVE_THRESHOLD = 100; // åŸºç‚¹ï¼Œ1%
    uint256 private constant A = 100; // Curveæ”¾å¤§ç³»æ•°
    
    IUniswapV3Pool public immutable uniV3Pool;
    IStableSwap public immutable curvePool;
    
    struct RouteParams {
        bool useCurve;
        uint256 expectedOut;
        uint256 priceImpact;
        uint256 gasEstimate;
    }
    
    // æ™ºèƒ½è·¯ç”±ï¼šé€‰æ‹©æœ€ä¼˜AMM
    function findBestRoute(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) public view returns (RouteParams memory best) {
        // è·å–CurveæŠ¥ä»·
        uint256 curveOut = _getCurveQuote(tokenIn, tokenOut, amountIn);
        uint256 curvePriceImpact = _calculatePriceImpact(amountIn, curveOut);
        
        // è·å–UniV3æŠ¥ä»·
        uint256 uniV3Out = _getUniV3Quote(tokenIn, tokenOut, amountIn);
        uint256 uniV3PriceImpact = _calculatePriceImpact(amountIn, uniV3Out);
        
        // è€ƒè™‘Gasæˆæœ¬
        uint256 curveGas = 150000; // ä¼°è®¡å€¼
        uint256 uniV3Gas = 180000; // ä¼°è®¡å€¼
        
        // å†³ç­–é€»è¾‘
        if (curvePriceImpact < CURVE_THRESHOLD && curveOut > uniV3Out) {
            best = RouteParams({
                useCurve: true,
                expectedOut: curveOut,
                priceImpact: curvePriceImpact,
                gasEstimate: curveGas
            });
        } else {
            best = RouteParams({
                useCurve: false,
                expectedOut: uniV3Out,
                priceImpact: uniV3PriceImpact,
                gasEstimate: uniV3Gas
            });
        }
    }
    
    // æ‰§è¡Œæœ€ä¼˜è·¯ç”±äº¤æ¢
    function smartSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient
    ) external returns (uint256 amountOut) {
        RouteParams memory route = findBestRoute(tokenIn, tokenOut, amountIn);
        require(route.expectedOut >= minAmountOut, "Insufficient output");
        
        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        
        if (route.useCurve) {
            IERC20(tokenIn).approve(address(curvePool), amountIn);
            amountOut = curvePool.exchange(
                _getTokenIndex(tokenIn),
                _getTokenIndex(tokenOut),
                amountIn,
                minAmountOut,
                recipient
            );
        } else {
            amountOut = _swapOnUniV3(tokenIn, tokenOut, amountIn, minAmountOut, recipient);
        }
        
        emit SmartSwapExecuted(
            tokenIn,
            tokenOut,
            amountIn,
            amountOut,
            route.useCurve,
            route.priceImpact
        );
    }
    
    // åŠ¨æ€æµåŠ¨æ€§åˆ†é…
    function rebalanceLiquidity() external {
        // è·å–ä¸¤ä¸ªæ± çš„TVLå’Œäº¤æ˜“é‡
        uint256 curveTVL = _getCurveTVL();
        uint256 uniV3TVL = _getUniV3TVL();
        uint256 curveVolume24h = _getCurveVolume24h();
        uint256 uniV3Volume24h = _getUniV3Volume24h();
        
        // è®¡ç®—æ•ˆç‡æŒ‡æ ‡
        uint256 curveEfficiency = curveVolume24h * 1e18 / curveTVL;
        uint256 uniV3Efficiency = uniV3Volume24h * 1e18 / uniV3TVL;
        
        // æ ¹æ®æ•ˆç‡è°ƒæ•´æµåŠ¨æ€§åˆ†é…
        if (curveEfficiency > uniV3Efficiency * 120 / 100) {
            // Curveæ•ˆç‡é«˜20%ä»¥ä¸Šï¼Œå¢åŠ CurveæµåŠ¨æ€§
            _shiftLiquidityToCurve();
        } else if (uniV3Efficiency > curveEfficiency * 120 / 100) {
            // UniV3æ•ˆç‡é«˜20%ä»¥ä¸Šï¼Œå¢åŠ UniV3æµåŠ¨æ€§
            _shiftLiquidityToUniV3();
        }
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.4.2 MEVé˜²æŠ¤æœºåˆ¶</h4>
        <p>ç¨³å®šå¸AMMç‰¹åˆ«å®¹æ˜“å—åˆ°MEVæ”»å‡»ï¼Œéœ€è¦ä¸“é—¨çš„é˜²æŠ¤æœºåˆ¶ï¼š</p>
        
        <div class="tip-box">
            <strong>ğŸ›¡ï¸ MEVæ”»å‡»ç±»å‹ï¼š</strong>
            <ul>
                <li><strong>ä¸‰æ˜æ²»æ”»å‡»ï¼š</strong>åœ¨å¤§é¢äº¤æ˜“å‰åæ’å…¥äº¤æ˜“è·åˆ©</li>
                <li><strong>å¥—åˆ©æ”»å‡»ï¼š</strong>åˆ©ç”¨ä¸åŒæ± ä¹‹é—´çš„ä»·æ ¼å·®</li>
                <li><strong>JITæµåŠ¨æ€§ï¼š</strong>åœ¨äº¤æ˜“å‰æ·»åŠ æµåŠ¨æ€§ï¼Œäº¤æ˜“åç«‹å³ç§»é™¤</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">MEVé˜²æŠ¤AMM <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract MEVProtectedAMM {
    using SafeMath for uint256;
    
    uint256 private constant TWAP_WINDOW = 600; // 10åˆ†é’Ÿ
    uint256 private constant MAX_PRICE_IMPACT = 50; // 0.5%
    uint256 private constant COMMIT_DELAY = 2; // 2ä¸ªåŒºå—å»¶è¿Ÿ
    
    struct PriceObservation {
        uint256 timestamp;
        uint256 price0Cumulative;
        uint256 price1Cumulative;
    }
    
    struct CommitData {
        address user;
        bytes32 commitment;
        uint256 blockNumber;
        bool revealed;
    }
    
    PriceObservation[] public observations;
    mapping(bytes32 => CommitData) public commitments;
    
    // TWAPä»·æ ¼è®¡ç®—
    function getTWAPPrice() public view returns (uint256) {
        require(observations.length >= 2, "Insufficient observations");
        
        uint256 length = observations.length;
        PriceObservation memory oldest = observations[length - 2];
        PriceObservation memory newest = observations[length - 1];
        
        uint256 timeElapsed = newest.timestamp - oldest.timestamp;
        require(timeElapsed >= TWAP_WINDOW, "TWAP window too small");
        
        uint256 price0Average = (newest.price0Cumulative - oldest.price0Cumulative) / timeElapsed;
        uint256 price1Average = (newest.price1Cumulative - oldest.price1Cumulative) / timeElapsed;
        
        return price0Average * 1e18 / price1Average;
    }
    
    // Commit-Revealæœºåˆ¶é˜²æ­¢æŠ¢è·‘
    function commitSwap(
        bytes32 commitment
    ) external {
        bytes32 commitId = keccak256(abi.encodePacked(msg.sender, commitment));
        
        commitments[commitId] = CommitData({
            user: msg.sender,
            commitment: commitment,
            blockNumber: block.number,
            revealed: false
        });
        
        emit SwapCommitted(msg.sender, commitId, block.number);
    }
    
    function revealSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 nonce
    ) external returns (uint256 amountOut) {
        // éªŒè¯commitment
        bytes32 commitment = keccak256(abi.encodePacked(
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut,
            nonce
        ));
        
        bytes32 commitId = keccak256(abi.encodePacked(msg.sender, commitment));
        CommitData storage commit = commitments[commitId];
        
        require(commit.user == msg.sender, "Invalid commitment");
        require(!commit.revealed, "Already revealed");
        require(block.number >= commit.blockNumber + COMMIT_DELAY, "Too early");
        require(block.number <= commit.blockNumber + COMMIT_DELAY + 10, "Too late");
        
        commit.revealed = true;
        
        // ä»·æ ¼æ£€æŸ¥
        uint256 twapPrice = getTWAPPrice();
        uint256 spotPrice = getSpotPrice();
        uint256 priceDeviation = spotPrice > twapPrice ? 
            (spotPrice - twapPrice) * 10000 / twapPrice :
            (twapPrice - spotPrice) * 10000 / twapPrice;
        
        require(priceDeviation <= MAX_PRICE_IMPACT, "Price manipulation detected");
        
        // æ‰§è¡Œäº¤æ¢
        amountOut = _executeSwap(tokenIn, tokenOut, amountIn, minAmountOut);
        
        emit SwapExecuted(msg.sender, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    // æ‰¹é‡äº¤æ˜“ä»¥åˆ†æ‘ŠGasæˆæœ¬
    function batchSwap(
        SwapData[] calldata swaps
    ) external {
        uint256 totalGasSaved = 0;
        
        for (uint256 i = 0; i < swaps.length; i++) {
            SwapData memory swap = swaps[i];
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶ç›¸åŒè·¯å¾„çš„äº¤æ˜“
            uint256 combinedAmountIn = swap.amountIn;
            uint256 j = i + 1;
            
            while (j < swaps.length && 
                   swaps[j].tokenIn == swap.tokenIn && 
                   swaps[j].tokenOut == swap.tokenOut) {
                combinedAmountIn += swaps[j].amountIn;
                j++;
            }
            
            // æ‰§è¡Œåˆå¹¶åçš„äº¤æ¢
            if (j > i + 1) {
                uint256 amountOut = _executeSwap(
                    swap.tokenIn,
                    swap.tokenOut,
                    combinedAmountIn,
                    0
                );
                
                // æŒ‰æ¯”ä¾‹åˆ†é…è¾“å‡º
                for (uint256 k = i; k < j; k++) {
                    uint256 userAmountOut = amountOut * swaps[k].amountIn / combinedAmountIn;
                    IERC20(swap.tokenOut).transfer(swaps[k].recipient, userAmountOut);
                }
                
                totalGasSaved += (j - i - 1) * 100000; // ä¼°è®¡èŠ‚çœçš„Gas
                i = j - 1; // è·³è¿‡å·²å¤„ç†çš„äº¤æ˜“
            } else {
                _executeSwap(
                    swap.tokenIn,
                    swap.tokenOut,
                    swap.amountIn,
                    swap.minAmountOut
                );
            }
        }
        
        emit BatchSwapExecuted(swaps.length, totalGasSaved);
    }
    
    // å»¶è¿Ÿä»·æ ¼æ›´æ–°é˜²æ­¢æ“çºµ
    function updatePriceOracle() external {
        uint256 timeElapsed = block.timestamp - observations[observations.length - 1].timestamp;
        require(timeElapsed >= 60, "Update too frequent"); // æœ€å°‘1åˆ†é’Ÿé—´éš”
        
        (uint112 reserve0, uint112 reserve1,) = getReserves();
        
        uint256 price0Cumulative = observations[observations.length - 1].price0Cumulative + 
            reserve1 * timeElapsed / reserve0;
        uint256 price1Cumulative = observations[observations.length - 1].price1Cumulative + 
            reserve0 * timeElapsed / reserve1;
        
        observations.push(PriceObservation({
            timestamp: block.timestamp,
            price0Cumulative: price0Cumulative,
            price1Cumulative: price1Cumulative
        }));
        
        // é™åˆ¶æ•°ç»„å¤§å°
        if (observations.length > 24) {
            for (uint256 i = 0; i < observations.length - 24; i++) {
                observations[i] = observations[i + 1];
            }
            observations.pop();
        }
    }
}</code></pre>
            </div>
        </div>

        <h3>6.5 2024å¹´æœ€æ–°å‘å±•è¶‹åŠ¿</h3>
        
        <h4>6.5.1 Uniswap V4 Hooksï¼šå¯ç»„åˆçš„AMMæ–°èŒƒå¼</h4>
        <div class="info-box">
            <h5>ğŸ”— Hookså¸¦æ¥çš„é©å‘½æ€§å˜åŒ–</h5>
            <ul>
                <li><strong>è‡ªå®šä¹‰é€»è¾‘ï¼š</strong>åœ¨äº¤æ˜“ç”Ÿå‘½å‘¨æœŸçš„ä»»ä½•ç‚¹æ’å…¥è‡ªå®šä¹‰ä»£ç </li>
                <li><strong>åŠ¨æ€è´¹ç”¨ï¼š</strong>åŸºäºä»»æ„é€»è¾‘å®æ—¶è°ƒæ•´è´¹ç”¨</li>
                <li><strong>MEVå†…éƒ¨åŒ–ï¼š</strong>å°†MEVæ”¶ç›Šè¿”è¿˜ç»™LPè€Œéå¥—åˆ©è€…</li>
                <li><strong>æ¡ä»¶è®¢å•ï¼š</strong>å®ç°é™ä»·å•ã€æ­¢æŸå•ç­‰å¤æ‚è®¢å•ç±»å‹</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Uniswap V4 ç¨³å®šå¸ä¸“ç”¨Hookç¤ºä¾‹ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract StablecoinOptimizedHook is BaseHook {
    using FixedPoint96 for uint256;
    
    // Hooké…ç½®
    struct HookConfig {
        uint24 baseFee;           // åŸºç¡€è´¹ç”¨
        uint24 maxFee;            // æœ€å¤§è´¹ç”¨
        uint256 targetRatio;      // ç›®æ ‡å¹³è¡¡æ¯”ä¾‹
        uint256 priceThreshold;   // ä»·æ ¼åç¦»é˜ˆå€¼
        bool enableMEVProtection; // MEVä¿æŠ¤å¼€å…³
    }
    
    mapping(PoolId => HookConfig) public poolConfigs;
    mapping(PoolId => uint256) public lastTradeTimestamp;
    
    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params
    ) external override returns (bytes4) {
        // 1. åŠ¨æ€è´¹ç”¨è°ƒæ•´
        uint24 dynamicFee = calculateDynamicFee(key.toId(), params);
        
        // 2. MEVä¿æŠ¤ï¼šæ£€æµ‹æ½œåœ¨çš„ä¸‰æ˜æ²»æ”»å‡»
        if (poolConfigs[key.toId()].enableMEVProtection) {
            require(
                block.timestamp > lastTradeTimestamp[key.toId()] + 1,
                "Too frequent trading"
            );
        }
        
        // 3. å¤§é¢äº¤æ˜“è­¦å‘Š
        if (params.amountSpecified > getPoolLiquidity(key.toId()) / 100) {
            emit LargeTradeWarning(sender, params.amountSpecified);
        }
        
        // æ›´æ–°è´¹ç”¨
        poolManager.updateDynamicFee(key, dynamicFee);
        
        return BaseHook.beforeSwap.selector;
    }
    
    function afterSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        BalanceDelta delta
    ) external override returns (bytes4) {
        // 1. æ›´æ–°ä»·æ ¼é¢„è¨€æœº
        updateInternalOracle(key.toId(), delta);
        
        // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘å†å¹³è¡¡
        if (shouldRebalance(key.toId())) {
            triggerRebalance(key.toId());
        }
        
        // 3. åˆ†é…MEVæ”¶ç›Šç»™LP
        uint256 mevRevenue = calculateMEVRevenue(params, delta);
        if (mevRevenue > 0) {
            distributeMEVToLPs(key.toId(), mevRevenue);
        }
        
        lastTradeTimestamp[key.toId()] = block.timestamp;
        
        return BaseHook.afterSwap.selector;
    }
    
    function calculateDynamicFee(
        PoolId poolId,
        IPoolManager.SwapParams calldata params
    ) internal view returns (uint24) {
        HookConfig memory config = poolConfigs[poolId];
        
        // è·å–æ± å­çŠ¶æ€
        (uint256 balance0, uint256 balance1) = getPoolBalances(poolId);
        uint256 totalBalance = balance0 + balance1;
        
        // è®¡ç®—ä¸å¹³è¡¡åº¦
        uint256 imbalance = balance0 > balance1 ?
            (balance0 - balance1) * 1e6 / totalBalance :
            (balance1 - balance0) * 1e6 / totalBalance;
            
        // æ ¹æ®äº¤æ˜“æ–¹å‘è°ƒæ•´è´¹ç”¨
        bool isBalancing = (params.zeroForOne && balance0 > balance1) ||
                          (!params.zeroForOne && balance1 > balance0);
                          
        if (isBalancing) {
            // æœ‰åŠ©äºå¹³è¡¡çš„äº¤æ˜“ï¼Œé™ä½è´¹ç”¨
            return config.baseFee / 2;
        } else {
            // åŠ å‰§ä¸å¹³è¡¡çš„äº¤æ˜“ï¼Œæé«˜è´¹ç”¨
            uint24 fee = config.baseFee + uint24(imbalance * (config.maxFee - config.baseFee) / 1e6);
            return fee > config.maxFee ? config.maxFee : fee;
        }
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.5.2 AIé©±åŠ¨çš„æµåŠ¨æ€§ç®¡ç†</h4>
        <p>2024å¹´è§è¯äº†AIåœ¨DeFiä¸­çš„å®é™…åº”ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨æµåŠ¨æ€§ç®¡ç†å’Œå‚æ•°ä¼˜åŒ–æ–¹é¢ï¼š</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">åŸºäºTransformerçš„æµåŠ¨æ€§é¢„æµ‹æ¨¡å‹ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># ä½¿ç”¨Transformeré¢„æµ‹æœ€ä¼˜æµåŠ¨æ€§åˆ†é…
import torch
import torch.nn as nn
import numpy as np
from transformers import TimeSeriesTransformerModel

class LiquidityOptimizer:
    def __init__(self):
        # é¢„è®­ç»ƒçš„å¸‚åœºé¢„æµ‹æ¨¡å‹
        self.market_predictor = TimeSeriesTransformerModel.from_pretrained(
            "defi-market-predictor-v2"
        )
        
        # æµåŠ¨æ€§åˆ†é…ç½‘ç»œ
        self.allocation_net = nn.Sequential(
            nn.Linear(256, 512),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(512, 256),
            nn.ReLU(),
            nn.Linear(256, 10),  # æœ€å¤š10ä¸ªæ± å­
            nn.Softmax(dim=-1)
        )
        
    def predict_market_conditions(self, historical_data):
        """é¢„æµ‹æœªæ¥24å°æ—¶çš„å¸‚åœºæ¡ä»¶"""
        # å‡†å¤‡è¾“å…¥æ•°æ®
        features = self.extract_features(historical_data)
        
        # Transformeré¢„æµ‹
        with torch.no_grad():
            predictions = self.market_predictor(
                input_ids=features['price_series'],
                attention_mask=features['mask']
            )
        
        # è§£æé¢„æµ‹ç»“æœ
        market_forecast = {
            'volatility': predictions.volatility_forecast,
            'volume': predictions.volume_forecast,
            'correlation_matrix': predictions.correlation_forecast,
            'black_swan_probability': predictions.tail_risk_estimate
        }
        
        return market_forecast
    
    def optimize_liquidity_allocation(self, 
                                    available_capital,
                                    pool_candidates,
                                    risk_tolerance):
        """ä¼˜åŒ–è·¨å¤šä¸ªæ± å­çš„æµåŠ¨æ€§åˆ†é…"""
        
        # 1. è·å–å¸‚åœºé¢„æµ‹
        market_forecast = self.predict_market_conditions(self.get_market_data())
        
        # 2. è¯„ä¼°æ¯ä¸ªæ± å­
        pool_scores = []
        for pool in pool_candidates:
            score = self.evaluate_pool(pool, market_forecast)
            pool_scores.append(score)
        
        # 3. è¿è¡Œä¼˜åŒ–
        allocation = self.solve_markowitz_optimization(
            expected_returns=pool_scores['returns'],
            covariance_matrix=pool_scores['risks'],
            risk_tolerance=risk_tolerance
        )
        
        # 4. è€ƒè™‘å®é™…çº¦æŸ
        allocation = self.apply_practical_constraints(
            allocation,
            min_position_size=1000,  # $1000æœ€å°ä»“ä½
            max_concentration=0.3,    # å•æ± æœ€å¤§30%
            gas_budget=available_capital * 0.01  # 1% gasé¢„ç®—
        )
        
        return allocation
    
    def real_time_rebalancing(self, current_positions):
        """å®æ—¶å†å¹³è¡¡å†³ç­–"""
        rebalance_actions = []
        
        for position in current_positions:
            # è®¡ç®—å½“å‰è¡¨ç°
            performance = self.calculate_position_performance(position)
            
            # é¢„æµ‹æœªæ¥è¡¨ç°
            future_performance = self.predict_position_performance(
                position,
                horizon=24  # 24å°æ—¶
            )
            
            # å†å¹³è¡¡å†³ç­–
            if self.should_rebalance(performance, future_performance):
                action = self.generate_rebalance_action(position)
                rebalance_actions.append(action)
        
        # æ‰¹é‡ä¼˜åŒ–ä»¥èŠ‚çœgas
        optimized_actions = self.batch_optimize_actions(rebalance_actions)
        
        return optimized_actions

# å®é™…åº”ç”¨
optimizer = LiquidityOptimizer()
allocation = optimizer.optimize_liquidity_allocation(
    available_capital=1000000,  # $1M
    pool_candidates=['USDC/DAI', 'USDC/USDT', 'DAI/FRAX'],
    risk_tolerance=0.05  # 5%æœ€å¤§å›æ’¤
)</code></pre>
            </div>
        </div>
        
        <h4>6.5.3 è·¨é“¾æµåŠ¨æ€§èšåˆä¸åŸç”Ÿç¨³å®šå¸</h4>
        <div class="tip-box">
            <strong>ğŸŒ‰ 2024å¹´è·¨é“¾å‘å±•</strong>
            <ul>
                <li><strong>LayerZero OFTï¼š</strong>åŸç”Ÿè·¨é“¾ç¨³å®šå¸ï¼Œæ— éœ€æ¡¥æ¥</li>
                <li><strong>Chainlink CCIPï¼š</strong>å®‰å…¨çš„è·¨é“¾æµåŠ¨æ€§è½¬ç§»</li>
                <li><strong>ç»Ÿä¸€æµåŠ¨æ€§å±‚ï¼š</strong>å¤šé“¾å…±äº«æµåŠ¨æ€§æ± </li>
                <li><strong>Intent-basedæ¶æ„ï¼š</strong>ç”¨æˆ·è¡¨è¾¾æ„å›¾ï¼Œåè®®è‡ªåŠ¨å¯»æ‰¾æœ€ä¼˜è·¯å¾„</li>
            </ul>
        </div>
        
        <h4>6.5.4 æµåŠ¨æ€§æ¿€åŠ±ä¸veTokenomics</h4>
        <p>ç†è§£ç°ä»£AMMä¸èƒ½å¿½è§†å…¶ç»æµæ¿€åŠ±å±‚ï¼Œç‰¹åˆ«æ˜¯Curveå¼€åˆ›çš„veæ¨¡å‹ï¼š</p>
        
        <div class="info-box">
            <h5>ğŸ’° veTokenomicsæ ¸å¿ƒæœºåˆ¶</h5>
            <ul>
                <li><strong>æŠ•ç¥¨æ‰˜ç®¡ï¼ˆVote Escrowï¼‰ï¼š</strong>é”å®šæ²»ç†ä»£å¸è·å¾—æŠ•ç¥¨æƒ</li>
                <li><strong>æ”¶ç›ŠåŠ é€Ÿï¼š</strong>veCRVæŒæœ‰è€…å¯å°†LPæ”¶ç›Šæå‡è‡³2.5å€</li>
                <li><strong>è´¿èµ‚å¸‚åœºï¼š</strong>åè®®é€šè¿‡è´¿èµ‚veCRVæŒæœ‰è€…å¼•å¯¼æµåŠ¨æ€§</li>
                <li><strong>Gaugeæƒé‡ï¼š</strong>æŠ•ç¥¨å†³å®šå„æ± å­çš„CRVé‡Šæ”¾é‡</li>
            </ul>
        </div>

        <h3>ç»ƒä¹ é¢˜</h3>
        
        <div class="exercise">
            <h4>ç»ƒä¹  6.1ï¼šå®ç°åŠ¨æ€è´¹ç”¨AMM</h4>
            <p>è®¾è®¡ä¸€ä¸ªAMMï¼Œæ ¹æ®ä»¥ä¸‹å› ç´ åŠ¨æ€è°ƒæ•´äº¤æ˜“è´¹ç”¨ï¼š</p>
            <ul>
                <li>æ± å­çš„ä¸å¹³è¡¡ç¨‹åº¦</li>
                <li>äº¤æ˜“è§„æ¨¡ç›¸å¯¹äºæ± å­å¤§å°</li>
                <li>å¸‚åœºæ³¢åŠ¨ç‡</li>
                <li>å†å²äº¤æ˜“é¢‘ç‡</li>
            </ul>
            <p>è¦æ±‚è´¹ç”¨åœ¨0.01%åˆ°1%ä¹‹é—´åŠ¨æ€è°ƒæ•´ã€‚</p>
            
            <button onclick="toggleAnswer('answer6-1')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer6-1" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract DynamicFeeAMM {
    uint256 private constant MIN_FEE = 1; // 0.01%
    uint256 private constant MAX_FEE = 100; // 1%
    uint256 private constant FEE_DENOMINATOR = 10000;
    
    uint256 public volatilityWindow = 1 hours;
    uint256 public volumeDecayFactor = 9900; // 99%è¡°å‡
    
    struct FeeParameters {
        uint256 imbalanceFee;
        uint256 sizeFee;
        uint256 volatilityFee;
        uint256 frequencyFee;
    }
    
    function calculateDynamicFee(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public view returns (uint256 fee) {
        FeeParameters memory params;
        
        // 1. ä¸å¹³è¡¡è´¹ç”¨
        uint256 totalReserves = reserveIn + reserveOut;
        uint256 imbalanceRatio = reserveIn > reserveOut ?
            (reserveIn - reserveOut) * FEE_DENOMINATOR / totalReserves :
            (reserveOut - reserveIn) * FEE_DENOMINATOR / totalReserves;
        params.imbalanceFee = imbalanceRatio * MAX_FEE / FEE_DENOMINATOR;
        
        // 2. äº¤æ˜“è§„æ¨¡è´¹ç”¨
        uint256 sizeRatio = amountIn * FEE_DENOMINATOR / reserveIn;
        params.sizeFee = sizeRatio * MAX_FEE / (FEE_DENOMINATOR * 10); // 10%çš„reserveæ”¶æœ€é«˜è´¹
        
        // 3. æ³¢åŠ¨ç‡è´¹ç”¨
        uint256 volatility = getHistoricalVolatility();
        params.volatilityFee = volatility > 100 ? // 1%æ—¥æ³¢åŠ¨ç‡
            (volatility - 100) * MAX_FEE / 1000 : 0;
        
        // 4. äº¤æ˜“é¢‘ç‡è´¹ç”¨
        uint256 recentVolume = getRecentVolume();
        uint256 volumeRatio = recentVolume * FEE_DENOMINATOR / totalReserves;
        params.frequencyFee = volumeRatio > FEE_DENOMINATOR ?
            MAX_FEE / 2 : volumeRatio * MAX_FEE / (FEE_DENOMINATOR * 2);
        
        // ç»¼åˆè®¡ç®—ï¼ˆåŠ æƒå¹³å‡ï¼‰
        fee = (params.imbalanceFee * 30 + 
               params.sizeFee * 30 + 
               params.volatilityFee * 20 + 
               params.frequencyFee * 20) / 100;
        
        // é™åˆ¶åœ¨æœ€å°æœ€å¤§èŒƒå›´å†…
        if (fee < MIN_FEE) fee = MIN_FEE;
        if (fee > MAX_FEE) fee = MAX_FEE;
    }
    
    function getHistoricalVolatility() private view returns (uint256) {
        // è®¡ç®—è¿‡å»1å°æ—¶çš„ä»·æ ¼æ ‡å‡†å·®
        uint256 priceSum = 0;
        uint256 priceSquareSum = 0;
        uint256 count = 0;
        
        for (uint256 i = priceHistory.length - 1; i > 0; i--) {
            if (block.timestamp - priceHistory[i].timestamp > volatilityWindow) break;
            
            priceSum += priceHistory[i].price;
            priceSquareSum += priceHistory[i].price ** 2;
            count++;
        }
        
        if (count < 2) return 0;
        
        uint256 mean = priceSum / count;
        uint256 variance = priceSquareSum / count - mean ** 2;
        
        return sqrt(variance) * 10000 / mean; // åŸºç‚¹è¡¨ç¤º
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>ç»ƒä¹  6.2ï¼šä¼˜åŒ–ç¨³å®šå¸å¯¹çš„æµåŠ¨æ€§ç®¡ç†</h4>
            <p>åˆ›å»ºä¸€ä¸ªè‡ªåŠ¨æµåŠ¨æ€§ç®¡ç†å™¨ï¼Œå®ç°ï¼š</p>
            <ul>
                <li>è‡ªåŠ¨è¯†åˆ«æœ€ä¼˜ä»·æ ¼èŒƒå›´</li>
                <li>æ ¹æ®è´¹ç”¨æ”¶ç›Šå’Œæ— å¸¸æŸå¤±åŠ¨æ€è°ƒæ•´</li>
                <li>å¤šæ± èšåˆä»¥æœ€å¤§åŒ–æ”¶ç›Š</li>
                <li>é£é™©ç®¡ç†å’Œæ­¢æŸæœºåˆ¶</li>
            </ul>
            
            <button onclick="toggleAnswer('answer6-2')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer6-2" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract StablecoinLiquidityOptimizer {
    struct Position {
        uint256 tokenId;
        address pool;
        int24 tickLower;
        int24 tickUpper;
        uint128 liquidity;
        uint256 feeEarned;
        uint256 impermanentLoss;
        uint256 lastRebalance;
    }
    
    mapping(uint256 => Position) public positions;
    uint256 public nextPositionId;
    
    uint256 public maxImpermanentLoss = 50; // 0.5%
    uint256 public minFeeAPY = 500; // 5% APY
    uint256 public rebalanceInterval = 1 days;
    
    function optimizePosition(
        address token0,
        address token1,
        uint256 amount0,
        uint256 amount1
    ) external returns (uint256 positionId) {
        // 1. åˆ†æå†å²æ•°æ®æ‰¾å‡ºæœ€ä¼˜èŒƒå›´
        (int24 optimalLower, int24 optimalUpper) = findOptimalRange(token0, token1);
        
        // 2. è¯„ä¼°ä¸åŒæ± çš„æ”¶ç›Šæ½œåŠ›
        PoolEvaluation[] memory evaluations = evaluatePools(token0, token1);
        
        // 3. åˆ†é…æµåŠ¨æ€§åˆ°å¤šä¸ªæ± 
        for (uint256 i = 0; i < evaluations.length && i < 3; i++) {
            if (evaluations[i].expectedAPY > minFeeAPY) {
                uint256 allocation = calculateOptimalAllocation(
                    evaluations[i],
                    amount0,
                    amount1
                );
                
                if (allocation > 0) {
                    uint256 tokenId = deployLiquidity(
                        evaluations[i].pool,
                        amount0 * allocation / 100,
                        amount1 * allocation / 100,
                        optimalLower,
                        optimalUpper
                    );
                    
                    positions[nextPositionId++] = Position({
                        tokenId: tokenId,
                        pool: evaluations[i].pool,
                        tickLower: optimalLower,
                        tickUpper: optimalUpper,
                        liquidity: getLiquidityAmount(tokenId),
                        feeEarned: 0,
                        impermanentLoss: 0,
                        lastRebalance: block.timestamp
                    });
                }
            }
        }
        
        return nextPositionId - 1;
    }
    
    function autoRebalance(uint256 positionId) external {
        Position storage pos = positions[positionId];
        require(block.timestamp >= pos.lastRebalance + rebalanceInterval, "Too soon");
        
        // è®¡ç®—å½“å‰è¡¨ç°
        (uint256 currentFees, uint256 currentIL) = calculatePerformance(pos);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒæ•´
        bool needsRebalance = false;
        
        if (currentIL > maxImpermanentLoss) {
            needsRebalance = true; // ILè¿‡é«˜
        }
        
        uint256 feeAPY = currentFees * 365 days * 10000 / 
                         (pos.liquidity * (block.timestamp - pos.lastRebalance));
        
        if (feeAPY < minFeeAPY) {
            needsRebalance = true; // æ”¶ç›Šè¿‡ä½
        }
        
        if (needsRebalance) {
            // æ”¶é›†æµåŠ¨æ€§å’Œè´¹ç”¨
            collectAndRemove(pos.tokenId);
            
            // é‡æ–°ä¼˜åŒ–éƒ¨ç½²
            optimizePosition(
                getToken0(pos.pool),
                getToken1(pos.pool),
                getBalance0(),
                getBalance1()
            );
        }
        
        pos.lastRebalance = block.timestamp;
    }
    
    function findOptimalRange(
        address token0,
        address token1
    ) private view returns (int24 tickLower, int24 tickUpper) {
        // åˆ†æå†å²ä»·æ ¼åˆ†å¸ƒ
        uint256[] memory priceDistribution = getPriceDistribution(token0, token1, 30 days);
        
        // æ‰¾å‡ºåŒ…å«95%äº¤æ˜“çš„ä»·æ ¼èŒƒå›´
        uint256 percentile25 = getPercentile(priceDistribution, 25);
        uint256 percentile75 = getPercentile(priceDistribution, 75);
        
        // è½¬æ¢ä¸ºtick
        tickLower = priceToTick(percentile25);
        tickUpper = priceToTick(percentile75);
        
        // ç¡®ä¿èŒƒå›´ä¸å¤ªçª„
        int24 minWidth = 10; // æœ€å°10ä¸ªtick
        if (tickUpper - tickLower < minWidth) {
            int24 mid = (tickLower + tickUpper) / 2;
            tickLower = mid - minWidth / 2;
            tickUpper = mid + minWidth / 2;
        }
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>ç»ƒä¹  6.3ï¼šå®ç°è·¨é“¾AMMèšåˆå™¨</h4>
            <p>æ„å»ºä¸€ä¸ªè·¨é“¾AMMèšåˆå™¨ï¼Œè¦æ±‚ï¼š</p>
            <ul>
                <li>èšåˆå¤šæ¡é“¾ä¸Šçš„æµåŠ¨æ€§</li>
                <li>è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ‰§è¡Œè·¯å¾„</li>
                <li>å¤„ç†è·¨é“¾å»¶è¿Ÿå’Œå¤±è´¥</li>
                <li>ä¼˜åŒ–Gasæˆæœ¬</li>
            </ul>
            
            <button onclick="toggleAnswer('answer6-3')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer6-3" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract CrossChainAMMAggregator {
    using LayerZeroEndpoint for address;
    
    struct ChainLiquidity {
        uint16 chainId;
        address[] amms;
        uint256[] reserves;
        uint256[] fees;
        uint256 gasPrice;
    }
    
    struct CrossChainRoute {
        uint16[] chains;
        address[] amms;
        uint256[] amounts;
        uint256 totalGas;
        uint256 estimatedOut;
    }
    
    mapping(uint16 => ChainLiquidity) public chainLiquidities;
    mapping(bytes32 => PendingSwap) public pendingSwaps;
    
    ILayerZeroEndpoint public immutable lzEndpoint;
    
    function findBestCrossChainRoute(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint16[] memory targetChains
    ) public view returns (CrossChainRoute memory bestRoute) {
        uint256 bestOutput = 0;
        
        // å•é“¾æ‰§è¡Œ
        for (uint256 i = 0; i < targetChains.length; i++) {
            (uint256 output, uint256 gas) = getChainQuote(
                targetChains[i],
                tokenIn,
                tokenOut,
                amountIn
            );
            
            if (output > bestOutput) {
                bestOutput = output;
                bestRoute = CrossChainRoute({
                    chains: new uint16[](1),
                    amms: new address[](1),
                    amounts: new uint256[](1),
                    totalGas: gas,
                    estimatedOut: output
                });
                bestRoute.chains[0] = targetChains[i];
            }
        }
        
        // å¤šé“¾åˆ†å‰²æ‰§è¡Œ
        if (targetChains.length > 1) {
            CrossChainRoute memory splitRoute = optimizeSplitRoute(
                tokenIn,
                tokenOut,
                amountIn,
                targetChains
            );
            
            if (splitRoute.estimatedOut > bestOutput) {
                bestRoute = splitRoute;
            }
        }
    }
    
    function executeCrossChainSwap(
        CrossChainRoute memory route,
        uint256 minAmountOut,
        address recipient
    ) external payable {
        require(route.estimatedOut >= minAmountOut, "Slippage");
        
        bytes32 swapId = keccak256(abi.encodePacked(
            msg.sender,
            route.chains,
            block.timestamp
        ));
        
        pendingSwaps[swapId] = PendingSwap({
            user: msg.sender,
            recipient: recipient,
            expectedOut: route.estimatedOut,
            receivedOut: 0,
            completedChains: 0,
            totalChains: route.chains.length,
            deadline: block.timestamp + 30 minutes
        });
        
        // æ‰§è¡Œæ¯æ¡é“¾çš„äº¤æ¢
        for (uint256 i = 0; i < route.chains.length; i++) {
            if (route.chains[i] == getChainId()) {
                // æœ¬é“¾æ‰§è¡Œ
                executeLocalSwap(
                    route.amms[i],
                    route.amounts[i],
                    swapId
                );
            } else {
                // è·¨é“¾æ‰§è¡Œ
                bytes memory payload = abi.encode(
                    swapId,
                    route.amms[i],
                    route.amounts[i],
                    recipient
                );
                
                lzEndpoint.send{value: msg.value / route.chains.length}(
                    route.chains[i],
                    abi.encodePacked(address(this)),
                    payload,
                    payable(msg.sender),
                    address(0),
                    bytes("")
                );
            }
        }
    }
    
    function lzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) external {
        require(msg.sender == address(lzEndpoint), "Invalid endpoint");
        
        (bytes32 swapId, address amm, uint256 amount, address recipient) = 
            abi.decode(_payload, (bytes32, address, uint256, address));
        
        PendingSwap storage swap = pendingSwaps[swapId];
        require(swap.deadline > block.timestamp, "Expired");
        
        // æ‰§è¡Œäº¤æ¢
        uint256 amountOut = IAMM(amm).swap(amount, recipient);
        
        swap.receivedOut += amountOut;
        swap.completedChains++;
        
        if (swap.completedChains == swap.totalChains) {
            // æ£€æŸ¥æ»‘ç‚¹
            require(
                swap.receivedOut >= swap.expectedOut * 95 / 100,
                "Excessive slippage"
            );
            
            emit CrossChainSwapCompleted(swapId, swap.receivedOut);
            delete pendingSwaps[swapId];
        }
    }
    
    // å¤±è´¥å¤„ç†
    function handleFailedSwap(bytes32 swapId) external {
        PendingSwap storage swap = pendingSwaps[swapId];
        require(swap.user == msg.sender, "Not owner");
        require(swap.deadline < block.timestamp, "Not expired");
        require(swap.completedChains < swap.totalChains, "Already completed");
        
        // è¿”è¿˜å·²å®Œæˆéƒ¨åˆ†
        if (swap.receivedOut > 0) {
            IERC20(tokenOut).transfer(swap.recipient, swap.receivedOut);
        }
        
        // è§¦å‘æœªå®Œæˆé“¾çš„é€€æ¬¾æµç¨‹
        for (uint256 i = 0; i < swap.totalChains; i++) {
            if (!isChainCompleted(swapId, i)) {
                triggerRefund(swap.chains[i], swapId);
            }
        }
        
        emit CrossChainSwapFailed(swapId, swap.completedChains, swap.totalChains);
        delete pendingSwaps[swapId];
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>ç»ƒä¹  6.4ï¼šè®¾è®¡ä¸“ç”¨ç¨³å®šå¸AMMæ›²çº¿</h4>
            <p>è®¾è®¡ä¸€ä¸ªæ–°çš„AMMæ›²çº¿ï¼Œä¸“é—¨ä¼˜åŒ–ç¨³å®šå¸äº¤æ˜“ï¼š</p>
            <ul>
                <li>åœ¨0.99-1.01èŒƒå›´å†…æä¾›æä½æ»‘ç‚¹</li>
                <li>æ”¯æŒå¤šèµ„äº§æ± ï¼ˆ3ä¸ªä»¥ä¸Šç¨³å®šå¸ï¼‰</li>
                <li>åŠ¨æ€è°ƒæ•´æ›²çº¿å‚æ•°</li>
                <li>å†…ç½®è„±é”šä¿æŠ¤æœºåˆ¶</li>
            </ul>
            
            <button onclick="toggleAnswer('answer6-4')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer6-4" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract AdvancedStableCurve {
    using FixedPoint for uint256;
    
    uint256 private constant PRECISION = 1e18;
    uint256 private constant A_MULTIPLIER = 10000;
    
    struct PoolParams {
        uint256 A;              // æ”¾å¤§ç³»æ•°
        uint256 gamma;          // æ›²ç‡å‚æ•°
        uint256 beta;           // ä»·æ ¼å½±å“å‚æ•°
        uint256 delta;          // è„±é”šæƒ©ç½šå‚æ•°
        uint256[] weights;      // èµ„äº§æƒé‡
        uint256 lastUpdateTime;
    }
    
    PoolParams public params;
    uint256[] public balances;
    uint256 public D; // ä¸å˜é‡
    
    // æ–°çš„ä¸å˜é‡å…¬å¼ï¼šæ··åˆå‡ ä½•å¹³å‡å’Œç®—æœ¯å¹³å‡
    function computeD(uint256[] memory xp) private view returns (uint256) {
        uint256 n = xp.length;
        uint256 s = 0;
        uint256 p = PRECISION;
        
        for (uint256 i = 0; i < n; i++) {
            s += xp[i];
            p = p * xp[i] / PRECISION;
        }
        
        if (s == 0) return 0;
        
        uint256 nPow = PRECISION;
        for (uint256 i = 0; i < n - 1; i++) {
            nPow = nPow * n / PRECISION;
        }
        
        uint256 d = s;
        uint256 d_prev;
        uint256 ann = params.A * nPow;
        
        // æ··åˆä¸å˜é‡ï¼šD^n + b*D = a*sum(x_i) + c*prod(x_i)
        for (uint256 i = 0; i < 255; i++) {
            uint256 dp = d;
            for (uint256 j = 0; j < n; j++) {
                dp = dp * d / (xp[j] * n);
            }
            
            d_prev = d;
            
            // åŠ å…¥æ›²ç‡è°ƒæ•´
            uint256 gamma_adj = PRECISION + params.gamma * (s - d) / s;
            
            d = (ann * s * gamma_adj / PRECISION + dp * n) * d /
                ((ann - PRECISION) * d / PRECISION + (n + 1) * dp);
            
            if (d > d_prev) {
                if (d - d_prev <= 1) break;
            } else {
                if (d_prev - d <= 1) break;
            }
        }
        
        return d;
    }
    
    // åŠ¨æ€Aå€¼è°ƒæ•´
    function updateAmplification() external {
        uint256 timePassed = block.timestamp - params.lastUpdateTime;
        if (timePassed < 1 hours) return;
        
        // è®¡ç®—ä»·æ ¼åç¦»åº¦
        uint256 maxDeviation = 0;
        for (uint256 i = 0; i < balances.length; i++) {
            uint256 idealBalance = D * params.weights[i] / PRECISION;
            uint256 deviation = balances[i] > idealBalance ?
                (balances[i] - idealBalance) * PRECISION / idealBalance :
                (idealBalance - balances[i]) * PRECISION / idealBalance;
            
            if (deviation > maxDeviation) maxDeviation = deviation;
        }
        
        // æ ¹æ®åç¦»åº¦è°ƒæ•´Aå€¼
        if (maxDeviation > 0.01e18) { // 1%ä»¥ä¸Šåç¦»
            params.A = params.A * 95 / 100; // é™ä½Aå€¼
        } else if (maxDeviation < 0.001e18) { // 0.1%ä»¥ä¸‹åç¦»
            params.A = params.A * 105 / 100; // æé«˜Aå€¼
        }
        
        // é™åˆ¶Aå€¼èŒƒå›´
        if (params.A < 10) params.A = 10;
        if (params.A > 10000) params.A = 10000;
        
        params.lastUpdateTime = block.timestamp;
    }
    
    // è„±é”šä¿æŠ¤
    function applyDepegProtection(
        uint256[] memory amounts,
        uint256[] memory prices
    ) private view returns (uint256[] memory adjusted) {
        adjusted = new uint256[](amounts.length);
        
        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 priceDeviation = prices[i] > PRECISION ?
                (prices[i] - PRECISION) * PRECISION / PRECISION :
                (PRECISION - prices[i]) * PRECISION / PRECISION;
            
            if (priceDeviation > 0.02e18) { // 2%ä»¥ä¸Šè„±é”š
                // åº”ç”¨æƒ©ç½šå› å­
                uint256 penalty = PRECISION + params.delta * priceDeviation / PRECISION;
                adjusted[i] = amounts[i] * PRECISION / penalty;
            } else {
                adjusted[i] = amounts[i];
            }
        }
    }
    
    // å¤šèµ„äº§äº¤æ¢
    function swapExactInput(
        uint256 tokenIn,
        uint256 tokenOut,
        uint256 amountIn,
        uint256 minAmountOut
    ) external returns (uint256 amountOut) {
        require(tokenIn < balances.length && tokenOut < balances.length, "Invalid token");
        require(tokenIn != tokenOut, "Same token");
        
        // è·å–å¤–éƒ¨ä»·æ ¼
        uint256[] memory prices = getExternalPrices();
        
        // åº”ç”¨è„±é”šä¿æŠ¤
        uint256[] memory adjustedBalances = applyDepegProtection(balances, prices);
        
        // è®¡ç®—è¾“å‡º
        uint256 y = computeY(tokenIn, tokenOut, adjustedBalances[tokenIn] + amountIn, adjustedBalances);
        amountOut = adjustedBalances[tokenOut] - y;
        
        // åŠ¨æ€è´¹ç”¨
        uint256 fee = calculateDynamicFee(tokenIn, tokenOut, amountIn, prices);
        amountOut = amountOut - amountOut * fee / PRECISION;
        
        require(amountOut >= minAmountOut, "Slippage");
        
        // æ›´æ–°ä½™é¢
        balances[tokenIn] += amountIn;
        balances[tokenOut] -= amountOut;
        
        // æ›´æ–°Då€¼
        D = computeD(balances);
        
        emit Swap(msg.sender, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    function calculateDynamicFee(
        uint256 tokenIn,
        uint256 tokenOut,
        uint256 amount,
        uint256[] memory prices
    ) private view returns (uint256 fee) {
        // åŸºç¡€è´¹ç”¨
        fee = 0.0001e18; // 0.01%
        
        // ä»·æ ¼åç¦»è´¹ç”¨
        uint256 priceDevIn = prices[tokenIn] > PRECISION ?
            prices[tokenIn] - PRECISION : PRECISION - prices[tokenIn];
        uint256 priceDevOut = prices[tokenOut] > PRECISION ?
            prices[tokenOut] - PRECISION : PRECISION - prices[tokenOut];
        
        fee += (priceDevIn + priceDevOut) * params.beta / PRECISION;
        
        // ä¸å¹³è¡¡è´¹ç”¨
        uint256 imbalance = calculateImbalance();
        fee += imbalance * 0.001e18 / PRECISION;
        
        // é™åˆ¶æœ€å¤§è´¹ç”¨
        if (fee > 0.01e18) fee = 0.01e18; // æœ€å¤§1%
    }
}</code></pre>
            </div>
        </div>
        
        <h3>æœ¬ç« å°ç»“</h3>
        <div class="tip">
            <strong>å…³é”®è¦ç‚¹ï¼š</strong>
            <ul>
                <li><strong>AMMé€‰æ‹©ï¼š</strong>ä¸åŒçš„AMMæ¨¡å‹é€‚åˆä¸åŒçš„ç¨³å®šå¸äº¤æ˜“åœºæ™¯ï¼Œéœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©</li>
                <li><strong>èµ„æœ¬æ•ˆç‡ï¼š</strong>é›†ä¸­æµåŠ¨æ€§å’Œä¸“ç”¨æ›²çº¿å¯ä»¥æ˜¾è‘—æé«˜ç¨³å®šå¸äº¤æ˜“çš„èµ„æœ¬æ•ˆç‡</li>
                <li><strong>MEVé˜²æŠ¤ï¼š</strong>ç¨³å®šå¸AMMç‰¹åˆ«å®¹æ˜“å—åˆ°MEVæ”»å‡»ï¼Œéœ€è¦ä¸“é—¨çš„é˜²æŠ¤æœºåˆ¶</li>
                <li><strong>åŠ¨æ€è°ƒæ•´ï¼š</strong>è´¹ç”¨ã€æµåŠ¨æ€§èŒƒå›´å’Œæ›²çº¿å‚æ•°éƒ½åº”è¯¥æ ¹æ®å¸‚åœºæ¡ä»¶åŠ¨æ€è°ƒæ•´</li>
                <li><strong>è·¨é“¾æ•´åˆï¼š</strong>æœªæ¥çš„AMMéœ€è¦è€ƒè™‘è·¨é“¾æµåŠ¨æ€§èšåˆä»¥æä¾›æœ€ä¼˜ä»·æ ¼</li>
            </ul>
        </div>
        
        <h3>æœ¯è¯­é€ŸæŸ¥è¡¨</h3>
        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
            <tr style="background: #f3f4f6;">
                <th style="border: 1px solid #ddd; padding: 12px;">æœ¯è¯­</th>
                <th style="border: 1px solid #ddd; padding: 12px;">è‹±æ–‡</th>
                <th style="border: 1px solid #ddd; padding: 12px;">å«ä¹‰</th>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">è‡ªåŠ¨åšå¸‚å•†</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Automated Market Maker (AMM)</td>
                <td style="border: 1px solid #ddd; padding: 8px;">ä½¿ç”¨ç®—æ³•è‡ªåŠ¨æä¾›æµåŠ¨æ€§çš„åè®®</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">æ’å®šä¹˜ç§¯</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Constant Product</td>
                <td style="border: 1px solid #ddd; padding: 8px;">x*y=kçš„AMMå…¬å¼</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">é›†ä¸­æµåŠ¨æ€§</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Concentrated Liquidity</td>
                <td style="border: 1px solid #ddd; padding: 8px;">å°†æµåŠ¨æ€§é›†ä¸­åœ¨ç‰¹å®šä»·æ ¼èŒƒå›´</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">æ— å¸¸æŸå¤±</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Impermanent Loss</td>
                <td style="border: 1px solid #ddd; padding: 8px;">æä¾›æµåŠ¨æ€§vsæŒæœ‰ä»£å¸çš„ä»·å€¼å·®å¼‚</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">æ»‘ç‚¹</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Slippage</td>
                <td style="border: 1px solid #ddd; padding: 8px;">é¢„æœŸä»·æ ¼ä¸å®é™…æ‰§è¡Œä»·æ ¼çš„å·®å¼‚</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">TWAP</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Time-Weighted Average Price</td>
                <td style="border: 1px solid #ddd; padding: 8px;">æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">æ”¾å¤§ç³»æ•°</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Amplification Factor</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Curveä¸­æ§åˆ¶æ›²çº¿å¹³å¦åº¦çš„å‚æ•°</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">JITæµåŠ¨æ€§</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Just-In-Time Liquidity</td>
                <td style="border: 1px solid #ddd; padding: 8px;">åœ¨äº¤æ˜“å‰ä¸´æ—¶æ·»åŠ çš„æµåŠ¨æ€§</td>
            </tr>
        </table>

        <h3>ç¬¬å…­ç« å°ç»“</h3>
        <div class="info-box">
            <h4>æ ¸å¿ƒè¦ç‚¹</h4>
            <ul>
                <li><strong>ç†è®ºåŸºç¡€ï¼š</strong>ä»æ’å®šä¹˜ç§¯åˆ°æ’å®šå’Œï¼Œç†è§£AMMæ¨¡å‹çš„æ•°å­¦æœ¬è´¨</li>
                <li><strong>æ•ˆç‡ä¼˜åŒ–ï¼š</strong>ä»V2åˆ°V3ï¼Œé›†ä¸­æµåŠ¨æ€§æå‡100å€èµ„æœ¬æ•ˆç‡ä½†å¢åŠ é£é™©</li>
                <li><strong>ç¨³å®šå¸ä¸“ç”¨ï¼š</strong>Curve StableSwapé€šè¿‡æ··åˆä¸å˜é‡å®ç°ä½æ»‘ç‚¹é«˜æ•ˆç‡</li>
                <li><strong>åŠ¨æ€è°ƒæ•´ï¼š</strong>Curve V2çš„è‡ªé€‚åº”ç³»ç»Ÿï¼Œæ ¹æ®å¸‚åœºçŠ¶æ€è°ƒæ•´å‚æ•°</li>
                <li><strong>å‰æ²¿å‘å±•ï¼š</strong>Uniswap V4 Hooksã€AIé©±åŠ¨ä¼˜åŒ–ã€è·¨é“¾èšåˆ</li>
            </ul>
        </div>

        <div class="example-box">
            <h4>å®è·µå»ºè®®</h4>
            <ol>
                <li><strong>é£é™©è¯„ä¼°ï¼š</strong>éƒ¨ç½²å‰å¿…é¡»è¿›è¡Œæ— å¸¸æŸå¤±å’Œè„±é”šé£é™©çš„å®šé‡åˆ†æ</li>
                <li><strong>å‚æ•°é€‰æ‹©ï¼š</strong>æ ¹æ®èµ„äº§ç‰¹æ€§å’Œå¸‚åœºç¯å¢ƒåˆç†è®¾ç½®æ”¾å¤§ç³»æ•°A</li>
                <li><strong>MEVé˜²æŠ¤ï¼š</strong>å®æ–½TWAPã€æ‰¹é‡äº¤æ˜“ç­‰æœºåˆ¶ä¿æŠ¤ç”¨æˆ·</li>
                <li><strong>ç›‘æ§ç³»ç»Ÿï¼š</strong>å»ºç«‹å®æ—¶ç›‘æ§ï¼ŒåŠæ—¶å“åº”å¸‚åœºå¼‚å¸¸</li>
                <li><strong>æ²»ç†æœºåˆ¶ï¼š</strong>é€šè¿‡veTokenç­‰æ¨¡å‹å»ºç«‹å¯æŒç»­çš„æ¿€åŠ±ä½“ç³»</li>
            </ol>
        </div>

        <div class="warning-box">
            <h4>é£é™©æé†’</h4>
            <ul>
                <li><strong>æµåŠ¨æ€§é£é™©ï¼š</strong>æç«¯å¸‚åœºæ¡ä»¶ä¸‹å¯èƒ½å‡ºç°æµåŠ¨æ€§æ¯ç«­</li>
                <li><strong>Oracleé£é™©ï¼š</strong>ä»·æ ¼é¢„è¨€æœºæ“çºµå¯èƒ½å¯¼è‡´åè®®æŸå¤±</li>
                <li><strong>æ™ºèƒ½åˆçº¦é£é™©ï¼š</strong>ä»£ç æ¼æ´å¯èƒ½è¢«åˆ©ç”¨é€ æˆèµ„é‡‘æŸå¤±</li>
                <li><strong>æ²»ç†æ”»å‡»ï¼š</strong>æ¶æ„ææ¡ˆå¯èƒ½æŸå®³åè®®åˆ©ç›Š</li>
                <li><strong>ç›‘ç®¡é£é™©ï¼š</strong>æ³•è§„å˜åŒ–å¯èƒ½å½±å“åè®®è¿è¥</li>
            </ul>
        </div>

        <h3>æ¨èé˜…è¯»</h3>
        <ul>
            <li><a href="https://curve.fi/files/stableswap-paper.pdf" target="_blank">Curve StableSwap Whitepaper</a></li>
            <li><a href="https://uniswap.org/whitepaper-v3.pdf" target="_blank">Uniswap V3 Core</a></li>
            <li><a href="https://github.com/Uniswap/v4-core" target="_blank">Uniswap V4 Documentation</a></li>
            <li><a href="https://arxiv.org/abs/2103.12732" target="_blank">Automated Market Making: Theory and Practice</a></li>
            <li><a href="https://ethereum.org/en/developers/docs/mev/" target="_blank">MEV Research Resources</a></li>
        </ul>
    
            
            <!-- ç« èŠ‚å¯¼èˆª -->
            <div class="chapter-nav">
                <a href="chapter5.html">â† ç¬¬5ç« </a>
                <a href="chapter7.html">ç¬¬7ç«  â†’</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>