<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬å››ç« ï¼šæŠµæŠ¼å‹ç¨³å®šå¸è®¾è®¡ - åŒºå—é“¾ç¨³å®šå¸æ•™ç¨‹</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">ç¨³å®šå¸æ•™ç¨‹</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">â˜°</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">é¦–é¡µ</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">å¼•è¨€</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">ç« èŠ‚</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">ç¬¬1ç« ï¼šåŒºå—é“¾åŸºç¡€</a>
                        <a href="chapter2.html" class="dropdown-item">ç¬¬2ç« ï¼šç¨³å®šå¸åˆ†ç±»</a>
                        <a href="chapter3.html" class="dropdown-item">ç¬¬3ç« ï¼šERC-20æ ‡å‡†</a>
                        <a href="chapter4.html" class="dropdown-item">ç¬¬4ç« ï¼šæŠµæŠ¼å‹è®¾è®¡</a>
                        <a href="chapter5.html" class="dropdown-item">ç¬¬5ç« ï¼šæ•°å­¦æ¨¡å‹</a>
                        <a href="chapter6.html" class="dropdown-item">ç¬¬6ç« ï¼šAMMé›†æˆ</a>
                        <a href="chapter7.html" class="dropdown-item">ç¬¬7ç« ï¼šå€Ÿè´·åè®®</a>
                        <a href="chapter8.html" class="dropdown-item">ç¬¬8ç« ï¼šæ”¶ç›Šç­–ç•¥</a>
                        <a href="chapter9.html" class="dropdown-item">ç¬¬9ç« ï¼šæ™ºèƒ½åˆçº¦å®‰å…¨</a>
                        <a href="chapter10.html" class="dropdown-item">ç¬¬10ç« ï¼šç»æµæ”»å‡»</a>
                        <a href="chapter11.html" class="dropdown-item">ç¬¬11ç« ï¼šæœªæ¥æ–¹å‘</a>
                        <a href="chapter12.html" class="dropdown-item">ç¬¬12ç« ï¼šç”Ÿäº§éƒ¨ç½²</a>
                        <a href="chapter13.html" class="dropdown-item">ç¬¬13ç« ï¼šç”Ÿæ€é›†æˆ</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="#resources" class="nav-link">èµ„æº</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- å¤´éƒ¨ -->
    <header id="top">
        <div class="container">
            <h1>ç¬¬å››ç« ï¼šæŠµæŠ¼å‹ç¨³å®šå¸è®¾è®¡</h1>
        </div>
    </header>
    
    <!-- ä¸»è¦å†…å®¹ -->
    <div class="container">
        <div class="chapter">
<h2>ç¬¬å››ç« ï¼šæŠµæŠ¼å‹ç¨³å®šå¸è®¾è®¡</h2>
            
            <div class="intro-box">
                <strong>æœ¬ç« æ¦‚è§ˆï¼š</strong>
                <ul>
                    <li>æ·±å…¥ç†è§£é‡‘åº“(Vault)æœºåˆ¶å’ŒCDPç³»ç»Ÿ</li>
                    <li>æ¸…ç®—å¼•æ“è®¾è®¡ä¸Keeperæ¿€åŠ±æœºåˆ¶</li>
                    <li>é¢„è¨€æœºé›†æˆå’Œä»·æ ¼å–‚ä»·ç­–ç•¥</li>
                    <li>é”šå®šç¨³å®šæ¨¡å—(PSM)ä¸çœŸå®ä¸–ç•Œèµ„äº§(RWA)</li>
                    <li>å®æˆ˜ï¼šæ„å»ºç±»ä¼¼MakerDAOçš„è¶…é¢æŠµæŠ¼ç¨³å®šå¸ç³»ç»Ÿ</li>
                </ul>
            </div>
            
            <div class="tip-box">
                <strong>ğŸ¯ ç« èŠ‚ç›®æ ‡ï¼š</strong>
                <p>æœ¬ç« ä¸ä»…è¦è®©æ‚¨ç†è§£â€œå¦‚ä½•å®ç°â€æŠµæŠ¼å‹ç¨³å®šå¸ï¼Œæ›´é‡è¦çš„æ˜¯ç†è§£â€œä¸ºä½•å¦‚æ­¤è®¾è®¡â€ä»¥åŠâ€œæœ‰ä½•æƒè¡¡â€ã€‚æˆ‘ä»¬å°†é€šè¿‡é‡åŒ–é£é™©å»ºæ¨¡ã€çœŸå®æ¡ˆä¾‹åˆ†æå’Œæœ€æ–°å®è·µï¼Œå¸®åŠ©æ‚¨æ„å»ºå¯¹è¿™ä¸€å¤æ‚ç³»ç»Ÿçš„æ·±åˆ»ç†è§£ã€‚</p>
            </div>

            <h3>4.1 é‡‘åº“æœºåˆ¶ä¸CDPç³»ç»Ÿ</h3>
            
            <h4>4.1.1 æŠµæŠ¼å€ºä»“ä½(CDP)æ ¸å¿ƒæ¦‚å¿µ</h4>
            <p>CDPï¼ˆCollateralized Debt Positionï¼ŒæŠµæŠ¼å€ºä»“ä½ï¼‰æ˜¯æŠµæŠ¼å‹ç¨³å®šå¸çš„æ ¸å¿ƒæœºåˆ¶ï¼Œå…è®¸ç”¨æˆ·é€šè¿‡é”å®šæŠµæŠ¼å“æ¥é“¸é€ ç¨³å®šå¸ã€‚è®©æˆ‘ä»¬æ·±å…¥äº†è§£å…¶å·¥ä½œåŸç†ï¼š</p>
            
            <div class="tip">
                ğŸ’¡ å…³é”®æ´å¯Ÿï¼šCDPæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæ™ºèƒ½åˆçº¦æ§åˆ¶çš„è´·æ¬¾ç³»ç»Ÿï¼Œç”¨æˆ·çš„æŠµæŠ¼å“è¢«é”å®šåœ¨åˆçº¦ä¸­ï¼Œä½œä¸ºé“¸é€ ç¨³å®šå¸çš„æ‹…ä¿ã€‚
            </div>
            
            <h4>4.1.2 é£é™©å‚æ•°äº”å…ƒç»„</h4>
            <p>æŠµæŠ¼å‹ç¨³å®šå¸çš„å®‰å…¨æ€§ä¾èµ–äºç²¾å¿ƒè®¾è®¡çš„é£é™©å‚æ•°ã€‚è¿™äº›å‚æ•°ä¸æ˜¯å­¤ç«‹çš„ï¼Œè€Œæ˜¯ç›¸äº’å½±å“çš„ï¼š</p>
            
            <table class="comparison-table">
                <tr>
                    <th>å‚æ•°åç§°</th>
                    <th>å«ä¹‰</th>
                    <th>å…¸å‹å€¼</th>
                    <th>è®¾å®šä¾æ®</th>
                </tr>
                <tr>
                    <td>å€ºåŠ¡ä¸Šé™ (Debt Ceiling)</td>
                    <td>è¯¥æŠµæŠ¼å“ç±»å‹å¯é“¸é€ çš„æœ€å¤§ç¨³å®šå¸æ•°é‡</td>
                    <td>100M - 5B DAI</td>
                    <td>æŠµæŠ¼å“æµåŠ¨æ€§ã€å¸‚åœºè§„æ¨¡</td>
                </tr>
                <tr>
                    <td>æ¸…ç®—çº¿ (Liquidation Ratio)</td>
                    <td>è§¦å‘æ¸…ç®—çš„æœ€ä½æŠµæŠ¼ç‡</td>
                    <td>130% - 175%</td>
                    <td>èµ„äº§æ³¢åŠ¨æ€§ã€VaRæ¨¡å‹</td>
                </tr>
                <tr>
                    <td>ç¨³å®šè´¹ (Stability Fee)</td>
                    <td>å€Ÿæ¬¾åˆ©ç‡ï¼Œä½œä¸ºè´§å¸æ”¿ç­–å·¥å…·</td>
                    <td>0.5% - 20% APR</td>
                    <td>å¸‚åœºåˆ©ç‡ã€ä»·æ ¼é”šå®šæƒ…å†µ</td>
                </tr>
                <tr>
                    <td>æ¸…ç®—ç½šé‡‘ (Liquidation Penalty)</td>
                    <td>æ¸…ç®—æ—¶çš„é¢å¤–è´¹ç”¨</td>
                    <td>5% - 13%</td>
                    <td>æ¿€åŠ±Keeperã€è¡¥å¿ç³»ç»Ÿé£é™©</td>
                </tr>
                <tr>
                    <td>ç›®æ ‡æŠµæŠ¼ç‡ (Target CR)</td>
                    <td>å»ºè®®çš„å®‰å…¨æŠµæŠ¼ç‡</td>
                    <td>150% - 200%</td>
                    <td>ç»™ç”¨æˆ·ç¼“å†²ç©ºé—´</td>
                </tr>
            </table>
            
            <div class="tip-box">
                <strong>ğŸ“Š é‡åŒ–é£é™©å»ºæ¨¡ï¼š</strong>
                <p>è¿™äº›å‚æ•°çš„è®¾å®šä¸æ˜¯ä»»æ„çš„ï¼Œè€Œæ˜¯åŸºäºï¼š</p>
                <ul>
                    <li><strong>Value-at-Risk (VaR)ï¼š</strong>é€šè¿‡å†å²æ•°æ®æ¨¡æ‹Ÿæç«¯å¸‚åœºæƒ…å†µä¸‹çš„æŸå¤±æ¦‚ç‡</li>
                    <li><strong>Monte Carloæ¨¡æ‹Ÿï¼š</strong>éšæœºç”Ÿæˆä»·æ ¼è·¯å¾„ï¼Œè¯„ä¼°ç³»ç»Ÿåœ¨ä¸åŒåœºæ™¯ä¸‹çš„è¡¨ç°</li>
                    <li><strong>å¸‚åœºæ·±åº¦åˆ†æï¼š</strong>è€ƒè™‘å¤§è§„æ¨¡æ¸…ç®—å¯¹å¸‚åœºçš„å†²å‡»</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">CDPæ ¸å¿ƒæ•°æ®ç»“æ„è®¾è®¡ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CDPEngine {
    // CDPæ ¸å¿ƒæ•°æ®ç»“æ„
    struct CDP {
        uint256 collateral;      // æŠµæŠ¼å“æ•°é‡
        uint256 debt;           // å€ºåŠ¡æ•°é‡ï¼ˆé“¸é€ çš„ç¨³å®šå¸ï¼‰
        uint256 accumulatedRate; // ç´¯ç§¯åˆ©ç‡ï¼ˆç”¨äºè®¡ç®—åˆ©æ¯ï¼‰
    }
    
    // æŠµæŠ¼å“ç±»å‹ä¿¡æ¯ - é£é™©å‚æ•°äº”å…ƒç»„
    struct CollateralType {
        // é£é™©å‚æ•°
        uint256 debtCeiling;        // å€ºåŠ¡ä¸Šé™
        uint256 liquidationRatio;   // æ¸…ç®—æ¯”ç‡ï¼ˆå¦‚150%ï¼‰
        uint256 stabilityFee;       // ç¨³å®šè´¹ç‡ï¼ˆå¹´åŒ–ï¼‰
        uint256 liquidationPenalty; // æ¸…ç®—ç½šé‡‘ï¼ˆå¦‚13%ï¼‰
        uint256 targetRatio;        // ç›®æ ‡æŠµæŠ¼ç‡ï¼ˆå¦‚175%ï¼‰
        
        // çŠ¶æ€å˜é‡
        uint256 totalCollateral;     // è¯¥ç±»å‹æ€»æŠµæŠ¼é‡
        uint256 totalDebt;          // è¯¥ç±»å‹æ€»å€ºåŠ¡
        uint256 debtFloor;          // æœ€å°å€ºåŠ¡é‡
        uint256 accumulatedRate;    // ç´¯ç§¯åˆ©ç‡
        uint256 lastUpdateTime;     // ä¸Šæ¬¡æ›´æ–°æ—¶é—´
        
        // é…ç½®
        address priceOracle;        // ä»·æ ¼é¢„è¨€æœºåœ°å€
        address gemAdapter;         // æŠµæŠ¼å“é€‚é…å™¨
        bool isActive;              // æ˜¯å¦æ¿€æ´»
    }
    
    // çŠ¶æ€å˜é‡
    mapping(bytes32 => CollateralType) public collateralTypes;
    mapping(bytes32 => mapping(address => CDP)) public cdps;
    mapping(address => uint256) public systemDebt;  // ç³»ç»Ÿå€ºåŠ¡
    mapping(address => uint256) public systemSurplus; // ç³»ç»Ÿç›ˆä½™
    
    uint256 public globalDebtCeiling;  // å…¨å±€å€ºåŠ¡ä¸Šé™
    uint256 public baseRate = 1e27;    // åŸºç¡€åˆ©ç‡ï¼ˆRayå•ä½ï¼‰
    uint256 constant RAY = 1e27;       // Rayç²¾åº¦
    
    // äº‹ä»¶
    event CDPOpened(bytes32 indexed ilk, address indexed user);
    event CollateralLocked(bytes32 indexed ilk, address indexed user, uint256 amount);
    event DebtGenerated(bytes32 indexed ilk, address indexed user, uint256 amount);
    event CDPClosed(bytes32 indexed ilk, address indexed user);
    
    // å¼€å¯æ–°çš„CDP
    function openCDP(bytes32 ilk) external returns (uint256 cdpId) {
        require(collateralTypes[ilk].debtCeiling > 0, "Collateral type not initialized");
        
        // åˆå§‹åŒ–ç”¨æˆ·çš„CDP
        cdps[ilk][msg.sender] = CDP({
            collateral: 0,
            debt: 0,
            accumulatedRate: collateralTypes[ilk].accumulatedRate
        });
        
        emit CDPOpened(ilk, msg.sender);
    }
    
    // é”å®šæŠµæŠ¼å“
    function lockCollateral(bytes32 ilk, uint256 amount) external {
        CDP storage cdp = cdps[ilk][msg.sender];
        CollateralType storage collType = collateralTypes[ilk];
        
        // ä»ç”¨æˆ·è½¬å…¥æŠµæŠ¼å“ï¼ˆéœ€è¦å…ˆapproveï¼‰
        // è¿™é‡Œå‡è®¾æœ‰ä¸€ä¸ªgem adapterå¤„ç†ä¸åŒç±»å‹çš„æŠµæŠ¼å“
        IGemAdapter(collType.gemAdapter).join(msg.sender, amount);
        
        cdp.collateral += amount;
        collType.totalCollateral += amount;
        
        emit CollateralLocked(ilk, msg.sender, amount);
    }
    
    // è®¡ç®—CDPçš„æŠµæŠ¼ç‡
    function getCDPStatus(bytes32 ilk, address user) 
        public 
        view 
        returns (
            uint256 collateralValue,
            uint256 debtValue,
            uint256 collateralizationRatio,
            bool isSafe
        ) 
    {
        CDP memory cdp = cdps[ilk][user];
        CollateralType memory collType = collateralTypes[ilk];
        
        // è·å–æŠµæŠ¼å“ä»·æ ¼
        uint256 price = IPriceOracle(collType.priceOracle).getPrice(ilk);
        
        // è®¡ç®—ä»·å€¼
        collateralValue = cdp.collateral * price / 1e18;
        debtValue = cdp.debt * collType.accumulatedRate / RAY;
        
        // è®¡ç®—æŠµæŠ¼ç‡
        if (debtValue > 0) {
            collateralizationRatio = collateralValue * 100 / debtValue;
        } else {
            collateralizationRatio = type(uint256).max;
        }
        
        // æ£€æŸ¥æ˜¯å¦å®‰å…¨
        isSafe = collateralizationRatio >= collType.liquidationRatio;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.1.2 åˆ©ç‡ç´¯ç§¯æœºåˆ¶</h4>
            <p>ç¨³å®šè´¹ï¼ˆStability Feeï¼‰æ˜¯æŠµæŠ¼å‹ç¨³å®šå¸çš„é‡è¦æ”¶å…¥æ¥æºï¼Œé€šè¿‡å¤åˆ©è®¡ç®—å®ç°ç²¾ç¡®çš„åˆ©æ¯ç´¯ç§¯ï¼š</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">åˆ©ç‡ç´¯ç§¯è®¡ç®—å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">library RateMath {
    uint256 constant RAY = 1e27;
    uint256 constant YEAR = 365 days;
    
    // è®¡ç®—å¤åˆ©
    function compound(uint256 principal, uint256 rate, uint256 time) 
        internal 
        pure 
        returns (uint256) 
    {
        // ä½¿ç”¨æ³°å‹’çº§æ•°è¿‘ä¼¼è®¡ç®— e^(rate * time)
        // å¯¹äºå°çš„rate * timeï¼Œè¿™ä¸ªè¿‘ä¼¼éå¸¸å‡†ç¡®
        uint256 ratePerSecond = rate / YEAR;
        uint256 exp = time * ratePerSecond / RAY;
        
        // e^x â‰ˆ 1 + x + x^2/2 + x^3/6 + ...
        uint256 result = RAY + exp;
        uint256 term = exp;
        
        // è®¡ç®—å‰å‡ é¡¹ä»¥æé«˜ç²¾åº¦
        for (uint256 i = 2; i <= 6; i++) {
            term = term * exp / (i * RAY);
            result += term;
            
            // å¦‚æœé¡¹å¤ªå°ï¼Œåœæ­¢è®¡ç®—
            if (term < 1) break;
        }
        
        return principal * result / RAY;
    }
}

contract StabilityFeeCollector {
    using RateMath for uint256;
    
    struct RateUpdate {
        uint256 rate;           // å½“å‰åˆ©ç‡
        uint256 accumulated;    // ç´¯ç§¯å› å­
        uint256 lastUpdate;     // ä¸Šæ¬¡æ›´æ–°æ—¶é—´
    }
    
    mapping(bytes32 => RateUpdate) public rates;
    
    // æ›´æ–°ç´¯ç§¯åˆ©ç‡
    function updateAccumulatedRate(bytes32 ilk) public returns (uint256) {
        RateUpdate storage r = rates[ilk];
        
        if (block.timestamp > r.lastUpdate) {
            uint256 timeDelta = block.timestamp - r.lastUpdate;
            
            // è®¡ç®—æ–°çš„ç´¯ç§¯å› å­
            uint256 newAccumulated = r.accumulated.compound(
                r.rate,
                timeDelta
            );
            
            r.accumulated = newAccumulated;
            r.lastUpdate = block.timestamp;
        }
        
        return r.accumulated;
    }
    
    // è®¡ç®—å€ºåŠ¡çš„å½“å‰ä»·å€¼ï¼ˆåŒ…å«åˆ©æ¯ï¼‰
    function debtWithInterest(
        bytes32 ilk,
        uint256 principal
    ) public view returns (uint256) {
        RateUpdate memory r = rates[ilk];
        uint256 timeDelta = block.timestamp - r.lastUpdate;
        
        uint256 currentAccumulated = r.accumulated.compound(
            r.rate,
            timeDelta
        );
        
        return principal * currentAccumulated / RAY;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.1.3 å€ºåŠ¡å’Œç›ˆä½™ç®¡ç†</h4>
            <p>ç³»ç»Ÿéœ€è¦ç²¾ç¡®ç®¡ç†å…¨å±€å€ºåŠ¡å’Œç›ˆä½™ï¼Œç¡®ä¿æ•´ä½“å¿ä»˜èƒ½åŠ›ï¼š</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">å€ºåŠ¡ä¼šè®¡ç³»ç»Ÿ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract DebtAccounting {
    // ç³»ç»Ÿä¼šè®¡å˜é‡
    mapping(address => uint256) public dai;      // DAIä½™é¢
    mapping(address => uint256) public sin;      // åè´¦ï¼ˆç³»ç»Ÿå€ºåŠ¡ï¼‰
    uint256 public vice;                         // å…¨å±€æœªæ‹å–åè´¦
    uint256 public surplus;                      // ç³»ç»Ÿç›ˆä½™
    
    uint256 constant RAD = 1e45;                 // é«˜ç²¾åº¦å•ä½
    
    // é“¸é€ ç¨³å®šå¸
    function mint(address user, uint256 amount) internal {
        dai[user] += amount;
        
        // åŒæ—¶å¢åŠ ç­‰é¢çš„ç³»ç»Ÿå€ºåŠ¡
        sin[address(this)] += amount;
    }
    
    // é”€æ¯ç¨³å®šå¸å¿è¿˜å€ºåŠ¡
    function burn(address user, uint256 amount) internal {
        require(dai[user] >= amount, "Insufficient balance");
        
        dai[user] -= amount;
        sin[address(this)] -= amount;
    }
    
    // å¤„ç†ç›ˆä½™
    function handleSurplus() external {
        // å½“ç³»ç»Ÿæœ‰ç›ˆä½™æ—¶ï¼Œå¯ä»¥ï¼š
        // 1. é”€æ¯MKRä»£å¸ï¼ˆé€šè¿‡æ‹å–ï¼‰
        // 2. å¢åŠ å‚¨å¤‡é‡‘
        // 3. é™ä½ç¨³å®šè´¹ç‡
        
        if (surplus > surplusBuffer) {
            uint256 auctionAmount = surplus - surplusBuffer;
            // å¯åŠ¨ç›ˆä½™æ‹å–...
        }
    }
    
    // å¤„ç†åè´¦
    function handleBadDebt() external {
        // å½“ç³»ç»Ÿæœ‰åè´¦æ—¶ï¼Œéœ€è¦ï¼š
        // 1. é“¸é€ MKRä»£å¸ï¼ˆé€šè¿‡æ‹å–ï¼‰
        // 2. ä½¿ç”¨å‚¨å¤‡é‡‘
        // 3. æé«˜ç¨³å®šè´¹ç‡
        
        if (vice > debtBuffer) {
            uint256 auctionAmount = vice - debtBuffer;
            // å¯åŠ¨å€ºåŠ¡æ‹å–...
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.2 æ¸…ç®—å¼•æ“ä¸Keeperæ¿€åŠ±</h3>
            
            <h4>4.2.0 æ¸…ç®—æœºåˆ¶å¯¹æ¯”åˆ†æ</h4>
            <p>åœ¨æ·±å…¥å®ç°ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆä»å¤šä¸ªç»´åº¦å¯¹æ¯”ä¸åŒçš„æ¸…ç®—æœºåˆ¶ï¼š</p>
            
            <table class="comparison-table">
                <tr>
                    <th>æ¸…ç®—æœºåˆ¶</th>
                    <th>èµ„æœ¬æ•ˆç‡</th>
                    <th>Gasæˆæœ¬</th>
                    <th>å¸‚åœºæ“çºµé£é™©</th>
                    <th>æ¸…ç®—é€Ÿåº¦</th>
                    <th>Keeperè¦æ±‚</th>
                    <th>é€‚ç”¨åœºæ™¯</th>
                </tr>
                <tr>
                    <td>è·å…°æ‹å–</td>
                    <td>ä¸­ç­‰</td>
                    <td>é«˜</td>
                    <td>ä½</td>
                    <td>æ…¢</td>
                    <td>å¤æ‚</td>
                    <td>å¤§é¢æ¸…ç®—</td>
                </tr>
                <tr>
                    <td>è‹±å¼æ‹å– (Liquidation 2.0)</td>
                    <td>é«˜</td>
                    <td>ä¸­</td>
                    <td>ä½</td>
                    <td>ä¸­</td>
                    <td>ç®€å•</td>
                    <td>MakerDAOç°è¡Œæ–¹æ¡ˆ</td>
                </tr>
                <tr>
                    <td>å›ºå®šä»·å·®</td>
                    <td>ä½</td>
                    <td>ä½</td>
                    <td>ä¸­</td>
                    <td>å¿«</td>
                    <td>ç®€å•</td>
                    <td>å°é¢é«˜é¢‘</td>
                </tr>
                <tr>
                    <td>AMMæ¸…ç®—</td>
                    <td>æœ€é«˜</td>
                    <td>ä¸­</td>
                    <td>æœ€ä½</td>
                    <td>å³æ—¶</td>
                    <td>æ— </td>
                    <td>Curve crvUSD</td>
                </tr>
            </table>
            
            <div class="tip-box">
                <strong>ğŸ¨ MakerDAO Liquidation 2.0ï¼š</strong>
                <p>MakerDAOå·²ç»ä»Liquidation 1.0çš„è·å…°æ‹å–å‡çº§åˆ°äº†2.0çš„è‹±å¼æ‹å–ç³»ç»Ÿï¼š</p>
                <ul>
                    <li>å›ºå®šæŠ˜æ‰£çš„è‹±å¼æ‹å–ï¼Œå‡å°‘å¸‚åœºå†²å‡»</li>
                    <li>å³æ—¶æ¸…ç®—ï¼Œæ— éœ€ç­‰å¾…æ‹å–ç»“æŸ</li>
                    <li>æ”¯æŒéƒ¨åˆ†æ¸…ç®—ï¼Œæé«˜ç”¨æˆ·ä½“éªŒ</li>
                    <li>æ›´é«˜çš„èµ„æœ¬æ•ˆç‡å’Œæ›´ä½çš„æ¸…ç®—æŸå¤±</li>
                </ul>
            </div>
            
            <h4>4.2.1 æ¸…ç®—è§¦å‘æ¡ä»¶</h4>
            <p>å½“CDPçš„æŠµæŠ¼ç‡ä½äºæ¸…ç®—çº¿æ—¶ï¼Œç³»ç»Ÿéœ€è¦åŠæ—¶æ¸…ç®—ä»¥ä¿æŠ¤æ•´ä½“å¿ä»˜èƒ½åŠ›ï¼š</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">æ¸…ç®—å¼•æ“æ ¸å¿ƒé€»è¾‘ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract LiquidationEngine {
    struct Auction {
        uint256 collateralAmount;  // æ‹å–çš„æŠµæŠ¼å“æ•°é‡
        uint256 debtAmount;        // éœ€è¦å¿è¿˜çš„å€ºåŠ¡
        address cdpOwner;          // CDPåŸä¸»äºº
        uint256 startTime;         // æ‹å–å¼€å§‹æ—¶é—´
        uint256 startPrice;        // èµ·å§‹ä»·æ ¼
        uint256 endTime;           // æ‹å–ç»“æŸæ—¶é—´
        address highBidder;        // æœ€é«˜å‡ºä»·è€…
        uint256 highBid;           // æœ€é«˜å‡ºä»·
    }
    
    mapping(uint256 => Auction) public auctions;
    uint256 public nextAuctionId;
    
    // æ¸…ç®—å‚æ•°
    uint256 public liquidationPenalty = 13e16;  // 13%ç½šé‡‘
    uint256 public auctionDuration = 6 hours;    // æ‹å–æŒç»­æ—¶é—´
    uint256 public bufferPercentage = 3e16;      // 3%ç¼“å†²
    
    // è§¦å‘æ¸…ç®—
    function liquidate(bytes32 ilk, address user) external returns (uint256 auctionId) {
        // æ£€æŸ¥CDPçŠ¶æ€
        (uint256 collateralValue, uint256 debtValue, uint256 ratio, bool isSafe) = 
            cdpEngine.getCDPStatus(ilk, user);
        
        require(!isSafe, "CDP is safe");
        
        CDP storage cdp = cdpEngine.cdps(ilk, user);
        CollateralType memory collType = cdpEngine.collateralTypes(ilk);
        
        // è®¡ç®—æ¸…ç®—é‡‘é¢
        uint256 debtToRecover = cdp.debt * collType.accumulatedRate / RAY;
        uint256 penaltyAmount = debtToRecover * liquidationPenalty / 1e18;
        uint256 totalDebtWithPenalty = debtToRecover + penaltyAmount;
        
        // è®¡ç®—éœ€è¦æ‹å–çš„æŠµæŠ¼å“
        uint256 collateralPrice = oracle.getPrice(ilk);
        uint256 collateralToAuction = totalDebtWithPenalty * 1e18 / collateralPrice;
        
        // å¦‚æœéœ€è¦çš„æŠµæŠ¼å“è¶…è¿‡CDPæ‹¥æœ‰çš„ï¼Œæ‹å–å…¨éƒ¨
        if (collateralToAuction > cdp.collateral) {
            collateralToAuction = cdp.collateral;
        }
        
        // åˆ›å»ºæ‹å–
        auctionId = nextAuctionId++;
        auctions[auctionId] = Auction({
            collateralAmount: collateralToAuction,
            debtAmount: debtToRecover,
            cdpOwner: user,
            startTime: block.timestamp,
            startPrice: collateralPrice * (100 + bufferPercentage) / 100,
            endTime: block.timestamp + auctionDuration,
            highBidder: address(0),
            highBid: 0
        });
        
        // ä»CDPä¸­ç§»é™¤æŠµæŠ¼å“
        cdp.collateral -= collateralToAuction;
        
        emit LiquidationStarted(ilk, user, auctionId, collateralToAuction, debtToRecover);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.2.2 æ‹å–æœºåˆ¶è®¾è®¡</h4>
            <p>MakerDAOä½¿ç”¨ä¸‰ç§æ‹å–æœºåˆ¶ï¼šæŠµæŠ¼å“æ‹å–ï¼ˆCollateral Auctionï¼‰ã€å€ºåŠ¡æ‹å–ï¼ˆDebt Auctionï¼‰å’Œç›ˆä½™æ‹å–ï¼ˆSurplus Auctionï¼‰ï¼š</p>
            
            <table class="comparison-table">
                <tr>
                    <th>æ‹å–ç±»å‹</th>
                    <th>è§¦å‘æ¡ä»¶</th>
                    <th>æ‹å–æ ‡çš„</th>
                    <th>æ”¯ä»˜æ–¹å¼</th>
                    <th>ç›®æ ‡</th>
                </tr>
                <tr>
                    <td>æŠµæŠ¼å“æ‹å–</td>
                    <td>CDPè¢«æ¸…ç®—</td>
                    <td>æŠµæŠ¼å“</td>
                    <td>DAI</td>
                    <td>å›æ”¶å€ºåŠ¡+ç½šé‡‘</td>
                </tr>
                <tr>
                    <td>å€ºåŠ¡æ‹å–</td>
                    <td>ç³»ç»Ÿåè´¦è¿‡å¤š</td>
                    <td>MKRä»£å¸</td>
                    <td>DAI</td>
                    <td>å¡«è¡¥åè´¦ç¼ºå£</td>
                </tr>
                <tr>
                    <td>ç›ˆä½™æ‹å–</td>
                    <td>ç³»ç»Ÿç›ˆä½™è¿‡å¤š</td>
                    <td>DAI</td>
                    <td>MKRä»£å¸</td>
                    <td>é”€æ¯MKR</td>
                </tr>
            </table>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">è·å…°å¼æ‹å–å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract DutchAuction {
    // è·å…°å¼æ‹å–ï¼šä»·æ ¼éšæ—¶é—´çº¿æ€§ä¸‹é™
    function getCurrentPrice(Auction memory auction) 
        public 
        view 
        returns (uint256) 
    {
        if (block.timestamp >= auction.endTime) {
            // æ‹å–ç»“æŸï¼Œè¿”å›æœ€ä½ä»·
            return auction.startPrice / 2;
        }
        
        uint256 elapsed = block.timestamp - auction.startTime;
        uint256 duration = auction.endTime - auction.startTime;
        
        // çº¿æ€§ä¸‹é™åˆ°50%
        uint256 priceDrop = auction.startPrice * elapsed / (2 * duration);
        return auction.startPrice - priceDrop;
    }
    
    // ç«æ‹
    function bid(uint256 auctionId, uint256 amount) external {
        Auction storage auction = auctions[auctionId];
        require(block.timestamp < auction.endTime, "Auction ended");
        
        uint256 currentPrice = getCurrentPrice(auction);
        uint256 collateralWanted = amount * 1e18 / currentPrice;
        
        require(collateralWanted <= auction.collateralAmount, "Not enough collateral");
        
        // è½¬å…¥DAI
        dai.transferFrom(msg.sender, address(this), amount);
        
        // è½¬å‡ºæŠµæŠ¼å“
        collateral.transfer(msg.sender, collateralWanted);
        
        // æ›´æ–°æ‹å–çŠ¶æ€
        auction.collateralAmount -= collateralWanted;
        
        // å¦‚æœå€ºåŠ¡å·²å®Œå…¨å¿è¿˜ï¼Œç»“æŸæ‹å–
        if (amount >= auction.debtAmount) {
            // è¿”è¿˜å‰©ä½™æŠµæŠ¼å“ç»™åŸä¸»äºº
            if (auction.collateralAmount > 0) {
                collateral.transfer(auction.cdpOwner, auction.collateralAmount);
            }
            
            // å¤šä½™çš„DAIä½œä¸ºç³»ç»Ÿç›ˆä½™
            if (amount > auction.debtAmount) {
                surplus += amount - auction.debtAmount;
            }
            
            delete auctions[auctionId];
        } else {
            auction.debtAmount -= amount;
        }
        
        emit BidPlaced(auctionId, msg.sender, amount, collateralWanted);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.2.3 Keeperæ¿€åŠ±æœºåˆ¶ä¸MEVé˜²æŠ¤</h4>
            <p>Keeperæ˜¯ç»´æŠ¤ç³»ç»Ÿå¥åº·çš„å…³é”®å‚ä¸è€…ï¼Œä½†ä¹Ÿå¯èƒ½æˆä¸ºMEVæ”»å‡»çš„æ¥æºã€‚æˆ‘ä»¬éœ€è¦åœ¨æ¿€åŠ±å’Œé˜²æŠ¤ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼š</p>
            
            <div class="tip-box">
                <strong>ğŸ•¸ï¸ MEVåœ¨æ¸…ç®—ä¸­çš„ä¸¤ç§ä¸»è¦å½¢å¼ï¼š</strong>
                <ul>
                    <li><strong>æŠ¢è·‘ (Front-running)ï¼š</strong>Keeperç›‘æ§å†…å­˜æ± ï¼ŒæŠ¢å…ˆæ‰§è¡Œæœ‰åˆ©å¯å›¾çš„æ¸…ç®—</li>
                    <li><strong>ä¸‰æ˜æ²»æ”»å‡» (Sandwiching)ï¼š</strong>åœ¨é¢„è¨€æœºæ›´æ–°å‰åæ“çºµä»·æ ¼è§¦å‘æ¸…ç®—</li>
                </ul>
                <p><strong>ç¼“è§£ç­–ç•¥ï¼š</strong></p>
                <ul>
                    <li>æ‰¹é‡æ‹å–ï¼šå‡å°‘å•ä¸ªäº¤æ˜“çš„MEVæœºä¼š</li>
                    <li>Commit-Revealï¼šéšè—æ„å›¾ç›´åˆ°æ‰§è¡Œ</li>
                    <li>Flashbots Protectï¼šä½¿ç”¨åŠ å¯†å†…å­˜æ± </li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Keeperæ¿€åŠ±ç³»ç»Ÿ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract KeeperIncentives {
    // Keeperå¥–åŠ±å‚æ•°
    uint256 public liquidationReward = 3e16;     // 3%å¥–åŠ±
    uint256 public priceUpdateReward = 1e15;     // 0.1%å¥–åŠ±
    uint256 public gasCompensation = 200000;     // Gasè¡¥å¿
    
    mapping(address => uint256) public keeperRewards;
    mapping(address => uint256) public keeperReputation;
    
    // æ¸…ç®—å¥–åŠ±
    function rewardLiquidation(address keeper, uint256 debtAmount) internal {
        uint256 reward = debtAmount * liquidationReward / 1e18;
        keeperRewards[keeper] += reward;
        keeperReputation[keeper] += 1;
        
        emit KeeperRewarded(keeper, "liquidation", reward);
    }
    
    // ä»·æ ¼æ›´æ–°å¥–åŠ±
    function rewardPriceUpdate(address keeper) internal {
        uint256 reward = priceUpdateReward;
        keeperRewards[keeper] += reward;
        
        emit KeeperRewarded(keeper, "price_update", reward);
    }
    
    // MEVä¿æŠ¤ï¼šä½¿ç”¨commit-revealæœºåˆ¶
    mapping(bytes32 => uint256) public commitments;
    uint256 public revealDelay = 2; // åŒºå—å»¶è¿Ÿ
    
    // æ‰¹é‡æ‹å–æœºåˆ¶
    struct BatchAuction {
        uint256 startBlock;
        uint256 endBlock;
        bytes32[] liquidations;
        mapping(address => uint256) bids;
        uint256 totalBids;
        bool settled;
    }
    
    mapping(uint256 => BatchAuction) public batches;
    uint256 public currentBatch;
    
    // åŠ å¯†è®¢å•æµ
    function submitEncryptedBid(
        uint256 batchId,
        bytes32 encryptedBid
    ) external {
        require(block.number < batches[batchId].endBlock, "Batch ended");
        // å­˜å‚¨åŠ å¯†ç«ä»·
        encryptedBids[batchId][msg.sender] = encryptedBid;
    }
    
    // ä½¿ç”¨VDFå»¶è¿Ÿæ­ç¤º
    function revealWithVDF(
        uint256 batchId,
        uint256 bid,
        uint256 nonce,
        bytes memory vdfProof
    ) external {
        // éªŒè¯VDFè¯æ˜
        require(verifyVDF(vdfProof, block.number - batches[batchId].endBlock), "Invalid VDF");
        
        // éªŒè¯åŠ å¯†ç«ä»·
        bytes32 commitment = keccak256(abi.encodePacked(bid, nonce));
        require(encryptedBids[batchId][msg.sender] == commitment, "Invalid reveal");
        
        batches[batchId].bids[msg.sender] = bid;
        batches[batchId].totalBids += bid;
    }
    
    function commitLiquidation(bytes32 commitment) external {
        commitments[commitment] = block.number;
    }
    
    function revealLiquidation(
        bytes32 ilk,
        address user,
        uint256 nonce
    ) external {
        bytes32 commitment = keccak256(abi.encodePacked(ilk, user, nonce, msg.sender));
        require(commitments[commitment] > 0, "Invalid commitment");
        require(block.number >= commitments[commitment] + revealDelay, "Too early");
        require(block.number <= commitments[commitment] + revealDelay + 10, "Too late");
        
        // æ‰§è¡Œæ¸…ç®—
        liquidationEngine.liquidate(ilk, user);
        
        // å¥–åŠ±keeper
        rewardLiquidation(msg.sender, debtAmount);
        
        delete commitments[commitment];
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.3 é¢„è¨€æœºé›†æˆä¸ä»·æ ¼å–‚ä»·</h3>
            
            <h4>4.3.1 é¢„è¨€æœºæ¶æ„è®¾è®¡</h4>
            <p>ä»·æ ¼é¢„è¨€æœºæ˜¯æŠµæŠ¼å‹ç¨³å®šå¸çš„å…³é”®ç»„ä»¶ï¼Œéœ€è¦ç¡®ä¿ä»·æ ¼çš„å‡†ç¡®æ€§å’ŒæŠ—æ“çºµæ€§ï¼š</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">é¢„è¨€æœºç³»ç»Ÿæ¶æ„ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract PriceOracleSystem {
    struct PriceFeed {
        uint256 value;          // å½“å‰ä»·æ ¼
        uint256 timestamp;      // æ›´æ–°æ—¶é—´
        bool isActive;          // æ˜¯å¦æ´»è·ƒ
    }
    
    struct OracleConfig {
        address[] oracles;      // é¢„è¨€æœºåœ°å€åˆ—è¡¨
        uint256 quorum;         // æœ€å°æ•°é‡è¦æ±‚
        uint256 priceDeviation; // å…è®¸çš„ä»·æ ¼åå·®
        uint256 stalePeriod;    // ä»·æ ¼è¿‡æœŸæ—¶é—´
    }
    
    mapping(bytes32 => PriceFeed) public priceFeeds;
    mapping(bytes32 => OracleConfig) public oracleConfigs;
    mapping(bytes32 => mapping(address => uint256)) public oracleSubmissions;
    
    // ä¸­ä½æ•°ä»·æ ¼è®¡ç®—
    function updatePrice(bytes32 asset) external {
        OracleConfig memory config = oracleConfigs[asset];
        
        uint256[] memory prices = new uint256[](config.oracles.length);
        uint256 validSubmissions = 0;
        
        // æ”¶é›†æ‰€æœ‰æœ‰æ•ˆçš„ä»·æ ¼æäº¤
        for (uint256 i = 0; i < config.oracles.length; i++) {
            uint256 submission = oracleSubmissions[asset][config.oracles[i]];
            
            // æ£€æŸ¥æäº¤æ˜¯å¦åœ¨æœ‰æ•ˆæœŸå†…
            if (submission > 0 && block.timestamp - submission <= config.stalePeriod) {
                prices[validSubmissions++] = submission;
            }
        }
        
        require(validSubmissions >= config.quorum, "Insufficient oracle submissions");
        
        // è®¡ç®—ä¸­ä½æ•°
        uint256 medianPrice = calculateMedian(prices, validSubmissions);
        
        // æ£€æŸ¥ä»·æ ¼åå·®
        PriceFeed storage feed = priceFeeds[asset];
        if (feed.value > 0) {
            uint256 deviation = medianPrice > feed.value 
                ? (medianPrice - feed.value) * 1e18 / feed.value
                : (feed.value - medianPrice) * 1e18 / feed.value;
                
            require(deviation <= config.priceDeviation, "Price deviation too high");
        }
        
        // æ›´æ–°ä»·æ ¼
        feed.value = medianPrice;
        feed.timestamp = block.timestamp;
        feed.isActive = true;
        
        emit PriceUpdated(asset, medianPrice, validSubmissions);
    }
    
    // å®‰å…¨çš„ä»·æ ¼è·å–
    function getPrice(bytes32 asset) external view returns (uint256) {
        PriceFeed memory feed = priceFeeds[asset];
        require(feed.isActive, "Price feed not active");
        require(block.timestamp - feed.timestamp <= oracleConfigs[asset].stalePeriod, 
                "Price is stale");
        
        return feed.value;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.3.2 Chainlinké›†æˆ</h4>
            <p>é›†æˆChainlinké¢„è¨€æœºæä¾›å¯é çš„ä»·æ ¼æ•°æ®ï¼š</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Chainlinké¢„è¨€æœºé€‚é…å™¨ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract ChainlinkPriceAdapter {
    struct ChainlinkFeed {
        AggregatorV3Interface priceFeed;
        uint256 heartbeat;      // æœ€å¤§æ›´æ–°é—´éš”
        uint256 decimals;       // ä»·æ ¼ç²¾åº¦
        bool isInverse;         // æ˜¯å¦éœ€è¦å–å€’æ•°ï¼ˆå¦‚USD/ETHï¼‰
    }
    
    mapping(bytes32 => ChainlinkFeed) public chainlinkFeeds;
    uint256 constant PRICE_DECIMALS = 1e18;
    
    // é…ç½®Chainlinkæ•°æ®æº
    function setChainlinkFeed(
        bytes32 asset,
        address feedAddress,
        uint256 heartbeat,
        bool isInverse
    ) external onlyOwner {
        AggregatorV3Interface feed = AggregatorV3Interface(feedAddress);
        uint256 decimals = feed.decimals();
        
        chainlinkFeeds[asset] = ChainlinkFeed({
            priceFeed: feed,
            heartbeat: heartbeat,
            decimals: 10 ** decimals,
            isInverse: isInverse
        });
    }
    
    // è·å–Chainlinkä»·æ ¼
    function getChainlinkPrice(bytes32 asset) public view returns (uint256) {
        ChainlinkFeed memory feed = chainlinkFeeds[asset];
        require(address(feed.priceFeed) != address(0), "Feed not configured");
        
        (
            uint80 roundId,
            int256 price,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = feed.priceFeed.latestRoundData();
        
        // éªŒè¯æ•°æ®æœ‰æ•ˆæ€§
        require(price > 0, "Invalid price");
        require(updatedAt > 0, "Round not complete");
        require(block.timestamp - updatedAt <= feed.heartbeat, "Price stale");
        
        // æ ‡å‡†åŒ–ä»·æ ¼åˆ°18ä½å°æ•°
        uint256 normalizedPrice = uint256(price) * PRICE_DECIMALS / feed.decimals;
        
        // å¦‚æœéœ€è¦å–å€’æ•°ï¼ˆå¦‚USD/ETHè½¬æ¢ä¸ºETH/USDï¼‰
        if (feed.isInverse) {
            normalizedPrice = PRICE_DECIMALS * PRICE_DECIMALS / normalizedPrice;
        }
        
        return normalizedPrice;
    }
    
    // èšåˆå¤šä¸ªä»·æ ¼æº
    function getAggregatedPrice(bytes32 asset) external view returns (uint256) {
        uint256 chainlinkPrice = getChainlinkPrice(asset);
        uint256 internalPrice = priceOracle.getPrice(asset);
        
        // ç®€å•å¹³å‡ï¼Œå®é™…å¯ä»¥ä½¿ç”¨åŠ æƒå¹³å‡æˆ–å…¶ä»–ç®—æ³•
        return (chainlinkPrice + internalPrice) / 2;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.3.3 TWAPä»·æ ¼ä¿æŠ¤</h4>
            <p>ä½¿ç”¨æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼ˆTWAPï¼‰é˜²æ­¢ä»·æ ¼æ“çºµï¼š</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">TWAPå®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract TWAPOracle {
    struct Observation {
        uint256 timestamp;
        uint256 priceCumulative;
        uint256 price;
    }
    
    struct TWAPData {
        Observation[] observations;
        uint256 windowSize;        // TWAPçª—å£å¤§å°ï¼ˆç§’ï¼‰
        uint256 granularity;       // è§‚å¯Ÿç‚¹æ•°é‡
    }
    
    mapping(bytes32 => TWAPData) public twapData;
    
    // æ›´æ–°TWAP
    function updateTWAP(bytes32 asset, uint256 currentPrice) external {
        TWAPData storage data = twapData[asset];
        
        // è®¡ç®—æ—¶é—´é—´éš”
        uint256 timeElapsed = block.timestamp - data.observations[data.observations.length - 1].timestamp;
        require(timeElapsed > 0, "Time not elapsed");
        
        // è®¡ç®—ç´¯ç§¯ä»·æ ¼
        uint256 priceCumulative = data.observations[data.observations.length - 1].priceCumulative + 
                                 currentPrice * timeElapsed;
        
        // æ·»åŠ æ–°è§‚å¯Ÿç‚¹
        data.observations.push(Observation({
            timestamp: block.timestamp,
            priceCumulative: priceCumulative,
            price: currentPrice
        }));
        
        // ç§»é™¤è¶…å‡ºçª—å£çš„æ—§è§‚å¯Ÿç‚¹
        while (data.observations.length > 0 && 
               block.timestamp - data.observations[0].timestamp > data.windowSize) {
            // ç§»é™¤ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆæœ€æ—§çš„ï¼‰
            for (uint i = 0; i < data.observations.length - 1; i++) {
                data.observations[i] = data.observations[i + 1];
            }
            data.observations.pop();
        }
    }
    
    // è·å–TWAPä»·æ ¼
    function getTWAP(bytes32 asset) external view returns (uint256) {
        TWAPData storage data = twapData[asset];
        require(data.observations.length >= 2, "Insufficient observations");
        
        uint256 firstIndex = 0;
        uint256 lastIndex = data.observations.length - 1;
        
        // æ‰¾åˆ°çª—å£èµ·å§‹ç‚¹
        for (uint i = lastIndex; i > 0; i--) {
            if (block.timestamp - data.observations[i].timestamp >= data.windowSize) {
                firstIndex = i;
                break;
            }
        }
        
        Observation memory first = data.observations[firstIndex];
        Observation memory last = data.observations[lastIndex];
        
        // è®¡ç®—TWAP
        uint256 timeDelta = last.timestamp - first.timestamp;
        uint256 priceDelta = last.priceCumulative - first.priceCumulative;
        
        return priceDelta / timeDelta;
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.4 é”šå®šç¨³å®šæ¨¡å—(PSM)ä¸çœŸå®ä¸–ç•Œèµ„äº§(RWA)</h3>
            
            <h4>4.4.1 é”šå®šç¨³å®šæ¨¡å—(PSM)</h4>
            <p>PSMæ˜¯ç°ä»£æŠµæŠ¼ç¨³å®šå¸ç»´æŒä»·æ ¼ç¨³å®šçš„æœ€é‡è¦æœºåˆ¶ä¹‹ä¸€ï¼Œå…è®¸ç”¨æˆ·1:1çš„å›ºå®šæ±‡ç‡å…‘æ¢å…¶ä»–å—ä¿¡ä»»çš„ç¨³å®šå¸ï¼š</p>
            
            <div class="tip-box">
                <strong>ğŸ¯ PSMæ ¸å¿ƒæœºåˆ¶ï¼š</strong>
                <ul>
                    <li><strong>ä»·æ ¼å¥—åˆ©é€šé“ï¼š</strong>å½“DAI > $1æ—¶ï¼Œç”¨æˆ·å¯ä»¥ç”¨USDCé“¸é€ DAIå¹¶å–å‡ºå¥—åˆ©</li>
                    <li><strong>å³æ—¶æµåŠ¨æ€§ï¼š</strong>æä¾›å¤§é‡å³æ—¶å¯ç”¨çš„æµåŠ¨æ€§</li>
                    <li><strong>ä¸­å¿ƒåŒ–é£é™©ï¼š</strong>ä¾èµ–äºUSDCç­‰ä¸­å¿ƒåŒ–ç¨³å®šå¸</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">é”šå®šç¨³å®šæ¨¡å—å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract PegStabilityModule {
    // çŠ¶æ€å˜é‡
    IERC20 public immutable dai;
    IERC20 public immutable usdc;
    IVat public immutable vat;
    
    uint256 public tin;  // å…‘å…¥è´¹ç‡ (swap USDC -> DAI)
    uint256 public tout; // å…‘å‡ºè´¹ç‡ (swap DAI -> USDC)
    
    uint256 public line; // å€ºåŠ¡ä¸Šé™
    uint256 public buf;  // USDCç›®æ ‡ä½™é¢
    
    mapping(address => uint256) public wards;
    
    // å¸¸é‡
    uint256 constant WAD = 10**18;
    uint256 constant RAY = 10**27;
    uint256 constant TOLL_ONE_PCT = RAY / 100;
    
    // äº‹ä»¶
    event BuyGem(address indexed owner, uint256 value, uint256 fee);
    event SellGem(address indexed owner, uint256 value, uint256 fee);
    
    constructor(
        address dai_,
        address usdc_,
        address vat_
    ) {
        dai = IERC20(dai_);
        usdc = IERC20(usdc_);
        vat = IVat(vat_);
        
        // åˆå§‹è´¹ç‡è®¾ç½®ä¸º0.1%
        tin = TOLL_ONE_PCT / 10;
        tout = TOLL_ONE_PCT / 10;
    }
    
    // USDC -> DAI (1:1 - è´¹ç‡)
    function buyGem(address usr, uint256 gemAmt) external {
        require(vat.dai(address(this)) >= gemAmt * RAY, "PSM/insufficient-dai");
        
        uint256 fee = gemAmt * tin / RAY;
        uint256 daiAmt = gemAmt - fee;
        
        // è½¬å…¥USDC
        usdc.transferFrom(msg.sender, address(this), gemAmt);
        
        // ä»Vatä¸­é‡Šæ”¾DAI
        vat.move(address(this), usr, daiAmt * RAY);
        vat.move(address(this), address(vow), fee * RAY); // è´¹ç”¨ç»™åè®®
        
        emit BuyGem(usr, gemAmt, fee);
    }
    
    // DAI -> USDC (1:1 - è´¹ç‡)
    function sellGem(address usr, uint256 daiAmt) external {
        uint256 gemAmt = daiAmt * (RAY - tout) / RAY;
        require(usdc.balanceOf(address(this)) >= gemAmt, "PSM/insufficient-usdc");
        
        // è½¬å…¥DAIåˆ°Vat
        dai.transferFrom(msg.sender, address(this), daiAmt);
        vat.move(msg.sender, address(this), daiAmt * RAY);
        
        // è½¬å‡ºUSDC
        usdc.transfer(usr, gemAmt);
        
        uint256 fee = daiAmt - gemAmt;
        emit SellGem(usr, gemAmt, fee);
    }
    
    // è‡ªåŠ¨è¡¥å……USDCå‚¨å¤‡
    function fill() external returns (uint256 wad) {
        uint256 balance = usdc.balanceOf(address(this));
        
        if (balance < buf) {
            wad = buf - balance;
            require(wad <= line, "PSM/over-line");
            
            // ä»Vaté“¸é€ DAIä»¥è´­ä¹°USDC
            vat.mint(address(this), wad * RAY);
            
            // é€šè¿‡DEXè´­ä¹°USDC
            // ...
        }
    }
    
    // ç´§æ€¥å†»ç»“
    function cage() external auth {
        live = 0;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.4.2 çœŸå®ä¸–ç•Œèµ„äº§(RWA)</h4>
            <p>RWAæ˜¯2023-2024å¹´DeFiæœ€é‡è¦çš„è¶‹åŠ¿ï¼ŒMakerDAOå·²ç»å°†å¤§é‡å›½åº“åˆ¸ã€æˆ¿åœ°äº§è´·æ¬¾ç­‰RWAä½œä¸ºæŠµæŠ¼å“ï¼š</p>
            
            <div class="tip-box">
                <strong>ğŸ¦ RWAå¸¦æ¥çš„æœºé‡ä¸æŒ‘æˆ˜ï¼š</strong>
                <ul>
                    <li><strong>æœºé‡ï¼š</strong>æ›´ç¨³å®šçš„æ”¶ç›Šã€æ›´å¤§çš„èµ„äº§è§„æ¨¡ã€æ›´ä½çš„æ³¢åŠ¨æ€§</li>
                    <li><strong>æŒ‘æˆ˜ï¼š</strong>å¯¹æ‰‹æ–¹é£é™©ã€æ³•å¾‹é£é™©ã€æ‰˜ç®¡é£é™©ã€é“¾ä¸Šè¡¨ç¤ºå¤æ‚æ€§</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">RWAæŠµæŠ¼å“é€‚é…å™¨ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// RWAä»£å¸åŒ–åˆçº¦
contract RWAToken is ERC721, AccessControl {
    struct RealWorldAsset {
        string assetType;      // â€œT-Billâ€, â€œRealEstateâ€, etc
        uint256 maturityDate;  // åˆ°æœŸæ—¥
        uint256 principal;     // æœ¬é‡‘
        uint256 interestRate;  // åˆ©ç‡
        string legalDocs;      // IPFS hash of legal documents
        address custodian;     // æ‰˜ç®¡æœºæ„
        bool isActive;
    }
    
    mapping(uint256 => RealWorldAsset) public assets;
    mapping(address => bool) public trustedOriginators;
    
    // å‘è¡ŒRWAä»£å¸
    function mintRWA(
        address to,
        string memory assetType,
        uint256 maturityDate,
        uint256 principal,
        uint256 interestRate,
        string memory legalDocs
    ) external onlyRole(ORIGINATOR_ROLE) returns (uint256 tokenId) {
        tokenId = _nextTokenId++;
        
        assets[tokenId] = RealWorldAsset({
            assetType: assetType,
            maturityDate: maturityDate,
            principal: principal,
            interestRate: interestRate,
            legalDocs: legalDocs,
            custodian: msg.sender,
            isActive: true
        });
        
        _safeMint(to, tokenId);
        emit RWAMinted(tokenId, assetType, principal);
    }
    
    // è®¡ç®—å½“å‰ä»·å€¼ï¼ˆåŒ…æ‹¬åº”è®¡åˆ©æ¯ï¼‰
    function currentValue(uint256 tokenId) public view returns (uint256) {
        RealWorldAsset memory asset = assets[tokenId];
        require(asset.isActive, "Asset not active");
        
        if (block.timestamp >= asset.maturityDate) {
            return asset.principal;
        }
        
        // ç®€å•çº¿æ€§è®¡æ¯
        uint256 timeElapsed = block.timestamp - _mintTimestamp[tokenId];
        uint256 totalTime = asset.maturityDate - _mintTimestamp[tokenId];
        uint256 earnedInterest = asset.principal * asset.interestRate * timeElapsed / (totalTime * 10000);
        
        return asset.principal + earnedInterest;
    }
}

// RWAæŠµæŠ¼å“é€‚é…å™¨
contract RWACollateralAdapter {
    IVat public immutable vat;
    RWAToken public immutable rwaToken;
    
    mapping(uint256 => address) public ownership; // tokenId => CDP owner
    
    // å°†RWAä½œä¸ºæŠµæŠ¼å“
    function join(address usr, uint256 tokenId) external {
        require(rwaToken.ownerOf(tokenId) == msg.sender, "Not token owner");
        
        // è½¬ç§»ä»£å¸åˆ°é€‚é…å™¨
        rwaToken.transferFrom(msg.sender, address(this), tokenId);
        ownership[tokenId] = usr;
        
        // è·å–ä»£å¸ä»·å€¼
        uint256 value = rwaToken.currentValue(tokenId);
        
        // åœ¨Vatä¸­å¢åŠ æŠµæŠ¼å“
        vat.slip("RWA", usr, int256(value));
    }
    
    // æå–RWA
    function exit(address usr, uint256 tokenId) external {
        require(ownership[tokenId] == usr, "Not owner");
        
        uint256 value = rwaToken.currentValue(tokenId);
        
        // ä»Vatä¸­å‡å°‘æŠµæŠ¼å“
        vat.slip("RWA", usr, -int256(value));
        
        // è¿”è¿˜ä»£å¸
        rwaToken.transferFrom(address(this), usr, tokenId);
        delete ownership[tokenId];
    }
    
    // å®šæœŸæ›´æ–°ä»·å€¼
    function revalue(uint256 tokenId) external {
        address usr = ownership[tokenId];
        require(usr != address(0), "Token not deposited");
        
        uint256 oldValue = vat.gem("RWA", usr);
        uint256 newValue = rwaToken.currentValue(tokenId);
        
        int256 diff = int256(newValue) - int256(oldValue);
        if (diff != 0) {
            vat.slip("RWA", usr, diff);
            emit Revalued(tokenId, oldValue, newValue);
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.5 å®è·µé¡¹ç›®ï¼šæ„å»ºè¶…é¢æŠµæŠ¼ç¨³å®šå¸ç³»ç»Ÿ</h3>
            
            <h4>4.4.1 ç³»ç»Ÿæ¶æ„è®¾è®¡</h4>
            <p>æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªå®Œæ•´çš„è¶…é¢æŠµæŠ¼ç¨³å®šå¸ç³»ç»Ÿï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒç»„ä»¶ï¼š</p>
            
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <pre style="margin: 0; font-family: monospace; line-height: 1.5;">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ·ç•Œé¢                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  CDP Manager                             â”‚
â”‚  - å¼€ä»“/å…³ä»“    - å­˜å…¥/æå–æŠµæŠ¼å“    - é“¸é€ /å¿è¿˜DAI      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   é‡‘åº“å¼•æ“    â”‚   æ¸…ç®—å¼•æ“    â”‚      ç¨³å®šæ¨¡å—            â”‚
â”‚  (Vat.sol)   â”‚  (Dog.sol)   â”‚    (PSM.sol)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  ä»·æ ¼é¢„è¨€æœºç³»ç»Ÿ                           â”‚
â”‚        Chainlink â”‚ Uniswap V3 â”‚ å†…éƒ¨é¢„è¨€æœº              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   æ‹å–ç³»ç»Ÿ                               â”‚
â”‚     æŠµæŠ¼å“æ‹å– â”‚ å€ºåŠ¡æ‹å– â”‚ ç›ˆä½™æ‹å–                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </pre>
            </div>
            
            <h4>4.4.2 å®Œæ•´å®ç°</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">è¶…é¢æŠµæŠ¼ç¨³å®šå¸å®Œæ•´å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// ä¸»é‡‘åº“åˆçº¦
contract Vat {
    // æ ¸å¿ƒæ•°æ®ç»“æ„
    struct Ilk {  // æŠµæŠ¼å“ç±»å‹
        uint256 Art;   // æ€»æ ‡å‡†åŒ–å€ºåŠ¡
        uint256 rate;  // ç´¯ç§¯ç¨³å®šè´¹ç‡
        uint256 spot;  // ä»·æ ¼å®‰å…¨è¾¹é™…
        uint256 line;  // å€ºåŠ¡ä¸Šé™
        uint256 dust;  // æœ€å°å€ºåŠ¡é‡
    }
    
    struct Urn {  // CDP
        uint256 ink;   // é”å®šçš„æŠµæŠ¼å“
        uint256 art;   // æ ‡å‡†åŒ–å€ºåŠ¡
    }
    
    mapping(bytes32 => Ilk) public ilks;
    mapping(bytes32 => mapping(address => Urn)) public urns;
    mapping(address => uint256) public dai;
    mapping(address => uint256) public sin;
    
    uint256 public Line;  // å…¨å±€å€ºåŠ¡ä¸Šé™
    uint256 public live = 1;  // ç³»ç»ŸçŠ¶æ€
    
    // å¸¸é‡
    uint256 constant RAY = 10 ** 27;
    uint256 constant WAD = 10 ** 18;
    
    // æƒé™ç®¡ç†
    mapping(address => uint256) public wards;
    modifier auth() {
        require(wards[msg.sender] == 1, "Vat/not-authorized");
        _;
    }
    
    // åˆå§‹åŒ–æŠµæŠ¼å“ç±»å‹
    function init(bytes32 ilk) external auth {
        require(ilks[ilk].rate == 0, "Vat/ilk-already-init");
        ilks[ilk].rate = RAY;
    }
    
    // ä¿®æ”¹CDP
    function frob(
        bytes32 i,
        address u,
        address v,
        address w,
        int256 dink,
        int256 dart
    ) external {
        require(live == 1, "Vat/not-live");
        
        Urn memory urn = urns[i][u];
        Ilk memory ilk = ilks[i];
        
        urn.ink = _add(urn.ink, dink);
        urn.art = _add(urn.art, dart);
        ilk.Art = _add(ilk.Art, dart);
        
        int256 dtab = _mul(ilk.rate, dart);
        uint256 tab = _mul(ilk.rate, urn.art);
        
        // å€ºåŠ¡ä¸Šé™æ£€æŸ¥
        require(ilk.Art * ilk.rate <= ilk.line, "Vat/ilk-line-exceeded");
        require(Line >= dai[address(this)], "Vat/global-line-exceeded");
        
        // æŠµæŠ¼ç‡æ£€æŸ¥
        require(either(dart <= 0, tab <= _mul(urn.ink, ilk.spot)), "Vat/not-safe");
        
        // æœ€å°å€ºåŠ¡æ£€æŸ¥
        require(either(urn.art == 0, tab >= ilk.dust), "Vat/dust");
        
        // è½¬ç§»æŠµæŠ¼å“
        if (dink != 0) {
            gem[i][v] = _sub(gem[i][v], dink);
            gem[i][w] = _add(gem[i][w], dink);
        }
        
        // è½¬ç§»å€ºåŠ¡
        if (dtab != 0) {
            dai[v] = _sub(dai[v], dtab);
            dai[w] = _add(dai[w], dtab);
        }
        
        urns[i][u] = urn;
        ilks[i] = ilk;
    }
    
    // æ²¡æ”¶CDPï¼ˆæ¸…ç®—æ—¶è°ƒç”¨ï¼‰
    function grab(
        bytes32 i,
        address u,
        address v,
        address w,
        int256 dink,
        int256 dart
    ) external auth {
        Urn storage urn = urns[i][u];
        Ilk storage ilk = ilks[i];
        
        urn.ink = _add(urn.ink, dink);
        urn.art = _add(urn.art, dart);
        ilk.Art = _add(ilk.Art, dart);
        
        int256 dtab = _mul(ilk.rate, dart);
        
        gem[i][v] = _sub(gem[i][v], dink);
        sin[w] = _sub(sin[w], dtab);
    }
}

// DAIä»£å¸åˆçº¦
contract Dai is ERC20 {
    // æ˜ å°„Vatæˆæƒ
    mapping(address => uint256) public wards;
    modifier auth() {
        require(wards[msg.sender] == 1, "Dai/not-authorized");
        _;
    }
    
    constructor() ERC20("Dai Stablecoin", "DAI") {
        wards[msg.sender] = 1;
    }
    
    // ä»Vaté“¸é€ DAI
    function mint(address usr, uint256 wad) external auth {
        _mint(usr, wad);
    }
    
    // é”€æ¯DAIè¿”è¿˜ç»™Vat
    function burn(address usr, uint256 wad) external {
        _burn(usr, wad);
    }
}

// CDPç®¡ç†æ¥å£
contract CDPManager {
    Vat public vat;
    mapping(uint256 => address) public cdps;
    mapping(address => uint256[]) public userCdps;
    uint256 public nextCdpId = 1;
    
    // å¼€å¯CDP
    function openCDP(bytes32 ilk) external returns (uint256 cdpId) {
        cdpId = nextCdpId++;
        cdps[cdpId] = msg.sender;
        userCdps[msg.sender].push(cdpId);
        
        emit CDPOpened(cdpId, msg.sender, ilk);
    }
    
    // å­˜å…¥æŠµæŠ¼å“å¹¶å€Ÿå‡ºDAI
    function lockAndDraw(
        uint256 cdpId,
        uint256 collateralAmount,
        uint256 daiAmount
    ) external {
        require(cdps[cdpId] == msg.sender, "Not CDP owner");
        
        // è½¬å…¥æŠµæŠ¼å“
        collateral.transferFrom(msg.sender, address(this), collateralAmount);
        
        // åœ¨Vatä¸­è®°è´¦
        vat.frob(
            ilk,
            msg.sender,
            address(this),
            msg.sender,
            int256(collateralAmount),
            int256(daiAmount)
        );
        
        // é“¸é€ DAIç»™ç”¨æˆ·
        dai.mint(msg.sender, daiAmount);
    }
    
    // å¿è¿˜DAIå¹¶å–å›æŠµæŠ¼å“
    function wipeAndFree(
        uint256 cdpId,
        uint256 collateralAmount,
        uint256 daiAmount
    ) external {
        require(cdps[cdpId] == msg.sender, "Not CDP owner");
        
        // é”€æ¯DAI
        dai.burn(msg.sender, daiAmount);
        
        // åœ¨Vatä¸­è®°è´¦
        vat.frob(
            ilk,
            msg.sender,
            msg.sender,
            address(this),
            -int256(collateralAmount),
            -int256(daiAmount)
        );
        
        // è¿”è¿˜æŠµæŠ¼å“
        collateral.transfer(msg.sender, collateralAmount);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.4.3 éƒ¨ç½²å’Œæµ‹è¯•è„šæœ¬</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">éƒ¨ç½²è„šæœ¬ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-javascript">const { ethers } = require("hardhat");

async function main() {
    const [deployer] = await ethers.getSigners();
    
    console.log("Deploying contracts with account:", deployer.address);
    
    // 1. éƒ¨ç½²æ ¸å¿ƒåˆçº¦
    const Vat = await ethers.getContractFactory("Vat");
    const vat = await Vat.deploy();
    await vat.deployed();
    console.log("Vat deployed to:", vat.address);
    
    // 2. éƒ¨ç½²DAI
    const Dai = await ethers.getContractFactory("Dai");
    const dai = await Dai.deploy();
    await dai.deployed();
    console.log("DAI deployed to:", dai.address);
    
    // 3. éƒ¨ç½²ä»·æ ¼é¢„è¨€æœº
    const Oracle = await ethers.getContractFactory("PriceOracle");
    const oracle = await Oracle.deploy();
    await oracle.deployed();
    console.log("Oracle deployed to:", oracle.address);
    
    // 4. éƒ¨ç½²æ¸…ç®—å¼•æ“
    const Dog = await ethers.getContractFactory("LiquidationEngine");
    const dog = await Dog.deploy(vat.address);
    await dog.deployed();
    console.log("Dog deployed to:", dog.address);
    
    // 5. éƒ¨ç½²CDPç®¡ç†å™¨
    const CDPManager = await ethers.getContractFactory("CDPManager");
    const cdpManager = await CDPManager.deploy(vat.address, dai.address);
    await cdpManager.deployed();
    console.log("CDPManager deployed to:", cdpManager.address);
    
    // 6. é…ç½®æƒé™
    await vat.rely(dog.address);
    await vat.rely(cdpManager.address);
    await dai.rely(cdpManager.address);
    
    // 7. åˆå§‹åŒ–æŠµæŠ¼å“ç±»å‹ï¼ˆETHï¼‰
    const ethIlk = ethers.utils.formatBytes32String("ETH-A");
    await vat.init(ethIlk);
    
    // è®¾ç½®æŠµæŠ¼å“å‚æ•°
    await vat.file(ethIlk, "line", ethers.utils.parseEther("1000000")); // 100ä¸‡å€ºåŠ¡ä¸Šé™
    await vat.file(ethIlk, "dust", ethers.utils.parseEther("100"));     // æœ€å°100 DAI
    await vat.file(ethIlk, "spot", ethers.utils.parseEther("1.5"));     // 150%æŠµæŠ¼ç‡
    
    // 8. è®¾ç½®é¢„è¨€æœºä»·æ ¼
    await oracle.setPrice(ethIlk, ethers.utils.parseEther("2000")); // ETH = $2000
    
    console.log("Deployment complete!");
    
    // ä¿å­˜éƒ¨ç½²åœ°å€
    const addresses = {
        vat: vat.address,
        dai: dai.address,
        oracle: oracle.address,
        dog: dog.address,
        cdpManager: cdpManager.address
    };
    
    const fs = require("fs");
    fs.writeFileSync(
        "./deployments/addresses.json",
        JSON.stringify(addresses, null, 2)
    );
}

main()
    .then(() => process.exit(0))
    .catch(error => {
        console.error(error);
        process.exit(1);
    });</code></pre>
                </div>
            </div>
            
            <h3>ç»ƒä¹ é¢˜</h3>
            
            <div class="exercise">
                <h4>ç»ƒä¹  4.1ï¼šå®ç°åŠ¨æ€ç¨³å®šè´¹</h4>
                <p>è®¾è®¡å¹¶å®ç°ä¸€ä¸ªåŠ¨æ€è°ƒæ•´ç¨³å®šè´¹çš„æœºåˆ¶ï¼Œæ ¹æ®ä»¥ä¸‹å› ç´ è‡ªåŠ¨è°ƒæ•´ï¼š</p>
                <ul>
                    <li>DAIçš„å¸‚åœºä»·æ ¼åç¦»æƒ…å†µ</li>
                    <li>ç³»ç»Ÿæ€»å€ºåŠ¡é‡</li>
                    <li>æŠµæŠ¼å“ä»·æ ¼æ³¢åŠ¨ç‡</li>
                </ul>
                <p>è¦æ±‚ï¼šä½¿ç”¨PIDæ§åˆ¶å™¨æˆ–å…¶ä»–æ§åˆ¶ç†è®ºæ–¹æ³•ã€‚</p>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ â–¼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract DynamicStabilityFee {
    // PIDæ§åˆ¶å™¨å‚æ•°
    struct PIDController {
        int256 kp;        // æ¯”ä¾‹ç³»æ•°
        int256 ki;        // ç§¯åˆ†ç³»æ•°
        int256 kd;        // å¾®åˆ†ç³»æ•°
        int256 integral;  // ç§¯åˆ†ç´¯ç§¯
        int256 lastError; // ä¸Šæ¬¡è¯¯å·®
    }
    
    PIDController public feeController;
    uint256 public targetPrice = 1e18;  // ç›®æ ‡ä»·æ ¼ $1
    uint256 public baseFee = 2e16;     // åŸºç¡€è´¹ç‡ 2%
    
    // å†å²æ•°æ®
    uint256[] public priceHistory;
    uint256[] public debtHistory;
    uint256 public constant HISTORY_SIZE = 24; // 24å°æ—¶
    
    // æ›´æ–°ç¨³å®šè´¹
    function updateStabilityFee() external {
        // è·å–å½“å‰DAIä»·æ ¼
        uint256 currentPrice = oracle.getDaiPrice();
        
        // è®¡ç®—ä»·æ ¼è¯¯å·®
        int256 error = int256(targetPrice) - int256(currentPrice);
        
        // PIDè®¡ç®—
        int256 proportional = feeController.kp * error / 1e18;
        
        feeController.integral += error;
        int256 integral = feeController.ki * feeController.integral / 1e18;
        
        int256 derivative = feeController.kd * (error - feeController.lastError) / 1e18;
        
        // è®¡ç®—è°ƒæ•´é‡
        int256 adjustment = proportional + integral + derivative;
        
        // è€ƒè™‘å…¶ä»–å› ç´ 
        uint256 volatilityMultiplier = calculateVolatility();
        uint256 debtMultiplier = calculateDebtPressure();
        
        // è®¡ç®—æ–°è´¹ç‡
        uint256 newFee = baseFee;
        if (adjustment > 0) {
            newFee += uint256(adjustment) * volatilityMultiplier / 1e18;
        } else {
            uint256 decrease = uint256(-adjustment) * volatilityMultiplier / 1e18;
            newFee = newFee > decrease ? newFee - decrease : baseFee / 2;
        }
        
        // åº”ç”¨å€ºåŠ¡å‹åŠ›è°ƒæ•´
        newFee = newFee * debtMultiplier / 1e18;
        
        // é™åˆ¶è´¹ç‡èŒƒå›´
        if (newFee < 1e15) newFee = 1e15;       // æœ€ä½0.1%
        if (newFee > 20e16) newFee = 20e16;     // æœ€é«˜20%
        
        // æ›´æ–°è´¹ç‡
        updateIlkStabilityFee(newFee);
        
        feeController.lastError = error;
    }
    
    // è®¡ç®—ä»·æ ¼æ³¢åŠ¨ç‡
    function calculateVolatility() internal view returns (uint256) {
        if (priceHistory.length < 2) return 1e18;
        
        uint256 sum = 0;
        uint256 sumSquared = 0;
        
        for (uint i = 0; i < priceHistory.length; i++) {
            sum += priceHistory[i];
            sumSquared += priceHistory[i] ** 2;
        }
        
        uint256 mean = sum / priceHistory.length;
        uint256 variance = sumSquared / priceHistory.length - mean ** 2;
        uint256 stdDev = sqrt(variance);
        
        // æ³¢åŠ¨ç‡è¶Šé«˜ï¼Œè°ƒæ•´å¹…åº¦è¶Šå°
        return 1e18 * 1e18 / (1e18 + stdDev);
    }
    
    // è®¡ç®—å€ºåŠ¡å‹åŠ›
    function calculateDebtPressure() internal view returns (uint256) {
        uint256 currentDebt = vat.debt();
        uint256 debtCeiling = vat.Line();
        
        uint256 utilization = currentDebt * 1e18 / debtCeiling;
        
        // åˆ©ç”¨ç‡è¶Šé«˜ï¼Œè´¹ç‡è¶Šé«˜
        if (utilization > 80e16) {  // > 80%
            return 15e17;  // 1.5x
        } else if (utilization > 60e16) {  // > 60%
            return 12e17;  // 1.2x
        } else {
            return 1e18;   // 1x
        }
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>ç»ƒä¹  4.2ï¼šå®ç°é—ªç”µæ¸…ç®—</h4>
                <p>è®¾è®¡ä¸€ä¸ªé—ªç”µæ¸…ç®—ï¼ˆFlash Liquidationï¼‰æœºåˆ¶ï¼Œå…è®¸æ¸…ç®—è€…åœ¨å•ç¬”äº¤æ˜“ä¸­ï¼š</p>
                <ul>
                    <li>å€Ÿå…¥DAIè¿›è¡Œæ¸…ç®—</li>
                    <li>è·å¾—æŠ˜ä»·æŠµæŠ¼å“</li>
                    <li>åœ¨DEXä¸Šå–å‡ºæŠµæŠ¼å“</li>
                    <li>å¿è¿˜å€Ÿå…¥çš„DAIå¹¶è·åˆ©</li>
                </ul>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ â–¼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract FlashLiquidator {
    IVat public vat;
    IDog public dog;
    IERC20 public dai;
    IUniswapV2Router public router;
    
    // é—ªç”µæ¸…ç®—
    function flashLiquidate(
        bytes32 ilk,
        address urn,
        address[] calldata swapPath
    ) external {
        // 1. æ£€æŸ¥CDPæ˜¯å¦å¯æ¸…ç®—
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        (, uint256 rate, uint256 spot,,) = vat.ilks(ilk);
        
        require(ink * spot < art * rate, "CDP is safe");
        
        // 2. è®¡ç®—éœ€è¦çš„DAI
        uint256 dartNeeded = art;
        uint256 daiNeeded = dartNeeded * rate / RAY;
        
        // 3. é—ªç”µè´·DAI
        dai.flashLoan(address(this), daiNeeded, "");
    }
    
    // é—ªç”µè´·å›è°ƒ
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        require(msg.sender == address(dai), "Unknown lender");
        require(initiator == address(this), "Unknown initiator");
        
        (bytes32 ilk, address urn, address[] memory swapPath) = 
            abi.decode(data, (bytes32, address, address[]));
        
        // 4. æ‰§è¡Œæ¸…ç®—
        uint256 collateralReceived = dog.bark(ilk, urn);
        
        // 5. åœ¨DEXå–å‡ºæŠµæŠ¼å“
        IERC20(swapPath[0]).approve(address(router), collateralReceived);
        
        uint256[] memory amounts = router.swapExactTokensForTokens(
            collateralReceived,
            amount + fee,  // è‡³å°‘è¦æ¢å›è´·æ¬¾+æ‰‹ç»­è´¹
            swapPath,
            address(this),
            block.timestamp
        );
        
        uint256 daiReceived = amounts[amounts.length - 1];
        require(daiReceived >= amount + fee, "Insufficient profit");
        
        // 6. å¿è¿˜é—ªç”µè´·
        dai.approve(msg.sender, amount + fee);
        
        // 7. è½¬ç§»åˆ©æ¶¦
        uint256 profit = daiReceived - amount - fee;
        dai.transfer(tx.origin, profit);
        
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    
    // è®¡ç®—æ¸…ç®—åˆ©æ¶¦
    function calculateProfit(
        bytes32 ilk,
        address urn,
        address[] calldata swapPath
    ) external view returns (uint256) {
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        (, uint256 rate,,,) = vat.ilks(ilk);
        
        uint256 daiNeeded = art * rate / RAY;
        uint256 collateralReceived = ink;  // ç®€åŒ–ï¼Œå®é™…æœ‰ç½šé‡‘
        
        // è·å–DEXæŠ¥ä»·
        uint256[] memory amounts = router.getAmountsOut(
            collateralReceived,
            swapPath
        );
        uint256 daiFromSwap = amounts[amounts.length - 1];
        
        // æ‰£é™¤é—ªç”µè´·è´¹ç”¨ï¼ˆå‡è®¾0.09%ï¼‰
        uint256 flashFee = daiNeeded * 9 / 10000;
        
        if (daiFromSwap > daiNeeded + flashFee) {
            return daiFromSwap - daiNeeded - flashFee;
        }
        return 0;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>ç»ƒä¹  4.3ï¼šå®ç°å¤šæŠµæŠ¼å“ç»„åˆ</h4>
                <p>æ‰©å±•CDPç³»ç»Ÿæ”¯æŒå¤šç§æŠµæŠ¼å“ç»„åˆåœ¨åŒä¸€ä¸ªCDPä¸­ï¼Œè¦æ±‚ï¼š</p>
                <ul>
                    <li>æ”¯æŒä¸åŒæƒé‡çš„æŠµæŠ¼å“</li>
                    <li>å®ç°ç»„åˆæŠµæŠ¼ç‡è®¡ç®—</li>
                    <li>æ”¯æŒéƒ¨åˆ†æ¸…ç®—ä¸åŒæŠµæŠ¼å“</li>
                    <li>è€ƒè™‘æŠµæŠ¼å“ä¹‹é—´çš„ç›¸å…³æ€§</li>
                </ul>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ â–¼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract MultiCollateralCDP {
    struct CollateralPosition {
        uint256 amount;
        uint256 weight;      // æƒé‡ï¼ˆåŸºç‚¹ï¼‰
        uint256 lastPrice;   // ä¸Šæ¬¡ä»·æ ¼
    }
    
    struct MultiCDP {
        mapping(bytes32 => CollateralPosition) collaterals;
        uint256 totalDebt;
        uint256 lastUpdateTime;
        bytes32[] collateralTypes;
    }
    
    mapping(address => mapping(uint256 => MultiCDP)) public cdps;
    mapping(bytes32 => mapping(bytes32 => uint256)) public correlations; // ç›¸å…³æ€§çŸ©é˜µ
    
    // æ·»åŠ æŠµæŠ¼å“åˆ°CDP
    function addCollateral(
        uint256 cdpId,
        bytes32 ilk,
        uint256 amount
    ) external {
        MultiCDP storage cdp = cdps[msg.sender][cdpId];
        
        // è½¬å…¥æŠµæŠ¼å“
        IERC20(collateralTokens[ilk]).transferFrom(
            msg.sender,
            address(this),
            amount
        );
        
        // æ›´æ–°ä»“ä½
        if (cdp.collaterals[ilk].amount == 0) {
            cdp.collateralTypes.push(ilk);
        }
        
        cdp.collaterals[ilk].amount += amount;
        cdp.collaterals[ilk].lastPrice = getPrice(ilk);
        
        // é‡æ–°è®¡ç®—æƒé‡
        _updateWeights(cdpId);
    }
    
    // è®¡ç®—ç»„åˆæŠµæŠ¼ç‡ï¼ˆè€ƒè™‘ç›¸å…³æ€§ï¼‰
    function getPortfolioCollateralization(uint256 cdpId) 
        external 
        view 
        returns (uint256 ratio, uint256 var) 
    {
        MultiCDP storage cdp = cdps[msg.sender][cdpId];
        
        uint256 totalValue = 0;
        uint256 portfolioVariance = 0;
        
        // è®¡ç®—æ€»ä»·å€¼å’Œæ–¹å·®
        for (uint i = 0; i < cdp.collateralTypes.length; i++) {
            bytes32 ilk1 = cdp.collateralTypes[i];
            CollateralPosition memory pos1 = cdp.collaterals[ilk1];
            uint256 value1 = pos1.amount * getPrice(ilk1) / 1e18;
            totalValue += value1;
            
            // è®¡ç®—æ–¹å·®è´¡çŒ®
            uint256 vol1 = getVolatility(ilk1);
            portfolioVariance += (pos1.weight ** 2) * (vol1 ** 2) / 1e36;
            
            // è®¡ç®—åæ–¹å·®è´¡çŒ®
            for (uint j = i + 1; j < cdp.collateralTypes.length; j++) {
                bytes32 ilk2 = cdp.collateralTypes[j];
                CollateralPosition memory pos2 = cdp.collaterals[ilk2];
                uint256 vol2 = getVolatility(ilk2);
                uint256 corr = correlations[ilk1][ilk2];
                
                portfolioVariance += 2 * pos1.weight * pos2.weight * 
                                   vol1 * vol2 * corr / 1e54;
            }
        }
        
        // è®¡ç®—VaRè°ƒæ•´åçš„æŠµæŠ¼ç‡
        uint256 portfolioVol = sqrt(portfolioVariance);
        uint256 varAdjustedValue = totalValue * (1e18 - 2 * portfolioVol) / 1e18;
        
        if (cdp.totalDebt > 0) {
            ratio = varAdjustedValue * 100 / cdp.totalDebt;
        } else {
            ratio = type(uint256).max;
        }
        
        var = portfolioVol;
    }
    
    // éƒ¨åˆ†æ¸…ç®—
    function partialLiquidate(
        address owner,
        uint256 cdpId,
        bytes32 ilkToLiquidate,
        uint256 debtToRepay
    ) external {
        MultiCDP storage cdp = cdps[owner][cdpId];
        
        // æ£€æŸ¥æ˜¯å¦å¯æ¸…ç®—
        (uint256 ratio,) = getPortfolioCollateralization(cdpId);
        require(ratio < liquidationRatio, "CDP is safe");
        
        // è®¡ç®—è¦æ¸…ç®—çš„æŠµæŠ¼å“æ•°é‡
        uint256 price = getPrice(ilkToLiquidate);
        uint256 collateralNeeded = debtToRepay * 1e18 * 
                                  (100 + liquidationPenalty) / (price * 100);
        
        require(cdp.collaterals[ilkToLiquidate].amount >= collateralNeeded,
                "Insufficient collateral");
        
        // æ‰§è¡Œæ¸…ç®—
        dai.transferFrom(msg.sender, address(this), debtToRepay);
        cdp.totalDebt -= debtToRepay;
        
        cdp.collaterals[ilkToLiquidate].amount -= collateralNeeded;
        IERC20(collateralTokens[ilkToLiquidate]).transfer(
            msg.sender,
            collateralNeeded
        );
        
        // å¦‚æœæŠµæŠ¼å“æ¸…ç©ºï¼Œä»åˆ—è¡¨ä¸­ç§»é™¤
        if (cdp.collaterals[ilkToLiquidate].amount == 0) {
            _removeCollateralType(cdp, ilkToLiquidate);
        }
        
        // é‡æ–°è®¡ç®—æƒé‡
        _updateWeights(cdpId);
    }
    
    // æ›´æ–°æƒé‡
    function _updateWeights(uint256 cdpId) internal {
        MultiCDP storage cdp = cdps[msg.sender][cdpId];
        uint256 totalValue = 0;
        
        // è®¡ç®—æ€»ä»·å€¼
        for (uint i = 0; i < cdp.collateralTypes.length; i++) {
            bytes32 ilk = cdp.collateralTypes[i];
            uint256 value = cdp.collaterals[ilk].amount * getPrice(ilk) / 1e18;
            totalValue += value;
        }
        
        // æ›´æ–°æƒé‡
        for (uint i = 0; i < cdp.collateralTypes.length; i++) {
            bytes32 ilk = cdp.collateralTypes[i];
            uint256 value = cdp.collaterals[ilk].amount * getPrice(ilk) / 1e18;
            cdp.collaterals[ilk].weight = value * 10000 / totalValue;
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.6 æ¡ˆä¾‹ç ”ç©¶ï¼š2020å¹´3æœˆé»‘è‰²æ˜ŸæœŸå››</h3>
            
            <div class="tip-box">
                <strong>ğŸ“‰ äº‹ä»¶å›é¡¾ï¼š</strong>
                <p>2020å¹´3æœˆ12-13æ—¥ï¼ŒåŠ å¯†å¸‚åœºç»å†äº†å†å²ä¸Šæœ€å‰§çƒˆçš„ä»·æ ¼æš´è·Œï¼š</p>
                <ul>
                    <li>ETHä»·æ ¼åœ¨24å°æ—¶å†…ä»$194è·Œè‡³$87ï¼Œè·Œå¹…è¶…è¿‡50%</li>
                    <li>Gasä»·æ ¼é£™å‡è‡³æ­£å¸¸æ°´å¹³çš„100å€ä»¥ä¸Š</li>
                    <li>MakerDAOç³»ç»Ÿå‡ºç°$0ç«ä»·æ¸…ç®—ï¼Œé€ æˆ$5.67MæŸå¤±</li>
                    <li>DAIä¸€åº¦è„±é”šè‡³$1.12</li>
                </ul>
            </div>
            
            <h4>4.6.1 é—®é¢˜åˆ†æ</h4>
            <table class="comparison-table">
                <tr>
                    <th>é—®é¢˜ç±»å‹</th>
                    <th>å…·ä½“è¡¨ç°</th>
                    <th>æ ¹æœ¬åŸå› </th>
                    <th>æ”¹è¿›æªæ–½</th>
                </tr>
                <tr>
                    <td>é¢„è¨€æœºå»¶è¿Ÿ</td>
                    <td>ä»·æ ¼æ›´æ–°ä¸¥é‡æ»å</td>
                    <td>Gasä»·æ ¼è¿‡é«˜ï¼Œé¢„è¨€æœºæ— æ³•æ›´æ–°</td>
                    <td>å¼•å…¥OSM 1å°æ—¶å»¶è¿Ÿ</td>
                </tr>
                <tr>
                    <td>Keeperå¤±æ•ˆ</td>
                    <td>$0ç«ä»·æˆåŠŸ</td>
                    <td>Keeperæœºå™¨äººé…ç½®ä¸å½“</td>
                    <td>Liquidation 2.0</td>
                </tr>
                <tr>
                    <td>æ‹å–æœºåˆ¶ç¼ºé™·</td>
                    <td>å¤§é‡æŠµæŠ¼å“è¢«ä½ä»·æ‹å–</td>
                    <td>æ‹å–æ—¶é—´è¿‡é•¿ï¼Œå¸‚åœºå˜åŒ–å¤ªå¿«</td>
                    <td>å›ºå®šæŠ˜æ‰£å³æ—¶æ¸…ç®—</td>
                </tr>
                <tr>
                    <td>ç³»ç»Ÿåè´¦</td>
                    <td>$5.67Måè´¦</td>
                    <td>æ¸…ç®—æ”¶å…¥ä¸è¶³ä»¥è¦†ç›–å€ºåŠ¡</td>
                    <td>å€ºåŠ¡æ‹å–+ç´§æ€¥å…³åœ</td>
                </tr>
            </table>
            
            <h4>4.6.2 æ•™è®­ä¸æ”¹è¿›</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">æ”¹è¿›åçš„æ¸…ç®—ç³»ç»Ÿ (Liquidation 2.0) <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// Liquidation 2.0 æ ¸å¿ƒæ”¹è¿›
contract LiquidationEngine2 {
    // ä¸»è¦æ”¹è¿›ç‚¹ï¼š
    // 1. å›ºå®šæŠ˜æ‰£ä»·æ ¼è€Œéæ‹å–
    // 2. å³æ—¶æ¸…ç®—ï¼Œæ— éœ€ç­‰å¾…
    // 3. éƒ¨åˆ†æ¸…ç®—æ”¯æŒ
    // 4. æ›´å¥½çš„Keeperæ¿€åŠ±
    
    struct LiquidationConfig {
        uint256 discount;        // æ¸…ç®—æŠ˜æ‰£ (e.g., 5%)
        uint256 maxAuction;      // å•æ¬¡æœ€å¤§æ¸…ç®—é‡
        uint256 tip;             // Keeperå°è´¹
        uint256 chip;            // æ¯å•ä½æŠµæŠ¼å“å¥–åŠ±
        uint256 hole;            // æ€»æ¸…ç®—é™é¢
    }
    
    // å³æ—¶æ¸…ç®—å‡½æ•°
    function bark(
        bytes32 ilk,
        address urn,
        address kpr  // keeperåœ°å€
    ) external returns (uint256 id) {
        // æ£€æŸ¥CDPæ˜¯å¦å¯æ¸…ç®—
        require(unsafe(ilk, urn), "CDP is safe");
        
        // è®¡ç®—æ¸…ç®—å‚æ•°
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        uint256 dart = min(art, config.maxAuction);
        uint256 dink = ink * dart / art;
        
        // åˆ›å»ºæ¸…ç®—æ‹å–
        id = auctions.length++;
        auctions[id] = Auction({
            urn: urn,
            ink: dink,
            art: dart,
            usr: address(0),
            tic: 0,
            top: 0
        });
        
        // å³æ—¶å¥–åŠ±keeper
        uint256 reward = config.tip + (dink * config.chip);
        vat.mint(kpr, reward);
        
        emit Bark(ilk, urn, ink, art, dart, config.clip, id);
    }
    
    // æ‹å–å‚ä¸ (å›ºå®šæŠ˜æ‰£)
    function take(
        uint256 id,
        uint256 amt,  // æƒ³è¦çš„æŠµæŠ¼å“æ•°é‡
        uint256 max,  // æ„¿æ„æ”¯ä»˜çš„æœ€å¤§DAI
        address who,  // æ¥æ”¶åœ°å€
        bytes calldata data
    ) external {
        Auction storage auction = auctions[id];
        
        // è®¡ç®—ä»·æ ¼ (å¸‚åœºä»· * (1 - æŠ˜æ‰£))
        uint256 price = oracle.price(ilk) * (100 - config.discount) / 100;
        
        // è®¡ç®—å®é™…æ•°é‡
        uint256 slice = min(auction.ink, amt);
        uint256 owe = slice * price;
        
        require(owe <= max, "Price too high");
        require(owe <= auction.art, "Insufficient debt");
        
        // æ‰§è¡Œæ¸…ç®—
        auction.ink -= slice;
        auction.art -= owe;
        
        // è½¬ç§»èµ„äº§
        vat.flux(ilk, address(this), who, slice);
        vat.move(msg.sender, vow, owe);
        
        // å¦‚æœå®Œå…¨æ¸…ç®—ï¼Œè¿”è¿˜å‰©ä½™æŠµæŠ¼å“
        if (auction.art == 0 && auction.ink > 0) {
            vat.flux(ilk, address(this), auction.usr, auction.ink);
            auction.ink = 0;
        }
        
        emit Take(id, slice, owe, price);
    }
}</code></pre>
                </div>
            </div>
            
            <div class="practice-section">
                <h3>ğŸ“ ç¬¬å››ç« ç»ƒä¹ é¢˜</h3>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  4.1ï¼šå®ç°å±€éƒ¨æ¸…ç®—æœºåˆ¶</h4>
                    <p>è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ”¯æŒå±€éƒ¨æ¸…ç®—çš„CDPç³»ç»Ÿï¼Œå…è®¸ç”¨æˆ·é€šè¿‡éƒ¨åˆ†å¿è¿˜å€ºåŠ¡æ¥é¿å…å…¨éƒ¨æ¸…ç®—ã€‚</p>
                    <p>è¦æ±‚ï¼š</p>
                    <ul>
                        <li>æ”¯æŒæŒ‰æ¯”ä¾‹æ¸…ç®—éƒ¨åˆ†æŠµæŠ¼å“</li>
                        <li>ä¿ç•™æœ€ä½å¥åº·å› å­ä»¥ä¸Šçš„éƒ¨åˆ†</li>
                        <li>å®ç°å…¬å¹³çš„å¥–åŠ±æœºåˆ¶</li>
                        <li>é˜²æ­¢æ¶æ„å°é¢æ¸…ç®—æ”»å‡»</li>
                    </ul>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <pre><code class="language-solidity">contract PartialLiquidation {
    uint256 constant MIN_PARTIAL_LIQUIDATION = 1000 * 1e18; // æœ€å°æ¸…ç®—é‡‘é¢
    uint256 constant TARGET_HEALTH_FACTOR = 150; // ç›®æ ‡å¥åº·å› å­150%
    
    struct PartialLiquidationParams {
        uint256 maxLiquidationRatio; // æœ€å¤§æ¸…ç®—æ¯”ä¾‹ (50%)
        uint256 minHealthFactor;     // æœ€ä½ä¿ç•™å¥åº·å› å­
        uint256 liquidatorBonus;     // æ¸…ç®—å¥–åŠ± (5%)
        uint256 protocolFee;         // åè®®è´¹ç”¨ (1%)
    }
    
    function partialLiquidate(
        address user,
        bytes32 ilk,
        uint256 debtToRepay
    ) external {
        CDP storage cdp = cdps[ilk][user];
        require(getHealthFactor(ilk, user) < 100, "CDP is healthy");
        
        // è®¡ç®—æœ€å¤§å¯æ¸…ç®—é‡‘é¢
        uint256 maxLiquidation = cdp.debt * params.maxLiquidationRatio / 100;
        uint256 actualLiquidation = min(debtToRepay, maxLiquidation);
        
        // ç¡®ä¿æ»¡è¶³æœ€å°æ¸…ç®—é‡‘é¢
        require(actualLiquidation >= MIN_PARTIAL_LIQUIDATION, "Too small");
        
        // è®¡ç®—éœ€è¦çš„æŠµæŠ¼å“
        uint256 collateralPrice = getPrice(ilk);
        uint256 collateralNeeded = actualLiquidation * 1e18 / collateralPrice;
        uint256 liquidatorBonus = collateralNeeded * params.liquidatorBonus / 100;
        uint256 protocolFee = collateralNeeded * params.protocolFee / 100;
        
        uint256 totalCollateral = collateralNeeded + liquidatorBonus + protocolFee;
        require(cdp.collateral >= totalCollateral, "Insufficient collateral");
        
        // æ£€æŸ¥å‰©ä½™å¥åº·å› å­
        uint256 remainingCollateral = cdp.collateral - totalCollateral;
        uint256 remainingDebt = cdp.debt - actualLiquidation;
        uint256 remainingHealthFactor = (remainingCollateral * collateralPrice * 100) / (remainingDebt * 1e18);
        
        require(remainingHealthFactor >= params.minHealthFactor, "Would leave CDP too unhealthy");
        
        // æ‰§è¡Œæ¸…ç®—
        dai.transferFrom(msg.sender, address(this), actualLiquidation);
        cdp.debt -= actualLiquidation;
        
        cdp.collateral -= totalCollateral;
        collateralToken.transfer(msg.sender, collateralNeeded + liquidatorBonus);
        collateralToken.transfer(treasury, protocolFee);
        
        emit PartialLiquidation(user, ilk, actualLiquidation, totalCollateral);
    }
    
    // è‡ªåŠ¨è®¡ç®—æœ€ä½³æ¸…ç®—é‡
    function calculateOptimalLiquidation(
        address user,
        bytes32 ilk
    ) public view returns (uint256 optimalAmount) {
        CDP memory cdp = cdps[ilk][user];
        uint256 currentHealthFactor = getHealthFactor(ilk, user);
        
        if (currentHealthFactor >= 100) return 0;
        
        // è®¡ç®—è¾¾åˆ°ç›®æ ‡å¥åº·å› å­æ‰€éœ€çš„æ¸…ç®—é‡
        uint256 collateralPrice = getPrice(ilk);
        uint256 collateralValue = cdp.collateral * collateralPrice / 1e18;
        
        // ç›®æ ‡: (collateralValue - liquidationValue) / (debt - liquidationAmount) = 1.5
        // æ±‚è§£ liquidationAmount
        uint256 targetDebt = collateralValue * 100 / TARGET_HEALTH_FACTOR;
        optimalAmount = cdp.debt - targetDebt;
        
        // åº”ç”¨é™åˆ¶
        optimalAmount = min(optimalAmount, cdp.debt * params.maxLiquidationRatio / 100);
        optimalAmount = max(optimalAmount, MIN_PARTIAL_LIQUIDATION);
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  4.2ï¼šè®¾è®¡æŠ—MEVçš„æ¸…ç®—ç³»ç»Ÿ</h4>
                    <p>è®¾è®¡ä¸€ä¸ªèƒ½å¤ŸæŠµæŠ—MEVæ”»å‡»çš„æ¸…ç®—ç³»ç»Ÿï¼Œä¿æŠ¤è¢«æ¸…ç®—ç”¨æˆ·å’Œè¯šå®Keeperçš„åˆ©ç›Šã€‚</p>
                    <p>è¦æ±‚ï¼š</p>
                    <ul>
                        <li>é˜²æ­¢æŠ¢è·‘å’Œä¸‰æ˜æ²»æ”»å‡»</li>
                        <li>ä¿æŠ¤éšç§å’Œå…¬å¹³æ€§</li>
                        <li>ä¿æŒç³»ç»Ÿæ•ˆç‡</li>
                        <li>å®ç°å»ä¸­å¿ƒåŒ–</li>
                    </ul>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <pre><code class="language-solidity">contract MEVResistantLiquidation {
    using ECDSA for bytes32;
    
    // æ—¶é—´åŠ æƒç«æ‹
    struct TimeLockAuction {
        uint256 startTime;
        uint256 commitDeadline;
        uint256 revealDeadline;
        mapping(address => bytes32) commitments;
        mapping(address => Bid) bids;
        uint256 highestBid;
        address winner;
    }
    
    struct Bid {
        uint256 amount;
        uint256 nonce;
        bool revealed;
    }
    
    // VDF (å¯éªŒè¯å»¶è¿Ÿå‡½æ•°) å‚æ•°
    uint256 constant VDF_DIFFICULTY = 1000000;
    
    // æ‰¹é‡æ¸…ç®—æ± 
    struct LiquidationBatch {
        uint256 startBlock;
        uint256 endBlock;
        address[] liquidatableUsers;
        mapping(address => uint256) liquidatorScores;
        bool settled;
    }
    
    // æäº¤åŠ å¯†ç«ä»·
    function commitBid(
        uint256 auctionId,
        bytes32 commitment
    ) external {
        TimeLockAuction storage auction = auctions[auctionId];
        require(block.timestamp < auction.commitDeadline, "Commit phase ended");
        
        auction.commitments[msg.sender] = commitment;
        emit BidCommitted(auctionId, msg.sender);
    }
    
    // æ­ç¤ºç«ä»· (ä½¿ç”¨VDFå»¶è¿Ÿ)
    function revealBid(
        uint256 auctionId,
        uint256 bidAmount,
        uint256 nonce,
        uint256 vdfOutput,
        bytes memory vdfProof
    ) external {
        TimeLockAuction storage auction = auctions[auctionId];
        require(block.timestamp >= auction.commitDeadline, "Still in commit phase");
        require(block.timestamp < auction.revealDeadline, "Reveal phase ended");
        
        // éªŒè¯commitment
        bytes32 commitment = keccak256(abi.encodePacked(bidAmount, nonce, msg.sender));
        require(auction.commitments[msg.sender] == commitment, "Invalid reveal");
        
        // éªŒè¯VDF
        require(verifyVDF(commitment, vdfOutput, vdfProof, VDF_DIFFICULTY), "Invalid VDF");
        
        // è®°å½•ç«ä»·
        auction.bids[msg.sender] = Bid({
            amount: bidAmount,
            nonce: nonce,
            revealed: true
        });
        
        if (bidAmount > auction.highestBid) {
            auction.highestBid = bidAmount;
            auction.winner = msg.sender;
        }
    }
    
    // æ‰¹é‡æ¸…ç®—å¤„ç†
    function processBatchLiquidation(
        uint256 batchId
    ) external {
        LiquidationBatch storage batch = batches[batchId];
        require(block.number >= batch.endBlock, "Batch not ended");
        require(!batch.settled, "Already settled");
        
        // ä½¿ç”¨åŠ æƒéšæœºé€‰æ‹©
        uint256 seed = uint256(keccak256(abi.encode(block.timestamp, block.difficulty)));
        
        // æŒ‰ç…§è¯„åˆ†åŠ æƒåˆ†é…æ¸…ç®—æœºä¼š
        for (uint i = 0; i < batch.liquidatableUsers.length; i++) {
            address user = batch.liquidatableUsers[i];
            address selectedLiquidator = selectWeightedRandom(batch, seed + i);
            
            // æ‰§è¡Œæ¸…ç®—
            performLiquidation(user, selectedLiquidator);
        }
        
        batch.settled = true;
    }
    
    // ç§å¯†æ¸…ç®—æ± 
    function submitPrivateLiquidation(
        bytes calldata encryptedData,
        bytes calldata zkProof
    ) external {
        // éªŒè¯é›¶çŸ¥è¯†è¯æ˜
        require(verifyZKProof(zkProof), "Invalid proof");
        
        // å­˜å‚¨åŠ å¯†æ•°æ®ï¼Œç­‰å¾…æ‰¹é‡å¤„ç†
        privateLiquidations.push(encryptedData);
        
        // å½“è¾¾åˆ°é˜ˆå€¼æ—¶è§¦å‘æ‰¹å¤„ç†
        if (privateLiquidations.length >= BATCH_SIZE) {
            processPrivateBatch();
        }
    }
    
    // å£°èª‰ç³»ç»Ÿ
    mapping(address => uint256) public keeperReputation;
    
    function updateReputation(address keeper, bool success) internal {
        if (success) {
            keeperReputation[keeper] += 10;
        } else {
            keeperReputation[keeper] = keeperReputation[keeper] * 90 / 100; // -10%
        }
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  4.3ï¼šå®ç°åŠ¨æ€ç¨³å®šè´¹ç‡</h4>
                    <p>è®¾è®¡ä¸€ä¸ªåŸºäºPIDæ§åˆ¶å™¨çš„åŠ¨æ€ç¨³å®šè´¹ç‡ç³»ç»Ÿï¼Œæ ¹æ®ç¨³å®šå¸çš„å¸‚åœºä»·æ ¼è‡ªåŠ¨è°ƒæ•´åˆ©ç‡ã€‚</p>
                    <p>è¦æ±‚ï¼š</p>
                    <ul>
                        <li>å®ç°PIDæ§åˆ¶å™¨é€»è¾‘</li>
                        <li>è€ƒè™‘å¸‚åœºä¾›éœ€å…³ç³»</li>
                        <li>è®¾ç½®åˆç†çš„å‚æ•°èŒƒå›´</li>
                        <li>å¹³æ»‘è°ƒæ•´é¿å…éœ‡è¡</li>
                    </ul>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <pre><code class="language-solidity">contract DynamicStabilityFee {
    // PIDæ§åˆ¶å™¨å‚æ•°
    struct PIDController {
        int256 kp;        // æ¯”ä¾‹ç³»æ•°
        int256 ki;        // ç§¯åˆ†ç³»æ•°
        int256 kd;        // å¾®åˆ†ç³»æ•°
        int256 integral;  // ç§¯åˆ†ç´¯ç§¯
        int256 lastError; // ä¸Šæ¬¡è¯¯å·®
    }
    
    // ç³»ç»Ÿå‚æ•°
    uint256 constant TARGET_PRICE = 1e18;  // $1
    uint256 constant UPDATE_INTERVAL = 1 hours;
    uint256 constant MAX_FEE = 20e16;     // 20% APR
    uint256 constant MIN_FEE = 0;          // 0% APR
    uint256 constant SMOOTHING_FACTOR = 10; // å¹³æ»‘å› å­
    
    PIDController public controller = PIDController({
        kp: 1e15,  // 0.001
        ki: 1e14,  // 0.0001
        kd: 1e13,  // 0.00001
        integral: 0,
        lastError: 0
    });
    
    uint256 public currentFee;
    uint256 public lastUpdateTime;
    
    // ä»·æ ¼å†å²è®°å½•
    uint256[] public priceHistory;
    uint256 constant HISTORY_SIZE = 24; // 24å°æ—¶
    
    // æ›´æ–°ç¨³å®šè´¹ç‡
    function updateStabilityFee() external {
        require(block.timestamp >= lastUpdateTime + UPDATE_INTERVAL, "Too soon");
        
        // è·å–å½“å‰å¸‚åœºä»·æ ¼
        uint256 currentPrice = getMarketPrice();
        
        // è®°å½•ä»·æ ¼å†å²
        priceHistory.push(currentPrice);
        if (priceHistory.length > HISTORY_SIZE) {
            for (uint i = 0; i < priceHistory.length - 1; i++) {
                priceHistory[i] = priceHistory[i + 1];
            }
            priceHistory.pop();
        }
        
        // è®¡ç®—PIDè¾“å‡º
        int256 newFee = calculatePID(currentPrice);
        
        // åº”ç”¨å¹³æ»‘
        uint256 smoothedFee = applySmooting(uint256(newFee));
        
        // åº”ç”¨é™åˆ¶
        currentFee = bound(smoothedFee, MIN_FEE, MAX_FEE);
        
        // æ›´æ–°æ‰€æœ‰CDPçš„ç´¯ç§¯åˆ©ç‡
        updateAccumulatedRates();
        
        lastUpdateTime = block.timestamp;
        emit FeeUpdated(currentFee, currentPrice);
    }
    
    // PIDè®¡ç®—
    function calculatePID(uint256 currentPrice) internal returns (int256) {
        // è®¡ç®—è¯¯å·® (price - target)
        int256 error = int256(currentPrice) - int256(TARGET_PRICE);
        
        // Pé¡¹
        int256 p = controller.kp * error / 1e18;
        
        // Ié¡¹
        controller.integral += error;
        // é˜²æ­¢ç§¯åˆ†é¥±å’Œ
        controller.integral = bound(controller.integral, -1e20, 1e20);
        int256 i = controller.ki * controller.integral / 1e18;
        
        // Dé¡¹
        int256 d = controller.kd * (error - controller.lastError) / 1e18;
        controller.lastError = error;
        
        // PIDæ€»è¾“å‡º
        return p + i + d;
    }
    
    // å¹³æ»‘å¤„ç†
    function applySmooting(uint256 newFee) internal view returns (uint256) {
        // ä½¿ç”¨æŒ‡æ•°ç§»åŠ¨å¹³å‡
        uint256 smoothed = (currentFee * (SMOOTHING_FACTOR - 1) + newFee) / SMOOTHING_FACTOR;
        
        // é™åˆ¶å•æ¬¡è°ƒæ•´å¹…åº¦
        uint256 maxChange = currentFee / 10; // æœ€å¤š10%å˜åŒ–
        if (smoothed > currentFee + maxChange) {
            return currentFee + maxChange;
        } else if (smoothed < currentFee - maxChange) {
            return currentFee - maxChange;
        }
        
        return smoothed;
    }
    
    // è€ƒè™‘ä¾›éœ€å…³ç³»
    function getMarketPrice() internal view returns (uint256) {
        // ç»¼åˆå¤šä¸ªæ•°æ®æº
        uint256 dexPrice = getDEXPrice();
        uint256 cexPrice = getCEXPrice();
        uint256 twapPrice = getTWAPPrice();
        
        // åŠ æƒå¹³å‡
        return (dexPrice * 5 + cexPrice * 3 + twapPrice * 2) / 10;
    }
    
    // è·å–å†å²æ³¢åŠ¨æ€§
    function getVolatility() public view returns (uint256) {
        if (priceHistory.length < 2) return 0;
        
        uint256 sum = 0;
        uint256 mean = 0;
        
        // è®¡ç®—å‡å€¼
        for (uint i = 0; i < priceHistory.length; i++) {
            mean += priceHistory[i];
        }
        mean /= priceHistory.length;
        
        // è®¡ç®—æ ‡å‡†å·®
        for (uint i = 0; i < priceHistory.length; i++) {
            uint256 diff = priceHistory[i] > mean ? 
                priceHistory[i] - mean : mean - priceHistory[i];
            sum += diff * diff;
        }
        
        return sqrt(sum / priceHistory.length);
    }
    
    // åŠ¨æ€è°ƒæ•´PIDå‚æ•°
    function adaptPIDParameters() external {
        uint256 volatility = getVolatility();
        
        // é«˜æ³¢åŠ¨æ—¶å‡å°å“åº”
        if (volatility > 5e16) { // 5%
            controller.kp = controller.kp * 8 / 10;
            controller.ki = controller.ki * 8 / 10;
        } else if (volatility < 1e16) { // 1%
            controller.kp = controller.kp * 12 / 10;
            controller.ki = controller.ki * 12 / 10;
        }
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  4.4ï¼šæ„å»ºå®Œæ•´çš„ç¨³å®šå¸ç³»ç»Ÿ</h4>
                    <p>ç»¼åˆæœ¬ç« æ‰€å­¦ï¼Œè®¾è®¡å¹¶å®ç°ä¸€ä¸ªå®Œæ•´çš„è¶…é¢æŠµæŠ¼ç¨³å®šå¸ç³»ç»Ÿï¼ŒåŒ…æ‹¬PSMã€RWAæ”¯æŒå’Œç°ä»£åŒ–æ¸…ç®—æœºåˆ¶ã€‚</p>
                    <p>è¦æ±‚ï¼š</p>
                    <ul>
                        <li>å¤šæŠµæŠ¼å“æ”¯æŒï¼ˆåŒ…æ‹¬RWAï¼‰</li>
                        <li>PSMä¿æŒä»·æ ¼ç¨³å®š</li>
                        <li>Liquidation 2.0é£æ ¼æ¸…ç®—</li>
                        <li>å®Œå–„çš„æ²»ç†æœºåˆ¶</li>
                        <li>ç´§æ€¥å…³åœåŠŸèƒ½</li>
                    </ul>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <p>ç”±äºå®Œæ•´ç³»ç»Ÿè¿‡äºå¤æ‚ï¼Œè¿™é‡Œæä¾›æ ¸å¿ƒæ¶æ„å’Œå…³é”®ç»„ä»¶ï¼š</p>
                        <pre><code class="language-solidity">// ç³»ç»Ÿæ ¸å¿ƒæ¶æ„
contract StablecoinCore {
    // æ ¸å¿ƒæ¨¡å—
    IVat public vat;                // é‡‘åº“å¼•æ“
    IDog public dog;                // æ¸…ç®—å¼•æ“
    IVow public vow;                // ç³»ç»Ÿè´¢åŠ¡
    IPot public pot;                // å­˜æ¬¾åˆ©ç‡æ¨¡å—
    IEnd public end;                // ç´§æ€¥å…³åœ
    
    // è¾…åŠ©æ¨¡å—
    IPSM public psm;                // é”šå®šç¨³å®šæ¨¡å—
    IRWAAdapter public rwaAdapter;  // RWAé€‚é…å™¨
    IPriceFeed public priceFeed;    // ä»·æ ¼é¢„è¨€æœº
    IGovernance public governance;  // æ²»ç†æ¨¡å—
    
    // åˆå§‹åŒ–ç³»ç»Ÿ
    function initialize() external {
        // éƒ¨ç½²æ ¸å¿ƒåˆçº¦
        vat = new Vat();
        dog = new Dog(address(vat));
        vow = new Vow(address(vat));
        pot = new Pot(address(vat));
        end = new End(address(vat));
        
        // é…ç½®æŠµæŠ¼å“ç±»å‹
        setupCollateralTypes();
        
        // è®¾ç½®æ²»ç†
        setupGovernance();
    }
    
    // é…ç½®æŠµæŠ¼å“
    function setupCollateralTypes() internal {
        // ETH
        vat.init("ETH-A");
        vat.file("ETH-A", "line", 500_000_000 * RAD); // 500M debt ceiling
        vat.file("ETH-A", "mat", 150 * RAY / 100);   // 150% liquidation ratio
        
        // WBTC
        vat.init("WBTC-A");
        vat.file("WBTC-A", "line", 100_000_000 * RAD);
        vat.file("WBTC-A", "mat", 175 * RAY / 100);
        
        // RWA - US Treasury Bills
        vat.init("RWA001-A");
        vat.file("RWA001-A", "line", 1_000_000_000 * RAD); // 1B
        vat.file("RWA001-A", "mat", 105 * RAY / 100);      // 105% (low risk)
        
        // USDC (for PSM)
        vat.init("PSM-USDC-A");
        vat.file("PSM-USDC-A", "line", 10_000_000_000 * RAD); // 10B
        vat.file("PSM-USDC-A", "mat", RAY); // 100% (no liquidation)
    }
}</code></pre>
                        <p>å…³é”®ç»„ä»¶è®¾è®¡è¦ç‚¹ï¼š</p>
                        <ul>
                            <li><strong>Vatï¼š</strong>æ ¸å¿ƒé‡‘åº“ï¼Œç®¡ç†æ‰€æœ‰CDPå’Œå€ºåŠ¡</li>
                            <li><strong>Dogï¼š</strong>Liquidation 2.0å¼•æ“ï¼Œå¤„ç†æ¸…ç®—</li>
                            <li><strong>PSMï¼š</strong>1:1å…‘æ¢USDCï¼Œä¿æŒä»·æ ¼ç¨³å®š</li>
                            <li><strong>RWAï¼š</strong>é€šè¿‡ä¿¡æ‰˜å’Œæ³•å¾‹ç»“æ„å¼•å…¥çœŸå®èµ„äº§</li>
                            <li><strong>Governanceï¼š</strong>æ—¶é—´é”+å¤šç­¾ï¼Œç¡®ä¿å®‰å…¨</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <h3>æœ¬ç« å°ç»“</h3>
            <div class="summary-box">
                <h4>æ ¸å¿ƒè¦ç‚¹å›é¡¾ï¼š</h4>
                <ul>
                    <li><strong>é£é™©å‚æ•°äº”å…ƒç»„ï¼š</strong>å€ºåŠ¡ä¸Šé™ã€æ¸…ç®—çº¿ã€ç¨³å®šè´¹ã€æ¸…ç®—ç½šé‡‘ã€ç›®æ ‡æŠµæŠ¼ç‡çš„ååŒè®¾è®¡</li>
                    <li><strong>æ¸…ç®—æœºåˆ¶æ¼”è¿›ï¼š</strong>ä»è·å…°æ‹å–åˆ°Liquidation 2.0çš„å›ºå®šæŠ˜æ‰£å³æ—¶æ¸…ç®—</li>
                    <li><strong>MEVé˜²æŠ¤ï¼š</strong>é€šè¿‡commit-revealã€æ‰¹é‡æ‹å–ã€åŠ å¯†è®¢å•æµç­‰æœºåˆ¶ä¿æŠ¤å‚ä¸è€…</li>
                    <li><strong>PSMæœºåˆ¶ï¼š</strong>æä¾›å¼ºå¤§çš„ä»·æ ¼å¥—åˆ©é€šé“ï¼Œä½†å¼•å…¥ä¸­å¿ƒåŒ–é£é™©</li>
                    <li><strong>RWAé›†æˆï¼š</strong>å¸¦æ¥ç¨³å®šæ”¶ç›Šçš„åŒæ—¶å¼•å…¥æ–°å‹é£é™©</li>
                    <li><strong>é»‘è‰²æ˜ŸæœŸå››æ•™è®­ï¼š</strong>ç³»ç»Ÿè®¾è®¡å¿…é¡»è€ƒè™‘æç«¯å¸‚åœºæƒ…å†µ</li>
                </ul>
                
                <h4>ä¸‹ä¸€æ­¥å­¦ä¹ ï¼š</h4>
                <p>åœ¨æŒæ¡äº†æŠµæŠ¼å‹ç¨³å®šå¸çš„è®¾è®¡åï¼Œä¸‹ä¸€ç« æˆ‘ä»¬å°†æ·±å…¥æ¢è®¨æ•°å­¦æ¨¡å‹å’Œæ§åˆ¶ç†è®ºåœ¨ç¨³å®šå¸ä¸­çš„åº”ç”¨ï¼ŒåŒ…æ‹¬PIDæ§åˆ¶å™¨ã€åšå¼ˆè®ºåˆ†æå’Œé£é™©æ¨¡å‹ã€‚</p>
            </div>
            
            <h3>æœ¯è¯­é€ŸæŸ¥è¡¨</h3>
            <table class="glossary-table">
                <tr>
                    <th>æœ¯è¯­</th>
                    <th>è‹±æ–‡</th>
                    <th>è§£é‡Š</th>
                </tr>
                <tr>
                    <td>æŠµæŠ¼å€ºä»“ä½</td>
                    <td>CDP</td>
                    <td>ç”¨æˆ·é”å®šæŠµæŠ¼å“é“¸é€ ç¨³å®šå¸çš„æ™ºèƒ½åˆçº¦è´¦æˆ·</td>
                </tr>
                <tr>
                    <td>æ¸…ç®—çº¿</td>
                    <td>Liquidation Ratio</td>
                    <td>è§¦å‘æ¸…ç®—çš„æœ€ä½æŠµæŠ¼ç‡é˜ˆå€¼</td>
                </tr>
                <tr>
                    <td>ç¨³å®šè´¹</td>
                    <td>Stability Fee</td>
                    <td>CDPæŒæœ‰è€…éœ€æ”¯ä»˜çš„åˆ©æ¯</td>
                </tr>
                <tr>
                    <td>å–‚ä»·</td>
                    <td>Price Feed</td>
                    <td>é¢„è¨€æœºæä¾›çš„ä»·æ ¼æ•°æ®</td>
                </tr>
                <tr>
                    <td>è·å…°å¼æ‹å–</td>
                    <td>Dutch Auction</td>
                    <td>ä»·æ ¼éšæ—¶é—´é€’å‡çš„æ‹å–æ–¹å¼</td>
                </tr>
            </table>
        
            
            <!-- ç« èŠ‚å¯¼èˆª -->
            <div class="chapter-nav">
                <a href="chapter3.html">â† ç¬¬3ç« </a>
                <a href="chapter5.html">ç¬¬5ç«  â†’</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>