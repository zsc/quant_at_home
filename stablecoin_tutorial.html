<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>区块链稳定币智能合约教程</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --background-color: #f8fafc;
            --text-color: #1e293b;
            --code-bg: #1e293b;
            --border-color: #e2e8f0;
            --success-color: #10b981;
            --warning-color: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            border-radius: 0 0 20px 20px;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .chapter {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            font-size: 2rem;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        h3 {
            color: var(--secondary-color);
            margin: 1.5rem 0 1rem;
            font-size: 1.5rem;
        }

        .theory-section {
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid var(--primary-color);
        }

        .practice-section {
            background: #fef3c7;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid var(--warning-color);
        }

        .code-block {
            background: var(--code-bg);
            color: #f8f8f2;
            border-radius: 8px;
            margin: 1rem 0;
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0f172a;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #334155;
        }
        
        .code-language {
            color: #94a3b8;
            font-size: 0.875rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .code-toggle {
            background: #1e293b;
            border: 1px solid #475569;
            color: #94a3b8;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        .code-toggle:hover {
            background: #334155;
            color: #e2e8f0;
        }
        
        .code-content {
            padding: 1.5rem;
            overflow-x: auto;
            max-height: 400px;
            transition: max-height 0.3s ease-in-out;
        }
        
        .code-content.collapsed {
            max-height: 100px;
            overflow: hidden;
            position: relative;
        }
        
        .code-content.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(transparent, var(--code-bg));
        }
        
        .code-content pre {
            margin: 0;
            overflow: visible;
            white-space: pre;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .exercise {
            background: #dbeafe;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .exercise-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .exercise-icon {
            font-size: 1.5rem;
        }

        .answer-toggle {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
        }

        .answer-toggle:hover {
            background: var(--secondary-color);
        }

        .answer-content {
            display: none;
            background: white;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .answer-content.show {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .highlight {
            background: #fef3c7;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-weight: 600;
        }

        .tip {
            background: #d1fae5;
            border-left: 4px solid var(--success-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .warning {
            background: #fee2e2;
            border-left: 4px solid #ef4444;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        
        .tip {
            background: #e0f2fe;
            border-left: 4px solid #0284c7;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
            color: #075985;
        }
        
        .tip strong {
            color: #0c4a6e;
        }

        code {
            background: #e2e8f0;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .code-block code {
            background: none;
            padding: 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .chapter {
                padding: 1.5rem;
            }
        }
        
        /* 列表缩进样式 */
        ul, ol {
            margin-left: 1.5rem;
            padding-left: 0;
        }
        
        ul ul, ol ol, ul ol, ol ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        li {
            margin-bottom: 0.5rem;
            line-height: 1.8;
        }
        
        li > ul, li > ol {
            margin-top: 0.5rem;
        }
        
        /* 确保嵌套列表有适当的缩进 */
        .theory-section ul ul,
        .theory-section ol ol {
            margin-left: 2rem;
        }
        
        .theory-section ul ul ul,
        .theory-section ol ol ol {
            margin-left: 2rem;
        }
        
        /* 导航栏样式 */
        nav {
            background: #0f172a;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .nav-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }
        
        .nav-title {
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            text-decoration: none;
        }
        
        .nav-menu {
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 2rem;
        }
        
        .nav-item {
            position: relative;
        }
        
        .nav-link {
            color: #cbd5e1;
            text-decoration: none;
            padding: 0.5rem 0;
            transition: color 0.3s;
            font-size: 0.95rem;
        }
        
        .nav-link:hover,
        .nav-link.active {
            color: white;
        }
        
        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-color);
        }
        
        /* 移动端菜单按钮 */
        .nav-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }
        
        .nav-toggle span {
            display: block;
            width: 25px;
            height: 3px;
            background: white;
            margin: 5px 0;
            transition: 0.3s;
        }
        
        /* 章节指示器 */
        .chapter-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 200px;
            z-index: 100;
        }
        
        .chapter-indicator h4 {
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            color: var(--text-color);
        }
        
        .chapter-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.85rem;
        }
        
        .chapter-list li {
            padding: 0.3rem 0;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .chapter-list li:last-child {
            border-bottom: none;
        }
        
        .chapter-list a {
            color: #64748b;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .chapter-list a:hover,
        .chapter-list a.active {
            color: var(--primary-color);
        }
        
        /* 移动端响应式 */
        @media (max-width: 768px) {
            .nav-menu {
                position: fixed;
                top: 60px;
                left: -100%;
                width: 100%;
                height: calc(100vh - 60px);
                background: #0f172a;
                flex-direction: column;
                padding: 2rem;
                gap: 1rem;
                transition: left 0.3s;
                overflow-y: auto;
            }
            
            .nav-menu.active {
                left: 0;
            }
            
            .nav-toggle {
                display: block;
            }
            
            .nav-toggle.active span:nth-child(1) {
                transform: rotate(-45deg) translate(-5px, 6px);
            }
            
            .nav-toggle.active span:nth-child(2) {
                opacity: 0;
            }
            
            .nav-toggle.active span:nth-child(3) {
                transform: rotate(45deg) translate(-5px, -6px);
            }
            
            .chapter-indicator {
                display: none;
            }
            
            header {
                margin-bottom: 0;
            }
            
            .container {
                padding-top: 10px;
            }
        }
        
        /* 平滑滚动 */
        html {
            scroll-behavior: smooth;
            scroll-padding-top: 80px;
        }
        
        /* 调整header样式以配合导航栏 */
        header {
            margin-bottom: 0;
        }
        
        /* 章节顶部间距 */
        .chapter {
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <!-- 导航栏 -->
    <nav>
        <div class="nav-container">
            <div class="nav-content">
                <a href="#top" class="nav-title">稳定币教程</a>
                <button class="nav-toggle" onclick="toggleNav()">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <ul class="nav-menu" id="navMenu">
                    <li class="nav-item">
                        <a href="#intro" class="nav-link">引言</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter1" class="nav-link">第一章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter2" class="nav-link">第二章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter3" class="nav-link">第三章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#more" class="nav-link">更多</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    
    <!-- 章节指示器 -->
    <div class="chapter-indicator" id="chapterIndicator">
        <h4>章节导航</h4>
        <ul class="chapter-list">
            <li><a href="#intro">引言</a></li>
            <li><a href="#chapter1">1. 区块链基础</a></li>
            <li><a href="#chapter2">2. 稳定币分类</a></li>
            <li><a href="#chapter3">3. ERC-20标准</a></li>
            <li><a href="#chapter4">4. 抵押机制</a></li>
        </ul>
    </div>
    
    <header id="top">
        <div class="container">
            <h1>区块链稳定币智能合约：从理论到实践</h1>
        </div>
    </header>

    <div class="container">
        <div class="chapter" id="intro">
            <h2>引言：稳定币的历史、概念与市场格局</h2>
            
            <div class="theory-section">
                <h3>基础概念厘清</h3>
                <p>在深入稳定币之前，让我们快速厘清几个基础概念：</p>
                
                <h4>比特币（Bitcoin）</h4>
                <ul>
                    <li><strong>本质</strong>：第一个成功的去中心化数字货币，2009年由中本聪创造</li>
                    <li><strong>核心创新</strong>：解决了双重支付问题，无需可信第三方</li>
                    <li><strong>技术基础</strong>：工作量证明（PoW）+ UTXO模型 + P2P网络</li>
                    <li><strong>与稳定币关系</strong>：比特币的价格波动性（日波动可达10%+）催生了稳定币需求</li>
                </ul>
                
                <h4>区块链（Blockchain）</h4>
                <ul>
                    <li><strong>本质</strong>：分布式账本技术，按时间顺序链接的数据块</li>
                    <li><strong>关键特性</strong>：
                        <ul>
                            <li>不可篡改性：通过密码学哈希链接</li>
                            <li>透明性：所有节点可验证</li>
                            <li>去中心化：无单点控制</li>
                        </ul>
                    </li>
                    <li><strong>演进</strong>：
                        <ul>
                            <li>区块链1.0：数字货币（比特币）</li>
                            <li>区块链2.0：智能合约（以太坊）</li>
                            <li>区块链3.0：可扩展应用（Solana、Cosmos等）</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>为什么需要稳定币？</h4>
                <div style="background: #fef3c7; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <p><strong>核心矛盾</strong>：加密货币要成为真正的"货币"，需要满足三个功能：</p>
                    <ol>
                        <li><strong>交换媒介</strong>：比特币波动太大，商家不愿接受</li>
                        <li><strong>价值储存</strong>：今天1 BTC可能买一辆车，明天可能只够买辆自行车</li>
                        <li><strong>记账单位</strong>：无法用波动资产定价商品</li>
                    </ol>
                    <p><strong>稳定币的使命</strong>：在保留区块链技术优势的同时，提供价格稳定的数字货币。</p>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>常见误区澄清</h3>
                
                <h4>Q币、购物卡是稳定币吗？</h4>
                <div class="exercise" style="background: #f3f4f6; border: 2px solid #94a3b8;">
                    <p><strong>问题：</strong>腾讯Q币、商家购物充值卡算不算稳定币？</p>
                    
                    <div style="margin-top: 1rem;">
                        <p><strong>答案：不算。</strong>虽然它们都锚定法币（1Q币=1元人民币），但本质区别在于：</p>
                        
                        <table style="width: 100%; margin-top: 1rem;">
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px;">特征</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Q币/购物卡</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">区块链稳定币</th>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">技术基础</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">中心化数据库</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">分布式账本</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">可转让性</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">受限（通常不可转让）</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">自由转让</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">使用范围</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">单一平台/商家</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">全球通用</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">可编程性</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">无</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">智能合约集成</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">透明度</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">不透明</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">链上可审计</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">监管性质</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">预付卡/积分</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">数字资产/证券</td>
                            </tr>
                        </table>
                        
                        <div class="tip" style="margin-top: 1rem;">
                            <strong>💡 核心区别：</strong>Q币是"封闭系统内的积分"，而稳定币是"开放网络上的可编程货币"。这就像局域网内的文件共享vs互联网上的网站。
                        </div>
                    </div>
                </div>
                
                <h4>稳定币是新的ICO造富神话吗？</h4>
                <div class="warning" style="margin: 1rem 0;">
                    <p><strong>答案：绝对不是。</strong>稳定币与ICO有本质区别：</p>
                    
                    <ul>
                        <li><strong>ICO（Initial Coin Offering）</strong>：
                            <ul>
                                <li>目的：融资，承诺未来收益</li>
                                <li>价格：期望大幅升值</li>
                                <li>风险：95%+项目失败或诈骗</li>
                                <li>监管：多数被定性为非法证券发行</li>
                            </ul>
                        </li>
                        <li><strong>稳定币</strong>：
                            <ul>
                                <li>目的：提供稳定支付工具</li>
                                <li>价格：锚定法币，不升值</li>
                                <li>收益：仅来自利息或手续费</li>
                                <li>监管：逐步合规化</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <p><strong>投资角度：</strong></p>
                    <ul>
                        <li>持有稳定币不会让你暴富（设计目标就是保值）</li>
                        <li>稳定币项目方盈利来自：铸币税、利息收入、交易费用</li>
                        <li>用户使用稳定币是为了：避险、支付、DeFi收益</li>
                    </ul>
                    
                    <p style="color: #dc2626; font-weight: bold;">⚠️ 警告：任何承诺"稳定币投资高回报"的都是骗局！</p>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>稳定币发展简史</h3>
                
                <div style="background: #e0f2fe; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                    <h4>📊 稳定币市场增长数据</h4>
                    <ul>
                        <li>2017年：总市值 ~$10亿（主要是USDT）</li>
                        <li>2020年：总市值 ~$280亿（DeFi推动，增长28倍）</li>
                        <li>2021年：总市值 ~$1,800亿（牛市顶峰，单年增长6.4倍）</li>
                        <li>2024年：总市值 ~$1,600亿（市场成熟，日交易量超$700亿）</li>
                    </ul>
                    <p><strong>年复合增长率（CAGR）</strong>：2017-2024约为155%</p>
                </div>
                
                <h4>早期探索（2014-2017）：从概念验证到商业应用</h4>
                <ul>
                    <li><strong>2014年7月 - Tether (USDT)</strong>：中心化稳定币的开创者
                        <ul>
                            <li>技术架构演进：Omni Layer（比特币二层）→ ERC20（以太坊代币标准）（2017）→ TRC20（波场代币标准）（2019）→ 多链部署（30+条链）</li>
                            <li>储备演变：100%美元现金（声称）→ 商业票据+国债+现金（2021披露）→ 美国国债为主（2023）</li>
                            <li>关键里程碑：
                                <ul>
                                    <li>2017年：日交易量首次超过比特币</li>
                                    <li>2019年：承认仅74%现金支持</li>
                                    <li>2021年：与纽约州检察长达成和解，罚款$1850万</li>
                                    <li>2024年：持有超$900亿美国国债，成为第16大持有者</li>
                                </ul>
                            </li>
                            <li>技术创新：引入"授权铸造"模式，特定地址可铸造/销毁</li>
                        </ul>
                    </li>
                    <li><strong>2014年9月 - BitUSD</strong>：去中心化稳定币的先驱
                        <ul>
                            <li>基于BitShares的DPoS共识（21个见证人，3秒出块）</li>
                            <li>抵押机制：175%初始抵押率，110%强制清算线</li>
                            <li>价格反馈系统：见证人喂价，中位数定价，1小时更新</li>
                            <li>创新功能：
                                <ul>
                                    <li>强制平仓：任何人可以以110%抵押率强制平仓</li>
                                    <li>黑天鹅保护：全局结算机制</li>
                                    <li>做市商激励：价差收益归做市商</li>
                                </ul>
                            </li>
                            <li>失败教训：2018年BTS暴跌90%，大规模清算导致BitUSD长期溢价交易</li>
                        </ul>
                    </li>
                    <li><strong>2017年12月 - DAI (单抵押版)</strong>：智能合约稳定币的里程碑
                        <ul>
                            <li>技术突破：
                                <ul>
                                    <li>目标价格反馈机制（TRFM）：动态调整目标价格</li>
                                    <li>敏感度参数：控制反馈强度</li>
                                    <li>全局结算：紧急关停保护用户资产</li>
                                </ul>
                            </li>
                            <li>智能合约架构：
                                <ul>
                                    <li>CDP引擎：管理抵押品和债务</li>
                                    <li>价格预言机：14个独立喂价节点</li>
                                    <li>清算引擎：3%罚金 + 荷兰拍卖</li>
                                </ul>
                            </li>
                            <li>治理代币MKR：风险参数投票、紧急关停权限、稳定费收入销毁</li>
                        </ul>
                    </li>
                </ul>

                <h4>快速扩张期（2018-2020）：从实验到主流采用</h4>
                <ul>
                    <li><strong>2018年9月 - 合规稳定币元年</strong>
                        <ul>
                            <li><strong>USDC (Centre联盟)</strong>
                                <ul>
                                    <li>技术架构：可升级代理合约，支持暂停、黑名单功能</li>
                                    <li>合规措施：KYC/AML合作伙伴，月度审计报告</li>
                                    <li>初期增长：3个月达到$1亿市值，主要用于交易所间套利</li>
                                </ul>
                            </li>
                            <li><strong>PAX (Paxos Standard)</strong>
                                <ul>
                                    <li>监管创新：首个获NYDFS批准的ERC-20稳定币</li>
                                    <li>技术特色：智能合约可冻结特定地址，符合执法要求</li>
                                    <li>市场定位：机构级托管，与Revolut等金融科技合作</li>
                                </ul>
                            </li>
                            <li><strong>GUSD (Gemini Dollar)</strong>
                                <ul>
                                    <li>安全机制：离线签名铸造，多重签名销毁</li>
                                    <li>保险覆盖：FDIC保险（最高$250,000）</li>
                                    <li>应用场景：Flexa支付网络，BlockFi借贷</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2019年11月 - 多抵押DAI（MCD）革命</strong>
                        <ul>
                            <li><strong>架构升级</strong>
                                <ul>
                                    <li>模块化设计：独立的抵押品适配器（Join Adapters）</li>
                                    <li>拍卖引擎：盈余拍卖（FLAP）、债务拍卖（FLOP）、清算拍卖（FLIP）</li>
                                    <li>预言机安全模块（OSM，延迟价格更新以防止操纵）：1小时价格延迟，防闪电贷攻击</li>
                                </ul>
                            </li>
                            <li><strong>风险参数</strong>
                                <ul>
                                    <li>稳定费率（借出DAI的利息）：2-20%年化（根据抵押品类型）</li>
                                    <li>清算罚金：13%（防止系统性风险）</li>
                                    <li>债务上限：每种抵押品独立设置</li>
                                </ul>
                            </li>
                            <li><strong>DSR创新</strong>
                                <ul>
                                    <li>实现机制：通过pot合约累积利息</li>
                                    <li>利率决策：MKR持有者投票，2-8%区间</li>
                                    <li>市场影响：$1亿+DAI锁定，成为无风险利率基准</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2020年6-12月 - DeFi夏天：稳定币大爆发</strong>
                        <ul>
                            <li><strong>关键里程碑</strong>
                                <ul>
                                    <li>6月15日：Compound启动COMP挖矿，稳定币APY达40%</li>
                                    <li>7月17日：YFI发布，yUSD金库年化1000%+</li>
                                    <li>8月13日：Curve CRV上线，3pool（DAI/USDC/USDT）TVL $5亿</li>
                                    <li>9月17日：Uniswap UNI空投，稳定币对日交易量$10亿</li>
                                </ul>
                            </li>
                            <li><strong>创新机制</strong>
                                <ul>
                                    <li>Curve StableSwap：A参数动态调整，降低滑点100倍</li>
                                    <li>Ampleforth：弹性供应稳定币，每日rebase机制</li>
                                    <li>算法稳定币实验：ESD（优惠券机制）、DSD（债券系统）、Basis Cash（三币模型）</li>
                                </ul>
                            </li>
                            <li><strong>数据统计</strong>
                                <ul>
                                    <li>稳定币供应量：$50亿→$250亿（500%增长）</li>
                                    <li>DeFi锁仓价值：$10亿→$150亿，稳定币占40%</li>
                                    <li>日均交易笔数：10万→100万笔</li>
                                    <li>Gas消耗：稳定币转账占以太坊总Gas的30%</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>动荡与监管（2021-2023）：从狂热到理性回归</h4>
                <ul>
                    <li><strong>2021年 - 算法稳定币创新巅峰</strong>
                        <ul>
                            <li><strong>UST/Terra生态爆发</strong>
                                <ul>
                                    <li>市值增长：$1.8亿(1月)→$180亿(12月)，成为第四大稳定币</li>
                                    <li>Anchor Protocol：提供19.5%固定年化收益，TVL达$170亿</li>
                                    <li>生态扩张：支持Ethereum、Solana、Avalanche等10+条链</li>
                                    <li>比特币储备：Luna Foundation Guard购买$35亿BTC作为储备</li>
                                </ul>
                            </li>
                            <li><strong>FRAX革命性创新</strong>
                                <ul>
                                    <li>部分储备机制：初始100%抵押→逐步降至85%</li>
                                    <li>算法市场操作(AMO)：协议直接在Curve等部署流动性</li>
                                    <li><span class="tooltip">ve经济模型<span class="tooltip-content">Vote-Escrowed，锁定代币获得投票权</span></span>：veFXS锁定机制，最长4年</li>
                                    <li>收益分配：协议收入100%分配给veFXS持有者</li>
                                </ul>
                            </li>
                            <li><strong>其他创新项目</strong>
                                <ul>
                                    <li>MIM (Abracadabra)：利用生息资产作抵押，市值达$50亿</li>
                                    <li>FEI Protocol：PCV（协议控制价值）概念，$13亿创世发行</li>
                                    <li>LUSD (Liquity)：无治理、不可变合约，110%最低抵押率</li>
                                    <li>alUSD (Alchemix)：自我偿还贷款，未来收益作抵押</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2022年5月 - UST/LUNA死亡螺旋详解</strong>
                        <ul>
                            <li><strong>崩盘前奏（5月1-7日）</strong>
                                <ul>
                                    <li>4pool提案失败：Curve战争失利，UST失去流动性护城河</li>
                                    <li>大额提款：$1.5亿UST从Anchor提出并抛售</li>
                                    <li>LFG错误决策：动用BTC储备防守而非UST回购</li>
                                </ul>
                            </li>
                            <li><strong>崩盘过程（5月8-13日）</strong>
                                <ul>
                                    <li>5月8日：UST脱锚至$0.985，24小时交易量$20亿</li>
                                    <li>5月9日：LUNA从$80跌至$30，市值蒸发$300亿</li>
                                    <li>5月10日：铸币机制失效，LUNA供应量增加10倍</li>
                                    <li>5月11日：主要交易所暂停LUNA/UST交易</li>
                                    <li>5月13日：Terra链暂停出块，LUNA接近归零</li>
                                </ul>
                            </li>
                            <li><strong>连锁效应</strong>
                                <ul>
                                    <li>直接损失：$600亿市值归零，200万+用户受影响</li>
                                    <li>机构倒闭：Three Arrows($100亿)、Celsius($120亿)、Voyager($50亿)</li>
                                    <li>市场恐慌：BTC跌至$25,000，总市值缩水$1万亿</li>
                                    <li>信任危机：算法稳定币整体受质疑，FRAX等被迫增加抵押率</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2023年 - 全球监管框架加速成型</strong>
                        <ul>
                            <li><strong>美国监管收紧</strong>
                                <ul>
                                    <li>BUSD事件：2月13日，纽约州要求Paxos停止发行BUSD</li>
                                    <li>稳定币法案：要求发行方持有银行牌照或信托牌照</li>
                                    <li>SEC执法：起诉多个算法稳定币项目</li>
                                    <li>银行危机影响：3月硅谷银行倒闭，USDC短暂脱锚至$0.87</li>
                                </ul>
                            </li>
                            <li><strong>欧盟MiCA实施</strong>
                                <ul>
                                    <li>6月生效：全球首个综合性加密资产监管框架</li>
                                    <li>EMT要求：电子货币代币需持牌，储备金托管</li>
                                    <li>ART限制：资产参考代币日交易量上限€2亿</li>
                                    <li>过渡期：现有稳定币18个月内需合规</li>
                                </ul>
                            </li>
                            <li><strong>亚太地区进展</strong>
                                <ul>
                                    <li>香港：发布稳定币监管咨询总结，2024年实施牌照制</li>
                                    <li>新加坡：要求单一货币稳定币按面值赎回</li>
                                    <li>日本：只允许日元、美元等主要货币稳定币</li>
                                    <li>韩国：要求100%法币储备，禁止算法稳定币</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>

                <div class="tip">
                    <strong>💡 历史教训：</strong>稳定币的发展历程表明，技术创新必须与风险管理并重。UST的崩溃提醒我们，没有充分抵押品支撑的算法稳定机制在极端市场条件下极其脆弱。
                </div>
            </div>

            <div class="theory-section">
                <h3>核心概念回顾</h3>
                
                <h4>稳定币三元悖论（Stablecoin Trilemma）</h4>
                <p>在深入技术细节之前，我们需要理解稳定币设计的根本性约束。类似于区块链的"不可能三角"，稳定币也面临自己的三元悖论：</p>
                
                <div style="text-align: center; margin: 2rem 0;">
                    <svg width="400" height="350" viewBox="0 0 400 350">
                        <!-- 三角形 -->
                        <polygon points="200,50 350,300 50,300" fill="none" stroke="#2563eb" stroke-width="2"/>
                        
                        <!-- 三个顶点的圆圈和文字 -->
                        <circle cx="200" cy="50" r="40" fill="#2563eb" opacity="0.1" stroke="#2563eb" stroke-width="2"/>
                        <text x="200" y="55" text-anchor="middle" fill="#2563eb" font-weight="bold">去中心化</text>
                        <text x="200" y="20" text-anchor="middle" fill="#666" font-size="12">Decentralization</text>
                        
                        <circle cx="350" cy="300" r="40" fill="#2563eb" opacity="0.1" stroke="#2563eb" stroke-width="2"/>
                        <text x="350" y="305" text-anchor="middle" fill="#2563eb" font-weight="bold">资本效率</text>
                        <text x="350" y="330" text-anchor="middle" fill="#666" font-size="12">Capital Efficiency</text>
                        
                        <circle cx="50" cy="300" r="40" fill="#2563eb" opacity="0.1" stroke="#2563eb" stroke-width="2"/>
                        <text x="50" y="305" text-anchor="middle" fill="#2563eb" font-weight="bold">价格稳定</text>
                        <text x="50" y="330" text-anchor="middle" fill="#666" font-size="12">Price Stability</text>
                        
                        <!-- 中心文字 -->
                        <text x="200" y="200" text-anchor="middle" fill="#1e40af" font-size="16" font-weight="bold">最多选择两个</text>
                    </svg>
                </div>
                
                <div class="tip">
                    <strong>💡 关键洞察：</strong>任何稳定币项目都无法同时完美实现这三个目标。理解这个三元悖论是评估不同稳定币设计的基础框架。
                </div>
                
                <h4>三元悖论的深度技术解析</h4>
                <ul>
                    <li><strong>去中心化（Decentralization）- 技术维度分析</strong>
                        <ul>
                            <li><strong>量化指标</strong>：
                                <ul>
                                    <li>中本聪系数：需要多少个实体合谋才能控制系统</li>
                                    <li>基尼系数：代币分布的集中程度（0=完全平等，1=完全集中）</li>
                                    <li>治理参与率：实际参与投票的代币比例</li>
                                </ul>
                            </li>
                            <li><strong>技术实现</strong>：
                                <ul>
                                    <li>多签钱包：Gnosis Safe（2/3, 3/5, 4/7等配置）</li>
                                    <li>时间锁：24-72小时延迟执行，社区可审查</li>
                                    <li>DAO治理：链上提案、投票、执行全流程</li>
                                </ul>
                            </li>
                            <li><strong>攻击向量</strong>：
                                <ul>
                                    <li>治理攻击：购买足够代币控制投票</li>
                                    <li>预言机操纵：控制价格源影响系统</li>
                                    <li>MEV攻击：通过交易排序获利</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>资本效率（Capital Efficiency）- 经济模型分析</strong>
                        <ul>
                            <li><strong>效率计算公式</strong>：
                                <div class="code-block">
资本效率 = 稳定币流通量 / 锁定抵押品总价值
示例：
- USDT: $95B / $95B = 100%（完全储备）
- DAI: $5B / $7.5B = 66.7%（150%超额抵押）
- FRAX: $1B / $0.85B = 117%（部分算法）</div>
                            </li>
                            <li><strong>优化技术</strong>：
                                <ul>
                                    <li>PSM（Peg Stability Module）：1:1兑换其他稳定币</li>
                                    <li>D3M（Direct Deposit Module）：直接向借贷协议供应</li>
                                    <li>递归杠杆：循环借贷提高资本利用率</li>
                                </ul>
                            </li>
                            <li><strong>风险/收益权衡</strong>：
                                <ul>
                                    <li>高效率→高系统性风险（UST教训）</li>
                                    <li>低效率→高稳定性但机会成本大</li>
                                    <li>动态调整：根据市场条件改变抵押率</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>价格稳定（Price Stability）- 机制设计分析</strong>
                        <ul>
                            <li><strong>稳定性指标</strong>：
                                <ul>
                                    <li>日波动率：σ = √(Σ(xi - μ)²/n)</li>
                                    <li>最大偏离：max(|price - $1|)</li>
                                    <li>恢复时间：从脱锚到恢复$0.995-$1.005的时长</li>
                                    <li>深度指标：2%滑点所需交易量</li>
                                </ul>
                            </li>
                            <li><strong>稳定机制</strong>：
                                <ul>
                                    <li>一级市场：直接铸造/赎回套利</li>
                                    <li>二级市场：AMM流动性池套利</li>
                                    <li>稳定费调节：通过利率影响供需</li>
                                    <li>紧急机制：全局清算、紧急暂停</li>
                                </ul>
                            </li>
                            <li><strong>历史表现数据</strong>：
                                <ul>
                                    <li>USDC：年化波动率0.1%，最大偏离$0.13（SVB事件）</li>
                                    <li>DAI：年化波动率0.8%，最大偏离$0.05</li>
                                    <li>FRAX：年化波动率1.2%，最大偏离$0.03</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                
                <div style="background: #f1f5f9; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0; border-left: 4px solid #2563eb;">
                    <h5>稳定币三元悖论的形式化定义</h5>
                    <p><strong>定理：</strong>任何稳定币系统最多只能同时优化以下三个属性中的两个：</p>
                    <ol>
                        <li><strong>去中心化（Decentralization）</strong>：系统控制权的分散程度</li>
                        <li><strong>资本效率（Capital Efficiency）</strong>：抵押资产与稳定币发行量的比率</li>
                        <li><strong>价格稳定（Price Stability）</strong>：维持与目标价格锚定的能力</li>
                    </ol>
                    <p><strong>数学约束：</strong>若 D + C + P ≤ 2，其中 D、C、P ∈ [0,1] 分别代表三个属性的实现程度</p>
                </div>
                
                <h4>现有稳定币的三元悖论权衡分析</h4>
                
                <div style="background: #fafbfc; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                        <tr style="background: #e0f2fe;">
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: left;">稳定币项目</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: center;">去中心化</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: center;">资本效率</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: center;">价格稳定</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6;">技术实现特点</th>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">USDT/USDC</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #dc2626;">❌</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：单一owner地址控制mint/burn/blacklist<br/>
                                <strong>储备</strong>：链下银行账户持有等值美元<br/>
                                <strong>稳定</strong>：依赖发行方信誉和监管合规
                            </td>
                        </tr>
                        <tr style="background: #f8fafc;">
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">DAI</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #dc2626;">❌</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：MakerDAO治理投票决定参数<br/>
                                <strong>储备</strong>：链上智能合约锁定ETH/WBTC等<br/>
                                <strong>稳定</strong>：利率调节 + 清算机制 + PSM模块
                            </td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">UST<br/><span style="font-size: 0.8rem; color: #dc2626;">(已崩溃)</span></td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #dc2626;">❌</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：算法自动执行，无需人工干预<br/>
                                <strong>储备</strong>：LUNA代币作为弹性供应调节器<br/>
                                <strong>稳定</strong>：套利机制失效导致死亡螺旋
                            </td>
                        </tr>
                        <tr style="background: #f8fafc;">
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">FRAX</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #f59e0b;">⚡</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #f59e0b;">⚡</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：部分去中心化，团队保留关键权限<br/>
                                <strong>储备</strong>：USDC（88%）+ FXS算法调节<br/>
                                <strong>稳定</strong>：混合机制，动态调整抵押率
                            </td>
                        </tr>
                    </table>
                    <p style="margin-top: 1rem; font-size: 0.9rem; color: #64748b;">
                        <strong>图例：</strong>✅ 优化 | ❌ 牺牲 | ⚡ 部分实现
                    </p>
                </div>
                
                <h4>为什么不能三者兼得？</h4>
                <div style="background: #fef3c7; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0;">
                    <p><strong>三元悖论的经济学解释：</strong></p>
                    <ul>
                        <li><strong>去中心化 + 资本效率 → 价格不稳定</strong>
                            <p style="margin-left: 1.5rem; color: #666;">没有超额抵押缓冲，市场波动直接影响价格。当抵押品价值下跌时，系统缺乏足够的安全边际来维持锚定。UST的崩溃完美诠释了这一点。</p>
                        </li>
                        <li><strong>去中心化 + 价格稳定 → 资本效率低</strong>
                            <p style="margin-left: 1.5rem; color: #666;">需要超额抵押来应对市场波动，如DAI的150%最低抵押率。这意味着每生成$1的稳定币，需要锁定至少$1.5的资产，造成大量资本闲置。</p>
                        </li>
                        <li><strong>资本效率 + 价格稳定 → 中心化</strong>
                            <p style="margin-left: 1.5rem; color: #666;">需要可信第三方持有和管理储备资产，如USDC由Circle公司控制。中心化实体可以灵活调整储备，快速响应赎回需求。</p>
                        </li>
                    </ul>
                </div>

                <h4>抵押机制深度对比分析</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <tr>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">类型</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">抵押率</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">例子</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">优势</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">劣势</th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">法币抵押</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">100%</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">USDT, USDC</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">简单稳定</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">中心化风险</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">加密货币超额抵押</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">150-200%</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">DAI, LUSD</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">去中心化</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">资本效率低</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">算法调节</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">0-100%</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">FRAX, FEI</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">资本效率高</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">机制复杂</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">混合型</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">可变</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">FRAX, USDD</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">灵活性</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">治理复杂</td>
                    </tr>
                </table>

                <h4>关键机制</h4>
                <ol>
                    <li><strong>价格预言机（Oracle）- 稳定币的眼睛</strong>
                        <p>预言机是连接区块链与现实世界的桥梁，对稳定币至关重要。它们提供抵押品价格、汇率等关键数据。</p>
                        
                        <div style="background: #f3f4f6; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                            <h5>主要预言机方案对比</h5>
                            <ul>
                                <li><strong>Chainlink</strong>
                                    <ul>
                                        <li>原理：多节点聚合，去中心化网络</li>
                                        <li>优势：高可用性，抗操纵性强</li>
                                        <li>劣势：成本较高，更新延迟</li>
                                        <li>攻击面：节点串谋、数据源污染</li>
                                    </ul>
                                </li>
                                <li><strong>Uniswap V3 TWAP</strong>
                                    <ul>
                                        <li>原理：链上交易对的时间加权平均价格</li>
                                        <li>优势：完全去中心化，防闪电贷攻击</li>
                                        <li>劣势：需要足够流动性，易受长期操纵</li>
                                        <li>攻击面：流动性枯竭、长时间价格操纵</li>
                                    </ul>
                                </li>
                                <li><strong>Maker Oracle V2</strong>
                                    <ul>
                                        <li>原理：白名单喂价者 + 中位数聚合</li>
                                        <li>优势：为MakerDAO定制，延迟机制</li>
                                        <li>劣势：相对中心化，依赖<span class="tooltip">可信喂价者<span class="tooltip-content">经过验证的价格数据提供方，通常需要质押保证金</span></span></li>
                                        <li>攻击面：喂价者密钥泄露、OSM延迟利用</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="warning">
                            <strong>⚠️ 预言机攻击案例：</strong>
                            <ul>
                                <li>2020年 Compound DAI 价格异常：Coinbase Pro闪崩导致清算</li>
                                <li>2021年 Cream Finance：通过操纵预言机价格盗取1.3亿美元</li>
                                <li>2022年 Mango Markets：预言机价格操纵损失1.16亿美元</li>
                            </ul>
                        </div>
                    </li>
                    <li><strong>清算机制</strong>
                        <ul>
                            <li>固定折扣清算（如早期MakerDAO）</li>
                            <li><span class="tooltip">荷兰式拍卖<span class="tooltip-content">价格从高到低递减的拍卖方式，直到有人愿意购买</span></span>（如Liquity）</li>
                            <li>渐进式清算（如新版MakerDAO）</li>
                        </ul>
                    </li>
                    <li><strong>稳定机制</strong>
                        <ul>
                            <li>利率调节（DSR存款利率, 稳定费即借款利率）</li>
                            <li>铸币税/销毁机制</li>
                            <li>套利激励</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="theory-section">
                <h3>市场主要参与者</h3>
                
                <h4>2024年市场份额（按市值）</h4>
                <div style="background: #f9fafb; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <ul>
                        <li><strong>USDT (Tether)</strong> - $95B+ (约45%)
                            <ul>
                                <li>发行方：Tether Limited（香港）</li>
                                <li>支持链：Ethereum, Tron, BSC, Avalanche等15+条链</li>
                                <li>储备：美国国债、商业票据、现金等</li>
                            </ul>
                        </li>
                        <li><strong>USDC (USD Coin)</strong> - $25B+ (约12%)
                            <ul>
                                <li>发行方：Circle（美国）</li>
                                <li>支持链：Ethereum, Solana, Avalanche等</li>
                                <li>储备：100%现金和短期美国国债</li>
                            </ul>
                        </li>
                        <li><strong>DAI</strong> - $5B+ (约2.5%)
                            <ul>
                                <li>发行方：MakerDAO（去中心化）</li>
                                <li>支持链：Ethereum L1 + 多个L2</li>
                                <li>抵押品：ETH, WBTC（Wrapped Bitcoin - 以太坊上的比特币代币）, USDC, RWA（Real World Assets - 现实世界资产）等</li>
                            </ul>
                        </li>
                        <li><strong>FDUSD</strong> - $3B+ (约1.5%)
                            <ul>
                                <li>发行方：First Digital（香港）</li>
                                <li>特点：亚洲市场主导</li>
                            </ul>
                        </li>
                        <li><strong>其他</strong> - 包括TUSD, FRAX, LUSD, crvUSD等</li>
                    </ul>
                </div>

                <h4>技术创新者</h4>
                <ul>
                    <li><strong>Frax Finance</strong>
                        <ul>
                            <li>首个部分算法稳定币</li>
                            <li>动态调整抵押率</li>
                            <li>创新的AMO（Algorithmic Market Operations，算法市场操作 - 自动调节市场供需）机制</li>
                        </ul>
                    </li>
                    <li><strong>Curve Finance (crvUSD)</strong>
                        <ul>
                            <li>LLAMMA（Lending-Liquidating AMM Algorithm，借贷清算自动做市商算法 - 将清算过程变为渐进式）</li>
                            <li>软清算机制，减少清算损失</li>
                            <li>与Curve生态深度整合</li>
                        </ul>
                    </li>
                    <li><strong>Aave (GHO)</strong>
                        <ul>
                            <li>基于Aave V3的原生稳定币</li>
                            <li>利用Aave的风险管理框架</li>
                            <li>Facilitator模式（促进者模式 - 授权实体可以铸造和销毁GHO）分散风险</li>
                        </ul>
                    </li>
                </ul>

                <div class="warning">
                    <strong>⚠️ 市场集中度风险：</strong>USDT和USDC合计占据稳定币市场超过55%的份额，这种中心化给DeFi生态系统带来系统性风险。2023年3月Silicon Valley Bank倒闭期间，USDC一度脱锚至$0.87，影响整个DeFi生态。
                </div>
            </div>

            <div class="theory-section">
                <h3>全球监管现状</h3>
                
                <h4>主要司法管辖区监管框架</h4>
                
                <h5>🇺🇸 美国</h5>
                <ul>
                    <li><strong>现状</strong>：分散监管，多头管理
                        <ul>
                            <li>州级：纽约BitLicense（加密货币许可证）, 怀俄明州SPDI（特殊目的存款机构）</li>
                            <li>联邦级：尚无统一立法</li>
                        </ul>
                    </li>
                    <li><strong>关键法案</strong>：
                        <ul>
                            <li>Stablecoin TRUST Act（参议院）</li>
                            <li>Clarity for Payment Stablecoins Act（众议院）</li>
                            <li>STABLE Act（提案阶段）</li>
                        </ul>
                    </li>
                    <li><strong>监管重点</strong>：
                        <ul>
                            <li>储备资产透明度</li>
                            <li>赎回权保障</li>
                            <li>系统重要性机构认定</li>
                        </ul>
                    </li>
                </ul>

                <h5>🇪🇺 欧盟</h5>
                <ul>
                    <li><strong>MiCA法规</strong>（2024年生效）
                        <ul>
                            <li>统一的稳定币监管框架</li>
                            <li>区分EMT（E-Money Token，电子货币代币 - 锚定单一法币）和ART（Asset-Referenced Token，资产参考代币 - 锚定多种资产）</li>
                            <li>严格的储备和审计要求</li>
                        </ul>
                    </li>
                    <li><strong>关键要求</strong>：
                        <ul>
                            <li>1:1储备，存放于托管机构</li>
                            <li>每日市值上限（EMT: 2亿欧元）</li>
                            <li>白皮书审批制度</li>
                        </ul>
                    </li>
                </ul>

                <h5>🇨🇳 中国</h5>
                <ul>
                    <li>禁止所有加密货币交易和ICO</li>
                    <li>积极推进央行数字货币（数字人民币）</li>
                    <li>香港特区：
                        <ul>
                            <li>2023年6月实施稳定币监管制度</li>
                            <li>要求持牌经营</li>
                            <li>储备资产必须高质量、高流动性</li>
                        </ul>
                    </li>
                </ul>

                <h5>🇯🇵 日本</h5>
                <ul>
                    <li>2023年6月修订《资金结算法》</li>
                    <li>稳定币分类：
                        <ul>
                            <li>银行发行（存款型）</li>
                            <li>信托公司发行（信托型）</li>
                        </ul>
                    </li>
                    <li>禁止算法稳定币</li>
                </ul>

                <h5>🇸🇬 新加坡</h5>
                <ul>
                    <li>MAS（金管局）监管框架</li>
                    <li>单一货币支持的稳定币需申请牌照</li>
                    <li>储备要求：至少100%的低风险资产</li>
                </ul>

                <div class="tip">
                    <strong>💡 监管趋势：</strong>全球监管正在从"观望"转向"行动"。主要趋势包括：(1)要求100%法币储备，(2)禁止或限制算法稳定币，(3)强调用户资产保护，(4)防止系统性风险。开发者需要在创新和合规之间找到平衡。
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 0.1：监管影响分析</h4>
                </div>
                <p>假设你是一个DeFi协议的架构师，需要设计一个新的稳定币系统。考虑以下场景：</p>
                <ol>
                    <li>如果欧盟MiCA要求每日交易上限2亿欧元，你如何设计系统确保合规同时不影响用户体验？</li>
                    <li>如果美国要求所有稳定币发行方成为银行，对DeFi生态会有什么影响？</li>
                    <li>设计一个能同时满足美国、欧盟、新加坡监管要求的稳定币架构</li>
                </ol>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-0-1')">查看参考答案</button>
                <div id="answer-0-1" class="answer-content">
                    <h5>参考答案：</h5>
                    
                    <h6>1. 应对欧盟交易上限</h6>
                    <div class="code-block">
contract MiCACompliantStablecoin {
    uint256 constant DAILY_LIMIT = 200_000_000e6; // 2亿欧元
    mapping(uint256 => uint256) public dailyVolume; // day => volume
    
    modifier checkDailyLimit(uint256 amount) {
        uint256 today = block.timestamp / 1 days;
        require(
            dailyVolume[today] + amount <= DAILY_LIMIT,
            "Daily limit exceeded"
        );
        _;
    }
    
    // 解决方案1：多代币策略
    // 发行 EURS-1, EURS-2 等多个代币，每个有独立限额
    
    // 解决方案2：Layer 2 批处理
    function batchedTransfer(
        bytes calldata transferData
    ) external {
        // 在L2处理小额交易，定期结算到L1
        // L1只记录净额变化，不超限
    }
    
    // 解决方案3：时区轮转
    function getAvailableLimit() view returns (uint256) {
        // 根据用户时区分配限额
        // 亚洲、欧洲、美洲错峰使用
    }
}
</div>
                    
                    <h6>2. 银行牌照要求的影响</h6>
                    <ul>
                        <li><strong>直接影响</strong>：
                            <ul>
                                <li>去中心化稳定币（如DAI）可能被迫关闭或迁移</li>
                                <li>创新速度大幅降低</li>
                                <li>准入门槛提高，小团队无法参与</li>
                            </ul>
                        </li>
                        <li><strong>应对策略</strong>：
                            <ul>
                                <li>协议层与发行层分离</li>
                                <li>使用合规稳定币作为抵押品</li>
                                <li>开发"wrapped"版本的稳定币</li>
                                <li>探索DAO控制的特殊目的银行</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h6>3. 多司法区合规架构</h6>
                    <div class="code-block">
// 模块化合规架构
contract UniversalCompliantStablecoin {
    // 核心模块
    IReserveManager public reserveManager;
    IComplianceEngine public complianceEngine;
    IRedemptionGateway public redemptionGateway;
    
    // 司法区适配器
    mapping(string => IJurisdictionAdapter) public jurisdictions;
    
    struct TransferContext {
        address from;
        address to;
        uint256 amount;
        string fromJurisdiction;
        string toJurisdiction;
    }
    
    function transfer(TransferContext memory ctx) public {
        // 1. 检查发送方司法区规则
        require(
            jurisdictions[ctx.fromJurisdiction]
                .canSend(ctx.from, ctx.amount),
            "Sender jurisdiction check failed"
        );
        
        // 2. 检查接收方司法区规则
        require(
            jurisdictions[ctx.toJurisdiction]
                .canReceive(ctx.to, ctx.amount),
            "Receiver jurisdiction check failed"
        );
        
        // 3. 执行跨司法区合规检查
        complianceEngine.checkCrossBorder(ctx);
        
        // 4. 更新储备报告
        reserveManager.recordTransfer(ctx);
        
        // 5. 执行转账
        _executeTransfer(ctx);
    }
    
    // 司法区特定功能
    function enableJurisdiction(
        string memory code,
        IJurisdictionAdapter adapter
    ) external onlyGovernance {
        // 动态添加新司法区支持
        jurisdictions[code] = adapter;
    }
}

// 示例：欧盟适配器
contract EUAdapter is IJurisdictionAdapter {
    uint256 constant DAILY_LIMIT = 200_000_000e6;
    mapping(uint256 => uint256) public dailyVolume;
    
    function canSend(address user, uint256 amount) 
        external view returns (bool) {
        // 检查KYC状态
        if (!kycRegistry.isVerified(user)) return false;
        
        // 检查日限额
        uint256 today = block.timestamp / 1 days;
        if (dailyVolume[today] + amount > DAILY_LIMIT) {
            return false;
        }
        
        return true;
    }
}
</div>
                    
                    <h5>架构特点：</h5>
                    <ol>
                        <li><strong>模块化设计</strong>：不同功能模块可独立更新</li>
                        <li><strong>司法区隔离</strong>：各地区规则互不影响</li>
                        <li><strong>动态适配</strong>：可快速响应新法规</li>
                        <li><strong>审计友好</strong>：清晰的合规检查路径</li>
                        <li><strong>用户体验</strong>：自动路由最优合规路径</li>
                    </ol>
                </div>
            </div>
        </div>

        <div class="chapter" id="chapter1">
            <h2>第一章：稳定币的区块链基础</h2>
            
            <div class="theory-section">
                <h3>1.1 共识机制及其对稳定币设计的影响</h3>
                
                <p>作为资深程序员和AI科学家，你可能已经熟悉基本的区块链概念。让我们直接深入探讨共识机制如何影响稳定币的设计选择。</p>
                
                <h4>共识机制深度技术分析与性能指标</h4>
                
                <div style="background: #f0f9ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                    <h5>🔍 关键性能指标对比</h5>
                    <table style="width: 100%; font-size: 0.9rem;">
                        <tr>
                            <th style="padding: 8px; text-align: left;">共识机制</th>
                            <th style="padding: 8px;">TPS</th>
                            <th style="padding: 8px;">最终性</th>
                            <th style="padding: 8px;">去中心化度</th>
                            <th style="padding: 8px;">能耗</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>PoW (Bitcoin)</strong></td>
                            <td style="padding: 8px; text-align: center;">7</td>
                            <td style="padding: 8px; text-align: center;">60分钟</td>
                            <td style="padding: 8px; text-align: center;">极高</td>
                            <td style="padding: 8px; text-align: center;">110 TWh/年</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>PoS (Ethereum)</strong></td>
                            <td style="padding: 8px; text-align: center;">30</td>
                            <td style="padding: 8px; text-align: center;">15分钟</td>
                            <td style="padding: 8px; text-align: center;">高</td>
                            <td style="padding: 8px; text-align: center;">0.01 TWh/年</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>Tendermint (Cosmos)</strong></td>
                            <td style="padding: 8px; text-align: center;">10,000</td>
                            <td style="padding: 8px; text-align: center;">6秒</td>
                            <td style="padding: 8px; text-align: center;">中</td>
                            <td style="padding: 8px; text-align: center;">低</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>DPoS (Solana)</strong></td>
                            <td style="padding: 8px; text-align: center;">65,000</td>
                            <td style="padding: 8px; text-align: center;">400毫秒</td>
                            <td style="padding: 8px; text-align: center;">低</td>
                            <td style="padding: 8px; text-align: center;">低</td>
                        </tr>
                    </table>
                </div>
                
                <ul>
                    <li><strong>工作量证明（PoW）- 安全性的黄金标准</strong>
                        <ul>
                            <li><strong>技术特性</strong>：
                                <ul>
                                    <li>中本聪共识：最长链原则</li>
                                    <li>概率性最终性：6个区块确认≈99.9%安全</li>
                                    <li>51%攻击成本：比特币约$150亿/天</li>
                                </ul>
                            </li>
                            <li><strong>对稳定币的影响</strong>：
                                <ul>
                                    <li>交易成本：$1-50（动态费用市场）</li>
                                    <li>确认时间：10-60分钟（不适合即时支付）</li>
                                    <li>MEV风险：三明治攻击可能影响大额交易</li>
                                    <li>适用场景：大额结算、跨境转账</li>
                                </ul>
                            </li>
                            <li><strong>实际案例</strong>：
                                <ul>
                                    <li>Omni USDT：基于比特币，日交易量$1-5亿</li>
                                    <li>WBTC：以太坊上的比特币，用于DeFi</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    
                    <li><strong>权益证明（PoS）- 效率与去中心化的平衡</strong>
                        <ul>
                            <li><strong>技术特性</strong>：
                                <ul>
                                    <li>验证者选择：基于质押量的随机算法</li>
                                    <li>罚没机制：恶意行为导致质押损失</li>
                                    <li>分叉选择规则：LMD-GHOST（以太坊）</li>
                                </ul>
                            </li>
                            <li><strong>对稳定币的影响</strong>：
                                <ul>
                                    <li>Gas优化空间：EIP-1559后更可预测</li>
                                    <li>MEV-Boost：建设者分离带来的新机会</li>
                                    <li>Layer2集成：Optimism/Arbitrum上的稳定币</li>
                                    <li>流动性质押：stETH作为抵押品</li>
                                </ul>
                            </li>
                            <li><strong>性能优化</strong>：
                                <ul>
                                    <li>账户抽象（ERC-4337）：无Gas费稳定币交易</li>
                                    <li>Proto-danksharding：降低L2成本90%+</li>
                                    <li>并行EVM：多核处理提升TPS</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    
                    <li><strong>Byzantine Fault Tolerance (BFT)变种 - 即时最终性</strong>
                        <ul>
                            <li><strong>Tendermint Core（Cosmos生态）</strong>：
                                <ul>
                                    <li>1/3容错：最多33%恶意节点</li>
                                    <li>两阶段提交：propose → prevote → precommit</li>
                                    <li>IBC协议：原生跨链稳定币（如IST）</li>
                                </ul>
                            </li>
                            <li><strong>HotStuff（Diem/Aptos）</strong>：
                                <ul>
                                    <li>线性通信复杂度：O(n)vs O(n²)</li>
                                    <li>流水线共识：3阶段并行</li>
                                    <li>亚秒级最终性：适合支付场景</li>
                                </ul>
                            </li>
                            <li><strong>稳定币优势</strong>：
                                <ul>
                                    <li>确定性结算：无需等待确认</li>
                                    <li>可预测成本：固定手续费</li>
                                    <li>原子互换：跨链DvP（Delivery vs Payment）</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    
                    <li><strong>高性能共识 - 为稳定币优化</strong>
                        <ul>
                            <li><strong>Solana (Proof of History + PoS)</strong>：
                                <ul>
                                    <li>时间戳证明：无需等待网络同步</li>
                                    <li>Gulf Stream：提前转发交易</li>
                                    <li>并行处理：Sealevel运行时</li>
                                    <li>稳定币表现：USDC日交易$50亿+，费用<$0.001</li>
                                </ul>
                            </li>
                            <li><strong>Avalanche (雪崩共识)</strong>：
                                <ul>
                                    <li>亚秒级最终性：重复采样达成共识</li>
                                    <li>子网架构：定制化稳定币链</li>
                                    <li>C-Chain兼容EVM：无缝迁移</li>
                                </ul>
                            </li>
                            <li><strong>Sui/Aptos (并行执行)</strong>：
                                <ul>
                                    <li>Move语言：资产安全性保证</li>
                                    <li>对象模型：稳定币并行转账</li>
                                    <li>状态同步：增量更新降低延迟</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                
                <div class="code-block">
// 共识机制对稳定币设计的影响矩阵
interface ConsensusImpact {
    mechanism: string;
    stablecoin_suitability: {
        micropayments: number;      // 0-10分
        defi_integration: number;   // 0-10分
        cross_border: number;       // 0-10分
        censorship_resistance: number; // 0-10分
    };
    technical_constraints: {
        min_transaction_size: string;  // 经济可行的最小交易
        finality_time: string;         // 最终确认时间
        throughput: string;            // 实际TPS
        mev_exposure: string;          // MEV风险等级
    };
}

const consensusAnalysis: ConsensusImpact[] = [
    {
        mechanism: "Bitcoin PoW",
        stablecoin_suitability: {
            micropayments: 2,
            defi_integration: 3,
            cross_border: 9,
            censorship_resistance: 10
        },
        technical_constraints: {
            min_transaction_size: "$50+ (高手续费)",
            finality_time: "60分钟 (6确认)",
            throughput: "7 TPS",
            mev_exposure: "低 (无智能合约)"
        }
    },
    {
        mechanism: "Ethereum PoS",
        stablecoin_suitability: {
            micropayments: 5,
            defi_integration: 10,
            cross_border: 7,
            censorship_resistance: 8
        },
        technical_constraints: {
            min_transaction_size: "$1+ (L2: $0.01+)",
            finality_time: "15分钟 (2 epochs)",
            throughput: "30 TPS (L1), 2000+ TPS (L2)",
            mev_exposure: "高 (MEV-Boost)"
        }
    },
    {
        mechanism: "Solana PoH+PoS",
        stablecoin_suitability: {
            micropayments: 10,
            defi_integration: 8,
            cross_border: 8,
            censorship_resistance: 5
        },
        technical_constraints: {
            min_transaction_size: "$0.00001+",
            finality_time: "400ms",
            throughput: "5000+ TPS (实际)",
            mev_exposure: "中 (Jito Labs)"
        }
    }
];
                </div>

                <div class="tip">
                    <strong>💡 关键洞察：</strong>共识机制直接影响稳定币的最终性（finality）。在PoW链上，稳定币转账可能需要等待多个区块确认；而在Tendermint等具有即时最终性的共识机制上，稳定币可以实现近乎即时的结算。
                </div>

                <h4>最终性与稳定币设计</h4>
                <p>不同的最终性模型对稳定币系统产生深远影响：</p>
                
                <div class="code-block">
// 伪代码：不同最终性模型下的稳定币转账确认
interface FinalityModel {
    // 概率性最终性（如比特币、以太坊PoW）
    probabilistic: {
        confirmations_needed: 6-12,  // 区块确认数
        reorg_risk: "decreases exponentially",  // 重组风险（区块链回滚的可能性）
        settlement_time: "10-120 minutes"
    },
    
    // 确定性最终性（如Tendermint、以太坊PoS）
    deterministic: {
        confirmations_needed: 1,
        reorg_risk: "none after finalization",
        settlement_time: "6-12 seconds"
    }
}                </div>
            </div>

            <div class="theory-section">
                <h3>1.3 稳定币与PoW、比特币的关系</h3>
                
                <h4>稳定币对PoW的依赖程度</h4>
                <p><strong>结论：稳定币对PoW没有直接依赖，但存在间接关系。</strong></p>
                
                <div style="background: #e0f2fe; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
                    <h5>直接关系分析</h5>
                    <ul>
                        <li><strong>技术层面</strong>：
                            <ul>
                                <li>主流稳定币（USDT、USDC、DAI）主要部署在以太坊（已转PoS）</li>
                                <li>即使在比特币上发行（如Omni USDT），也只是利用其账本功能</li>
                                <li>稳定币的核心功能不依赖于PoW的安全性</li>
                            </ul>
                        </li>
                        <li><strong>实际分布</strong>：
                            <ul>
                                <li>90%+的稳定币在非PoW链上（以太坊PoS、Tron DPoS、BSC PoSA）</li>
                                <li>选择标准是交易成本和速度，而非共识机制</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h5>间接关系</h5>
                    <ul>
                        <li><strong>历史渊源</strong>：稳定币诞生于PoW主导的时代（2014年）</li>
                        <li><strong>信任传递</strong>：比特币的成功证明了区块链可行性</li>
                        <li><strong>基础设施</strong>：早期稳定币借用比特币网络（如Omni Layer）</li>
                        <li><strong>市场需求</strong>：比特币的波动性催生了稳定币需求</li>
                    </ul>
                </div>
                
                <h4>稳定币与比特币的共生关系</h4>
                
                <h5>1. 交易对关系</h5>
                <ul>
                    <li><strong>BTC/USDT</strong>：最大交易对，日交易量$10B+</li>
                    <li><strong>价格发现</strong>：稳定币成为BTC定价基准</li>
                    <li><strong>流动性桥梁</strong>：法币→稳定币→BTC的主要通道</li>
                </ul>
                
                <h5>2. 功能互补</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">特性</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">比特币</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">稳定币</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">角色</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">价值存储、数字黄金</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">交换媒介、记账单位</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">波动性</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">高</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">低</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">使用场景</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">长期投资、对冲通胀</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">日常支付、DeFi操作</td>
                    </tr>
                </table>
                
                <h5>3. 市场行为模式</h5>
                <ul>
                    <li><strong>牛市</strong>：BTC上涨→获利了结到稳定币</li>
                    <li><strong>熊市</strong>：稳定币避险→等待BTC抄底机会</li>
                    <li><strong>震荡</strong>：BTC/稳定币高频交易套利</li>
                </ul>
                
                <h5>稳定币在各链的分布（2024年数据）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">区块链</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">共识机制</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">市场份额</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Ethereum</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoS</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">45%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Tron</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">DPoS</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">35%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">BSC</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoSA</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">10%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Solana</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoH</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Avalanche</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Avalanche共识</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Bitcoin</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoW（仅Omni/RGB）</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">&lt;1%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">其他</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Various</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">1%</td>
                    </tr>
                </table>
                
                <h4>未来展望：后PoW时代的稳定币</h4>
                <div class="warning">
                    <p><strong>关键趋势：</strong></p>
                    <ul>
                        <li><strong>脱离PoW</strong>：以太坊转PoS后，稳定币与PoW的联系进一步减弱</li>
                        <li><strong>多链部署</strong>：追求低成本和高性能，而非特定共识机制</li>
                        <li><strong>Layer 2主导</strong>：Arbitrum、Optimism等L2成为稳定币主战场</li>
                        <li><strong>专用链探索</strong>：如Circle计划的USDC专用链</li>
                    </ul>
                    
                    <p><strong>结论：</strong>稳定币的未来不依赖于PoW，但会继续与比特币保持共生关系——比特币提供价值存储，稳定币提供流动性和可用性。</p>
                </div>
                
                <div class="tip">
                    <strong>💡 思考：</strong>如果比特币也转向PoS（理论假设），对稳定币生态会有什么影响？答案可能是：几乎没有直接影响，因为稳定币已经建立了独立的生态系统。
                </div>
            </div>
            
            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 1.1：共识机制分析</h4>
                </div>
                <p>假设你要设计一个用于跨境支付的稳定币系统，日交易量预计达到100万笔。请分析在以下三种区块链上部署的优缺点：</p>
                <ol>
                    <li>比特币（使用RGB协议或闪电网络）</li>
                    <li>以太坊L1</li>
                    <li>Solana</li>
                </ol>
                <p>考虑因素：交易成本、最终性时间、去中心化程度、开发生态系统</p>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-1')">查看参考答案</button>
                <div id="answer-1-1" class="answer-content">
                    <h5>参考答案：</h5>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <th style="border: 1px solid #ddd; padding: 8px;">特性</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">比特币+闪电网络</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">以太坊L1</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Solana</th>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">交易成本</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">极低（闪电网络）</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">高（$5-50）</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">极低（<$0.01）</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">最终性</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">即时（闪电）/60分钟（L1）</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">12秒</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">400毫秒</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">去中心化</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">最高</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">高</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">中等</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">推荐方案</td>
                            <td colspan="3" style="border: 1px solid #ddd; padding: 8px;">Solana最适合高频交易，但需要额外的去中心化措施。可考虑混合方案：Solana处理日常交易，以太坊作为结算层。</td>
                        </tr>
                    </table>
                    
                    <h5>为什么比特币+闪电网络没有被选中？</h5>
                    <div style="background: #f3f4f6; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                        <p><strong>技术限制：</strong></p>
                        <ul>
                            <li><strong>智能合约能力有限</strong>：比特币脚本语言（Script）功能受限，无法实现复杂的稳定币逻辑（如自动清算、利率调节等）</li>
                            <li><strong>闪电网络的流动性问题</strong>：
                                <ul>
                                    <li>需要预先锁定资金在通道中</li>
                                    <li>大额支付可能找不到足够容量的路由路径</li>
                                    <li>100万笔/天的交易量需要大量流动性提供者</li>
                                </ul>
                            </li>
                            <li><strong>稳定币功能缺失</strong>：
                                <ul>
                                    <li>RGB协议仍在早期，生态不成熟</li>
                                    <li>缺乏原生的价格预言机支持</li>
                                    <li>无法实现自动化的稳定机制（如抵押清算）</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <p><strong>实际考虑：</strong></p>
                        <ul>
                            <li><strong>开发生态</strong>：相比以太坊和Solana，比特币的DeFi开发工具和库极其有限</li>
                            <li><strong>互操作性</strong>：稳定币需要与DeFi生态集成（DEX、借贷等），比特币生态缺乏这些基础设施</li>
                            <li><strong>监管合规</strong>：在比特币上实现KYC/AML等合规功能更加困难</li>
                        </ul>
                        
                        <p><strong>适用场景：</strong></p>
                        <p>比特币+闪电网络更适合：</p>
                        <ul>
                            <li>点对点的小额支付（如小费、微支付）</li>
                            <li>不需要复杂金融逻辑的简单转账</li>
                            <li>强调去中心化和抗审查的场景</li>
                        </ul>
                        
                        <p>但对于需要<strong>日交易量100万笔</strong>的<strong>稳定币系统</strong>，需要：</p>
                        <ul>
                            <li>丰富的智能合约功能</li>
                            <li>成熟的DeFi生态集成</li>
                            <li>高效的批量处理能力</li>
                            <li>灵活的合规工具</li>
                        </ul>
                        <p>这些正是Solana和以太坊的优势所在。</p>
                    </div>
                    </table>
                </div>
            </div>

            <div class="theory-section">
                <h3>1.2 智能合约执行模型跨链对比</h3>
                
                <p>不同区块链的智能合约执行模型对稳定币功能实现有重要影响：</p>

                <h4>账户模型 vs UTXO模型</h4>
                
                <div class="code-block">
// 以太坊账户模型示例
contract AccountBasedStablecoin {
    mapping(address => uint256) public balances;
    
    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}

// Cardano UTXO模型伪代码
UTXOStablecoin {
    // 每个UTXO包含：
    struct UTXO {
        address: ScriptAddress,
        value: {
            ada: Integer,
            stablecoin: Integer
        },
        datum: StablecoinDatum
    }
    
    // 转账需要消费旧UTXO，创建新UTXO
    validator transfer(datum: Datum, redeemer: Redeemer, context: ScriptContext) {
        // 验证签名、金额等
        // 确保输入UTXO总和 = 输出UTXO总和
    }
}                </div>

                <div class="warning">
                    <strong>⚠️ 重要区别：</strong>UTXO模型天然支持并行处理，但实现复杂的DeFi逻辑更困难。账户模型编程直观，但容易产生竞态条件。
                </div>
                
                <h4>深入理解：UTXO vs 账户模型的权衡</h4>
                
                <h5>并行处理能力对比</h5>
                <p><strong>UTXO模型的并行优势：</strong></p>
                <ul>
                    <li><strong>交易独立性</strong>：每个UTXO只能被花费一次，不同UTXO的交易可以并行验证
                        <ul>
                            <li>示例：Alice→Bob和Carol→Dave的交易使用不同UTXO，可同时处理</li>
                            <li>结果：理论吞吐量更高，适合支付场景</li>
                        </ul>
                    </li>
                    <li><strong>无状态竞争</strong>：不存在账户余额的读写竞争
                        <ul>
                            <li>每笔交易明确指定输入输出</li>
                            <li>验证只需检查UTXO是否未花费</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>账户模型的串行瓶颈：</strong></p>
                <ul>
                    <li><strong>状态依赖</strong>：多笔交易修改同一账户时必须串行执行
                        <ul>
                            <li>示例：Alice同时向Bob和Carol转账，需要顺序更新Alice余额</li>
                            <li>以太坊的nonce机制强制交易顺序</li>
                        </ul>
                    </li>
                    <li><strong>竞态条件风险</strong>：
                        <ul>
                            <li>MEV（最大可提取价值）攻击利用交易顺序</li>
                            <li>三明治攻击在DeFi中普遍存在</li>
                        </ul>
                    </li>
                </ul>
                
                <h5>DeFi编程复杂度分析</h5>
                <p><strong>UTXO模型的DeFi挑战：</strong></p>
                <ul>
                    <li><strong>状态管理困难</strong>：
                        <ul>
                            <li>无全局状态概念，需要通过UTXO链传递状态</li>
                            <li>示例：实现ERC20需要为每个余额创建独立UTXO</li>
                        </ul>
                    </li>
                    <li><strong>复杂交互受限</strong>：
                        <ul>
                            <li>多方交互需要预先协调（如原子交换）</li>
                            <li>难以实现复杂的DeFi协议（如Uniswap V3）</li>
                        </ul>
                    </li>
                    <li><strong>解决方案</strong>：
                        <ul>
                            <li>扩展UTXO（eUTXO）：Cardano的Plutus添加datum存储状态</li>
                            <li>Cell模型：Nervos CKB的通用化UTXO</li>
                            <li>RGB协议：在Bitcoin上实现智能合约</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>账户模型的DeFi优势：</strong></p>
                <ul>
                    <li><strong>直观的编程模型</strong>：
                        <ul>
                            <li>合约即账户，拥有持久存储</li>
                            <li>函数调用模式符合传统编程习惯</li>
                        </ul>
                    </li>
                    <li><strong>复杂逻辑支持</strong>：
                        <ul>
                            <li>轻松实现多方交互（如AMM、借贷协议）</li>
                            <li>状态机模型适合复杂业务逻辑</li>
                        </ul>
                    </li>
                    <li><strong>生态系统成熟</strong>：
                        <ul>
                            <li>丰富的开发工具和框架</li>
                            <li>大量可复用的合约库（OpenZeppelin等）</li>
                        </ul>
                    </li>
                </ul>
                
                <h5>稳定币设计的模型选择</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">场景</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">推荐模型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">原因</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">支付型稳定币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">UTXO</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">高并发、隐私性好、防双花</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">DeFi稳定币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">账户</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">复杂交互、可组合性、生态丰富</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">跨链稳定币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">混合</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">不同链采用不同模型，通过桥接适配</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">CBDC</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">UTXO</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">监管友好、审计清晰、批量处理</td>
                    </tr>
                </table>
            </div>

            <div class="practice-section">
                <h3>1.3 实践：在本地Hardhat节点部署"Hello Stablecoin"</h3>
                
                <p>让我们快速搭建开发环境并部署第一个稳定币合约。</p>

                <h4>步骤1：环境搭建</h4>
                <div class="code-block">
# 安装必要工具
npm init -y
npm install --save-dev hardhat @openzeppelin/contracts
npm install --save-dev @nomicfoundation/hardhat-toolbox

# 初始化Hardhat项目
npx hardhat init
# 选择 "Create a JavaScript project"                </div>

                <h4>步骤2：编写最小化的中心化稳定币合约</h4>
                <p>让我们实现一个更贴近真实USDT/USDC的合约，展示中心化稳定币的核心特征：</p>
                
                <div class="code-block">
// contracts/CentralizedStablecoin.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// 导入OpenZeppelin标准合约库 - 行业最佳实践
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title CentralizedStablecoin
 * @dev 最小化的法币抵押型稳定币实现
 * 展示了USDT/USDC等中心化稳定币的核心机制
 */
contract CentralizedStablecoin is ERC20, Ownable, Pausable {
    // 状态变量
    uint8 private constant DECIMALS = 6;  // USDC标准精度
    mapping(address => bool) public blacklisted;  // 黑名单机制
    
    // 事件定义 - 用于链上活动追踪
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed from, uint256 amount);
    event Blacklist(address indexed account, bool status);
    event Redeem(address indexed from, uint256 amount, string txId);
    
    // 修饰符 - 可重用的访问控制
    modifier notBlacklisted(address account) {
        require(!blacklisted[account], "Account is blacklisted");
        _;
    }
    
    constructor() ERC20("Centralized Stablecoin", "CSTABLE") Ownable(msg.sender) {
        // 部署时不铸造初始供应量 - 符合真实稳定币模式
    }
    
    function decimals() public pure override returns (uint8) {
        return DECIMALS;
    }
    
    /**
     * @notice 铸造新代币 - 对应用户存入法币
     * @dev 只有owner可调用，模拟KYC后的法币存入流程
     * @param to 接收代币的地址
     * @param amount 铸造数量（最小单位）
     */
    function mint(address to, uint256 amount) 
        external 
        onlyOwner 
        notBlacklisted(to) 
        whenNotPaused 
    {
        _mint(to, amount);
        emit Mint(to, amount);
    }
    
    /**
     * @notice 销毁代币并记录赎回请求
     * @dev 实际稳定币需要链下处理法币提现
     * @param amount 销毁数量
     * @param txId 链下银行转账ID（用于审计）
     */
    function redeem(uint256 amount, string memory txId) 
        external 
        notBlacklisted(msg.sender) 
        whenNotPaused 
    {
        _burn(msg.sender, amount);
        emit Redeem(msg.sender, amount, txId);
    }
    
    /**
     * @notice 黑名单管理 - 合规要求
     * @dev 被黑名单的地址无法转账
     */
    function setBlacklist(address account, bool status) 
        external 
        onlyOwner 
    {
        blacklisted[account] = status;
        emit Blacklist(account, status);
    }
    
    /**
     * @notice 紧急暂停 - 应对安全事件
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @notice 重写transfer函数，加入黑名单和暂停检查
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);
        
        require(!paused(), "Token transfers are paused");
        require(!blacklisted[from], "Sender is blacklisted");
        require(!blacklisted[to], "Recipient is blacklisted");
    }
}

// 思考题：
// 1. 这个合约的中心化风险点在哪里？如何通过多签改进？
// 2. 如何实现合约升级？（提示：代理模式）
// 3. 黑名单机制的法律和道德影响是什么？
// 4. 如何增加审计日志功能来提高透明度？
                </div>
                
                <div class="tip">
                    <strong>💡 关键洞察：</strong>这个合约展示了中心化稳定币的核心特征：
                    <ul>
                        <li>单点控制（owner权限）</li>
                        <li>合规功能（黑名单、暂停）</li>
                        <li>链上记账，链下结算的模式</li>
                        <li>信任依赖于发行方而非代码</li>
                    </ul>
                </div>
                
                <h4>链上 vs 链下：理解稳定币的双重世界</h4>
                <div style="background: #e0f2fe; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
                    <p><strong>关键概念澄清：</strong></p>
                    <ul>
                        <li><strong>链上（On-chain）</strong>：
                            <ul>
                                <li>ERC-20合约是一个<strong>权威的IOU（我欠你）记账本</strong></li>
                                <li><code>balanceOf</code>返回的不是美元，而是<strong>发行方承诺兑付的美元债权</strong></li>
                                <li><code>transfer</code>转移的是<strong>债权记录</strong>，不是实际美元</li>
                            </ul>
                        </li>
                        <li><strong>链下（Off-chain）</strong>：
                            <ul>
                                <li>真实的美元储备在传统银行账户中</li>
                                <li>KYC/AML合规流程完全在链外进行</li>
                                <li>审计报告、监管文件等都是链下活动</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <div class="warning" style="margin-top: 1rem;">
                        <strong>⚠️ 常见误解：</strong>智能合约本身<strong>不知道</strong>也<strong>不保管</strong>任何美元。它只是一个由中心化实体控制的数字账本。用户的信任基础是发行方的信誉、监管合规和审计报告，而非智能合约代码。
                    </div>
                </div>

                <h4>步骤3：部署脚本</h4>
                <div class="code-block">
// scripts/deploy.js
async function main() {
    const [deployer] = await ethers.getSigners();
    console.log("部署账户:", deployer.address);
    
    const HelloStablecoin = await ethers.getContractFactory("HelloStablecoin");
    const stablecoin = await HelloStablecoin.deploy();
    await stablecoin.deployed();
    
    console.log("HelloStablecoin 部署地址:", stablecoin.address);
    
    // 验证初始余额
    const balance = await stablecoin.balanceOf(deployer.address);
    console.log("部署者余额:", ethers.utils.formatUnits(balance, 6), "HELLO");
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});                </div>

                <h4>步骤4：运行本地节点并部署</h4>
                <div class="code-block">
# 终端1：启动本地节点
npx hardhat node

# 终端2：部署合约
npx hardhat run scripts/deploy.js --network localhost                </div>
                
                <h4>步骤5：编写测试用例</h4>
                <p>专业的智能合约开发必须包含完整的测试。让我们为核心功能编写测试：</p>
                
                <div class="code-block">
// test/CentralizedStablecoin.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("CentralizedStablecoin", function () {
    let stablecoin;
    let owner;
    let addr1;
    let addr2;
    
    beforeEach(async function () {
        // 获取测试账户
        [owner, addr1, addr2] = await ethers.getSigners();
        
        // 部署合约
        const CentralizedStablecoin = await ethers.getContractFactory("CentralizedStablecoin");
        stablecoin = await CentralizedStablecoin.deploy();
        await stablecoin.deployed();
    });
    
    describe("铸造功能", function () {
        it("只有owner可以铸造", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            
            // owner铸造成功
            await expect(stablecoin.mint(addr1.address, amount))
                .to.emit(stablecoin, "Mint")
                .withArgs(addr1.address, amount);
            
            // 非owner铸造失败
            await expect(
                stablecoin.connect(addr1).mint(addr2.address, amount)
            ).to.be.revertedWith("Ownable: caller is not the owner");
        });
        
        it("不能向黑名单地址铸造", async function () {
            // 先将addr1加入黑名单
            await stablecoin.setBlacklist(addr1.address, true);
            
            // 尝试铸造应该失败
            await expect(
                stablecoin.mint(addr1.address, 1000)
            ).to.be.revertedWith("Account is blacklisted");
        });
    });
    
    describe("黑名单功能", function () {
        it("黑名单地址无法转账", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            
            // 先铸造一些代币
            await stablecoin.mint(addr1.address, amount);
            
            // 正常转账应该成功
            await stablecoin.connect(addr1).transfer(addr2.address, amount);
            
            // 将addr1加入黑名单
            await stablecoin.setBlacklist(addr1.address, true);
            
            // 黑名单地址转账应该失败
            await expect(
                stablecoin.connect(addr2).transfer(addr1.address, amount)
            ).to.be.revertedWith("Recipient is blacklisted");
        });
    });
    
    describe("暂停功能", function () {
        it("暂停时无法转账", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            await stablecoin.mint(addr1.address, amount);
            
            // 暂停合约
            await stablecoin.pause();
            
            // 转账应该失败
            await expect(
                stablecoin.connect(addr1).transfer(addr2.address, amount)
            ).to.be.revertedWith("Token transfers are paused");
            
            // 恢复后可以转账
            await stablecoin.unpause();
            await expect(
                stablecoin.connect(addr1).transfer(addr2.address, amount)
            ).to.not.be.reverted;
        });
    });
    
    describe("赎回功能", function () {
        it("可以销毁代币并记录赎回请求", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            const txId = "BANK_TX_12345";
            
            // 铸造代币
            await stablecoin.mint(addr1.address, amount);
            
            // 赎回
            await expect(
                stablecoin.connect(addr1).redeem(amount, txId)
            )
                .to.emit(stablecoin, "Redeem")
                .withArgs(addr1.address, amount, txId);
            
            // 检查余额为0
            expect(await stablecoin.balanceOf(addr1.address)).to.equal(0);
        });
    });
});

// 运行测试
// npx hardhat test
// 运行测试并查看覆盖率
// npx hardhat coverage
                </div>
                
                <div class="tip">
                    <strong>💡 测试最佳实践：</strong>
                    <ul>
                        <li>使用<code>beforeEach</code>确保每个测试的独立性</li>
                        <li>测试正常情况和异常情况</li>
                        <li>使用事件断言验证状态变化</li>
                        <li>测试访问控制和权限管理</li>
                        <li>追求高测试覆盖率（>95%）</li>
                    </ul>
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 1.2：扩展功能</h4>
                </div>
                <p>基于HelloStablecoin，实现以下功能：</p>
                <ol>
                    <li>添加暂停（pause）功能，允许所有者在紧急情况下暂停所有转账</li>
                    <li>实现黑名单机制，被加入黑名单的地址无法发送或接收代币</li>
                    <li>添加转账费用功能，每次转账收取0.1%的费用到指定地址</li>
                </ol>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-2')">查看参考答案</button>
                <div id="answer-1-2" class="answer-content">
                    <h5>参考答案：</h5>
                    <div class="code-block">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract AdvancedHelloStablecoin is ERC20, Ownable, Pausable {
    uint8 private constant DECIMALS = 6;
    uint256 private constant FEE_RATE = 10; // 0.1% = 10/10000
    
    address public feeCollector;
    mapping(address => bool) public blacklist;
    
    event AddedToBlacklist(address indexed account);
    event RemovedFromBlacklist(address indexed account);
    event FeeCollectorUpdated(address indexed newCollector);
    event FeesCollected(address indexed from, address indexed to, uint256 feeAmount);
    
    modifier notBlacklisted(address account) {
        require(!blacklist[account], "Account is blacklisted");
        _;
    }
    
    constructor(address _feeCollector) ERC20("Advanced Hello Stablecoin", "AHELLO") {
        require(_feeCollector != address(0), "Invalid fee collector");
        feeCollector = _feeCollector;
        _mint(msg.sender, 1000000 * 10**DECIMALS);
    }
    
    function decimals() public pure override returns (uint8) {
        return DECIMALS;
    }
    
    // 暂停功能
    function pause() public onlyOwner {
        _pause();
    }
    
    function unpause() public onlyOwner {
        _unpause();
    }
    
    // 黑名单管理
    function addToBlacklist(address account) public onlyOwner {
        require(account != address(0), "Invalid address");
        require(!blacklist[account], "Already blacklisted");
        blacklist[account] = true;
        emit AddedToBlacklist(account);
    }
    
    function removeFromBlacklist(address account) public onlyOwner {
        require(blacklist[account], "Not blacklisted");
        blacklist[account] = false;
        emit RemovedFromBlacklist(account);
    }
    
    // 更新费用收集地址
    function updateFeeCollector(address newCollector) public onlyOwner {
        require(newCollector != address(0), "Invalid fee collector");
        feeCollector = newCollector;
        emit FeeCollectorUpdated(newCollector);
    }
    
    // 重写transfer函数以添加费用逻辑
    function transfer(address to, uint256 amount) public override 
        whenNotPaused 
        notBlacklisted(msg.sender) 
        notBlacklisted(to) 
        returns (bool) 
    {
        uint256 feeAmount = (amount * FEE_RATE) / 10000;
        uint256 netAmount = amount - feeAmount;
        
        // 转账净额给接收者
        super.transfer(to, netAmount);
        
        // 如果有费用，转给费用收集者
        if (feeAmount > 0) {
            super.transfer(feeCollector, feeAmount);
            emit FeesCollected(msg.sender, to, feeAmount);
        }
        
        return true;
    }
    
    // 重写transferFrom函数
    function transferFrom(address from, address to, uint256 amount) public override 
        whenNotPaused 
        notBlacklisted(from) 
        notBlacklisted(to) 
        returns (bool) 
    {
        uint256 feeAmount = (amount * FEE_RATE) / 10000;
        uint256 netAmount = amount - feeAmount;
        
        // 使用批准的额度进行转账
        super.transferFrom(from, to, netAmount);
        
        // 如果有费用，从发送者转给费用收集者
        if (feeAmount > 0) {
            super.transferFrom(from, feeCollector, feeAmount);
            emit FeesCollected(from, to, feeAmount);
        }
        
        return true;
    }
    
    // 铸造和销毁功能
    function mint(address to, uint256 amount) public onlyOwner notBlacklisted(to) {
        _mint(to, amount);
    }
    
    function burn(uint256 amount) public notBlacklisted(msg.sender) {
        _burn(msg.sender, amount);
    }
}                    </div>
                    
                    <h5>测试脚本示例：</h5>
                    <div class="code-block">
const { expect } = require("chai");  // Chai测试断言库

describe("AdvancedHelloStablecoin", function () {
    let stablecoin, owner, addr1, addr2, feeCollector;
    
    beforeEach(async function () {
        [owner, addr1, addr2, feeCollector] = await ethers.getSigners();
        const Contract = await ethers.getContractFactory("AdvancedHelloStablecoin");
        stablecoin = await Contract.deploy(feeCollector.address);
        await stablecoin.deployed();
    });
    
    it("应该正确收取转账费用", async function () {
        const amount = ethers.utils.parseUnits("1000", 6);
        await stablecoin.transfer(addr1.address, amount);
        
        // addr1转账100 AHELLO给addr2
        const transferAmount = ethers.utils.parseUnits("100", 6);
        await stablecoin.connect(addr1).transfer(addr2.address, transferAmount);
        
        // 检查余额：addr2应该收到99.9，费用收集者收到0.1
        expect(await stablecoin.balanceOf(addr2.address))
            .to.equal(ethers.utils.parseUnits("99.9", 6));
        expect(await stablecoin.balanceOf(feeCollector.address))
            .to.equal(ethers.utils.parseUnits("0.1", 6));
    });
    
    it("黑名单地址无法转账", async function () {
        await stablecoin.addToBlacklist(addr1.address);
        await expect(
            stablecoin.transfer(addr1.address, 100)
        ).to.be.revertedWith("Account is blacklisted");
    });
});                    </div>
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 1.3：Gas优化挑战</h4>
                </div>
                <p>上面的AdvancedHelloStablecoin实现有几个Gas优化的机会。请识别并实现至少3个优化点，使transfer函数的Gas消耗降低至少20%。</p>
                
                <p>提示：</p>
                <ul>
                    <li>存储槽打包</li>
                    <li>避免重复的存储读取</li>
                    <li>使用assembly进行关键操作</li>
                </ul>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-3')">查看参考答案</button>
                <div id="answer-1-3" class="answer-content">
                    <h5>优化版本：</h5>
                    <div class="code-block">
<code>contract GasOptimizedStablecoin is ERC20, Ownable, Pausable {
    // 优化1：将相关变量打包到一个存储槽
    struct Config {
        uint8 decimals;      // 1 byte
        uint16 feeRate;      // 2 bytes (允许更精确的费率)
        bool paused;         // 1 byte
        address feeCollector; // 20 bytes
    }
    Config public config;
    
    // 优化2：使用uint256而不是bool映射（某些情况下更高效）
    mapping(address => uint256) public blacklistStatus; // 0 = 未黑名单, 1 = 已黑名单
    
    // 优化3：缓存常用计算
    uint256 private constant FEE_DENOMINATOR = 100000; // 允许0.001%精度
    
    constructor(address _feeCollector) ERC20("Gas Optimized Stablecoin", "GSTABLE") {
        config = Config({
            decimals: 6,
            feeRate: 100, // 0.1% = 100/100000
            paused: false,
            feeCollector: _feeCollector
        });
        _mint(msg.sender, 1000000 * 10**6);
    }
    
    // 优化4：使用自定义错误而不是字符串（节省部署和运行时Gas）
    error Blacklisted(address account);
    error TransferPaused();
    error InvalidAmount();
    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal view override {
        // 优化5：单次存储读取
        Config memory _config = config;
        
        if (_config.paused) revert TransferPaused();
        if (blacklistStatus[from] == 1) revert Blacklisted(from);
        if (blacklistStatus[to] == 1) revert Blacklisted(to);
    }
    
    // 优化6：优化的transfer实现
    function transfer(address to, uint256 amount) public override returns (bool) {
        address owner = _msgSender();
        
        // 优化7：避免小额转账的费用计算
        if (amount < 1000) {
            _transfer(owner, to, amount);
            return true;
        }
        
        // 优化8：使用位运算计算费用（当费率是2的幂时）
        Config memory _config = config;
        uint256 feeAmount = (amount * _config.feeRate) / FEE_DENOMINATOR;
        uint256 netAmount;
        
        // 优化9：使用unchecked块避免溢出检查（已知安全）
        unchecked {
            netAmount = amount - feeAmount;
        }
        
        // 优化10：批量更新余额以减少SSTORE操作
        _transfer(owner, to, netAmount);
        if (feeAmount > 0) {
            _transfer(owner, _config.feeCollector, feeAmount);
        }
        
        return true;
    }
    
    // 优化11：使用assembly优化关键路径
    function balanceOf(address account) public view override returns (uint256) {
        uint256 balance;
        assembly {
            // 直接读取存储槽
            mstore(0x00, account)
            mstore(0x20, 0) // balances mapping的槽位
            let slot := keccak256(0x00, 0x40)
            balance := sload(slot)
        }
        return balance;
    }
}                    </div>
                    
                    <h5>Gas对比测试：</h5>
                    <div class="code-block">
// Gas消耗对比（近似值）
// 原始版本 transfer: ~65,000 gas
// 优化版本 transfer: ~48,000 gas
// 节省: ~26%

// 额外优化建议：
// 1. 使用专门的批量转账函数
// 2. 实现EIP-2612 permit功能，避免approve+transferFrom
// 3. 考虑使用代理模式分离逻辑和存储                    </div>
                </div>
            </div>

            <div class="theory-section">
                <h3>1.3 Gas经济学与优化策略</h3>
                
                <p>Gas优化对稳定币至关重要，因为它们通常有高频交易需求。让我们深入了解各种优化技术：</p>

                <h4>存储优化技术</h4>
                <div class="code-block">
// 存储槽打包示例
contract StorageOptimized {
    // 差劣实践：每个变量占用一个槽（32字节）
    uint8 public decimals;        // 槽0：使用1字节，浪费31字节
    address public owner;         // 槽1：使用20字节，浪费12字节  
    uint16 public feeRate;        // 槽2：使用2字节，浪费30字节
    bool public paused;           // 槽3：使用1字节，浪费31字节
    
    // 优化实践：打包到2个槽
    struct PackedData {
        uint8 decimals;    // 1字节
        bool paused;       // 1字节
        uint16 feeRate;    // 2字节
        address owner;     // 20字节
        uint64 timestamp;  // 8字节
        // 总计：32字节 = 1个槽
    }
}                </div>

                <div class="tip">
                    <strong>💡 EVM存储规则：</strong>
                    <ul>
                        <li>SSTORE（存储写入）：20,000 gas（冷槽）或 2,900 gas（热槽）</li>
                        <li>SLOAD（存储读取）：2,100 gas（冷槽）或 100 gas（热槽）</li>
                        <li>内存操作：3 gas per 32字节</li>
                    </ul>
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>综合练习：设计高性能稳定币架构</h4>
                </div>
                <p>基于本章所学，设计一个能够支持以下需求的稳定币架构：</p>
                <ul>
                    <li>每秒处理10,000笔交易</li>
                    <li>平均交易成本低于$0.01</li>
                    <li>支持跨链转账（至少3条链）</li>
                    <li>具备紧急暂停和恢复机制</li>
                    <li>兼容主流DeFi协议</li>
                </ul>
                <p>请提供：架构图、核心合约接口、Gas估算、安全考虑</p>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-4')">查看参考答案</button>
                <div id="answer-1-4" class="answer-content">
                    <h5>参考架构方案：</h5>
                    <pre>
┌─────────────────────────────────────────────────────────┐
│                     用户界面层                           │
├─────────────────────────────────────────────────────────┤
│                    路由器合约                            │
│  (智能路由选择最优链和Layer2)                           │
├──────────────┬──────────────┬───────────────────────────┤
│   Polygon    │  Arbitrum    │      Optimism            │
│  (高频小额)  │  (DeFi集成)  │    (通用交易)            │
├──────────────┴──────────────┴───────────────────────────┤
│                 跨链消息层 (LayerZero/Axelar)           │
├─────────────────────────────────────────────────────────┤
│                以太坊主网（结算层）                       │
│          - 主稳定币合约                                  │
│          - 抵押品管理                                    │
│          - 治理合约                                      │
└─────────────────────────────────────────────────────────┘
                    </pre>
                    
                    <h5>核心合约接口：</h5>
                    <div class="code-block">
<code>interface IHighPerformanceStablecoin {
    // 基础ERC20功能
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    
    // 批量操作（Gas优化）
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external returns (bool);
    
    // 跨链功能
    function crossChainTransfer(
        uint16 destChainId,
        address recipient,
        uint256 amount,
        bytes calldata adapterParams
    ) external payable;
    
    // Layer2优化
    function depositToL2(uint256 amount, uint16 l2ChainId) external;
    function withdrawFromL2(uint256 amount, bytes calldata proof) external;
    
    // 紧急控制
    function pause() external; // 仅治理可调用
    function unpause() external;
    
    // DeFi集成钩子
    function beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// L2优化版本
contract L2OptimizedStablecoin {
    // 使用压缩的余额存储（适合稳定币）
    mapping(address => uint128) private packedBalances;
    
    // 签名批量转账（类似Uniswap Permit2）
    function transferWithSignature(
        TransferData calldata transfer,
        bytes calldata signature
    ) external {
        // 验证签名并执行转账
        // 避免多次approve操作
    }
}                    </div>
                    
                    <h5>Gas成本估算：</h5>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <th style="border: 1px solid #ddd; padding: 8px;">操作</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">L1成本</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">L2成本</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">USD成本(@$2000 ETH)</th>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">单笔转账</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">65,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">21,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">$0.002</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">批量转账(10笔)</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">180,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">80,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">$0.008</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">跨链转账</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">150,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">N/A</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">$0.015</td>
                        </tr>
                    </table>
                    
                    <h5>安全考虑：</h5>
                    <ol>
                        <li><strong>多签治理：</strong>关键操作需要3/5多签</li>
                        <li><strong>时间锁：</strong>所有治理操作48小时延迟</li>
                        <li><strong>断路器：</strong>异常大额转账自动暂停</li>
                        <li><strong>审计要求：</strong>每个L2部署独立审计</li>
                        <li><strong>跨链风险：</strong>设置每日跨链限额</li>
                    </ol>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>本章重点术语速查表</h3>
                
                <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                    <tr style="background: #f3f4f6;">
                        <th style="border: 1px solid #ddd; padding: 12px; width: 20%;">缩写/术语</th>
                        <th style="border: 1px solid #ddd; padding: 12px; width: 25%;">英文全称</th>
                        <th style="border: 1px solid #ddd; padding: 12px; width: 20%;">中文</th>
                        <th style="border: 1px solid #ddd; padding: 12px; width: 35%;">简要说明</th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>PoW</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Proof of Work</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">工作量证明</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">通过计算难题竞争记账权的共识机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>PoS</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Proof of Stake</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">权益证明</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">根据持币量和时间获得记账权的共识机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>DPoS</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Delegated Proof of Stake</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">委托权益证明</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">持币者投票选出验证者的共识机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>UTXO</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Unspent Transaction Output</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">未花费交易输出</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">比特币使用的账本模型</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>EVM</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Ethereum Virtual Machine</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">以太坊虚拟机</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">执行智能合约的运行环境</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>L1/L2</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Layer 1/Layer 2</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">第一层/第二层</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">主链/扩容解决方案</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>Gas</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">-</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">燃料费</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">执行交易或合约所需的计算费用</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>Oracle</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">-</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">预言机</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">向区块链提供外部数据的服务</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong><span class="tooltip">CDP<span class="tooltip-content">抵押债仓，锁定抵押品借出稳定币的智能合约仓位</span></span></strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Collateralized Debt Position</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">抵押债仓</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">锁定抵押品借出稳定币的仓位</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>DSR</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">DAI Savings Rate</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">DAI储蓄率</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">持有DAI获得的利息率</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>TWAP</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Time-Weighted Average Price</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">时间加权平均价格</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">防闪电贷攻击的价格计算方式</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>KYC/AML</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Know Your Customer/Anti-Money Laundering</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">了解你的客户/反洗钱</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">金融合规要求</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>RWA</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Real World Assets</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">现实世界资产</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">链下资产的链上表示</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>DEX</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Decentralized Exchange</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">去中心化交易所</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">无需信任第三方的交易平台</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>AMM</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Automated Market Maker</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">自动做市商</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">使用算法定价的交易机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>TVL</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Total Value Locked</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">总锁仓价值</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">DeFi协议中锁定的资产总值</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>APY/APR</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Annual Percentage Yield/Rate</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">年化收益率/年利率</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">复利收益率/简单利率</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>BFT</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Byzantine Fault Tolerance</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">拜占庭容错</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">容忍部分节点恶意行为的共识算法</td>
                    </tr>
                </table>
                
                <div class="tip" style="margin-top: 1rem;">
                    <strong>💡 学习建议：</strong>掌握这些术语是深入理解稳定币生态的基础。建议将此表作为参考，在阅读后续章节时随时查阅。
                </div>
            </div>
        </div>
        
        <!-- 第二章：稳定币分类与经济模型 -->
        <div class="chapter" id="chapter2">
            <h2>第二章：稳定币分类与经济模型</h2>
            
            <div class="theory-section">
                <h3>2.1 法币抵押型稳定币（Fiat-Collateralized）</h3>
                
                <p>法币抵押型稳定币是最直观的稳定币模型，通过持有等值的法币储备来保证稳定币价值。这类稳定币是目前市场份额最大的类型。</p>
                
                <h4>核心机制</h4>
                <div style="background: #f0f9ff; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>1:1储备模型</strong>
                    <ul>
                        <li><strong>铸造（Mint）</strong>：用户存入$1法币 → 发行1个稳定币</li>
                        <li><strong>赎回（Redeem）</strong>：用户销毁1个稳定币 → 取回$1法币</li>
                        <li><strong>储备证明</strong>：定期审计确保100%储备率</li>
                    </ul>
                </div>
                
                <h4>主要代表：USDC（USD Coin）</h4>
                <h5>技术架构</h5>
                <div class="code-block">
// USDC核心合约简化版
contract FiatTokenV2_1 is FiatTokenV2 {
    // 关键角色
    address public masterMinter;    // 主铸币者
    mapping(address => bool) public minters;    // 授权铸币者
    mapping(address => uint256) public minterAllowed;    // 铸币配额
    
    // 铸币功能（仅授权铸币者）
    function mint(address _to, uint256 _amount) 
        external 
        onlyMinters 
        notBlacklisted(msg.sender) 
        notBlacklisted(_to) 
        returns (bool) {
        require(_to != address(0), "Mint to zero address");
        require(_amount > 0, "Mint amount not greater than 0");
        
        uint256 mintingAllowedAmount = minterAllowed[msg.sender];
        require(_amount <= mintingAllowedAmount, "Mint amount exceeds allowed");
        
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);
        
        emit Mint(msg.sender, _to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }
    
    // 销毁功能（任何持币者）
    function burn(uint256 _amount) 
        external 
        whenNotPaused 
        notBlacklisted(msg.sender) {
        uint256 balance = balances[msg.sender];
        require(_amount > 0, "Burn amount not greater than 0");
        require(balance >= _amount, "Burn amount exceeds balance");
        
        totalSupply_ = totalSupply_.sub(_amount);
        balances[msg.sender] = balance.sub(_amount);
        
        emit Burn(msg.sender, _amount);
        emit Transfer(msg.sender, address(0), _amount);
    }
}
                </div>
                
                <h5>储备资产构成（2024年数据）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">资产类型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">比例</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">风险等级</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">现金存款</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">20%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">低</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">短期美国国债</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">80%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">极低</td>
                    </tr>
                </table>
                
                <h4>主要代表：USDT（Tether）</h4>
                <h5>储备资产构成（2024年Q1）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">资产类型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">金额（十亿美元）</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">比例</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">美国国债</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$90.9B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">84.5%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">隔夜逆回购</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$8.3B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">7.7%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">货币市场基金</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$5.3B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">4.9%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">比特币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$3.2B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3.0%</td>
                    </tr>
                </table>
                
                <h4>优缺点分析</h4>
                <div class="tip">
                    <strong>优点：</strong>
                    <ul>
                        <li>简单直观，易于理解</li>
                        <li>价格稳定性最高</li>
                        <li>流动性充足</li>
                        <li>适合大额交易和机构使用</li>
                    </ul>
                </div>
                
                <div class="warning">
                    <strong>缺点与风险：</strong>
                    <ul>
                        <li><strong>中心化风险</strong>：单点故障，可能被冻结</li>
                        <li><strong>监管风险</strong>：受政府监管影响</li>
                        <li><strong>交易对手风险</strong>：银行破产风险（如2023年3月硅谷银行倒闭导致USDC脱锚）</li>
                        <li><strong>透明度问题</strong>：需要信任第三方审计</li>
                    </ul>
                </div>
                
                <h4>2024年最新发展：PayPal USD (PYUSD)</h4>
                <p>传统金融巨头进军稳定币市场的里程碑案例。</p>
                
                <h5>技术架构与合规性</h5>
                <ul>
                    <li><strong>发行方</strong>：Paxos Trust Company（受纽约州金融服务部NYDFS监管）</li>
                    <li><strong>技术标准</strong>：ERC-20代币，部署在以太坊主网</li>
                    <li><strong>独特之处</strong>：
                        <ul>
                            <li>PayPal生态内原生集成（3.8亿活跃用户）</li>
                            <li>支持PayPal内部转账免手续费</li>
                            <li>可在DeFi协议中使用（开放性）</li>
                        </ul>
                    </li>
                    <li><strong>战略意义</strong>：
                        <ul>
                            <li>TradFi与DeFi的桥梁</li>
                            <li>为其他支付公司提供参考模板</li>
                            <li>推动稳定币主流化采用</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>监管合规最新进展</h4>
                
                <h5>欧盟MiCA法规（2024年生效）</h5>
                <ul>
                    <li><strong>资产分类</strong>：
                        <ul>
                            <li>EMT（E-Money Token）：单一法币锚定</li>
                            <li>ART（Asset-Referenced Token）：多资产锚定</li>
                        </ul>
                    </li>
                    <li><strong>核心要求</strong>：
                        <ul>
                            <li>储备资产必须1:1支持，存放于受监管托管机构</li>
                            <li>每日交易上限：EMT为2亿欧元</li>
                            <li>白皮书必须获得监管批准</li>
                            <li>算法稳定币受到严格限制</li>
                        </ul>
                    </li>
                    <li><strong>影响</strong>：Circle已在法国申请许可，USDC将符合MiCA要求</li>
                </ul>
                
                <h5>美国监管动态</h5>
                <ul>
                    <li><strong>Stablecoin TRUST Act</strong>：要求100%现金或短期国债储备</li>
                    <li><strong>州级创新</strong>：怀俄明州SPDI（特殊目的存款机构）框架</li>
                    <li><strong>联邦层面</strong>：SEC与CFTC管辖权之争仍在继续</li>
                </ul>
            </div>
            
            <div class="theory-section">
                <h3>2.2 加密货币抵押型稳定币（Crypto-Collateralized）</h3>
                
                <p>加密货币抵押型稳定币通过超额抵押加密资产来维持价值稳定，是DeFi生态系统的核心组成部分。</p>
                
                <h4>核心概念：超额抵押</h4>
                <div style="background: #f0fdf4; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <p><strong>为什么需要超额抵押？</strong></p>
                    <ul>
                        <li>加密资产价格波动大</li>
                        <li>需要缓冲空间防止资不抵债</li>
                        <li>激励及时还款和风险管理</li>
                    </ul>
                    <p><strong>典型抵押率：</strong>150% - 200%（借$100需要抵押$150-$200的资产）</p>
                </div>
                
                <h4>主要代表：DAI（MakerDAO）</h4>
                <h5>系统架构</h5>
                <div class="code-block">
// Maker协议核心组件简化
contract Vat {  // 核心会计引擎
    // CDP（现称Vault）状态
    struct Ilk {  // 抵押品类型
        uint256 Art;   // 总债务
        uint256 rate;  // 累积稳定费率
        uint256 spot;  // 价格（带安全边际）
        uint256 line;  // 债务上限
        uint256 dust;  // 最小债务额
    }
    
    struct Urn {  // 用户金库
        uint256 ink;   // 抵押品数量
        uint256 art;   // 标准化债务
    }
    
    mapping (bytes32 => Ilk) public ilks;  // 抵押品类型
    mapping (bytes32 => mapping (address => Urn)) public urns;  // 用户金库
    
    // 开仓（抵押品锁定，DAI生成）
    function frob(
        bytes32 i,      // 抵押品类型
        address u,      // 金库地址
        address v,      // 抵押品来源
        address w,      // DAI接收地址
        int dink,       // 抵押品变化
        int dart        // 债务变化
    ) external {
        Urn memory urn = urns[i][u];
        Ilk memory ilk = ilks[i];
        
        urn.ink = add(urn.ink, dink);
        urn.art = add(urn.art, dart);
        ilk.Art = add(ilk.Art, dart);
        
        // 检查抵押率
        uint dtab = mul(ilk.rate, dart);
        uint tab = mul(ilk.rate, urn.art);
        require(either(dart <= 0, both(
            mul(ilk.Art, ilk.rate) <= ilk.line,  // 债务上限
            tab <= mul(urn.ink, ilk.spot)        // 抵押率要求
        )), "Vat/not-safe");
        
        require(either(dart <= 0, tab >= ilk.dust), "Vat/dust");
        
        urns[i][u] = urn;
        ilks[i] = ilk;
    }
}

// 清算模块
contract Dog {  // Liquidation Engine 2.0
    struct Ilk {
        address clip;  // 拍卖合约地址
        uint256 chop;  // 清算罚金
        uint256 hole;  // 最大同时拍卖金额
        uint256 dirt;  // 当前拍卖金额
    }
    
    // 触发清算
    function bark(
        bytes32 ilk,    // 抵押品类型
        address urn,    // 待清算金库
        address kpr     // 清算人（获得奖励）
    ) external returns (uint256 id) {
        require(live == 1, "Dog/not-live");
        
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        Ilk memory milk = ilks[ilk];
        uint256 dart = art;
        
        // 检查是否可清算
        require(milk.chop > 0, "Dog/ilk-not-init");
        uint256 room = sub(milk.hole, milk.dirt);
        require(room > 0 && dart > 0, "Dog/liquidation-limit-hit");
        
        // 计算清算金额
        uint256 dink = ink;
        if (milk.hole != type(uint256).max) {
            dart = min(dart, mul(room, WAD) / milk.rate / milk.chop);
            dink = mul(ink, dart) / art;
        }
        
        // 转移债务到拍卖模块
        vat.grab(ilk, urn, address(this), address(vow), -int256(dink), -int256(dart));
        
        // 启动拍卖
        uint256 due = mul(dart, milk.rate);
        id = Clipper(milk.clip).kick({
            tab: mul(due, milk.chop) / WAD,
            lot: dink,
            usr: urn,
            kpr: kpr
        });
    }
}
                </div>
                
                <h5>支持的抵押品类型</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">抵押品</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">最低抵押率</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">稳定费率（年化）</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">债务上限</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">ETH-A</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">145%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5.25%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">15B DAI</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">WBTC-A</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">145%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5.75%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">500M DAI</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">USDC-A</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">101%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">0%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">2B DAI</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">RWA（现实资产）</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">100%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3-7%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3B DAI</td>
                    </tr>
                </table>
                
                <h4>其他重要项目</h4>
                
                <h5>LUSD（Liquity）</h5>
                <ul>
                    <li><strong>单一抵押品</strong>：仅支持ETH</li>
                    <li><strong>最低抵押率</strong>：110%（更资本高效）</li>
                    <li><strong>无治理</strong>：参数固定，真正去中心化</li>
                    <li><strong>一次性费用</strong>：0.5%借款费，无利息</li>
                    <li><strong>稳定机制</strong>：
                        <ul>
                            <li>硬锚定：$1.10赎回上限，$0.95 LUSD/ETH流动性下限</li>
                            <li>软锚定：套利激励</li>
                        </ul>
                    </li>
                </ul>
                
                <div class="code-block">
// Liquity核心机制：Trove（金库）操作
contract BorrowerOperations {
    // 开仓参数
    struct OpenTroveParams {
        uint _maxFeePercentage;
        uint _collAmount;
        uint _LUSDAmount;
        address _upperHint;
        address _lowerHint;
    }
    
    function openTrove(OpenTroveParams memory params) external payable {
        require(params._collAmount == msg.value, "BorrowerOps: Coll != msg.value");
        
        // 计算复合债务（本金 + 200 LUSD gas补偿）
        uint LUSDFee = _triggerBorrowingFee(params._LUSDAmount, params._maxFeePercentage);
        uint netDebt = params._LUSDAmount;
        uint compositeDebt = netDebt.add(LUSD_GAS_COMPENSATION);
        
        // 检查最低债务要求（2000 LUSD）
        require(compositeDebt >= MIN_NET_DEBT, "BorrowerOps: Trove net debt < minimum");
        
        // 计算ICR（个人抵押率）
        uint ICR = LiquityMath._computeCR(params._collAmount, compositeDebt, price);
        require(ICR >= MCR, "BorrowerOps: ICR < MCR");  // MCR = 110%
        
        // 创建Trove
        contractsCache.troveManager.openTrove(
            msg.sender, 
            params._collAmount, 
            compositeDebt
        );
        
        // 发送LUSD给借款人
        contractsCache.lusdToken.mint(msg.sender, params._LUSDAmount);
        
        emit TroveCreated(msg.sender, compositeDebt, params._collAmount);
    }
}
                </div>
                
                <h5>sUSD（Synthetix）</h5>
                <ul>
                    <li><strong>抵押品</strong>：SNX代币</li>
                    <li><strong>抵押率</strong>：400%（非常保守）</li>
                    <li><strong>特殊机制</strong>：债务池共担模式</li>
                    <li><strong>用途</strong>：合成资产交易的基础货币</li>
                </ul>
                
                <div class="warning">
                    <strong>⚠️ 加密抵押型稳定币的独特风险：</strong>
                    <ul>
                        <li><strong>清算风险</strong>：市场剧烈波动时可能被清算</li>
                        <li><strong>预言机风险</strong>：价格数据错误可能导致不当清算</li>
                        <li><strong>智能合约风险</strong>：代码漏洞可能造成损失</li>
                        <li><strong>扩展性限制</strong>：受抵押品市值限制</li>
                    </ul>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>2.3 算法稳定币（Algorithmic Stablecoins）</h3>
                
                <p>算法稳定币试图通过算法和市场激励机制来维持价格稳定，不依赖抵押品或仅部分抵押。这是最具实验性和争议性的稳定币类型。</p>
                
                <h4>核心机制：供需调节</h4>
                <div style="background: #fef3c7; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>基本原理：</strong>
                    <ul>
                        <li><strong>价格 > $1</strong>：增加供应量，稀释价格</li>
                        <li><strong>价格 < $1</strong>：减少供应量，提升价格</li>
                        <li><strong>调节工具</strong>：铸币/销毁、债券、股份代币等</li>
                    </ul>
                </div>
                
                <h4>历史案例：UST（Terra USD）的兴衰</h4>
                
                <h5>机制设计</h5>
                <div class="code-block">
// Terra协议核心机制（简化版）
contract TerraStation {
    uint256 constant DECIMAL_PRECISION = 1e6;
    
    // 铸造UST（烧毁等值LUNA）
    function mintUST(uint256 lunaAmount) external {
        uint256 lunaPrice = getOraclePrice("LUNA");
        uint256 ustToMint = (lunaAmount * lunaPrice) / DECIMAL_PRECISION;
        
        // 烧毁LUNA
        LUNA.burnFrom(msg.sender, lunaAmount);
        
        // 铸造UST
        UST.mint(msg.sender, ustToMint);
        
        emit Swap(msg.sender, "LUNA", "UST", lunaAmount, ustToMint);
    }
    
    // 赎回LUNA（烧毁UST）
    function redeemLUNA(uint256 ustAmount) external {
        uint256 lunaPrice = getOraclePrice("LUNA");
        uint256 lunaToMint = (ustAmount * DECIMAL_PRECISION) / lunaPrice;
        
        // 烧毁UST
        UST.burnFrom(msg.sender, ustAmount);
        
        // 铸造LUNA
        LUNA.mint(msg.sender, lunaToMint);
        
        emit Swap(msg.sender, "UST", "LUNA", ustAmount, lunaToMint);
    }
}

// Anchor协议（提供20%年化收益）
contract AnchorProtocol {
    uint256 constant EARN_RATE = 20e16; // 20% APY
    
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public lastUpdate;
    
    function deposit(uint256 amount) external {
        UST.transferFrom(msg.sender, address(this), amount);
        
        // 更新余额和利息
        uint256 earned = calculateEarnings(msg.sender);
        deposits[msg.sender] += amount + earned;
        lastUpdate[msg.sender] = block.timestamp;
    }
}
                </div>
                
                <h5>崩盘时间线详细分析（2022年5月）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">日期时间</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">关键事件</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">UST价格</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">LUNA价格</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">LUNA供应量</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月7日 21:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">巨鲸在Curve 4pool抛售1.5亿UST</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.985</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$64</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3.5亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月8日 14:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">LFG动用15亿美元BTC储备护盘</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.975</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$61</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3.8亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月9日 08:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Anchor挤兑开始，TVL下降50%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.65</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$30</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">11亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月10日 16:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Terra链暂停出块，死亡螺旋加速</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.30</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$1</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">1500亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月12日 23:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">LUNA超发至6.5万亿，完全崩溃</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.10</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.0001</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">6.5万亿</td>
                    </tr>
                </table>
                
                <h5>死亡螺旋的数学分析</h5>
                <div class="code-block">
# UST崩盘的动力学模型
import numpy as np
import matplotlib.pyplot as plt

class USTDeathSpiral:
    """UST死亡螺旋的数学建模"""
    
    def __init__(self):
        self.luna_supply = 350e6  # 初始LUNA供应量：3.5亿
        self.luna_price = 64      # 初始LUNA价格：$64
        self.ust_supply = 18e9    # UST供应量：180亿
        self.ust_price = 1.0      # UST初始价格：$1
        
    def simulate_spiral(self, ust_redemption_rate, time_steps):
        """模拟死亡螺旋过程
        
        参数:
            ust_redemption_rate: 每时间步的UST赎回比例
            time_steps: 模拟步数
        """
        history = {
            'time': [], 'luna_price': [], 'luna_supply': [],
            'ust_price': [], 'market_cap': []
        }
        
        for t in range(time_steps):
            # 记录当前状态
            history['time'].append(t)
            history['luna_price'].append(self.luna_price)
            history['luna_supply'].append(self.luna_supply)
            history['ust_price'].append(self.ust_price)
            history['market_cap'].append(self.luna_price * self.luna_supply)
            
            # UST赎回量
            ust_redeemed = self.ust_supply * ust_redemption_rate
            
            # 按当前LUNA价格铸造新LUNA
            new_luna_minted = ust_redeemed / self.luna_price
            self.luna_supply += new_luna_minted
            
            # 市场冲击：供应增加导致价格下跌
            # 使用简化的价格弹性模型
            supply_increase_pct = new_luna_minted / self.luna_supply
            price_elasticity = -2.5  # 价格弹性系数
            self.luna_price *= (1 + supply_increase_pct * price_elasticity)
            
            # UST价格跟随LUNA市值/UST供应量的比例
            luna_market_cap = self.luna_price * self.luna_supply
            implied_ust_backing = luna_market_cap / self.ust_supply
            self.ust_price = min(1.0, implied_ust_backing)
            
            # 恐慌加速因子：UST脱锚越严重，赎回越快
            if self.ust_price < 0.95:
                ust_redemption_rate *= 1.5  # 恐慌加速
                
            # 防止价格为负
            self.luna_price = max(0.0001, self.luna_price)
            
        return history
    
    def plot_results(self, history):
        """可视化死亡螺旋过程"""
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # LUNA价格
        axes[0, 0].plot(history['time'], history['luna_price'])
        axes[0, 0].set_title('LUNA价格走势')
        axes[0, 0].set_ylabel('价格 ($)')
        axes[0, 0].set_yscale('log')
        
        # LUNA供应量
        axes[0, 1].plot(history['time'], history['luna_supply'])
        axes[0, 1].set_title('LUNA供应量（指数增长）')
        axes[0, 1].set_ylabel('供应量')
        axes[0, 1].set_yscale('log')
        
        # UST价格
        axes[1, 0].plot(history['time'], history['ust_price'])
        axes[1, 0].axhline(y=1.0, color='r', linestyle='--', label='锚定价格')
        axes[1, 0].set_title('UST价格（脱锚过程）')
        axes[1, 0].set_ylabel('价格 ($)')
        axes[1, 0].legend()
        
        # LUNA市值
        axes[1, 1].plot(history['time'], history['market_cap'])
        axes[1, 1].set_title('LUNA总市值')
        axes[1, 1].set_ylabel('市值 ($)')
        axes[1, 1].set_yscale('log')
        
        for ax in axes.flat:
            ax.set_xlabel('时间步')
            ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

# 模拟死亡螺旋
simulator = USTDeathSpiral()
results = simulator.simulate_spiral(ust_redemption_rate=0.05, time_steps=100)
# simulator.plot_results(results)
                </div>
                
                <div class="warning">
                    <strong>深入分析：UST崩盘的根本原因</strong>
                    <ul>
                        <li><strong>内生抵押品的脆弱性</strong>：
                            <ul>
                                <li>LUNA既是UST的抵押品，又是吸收UST赎回压力的缓冲器</li>
                                <li>这种自我引用创造了正反馈循环：价格下跌→信心丧失→更多赎回→更大跌幅</li>
                            </ul>
                        </li>
                        <li><strong>不可持续的收益率</strong>：
                            <ul>
                                <li>Anchor Protocol的20% APY靠协议补贴维持</li>
                                <li>储备资金在2022年3月已接近耗尽</li>
                                <li>高收益掩盖了系统性风险，吸引了大量投机资金</li>
                            </ul>
                        </li>
                        <li><strong>流动性陷阱</strong>：
                            <ul>
                                <li>Curve 4pool深度不足以承受大额抛售</li>
                                <li>CEX/DEX价格差异被套利者利用，加速抛压</li>
                            </ul>
                        </li>
                        <li><strong>治理失效</strong>：
                            <ul>
                                <li>Do Kwon拒绝社区提出的多项风险缓解提案</li>
                                <li>LFG的BTC储备使用不透明，护盘策略失败</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <h5>控制论视角：为什么算法稳定币容易失控</h5>
                <div class="code-block">
# 控制系统分析：稳定币作为反馈控制系统
class StablecoinControlSystem:
    """稳定币的控制论模型"""
    
    def __init__(self, mechanism_type):
        self.mechanism_type = mechanism_type
        
    def transfer_function(self, s):
        """系统传递函数 G(s)"""
        if self.mechanism_type == "fiat_backed":
            # 法币抵押：一阶系统，稳定
            return 1 / (s + 1)
            
        elif self.mechanism_type == "crypto_backed":
            # 加密抵押：二阶系统，有阻尼
            omega_n = 0.5  # 自然频率
            zeta = 0.7     # 阻尼比
            return omega_n**2 / (s**2 + 2*zeta*omega_n*s + omega_n**2)
            
        elif self.mechanism_type == "algorithmic":
            # 算法稳定币：可能不稳定的高阶系统
            # 包含延迟和非线性反馈
            delay = 0.1
            gain = 2.0  # 高增益可能导致振荡
            return gain * np.exp(-delay * s) / (s**3 + 2*s**2 + s + 0.5)
    
    def stability_analysis(self):
        """分析系统稳定性"""
        # 使用根轨迹、波特图等工具
        # 算法稳定币往往在相位裕度和增益裕度上表现差
        pass
                </div>
                
                <h4>部分算法稳定币：FRAX</h4>
                
                <p>FRAX采用部分抵押模式，根据市场条件动态调整抵押率，是算法稳定币的改进尝试。</p>
                
                <h5>核心创新：分数算法稳定币</h5>
                <div class="code-block">
// FRAX协议核心：动态抵押率
contract FRAXStablecoin {
    uint256 public global_collateral_ratio; // 全局抵押率（0-100%）
    
    // 铸造FRAX
    function mintFrax(
        uint256 collateral_amount,
        uint256 fxs_amount,
        uint256 slippage
    ) external {
        uint256 frax_price = getFRAXPrice();
        uint256 fxs_price = getFXSPrice();
        
        // 计算可铸造的FRAX数量
        uint256 c_value = collateral_amount * collateral_price / 1e6;
        uint256 fxs_value = fxs_amount * fxs_price / 1e6;
        
        // 根据抵押率计算
        uint256 calculated_frax = 0;
        if(global_collateral_ratio == 1e6) { // 100%抵押
            calculated_frax = c_value;
        } else if(global_collateral_ratio == 0) { // 0%抵押（纯算法）
            calculated_frax = fxs_value;
        } else { // 部分抵押
            uint256 c_portion = c_value * 1e6 / global_collateral_ratio;
            calculated_frax = c_portion;
        }
        
        // 检查滑点
        require(calculated_frax >= frax_out_min, "Slippage limit");
        
        // 转移抵押品和烧毁FXS
        if(collateral_amount > 0) {
            collateral_token.transferFrom(msg.sender, address(this), collateral_amount);
        }
        if(fxs_amount > 0) {
            FXS.burnFrom(msg.sender, fxs_amount);
        }
        
        // 铸造FRAX
        FRAX.mint(msg.sender, calculated_frax);
    }
    
    // 动态调整抵押率
    function refreshCollateralRatio() external {
        uint256 frax_price = getFRAXPrice();
        
        if(frax_price > 1.01e6) { // FRAX > $1.01
            // 降低抵押率（每次0.25%）
            if(global_collateral_ratio > 0.25e6) {
                global_collateral_ratio -= 0.25e6;
            } else {
                global_collateral_ratio = 0;
            }
        } else if(frax_price < 0.99e6) { // FRAX < $0.99
            // 提高抵押率（每次0.25%）
            if(global_collateral_ratio + 0.25e6 <= 1e6) {
                global_collateral_ratio += 0.25e6;
            } else {
                global_collateral_ratio = 1e6;
            }
        }
        
        emit CollateralRatioRefreshed(global_collateral_ratio);
    }
}

// AMO（算法市场操作）控制器
contract FraxAMOMinter {
    // AMO可以无抵押铸造FRAX用于特定用途
    function mintFraxForAMO(address destination, uint256 frax_amount) external onlyAMO {
        // 检查不会导致抵押不足
        uint256 total_supply = FRAX.totalSupply();
        uint256 global_collateral_value = getGlobalCollateralValue();
        uint256 effective_collateral_ratio = global_collateral_value * 1e6 / (total_supply + frax_amount);
        
        require(effective_collateral_ratio >= global_collateral_ratio, "Collateral ratio violated");
        
        FRAX.mint(destination, frax_amount);
    }
}
                </div>
                
                <h5>FRAX生态系统</h5>
                <ul>
                    <li><strong>FRAX</strong>：稳定币</li>
                    <li><strong>FXS</strong>：股份/治理代币，吸收波动性</li>
                    <li><strong>veFXS</strong>：锁定FXS获得治理权和收益</li>
                    <li><strong>frxETH</strong>：以太坊流动性质押衍生品</li>
                    <li><strong>FPI</strong>：锚定CPI的通胀调整稳定币</li>
                </ul>
                
                <h4>其他算法稳定币尝试</h4>
                
                <h5>Basis Cash（已失败）</h5>
                <ul>
                    <li>三代币系统：BAC（稳定币）、BAS（股份）、BAB（债券）</li>
                    <li>失败原因：死亡螺旋，缺乏真实需求</li>
                </ul>
                
                <h5>Empty Set Dollar（已失败）</h5>
                <ul>
                    <li>单代币模型，结合稳定币和股份功能</li>
                    <li>失败原因：机制过于复杂，难以维持锚定</li>
                </ul>
                
                <h5>AMPL（Ampleforth）</h5>
                <ul>
                    <li><strong>弹性供应</strong>：通过rebase调整所有持有者余额</li>
                    <li><strong>目标</strong>：追踪2019年CPI调整后的美元购买力</li>
                    <li><strong>特点</strong>：不是传统意义的稳定币，更像"稳定购买力"</li>
                </ul>
                
                <div class="tip">
                    <strong>💡 算法稳定币的未来方向：</strong>
                    <ul>
                        <li>部分抵押模式（如FRAX）</li>
                        <li>与RWA（现实世界资产）结合</li>
                        <li>更复杂的稳定机制（如Gyroscope的储备池）</li>
                        <li>跨链流动性聚合</li>
                    </ul>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>2.4 混合模型与创新</h3>
                
                <p>随着稳定币生态的成熟，出现了结合多种机制优点的混合模型，以及针对特定用例的创新设计。</p>
                
                <h4>2024年最新创新：Ethena与合成美元</h4>
                
                <h5>USDe：Delta中性稳定币</h5>
                <p>Ethena Protocol推出的USDe代表了稳定币设计的新范式：通过衍生品对冲而非抵押品来维持稳定。</p>
                
                <div class="code-block">
// Ethena核心机制：Delta中性策略
contract EthenaProtocol {
    struct Position {
        uint256 stETHCollateral;     // 质押ETH现货
        int256 perpShortPosition;    // 永续合约空头
        uint256 fundingEarned;       // 累计资金费收益
        uint256 stakingRewards;      // 质押奖励
    }
    
    // 铸造USDe的核心逻辑
    function mintUSDe(uint256 ethAmount) external returns (uint256) {
        // 1. 接收ETH并质押获得stETH
        uint256 stETHAmount = stakingPool.stake{value: ethAmount}();
        
        // 2. 在衍生品交易所开立等值空头
        int256 shortSize = -int256(ethAmount * getETHPrice());
        perpExchange.openPosition(shortSize);
        
        // 3. 计算可铸造的USDe（扣除安全边际）
        uint256 netValue = calculateNetValue(stETHAmount, shortSize);
        uint256 usdeToMint = netValue * 90 / 100; // 10%安全边际
        
        // 4. 记录头寸
        positions[msg.sender] = Position({
            stETHCollateral: stETHAmount,
            perpShortPosition: shortSize,
            fundingEarned: 0,
            stakingRewards: 0
        });
        
        // 5. 铸造USDe
        _mint(msg.sender, usdeToMint);
        return usdeToMint;
    }
    
    // 收益分配机制
    function distributeYield() external {
        uint256 totalYield = 0;
        
        // 1. 收集质押奖励（约4% APY）
        uint256 stakingYield = stakingPool.claimRewards();
        totalYield += stakingYield;
        
        // 2. 收集资金费（可变，牛市可达20%+ APY）
        uint256 fundingYield = perpExchange.collectFunding();
        totalYield += fundingYield;
        
        // 3. 扣除协议费用
        uint256 protocolFee = totalYield * 10 / 100;
        uint256 userYield = totalYield - protocolFee;
        
        // 4. 分配给sUSDe持有者
        sUsdeVault.depositYield(userYield);
    }
}
                </div>
                
                <h5>风险分析：与UST的对比</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">风险类型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">UST</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">USDe</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押品风险</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">内生（LUNA），死亡螺旋</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">外生（ETH），但有质押风险</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">收益来源</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">不可持续的补贴</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">市场资金费+质押收益</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">主要风险</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">银行挤兑、信心崩溃</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">负资金费、交易所风险</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">脱锚保护</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">依赖套利者</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">保险基金+OTC赎回</td>
                    </tr>
                </table>
                
                <h4>混合抵押模型</h4>
                
                <h5>crvUSD（Curve Finance）</h5>
                <p>Curve的稳定币采用创新的LLAMMA（Lending-Liquidating AMM Algorithm）机制，实现软清算。</p>
                
                <div class="code-block">
// LLAMMA核心概念：连续清算
contract LLAMMA {
    struct Band {
        uint256 stablecoin_amount;  // 稳定币数量
        uint256 collateral_amount;  // 抵押品数量
    }
    
    mapping(int256 => Band) public bands;  // 价格区间
    
    // 软清算机制
    function deposit_collateral(uint256 amount, uint256 debt, int256 n_bands) external {
        uint256 amount_per_band = amount / uint256(n_bands);
        int256 active_band = price_oracle.active_band();
        
        // 在多个价格区间分散抵押品
        for(int256 i = 0; i < n_bands; i++) {
            int256 band = active_band - i;
            bands[band].collateral_amount += amount_per_band;
        }
        
        // 铸造crvUSD
        crvUSD.mint(msg.sender, debt);
    }
    
    // 自动做市商功能
    function exchange(int256 band) internal {
        Band storage b = bands[band];
        uint256 p_oracle = price_oracle.price();
        uint256 p_band_up = get_p(band + 1);
        uint256 p_band_down = get_p(band);
        
        if(p_oracle > p_band_up) {
            // 卖出所有稳定币买入抵押品
            uint256 collateral_to_buy = b.stablecoin_amount * 1e18 / p_oracle;
            b.collateral_amount += collateral_to_buy;
            b.stablecoin_amount = 0;
        } else if(p_oracle < p_band_down) {
            // 卖出所有抵押品买入稳定币
            uint256 stablecoin_to_buy = b.collateral_amount * p_oracle / 1e18;
            b.stablecoin_amount += stablecoin_to_buy;
            b.collateral_amount = 0;
        } else {
            // 部分转换（AMM逻辑）
            rebalance_band(band, p_oracle);
        }
    }
}
                </div>
                
                <h5>关键创新点</h5>
                <ul>
                    <li><strong>连续清算</strong>：避免瞬间大额清算造成的滑点</li>
                    <li><strong>AMM集成</strong>：清算过程即是做市过程</li>
                    <li><strong>自动再平衡</strong>：根据价格自动调整抵押品/债务比例</li>
                    <li><strong>无需清算人</strong>：系统自动处理风险头寸</li>
                </ul>
                
                <h4>特定用途稳定币</h4>
                
                <h5>GHO（Aave）</h5>
                <ul>
                    <li><strong>原生集成</strong>：与Aave借贷协议深度整合</li>
                    <li><strong>利率折扣</strong>：stkAAVE持有者享受借款利率优惠</li>
                    <li><strong>Facilitator模式</strong>：多个授权实体可铸造GHO</li>
                </ul>
                
                <h5>DOLA（Inverse Finance）</h5>
                <ul>
                    <li><strong>跨链原生</strong>：通过债务桥实现跨链</li>
                    <li><strong>Fed模式</strong>：协议控制的流动性管理</li>
                </ul>
                
                <h4>跨链稳定币</h4>
                
                <h5>跨链桥接模型</h5>
                <div class="code-block">
// 跨链稳定币标准接口
interface ICrossChainStablecoin {
    // 锁定并桥接
    function bridgeOut(
        uint256 amount,
        uint256 toChainId,
        address toAddress
    ) external;
    
    // 接收跨链铸造
    function bridgeIn(
        uint256 amount,
        address toAddress,
        bytes32 txHash
    ) external onlyBridge;
}

// LayerZero实现示例
contract LayerZeroStablecoin is OFT {  // Omnichain Fungible Token
    function sendFrom(
        address _from,
        uint16 _dstChainId,
        bytes calldata _toAddress,
        uint256 _amount,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes calldata _adapterParams
    ) public payable virtual override {
        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);
    }
    
    function _nonblockingLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal virtual override {
        uint16 packetType;
        assembly {
            packetType := mload(add(_payload, 32))
        }
        
        if (packetType == PT_SEND) {
            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);
        }
    }
}
                </div>
                
                <h4>创新稳定机制</h4>
                
                <h5>Gyroscope Protocol</h5>
                <ul>
                    <li><strong>储备池分层</strong>：多层次风险隔离</li>
                    <li><strong>动态定价</strong>：基于储备健康度的赎回定价</li>
                    <li><strong>E-CLP</strong>：椭圆集中流动性池</li>
                </ul>
                
                <h5>Reserve Protocol (RSR/RSV)</h5>
                <ul>
                    <li><strong>资产篮子</strong>：多样化抵押品降低风险</li>
                    <li><strong>保险机制</strong>：RSR作为最后的资本缓冲</li>
                    <li><strong>可配置</strong>：任何人可创建新的稳定币配置</li>
                </ul>
            </div>
            
            <div class="theory-section">
                <h3>2.5 AI/机器学习在稳定币中的应用</h3>
                
                <p>随着DeFi系统复杂性增加，AI和机器学习技术在稳定币风险管理、参数优化和市场预测中扮演越来越重要的角色。</p>
                
                <h4>风险预测与异常检测</h4>
                <div class="code-block">
# 使用LSTM预测稳定币脱锚风险
import torch
import torch.nn as nn
import numpy as np
from sklearn.preprocessing import StandardScaler

class StablecoinRiskPredictor(nn.Module):
    """基于LSTM的稳定币风险预测模型"""
    
    def __init__(self, input_features=10, hidden_size=64, num_layers=2):
        super().__init__()
        self.lstm = nn.LSTM(input_features, hidden_size, num_layers, 
                           batch_first=True, dropout=0.2)
        self.attention = nn.MultiheadAttention(hidden_size, num_heads=4)
        self.fc = nn.Sequential(
            nn.Linear(hidden_size, 32),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(32, 3)  # 输出：[正常, 警告, 危险]
        )
        
    def forward(self, x, market_context=None):
        # x shape: (batch, sequence_length, features)
        lstm_out, (h_n, c_n) = self.lstm(x)
        
        # 自注意力机制捕捉长期依赖
        attn_out, _ = self.attention(lstm_out, lstm_out, lstm_out)
        
        # 使用最后时间步的输出
        risk_scores = self.fc(attn_out[:, -1, :])
        return torch.softmax(risk_scores, dim=1)
    
    def extract_features(self, market_data):
        """特征工程：提取风险相关特征"""
        features = {
            # 价格相关
            'price_deviation': abs(market_data['price'] - 1.0),
            'price_volatility': market_data['price'].rolling(24).std(),
            'volume_spike': market_data['volume'] / market_data['volume'].rolling(168).mean(),
            
            # 链上指标
            'mint_burn_ratio': market_data['mints'] / (market_data['burns'] + 1e-8),
            'whale_concentration': market_data['top_10_holdings'] / market_data['total_supply'],
            'velocity': market_data['transfer_volume'] / market_data['total_supply'],
            
            # DeFi集成
            'liquidity_depth': market_data['amm_liquidity'],
            'utilization_rate': market_data['borrowed'] / market_data['supplied'],
            
            # 市场情绪
            'funding_rate': market_data['perp_funding'],
            'cex_premium': market_data['cex_price'] - market_data['dex_price']
        }
        return features

# 强化学习优化稳定币参数
class StablecoinRLAgent:
    """使用PPO算法优化稳定币参数"""
    
    def __init__(self, state_dim=20, action_dim=5):
        self.policy_net = self._build_network(state_dim, action_dim)
        self.value_net = self._build_network(state_dim, 1)
        self.optimizer = torch.optim.Adam(
            list(self.policy_net.parameters()) + 
            list(self.value_net.parameters()), 
            lr=3e-4
        )
        
    def _build_network(self, input_dim, output_dim):
        return nn.Sequential(
            nn.Linear(input_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, output_dim)
        )
    
    def get_action(self, state):
        """根据当前状态决定参数调整
        
        动作空间:
        - 调整抵押率要求
        - 修改稳定费率
        - 改变清算罚金
        - 调节债务上限
        - 修改预言机参数
        """
        state_tensor = torch.FloatTensor(state)
        action_probs = torch.softmax(self.policy_net(state_tensor), dim=-1)
        action = torch.multinomial(action_probs, 1).item()
        return action
    
    def optimize_parameters(self, env, episodes=1000):
        """通过与环境交互学习最优参数"""
        for episode in range(episodes):
            state = env.reset()
            episode_reward = 0
            
            while not env.done:
                action = self.get_action(state)
                next_state, reward, done = env.step(action)
                
                # 奖励设计：平衡稳定性、资本效率和用户体验
                stability_reward = -abs(env.price - 1.0) * 100
                efficiency_reward = env.utilization_rate * 10
                safety_reward = -env.liquidations * 50
                
                total_reward = stability_reward + efficiency_reward + safety_reward
                episode_reward += total_reward
                
                # PPO更新（简化版）
                self._update_policy(state, action, total_reward, next_state)
                state = next_state
                
            print(f"Episode {episode}: Reward = {episode_reward:.2f}")
                </div>
                
                <h4>博弈论分析：清算人激励机制</h4>
                <div class="code-block">
# 清算拍卖的博弈论模型
class LiquidationAuction:
    """分析清算人（Keepers）的最优策略"""
    
    def __init__(self, collateral_value, debt_value, num_keepers):
        self.collateral_value = collateral_value
        self.debt_value = debt_value
        self.num_keepers = num_keepers
        
    def calculate_nash_equilibrium(self):
        """计算纳什均衡出价策略
        
        假设：
        - 第一价格密封拍卖
        - 私有价值模型
        - 对称均衡
        """
        # 在均衡状态下，每个keeper的最优出价
        # b(v) = v - ∫[v_min to v] F(x)^(n-1) dx / F(v)^(n-1)
        
        # 简化：假设均匀分布的估值
        expected_profit_margin = 1 / (self.num_keepers + 1)
        equilibrium_bid = self.collateral_value * (1 - expected_profit_margin)
        
        return {
            'equilibrium_bid': equilibrium_bid,
            'expected_profit': self.collateral_value - equilibrium_bid,
            'protocol_recovery': equilibrium_bid / self.debt_value
        }
    
    def simulate_dutch_auction(self, start_price, decay_rate):
        """荷兰式拍卖模拟（如Liquity）"""
        time_steps = []
        prices = []
        
        current_price = start_price
        t = 0
        
        while current_price > self.debt_value * 0.9:  # 最低价格限制
            # 每个keeper的参与概率
            participation_prob = self._keeper_participation_probability(
                current_price, t
            )
            
            if np.random.random() < participation_prob:
                return {
                    'winning_price': current_price,
                    'time_to_clear': t,
                    'keeper_profit': self.collateral_value - current_price
                }
            
            # 价格衰减
            current_price *= (1 - decay_rate)
            t += 1
            
            time_steps.append(t)
            prices.append(current_price)
            
        return {'failed': True, 'final_price': current_price}
                </div>
                
                <h4>实际应用案例：MakerDAO的AutoLine</h4>
                <p>MakerDAO使用自动化系统调整债务上限，这是AI在稳定币治理中的实际应用。</p>
                
                <div class="code-block">
// Solidity实现：自动债务上限调整
contract AutoLine {
    struct CollateralConfig {
        uint256 line;      // 当前债务上限
        uint256 gap;       // 每次增加量
        uint256 ttl;       // 冷却时间
        uint256 last;      // 上次调整时间
        uint256 maxLine;   // 最大上限
    }
    
    mapping(bytes32 => CollateralConfig) public configs;
    
    function exec(bytes32 ilk) external returns (uint256) {
        CollateralConfig memory cfg = configs[ilk];
        
        // 获取当前使用情况
        (uint256 Art, uint256 rate,, uint256 line,) = vat.ilks(ilk);
        uint256 debt = Art * rate;
        
        // 如果使用率超过90%且未达到最大值，增加上限
        if (debt > line * 90 / 100 && line < cfg.maxLine) {
            // 检查冷却时间
            require(block.timestamp > cfg.last + cfg.ttl, "AutoLine/cooldown");
            
            // 增加债务上限
            uint256 newLine = Math.min(line + cfg.gap, cfg.maxLine);
            vat.file(ilk, "line", newLine);
            
            // 更新时间戳
            configs[ilk].last = block.timestamp;
            
            emit LineUpdate(ilk, line, newLine);
            return newLine;
        }
        
        return line;
    }
}
                </div>
            </div>
            
            <div class="practice-section">
                <h3>2.6 实践：分析历史锚定数据与DeFi集成</h3>
                
                <p>通过分析真实的历史数据和DeFi协议集成，深入理解稳定币在实际应用中的表现。</p>
                
                <h4>链上数据分析实战</h4>
                <div class="code-block">
# 使用Python分析稳定币锚定历史
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt

# 稳定币价格偏离分析
class StablecoinAnalyzer:
    def __init__(self):
        self.stablecoins = ['USDT', 'USDC', 'DAI', 'FRAX', 'LUSD']
        
    def calculate_peg_deviation(self, prices):
        """计算锚定偏离度"""
        deviations = abs(prices - 1.0)
        return {
            'mean_deviation': deviations.mean(),
            'max_deviation': deviations.max(),
            'volatility': prices.std(),
            'days_off_peg': (deviations > 0.01).sum()  # 偏离1%的天数
        }
    
    def analyze_depeg_events(self, prices, threshold=0.03):
        """分析脱锚事件"""
        depeg_mask = abs(prices - 1.0) > threshold
        depeg_events = []
        
        i = 0
        while i < len(prices):
            if depeg_mask.iloc[i]:
                start = i
                while i < len(prices) and depeg_mask.iloc[i]:
                    i += 1
                end = i - 1
                
                depeg_events.append({
                    'start_date': prices.index[start],
                    'end_date': prices.index[end],
                    'duration_days': end - start + 1,
                    'max_deviation': abs(prices.iloc[start:end+1] - 1.0).max(),
                    'min_price': prices.iloc[start:end+1].min(),
                    'max_price': prices.iloc[start:end+1].max()
                })
            else:
                i += 1
                
        return depeg_events
    
    def correlation_analysis(self, price_data):
        """分析稳定币之间的相关性"""
        correlations = price_data.corr()
        
        # 危机期间的相关性（2022年5月UST崩盘期间）
        crisis_start = '2022-05-07'
        crisis_end = '2022-05-15'
        crisis_data = price_data[crisis_start:crisis_end]
        crisis_corr = crisis_data.corr()
        
        return {
            'normal_correlation': correlations,
            'crisis_correlation': crisis_corr
        }

# 可视化分析
def plot_stablecoin_comparison(data):
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # 1. 价格历史
    ax1 = axes[0, 0]
    for coin in data.columns:
        ax1.plot(data.index, data[coin], label=coin, alpha=0.7)
    ax1.axhline(y=1.0, color='black', linestyle='--', alpha=0.5)
    ax1.set_title('稳定币价格历史')
    ax1.set_ylabel('价格 (USD)')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # 2. 偏离度分布
    ax2 = axes[0, 1]
    deviations = abs(data - 1.0)
    deviations.plot(kind='box', ax=ax2)
    ax2.set_title('锚定偏离度分布')
    ax2.set_ylabel('偏离度')
    
    # 3. 滚动波动率
    ax3 = axes[1, 0]
    rolling_vol = data.rolling(window=30).std()
    for coin in rolling_vol.columns:
        ax3.plot(rolling_vol.index, rolling_vol[coin], label=coin)
    ax3.set_title('30天滚动波动率')
    ax3.set_ylabel('波动率')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # 4. 脱锚事件统计
    ax4 = axes[1, 1]
    depeg_counts = {}
    for coin in data.columns:
        analyzer = StablecoinAnalyzer()
        events = analyzer.analyze_depeg_events(data[coin])
        depeg_counts[coin] = len(events)
    
    ax4.bar(depeg_counts.keys(), depeg_counts.values())
    ax4.set_title('脱锚事件次数（>3%偏离）')
    ax4.set_ylabel('事件数量')
    
    plt.tight_layout()
    plt.show()

# 风险指标计算
def calculate_risk_metrics(prices):
    """计算稳定币风险指标"""
    metrics = {}
    
    # 1. 最大回撤
    cummax = prices.cummax()
    drawdown = (prices - cummax) / cummax
    metrics['max_drawdown'] = drawdown.min()
    
    # 2. 恢复时间
    recovery_times = []
    for i in range(len(prices)):
        if prices.iloc[i] < 0.99:  # 脱锚
            for j in range(i+1, len(prices)):
                if prices.iloc[j] >= 0.995:  # 恢复
                    recovery_times.append(j - i)
                    break
    
    metrics['avg_recovery_time'] = np.mean(recovery_times) if recovery_times else 0
    
    # 3. 下行风险（仅计算负偏离）
    negative_deviations = prices[prices < 1.0] - 1.0
    metrics['downside_volatility'] = negative_deviations.std()
    
    # 4. 尾部风险（VaR和CVaR）
    returns = prices.pct_change().dropna()
    metrics['var_95'] = np.percentile(returns, 5)
    metrics['cvar_95'] = returns[returns <= metrics['var_95']].mean()
    
    return metrics

# 实时监控示例
class StablecoinMonitor:
    def __init__(self, alert_threshold=0.02):
        self.alert_threshold = alert_threshold
        self.alerts = []
        
    def check_peg(self, current_prices):
        """检查当前锚定状态"""
        for coin, price in current_prices.items():
            deviation = abs(price - 1.0)
            if deviation > self.alert_threshold:
                alert = {
                    'timestamp': datetime.now(),
                    'coin': coin,
                    'price': price,
                    'deviation': deviation,
                    'severity': 'HIGH' if deviation > 0.05 else 'MEDIUM'
                }
                self.alerts.append(alert)
                self.send_alert(alert)
                
    def send_alert(self, alert):
        """发送警报（实际应用中可以接入通知系统）"""
        print(f"⚠️ ALERT: {alert['coin']} at ${alert['price']:.4f} "
              f"({alert['deviation']*100:.2f}% deviation) - {alert['severity']}")
                </div>
                
                <h4>练习题</h4>
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">📝</span>
                        <h5>练习 2.1：深度分析 - 清算机制对比</h5>
                    </div>
                    <p>比较分析MakerDAO、Liquity和crvUSD的清算机制，从以下维度进行评估：</p>
                    <ol>
                        <li>资本效率（最低抵押率）</li>
                        <li>清算过程对市场的影响</li>
                        <li>清算人（Keeper）的激励设计</li>
                        <li>在极端市场条件下的表现</li>
                    </ol>
                    <p>要求：用数学模型量化分析每种机制的优劣，并提出改进建议。</p>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_1')">查看答案</button>
                    <div id="answer2_1" class="answer-content">
                        <h6>清算机制对比分析</h6>
                        
                        <table style="width: 100%; margin: 1rem 0;">
                            <tr>
                                <th style="padding: 0.5rem; background: #f1f5f9;">特性</th>
                                <th style="padding: 0.5rem; background: #f1f5f9;">MakerDAO</th>
                                <th style="padding: 0.5rem; background: #f1f5f9;">Liquity</th>
                                <th style="padding: 0.5rem; background: #f1f5f9;">crvUSD</th>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;"><strong>最低抵押率</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">150%（ETH-A）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">110%</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">~117%（动态）</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;"><strong>清算类型</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">拍卖（Clipper）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">固定折扣</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">连续清算（LLAMMA）</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;"><strong>市场影响</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">中等（批量清算）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">高（瞬时清算）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">低（平滑转换）</td>
                            </tr>
                        </table>
                        
                        <h6>数学分析</h6>
                        
                        <p><strong>1. MakerDAO - 荷兰式拍卖模型：</strong></p>
                        <pre>价格函数: P(t) = P₀ × (1 - λt)
其中：P₀ = 初始价格（市场价×缓冲系数）
     λ = 衰减率
     t = 时间
                        
预期收益: E[R] = ∫₀ᵀ P(t) × f(t) dt
其中：f(t) = keeper参与的概率密度函数</pre>
                        
                        <p><strong>2. Liquity - 固定折扣模型：</strong></p>
                        <pre>清算价格 = 债务价值 × 0.995（0.5%奖励）
稳定池激励 = 200 LUSD（gas补偿）

博弈论分析：
- Nash均衡：所有keeper同时监控
- 最优策略：gas价格优化 + MEV利用</pre>
                        
                        <p><strong>3. crvUSD - LLAMMA连续清算：</strong></p>
                        <pre>价格区间：[p_down, p_up]
AMM函数：x × y = k（在每个band内）

软清算优势量化：
- 滑点减少：~90%（相比硬清算）
- 资本效率提升：~35%（更低的安全边际需求）</pre>
                        
                        <h6>改进建议</h6>
                        <ol>
                            <li><strong>混合机制</strong>：结合LLAMMA的平滑性和Liquity的简单性</li>
                            <li><strong>动态参数</strong>：基于市场波动率自动调整清算参数</li>
                            <li><strong>MEV保护</strong>：使用commit-reveal或批量清算减少抢跑</li>
                            <li><strong>保险基金</strong>：建立协议级保险池吸收极端损失</li>
                        </ol>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">💻</span>
                        <h5>练习 2.2：实现简单的法币抵押稳定币</h5>
                    </div>
                    <p>完成以下合约，实现一个基本的法币抵押稳定币：</p>
                    <div class="code-block">
contract SimpleStablecoin is ERC20, Ownable {
    // TODO: 实现以下功能
    // 1. 添加铸币者管理
    // 2. 实现铸币功能（需要权限控制）
    // 3. 实现销毁功能（任何人可销毁自己的代币）
    // 4. 添加黑名单功能
    // 5. 实现暂停/恢复功能
    // 6. 添加事件日志
}
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_2')">查看答案</button>
                    <div id="answer2_2" class="answer-content">
                        <div class="code-block">
contract SimpleStablecoin is ERC20, Ownable, Pausable {
    // 铸币者管理
    mapping(address => bool) public minters;
    mapping(address => uint256) public mintingAllowance;
    
    // 黑名单
    mapping(address => bool) public blacklisted;
    
    // 事件
    event MinterConfigured(address indexed minter, uint256 allowance);
    event MinterRemoved(address indexed minter);
    event Mint(address indexed minter, address indexed to, uint256 amount);
    event Burn(address indexed burner, uint256 amount);
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    
    // 修饰器
    modifier onlyMinters() {
        require(minters[msg.sender], "Not a minter");
        _;
    }
    
    modifier notBlacklisted(address account) {
        require(!blacklisted[account], "Account is blacklisted");
        _;
    }
    
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    // 铸币者管理
    function configureMinter(address minter, uint256 allowance) external onlyOwner {
        minters[minter] = true;
        mintingAllowance[minter] = allowance;
        emit MinterConfigured(minter, allowance);
    }
    
    function removeMinter(address minter) external onlyOwner {
        minters[minter] = false;
        mintingAllowance[minter] = 0;
        emit MinterRemoved(minter);
    }
    
    // 铸币功能
    function mint(address to, uint256 amount) 
        external 
        onlyMinters 
        whenNotPaused
        notBlacklisted(msg.sender)
        notBlacklisted(to)
        returns (bool) 
    {
        require(to != address(0), "Mint to zero address");
        require(amount > 0, "Amount must be greater than 0");
        require(amount <= mintingAllowance[msg.sender], "Exceeds minting allowance");
        
        mintingAllowance[msg.sender] -= amount;
        _mint(to, amount);
        
        emit Mint(msg.sender, to, amount);
        return true;
    }
    
    // 销毁功能
    function burn(uint256 amount) 
        external 
        whenNotPaused
        notBlacklisted(msg.sender)
    {
        require(amount > 0, "Amount must be greater than 0");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        _burn(msg.sender, amount);
        emit Burn(msg.sender, amount);
    }
    
    // 黑名单管理
    function blacklist(address account) external onlyOwner {
        blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    function unBlacklist(address account) external onlyOwner {
        blacklisted[account] = false;
        emit UnBlacklisted(account);
    }
    
    // 重写transfer函数以检查黑名单
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);
        
        require(!blacklisted[from], "Sender is blacklisted");
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!paused(), "Token transfers are paused");
    }
    
    // 暂停功能（继承自Pausable）
    function pause() external onlyOwner {
        _pause();
    }
    
    function unpause() external onlyOwner {
        _unpause();
    }
}
                        </div>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">🔍</span>
                        <h5>练习 2.3：分析UST崩盘机制</h5>
                    </div>
                    <p>UST使用以下公式维持锚定：</p>
                    <pre>1 UST = $1 worth of LUNA (可相互转换)</pre>
                    <p>假设初始状态：LUNA价格$60，UST供应量100亿，LUNA供应量5亿</p>
                    <p>问题：</p>
                    <ol>
                        <li>如果有20亿UST被赎回成LUNA，LUNA供应量会增加多少？</li>
                        <li>假设市场只能吸收10%的新增LUNA供应而不影响价格，实际LUNA价格会跌到多少？</li>
                        <li>在新价格下，剩余80亿UST的抵押品价值是多少？</li>
                        <li>这会引发什么连锁反应？</li>
                    </ol>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_3')">查看答案</button>
                    <div id="answer2_3" class="answer-content">
                        <ol>
                            <li><strong>LUNA供应量增加计算：</strong>
                                <ul>
                                    <li>20亿UST ÷ $60/LUNA = 3333万LUNA</li>
                                    <li>新LUNA供应量 = 5亿 + 0.33亿 = 5.33亿</li>
                                    <li>供应量增加了6.67%</li>
                                </ul>
                            </li>
                            <li><strong>价格影响分析：</strong>
                                <ul>
                                    <li>如果市场深度只能吸收10%的新供应</li>
                                    <li>实际抛压 = 90% × 3333万 = 3000万LUNA</li>
                                    <li>假设价格弹性为-2（供应增1%，价格跌2%）</li>
                                    <li>价格跌幅 = 6% × 2 = 12%</li>
                                    <li>新LUNA价格 ≈ $60 × 0.88 = $52.8</li>
                                </ul>
                            </li>
                            <li><strong>抵押品价值：</strong>
                                <ul>
                                    <li>LUNA总市值 = 5.33亿 × $52.8 = 281亿美元</li>
                                    <li>UST市值需求 = 80亿美元</li>
                                    <li>理论上足够，但信心已受损</li>
                                </ul>
                            </li>
                            <li><strong>死亡螺旋：</strong>
                                <ul>
                                    <li>价格下跌→更多UST持有者恐慌赎回</li>
                                    <li>更多赎回→更多LUNA增发→价格进一步下跌</li>
                                    <li>Anchor协议挤兑加速UST抛售</li>
                                    <li>LUNA价格崩溃→UST完全失去支撑</li>
                                    <li>最终：LUNA接近归零，UST严重脱锚</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>关键教训：</strong>纯算法稳定币在极端市场条件下极其脆弱，死亡螺旋一旦开始很难停止。</p>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">⚡</span>
                        <h5>练习 2.4：设计改进的稳定币机制</h5>
                    </div>
                    <p>基于本章学习的内容，设计一个结合多种机制优点的新型稳定币。要求：</p>
                    <ol>
                        <li>描述核心稳定机制</li>
                        <li>说明如何避免死亡螺旋</li>
                        <li>设计应急机制</li>
                        <li>考虑监管合规</li>
                    </ol>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_4')">查看答案</button>
                    <div id="answer2_4" class="answer-content">
                        <h5>混合稳定币设计方案</h5>
                        
                        <h6>1. 核心稳定机制（三层防御）</h6>
                        <ul>
                            <li><strong>第一层：部分法币储备（40%）</strong>
                                <ul>
                                    <li>USDC/美国国债作为硬底</li>
                                    <li>提供基础信心和流动性</li>
                                </ul>
                            </li>
                            <li><strong>第二层：加密资产超额抵押（40%）</strong>
                                <ul>
                                    <li>ETH/BTC等主流资产</li>
                                    <li>150%最低抵押率</li>
                                    <li>软清算机制（类似crvUSD）</li>
                                </ul>
                            </li>
                            <li><strong>第三层：算法调节（20%）</strong>
                                <ul>
                                    <li>协议控制的资金（PCV）</li>
                                    <li>动态调节供应量</li>
                                    <li>但不超过总供应的20%</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h6>2. 避免死亡螺旋的机制</h6>
                        <ul>
                            <li><strong>熔断机制</strong>：24小时内赎回量超过10%时暂停大额赎回</li>
                            <li><strong>时间锁</strong>：大额赎回需要7天等待期</li>
                            <li><strong>费率调节</strong>：市场压力时提高赎回费用（最高5%）</li>
                            <li><strong>储备比率下限</strong>：法币储备不得低于30%</li>
                        </ul>
                        
                        <h6>3. 应急机制</h6>
                        <ul>
                            <li><strong>保险基金</strong>：协议收入的50%进入保险基金</li>
                            <li><strong>紧急暂停</strong>：多签控制的紧急暂停功能</li>
                            <li><strong>渐进式清算</strong>：避免大规模同时清算</li>
                            <li><strong>备用稳定模块（BSM）</strong>：
                                <pre>如果价格 < $0.95：激活1:1 USDC兑换（有限额）
如果价格 > $1.05：激活1:1 USDC铸造（有限额）</pre>
                            </li>
                        </ul>
                        
                        <h6>4. 监管合规设计</h6>
                        <ul>
                            <li><strong>可选KYC层</strong>：
                                <ul>
                                    <li>基础功能无需KYC（DeFi友好）</li>
                                    <li>大额交易和法币出入金需要KYC</li>
                                </ul>
                            </li>
                            <li><strong>透明度</strong>：
                                <ul>
                                    <li>实时链上储备证明</li>
                                    <li>月度第三方审计</li>
                                </ul>
                            </li>
                            <li><strong>管辖权考虑</strong>：
                                <ul>
                                    <li>基金会设立在瑞士/新加坡</li>
                                    <li>遵守当地稳定币法规</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h6>实现草图</h6>
                        <div class="code-block">
contract HybridStablecoin {
    // 储备类型
    struct Reserve {
        uint256 fiatBacked;      // USDC等
        uint256 cryptoBacked;    // ETH等的美元价值
        uint256 algorithmic;     // 协议控制价值
    }
    
    // 稳定机制
    function mint(uint256 amount, uint256 collateralType) external {
        if (collateralType == FIAT) {
            // 1:1 铸造
            require(USDC.transferFrom(msg.sender, reserves, amount));
        } else if (collateralType == CRYPTO) {
            // 超额抵押铸造
            uint256 requiredCollateral = amount * 150 / 100;
            // ... 抵押逻辑
        } else {
            // 算法铸造（有限额）
            require(algorithmicSupply + amount <= maxAlgorithmicSupply);
            // ... 算法逻辑
        }
    }
    
    // 紧急机制
    function emergencyPause() external onlyGuardian {
        require(getPrice() < 0.90 || systemHealthScore() < 50);
        _pause();
        emit EmergencyPauseActivated();
    }
}
                        </div>
                    </div>
                </div>
                
                <h3>本章小结</h3>
                <div class="tip">
                    <strong>关键要点：</strong>
                    <ul>
                        <li><strong>法币抵押型</strong>：最稳定但中心化，适合大额交易和合规需求</li>
                        <li><strong>加密抵押型</strong>：去中心化但资本效率低，是DeFi的基石</li>
                        <li><strong>算法稳定币</strong>：资本效率高但风险大，纯算法模式已被证明不可行</li>
                        <li><strong>混合模型</strong>：结合多种机制，是未来发展方向</li>
                        <li><strong>风险意识</strong>：每种模型都有其特定风险，没有完美的稳定币</li>
                    </ul>
                </div>
                
                <h3>术语速查</h3>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">术语</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">英文</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">含义</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">锚定</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Peg</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">稳定币维持1:1美元价值</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">铸造/销毁</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Mint/Burn</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">创建/销毁稳定币的过程</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押率</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Collateral Ratio</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押品价值/债务价值</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">清算</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Liquidation</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押不足时强制平仓</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">死亡螺旋</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Death Spiral</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">价格下跌引发的恶性循环</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">软清算</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Soft Liquidation</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">渐进式清算，减少市场冲击</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">协议控制价值</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PCV</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">协议直接拥有的资产</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">算法市场操作</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">AMO</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">协议自动化市场干预</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- 第三章：ERC-20标准与扩展 -->
        <div class="chapter" id="chapter3">
            <h2>第三章：ERC-20标准与扩展</h2>
            
            <div class="intro-box">
                <strong>本章概览：</strong>
                <ul>
                    <li>深入理解ERC-20标准及其在稳定币中的应用</li>
                    <li>探索代理模式和可升级合约架构</li>
                    <li>跨链标准与互操作性解决方案</li>
                    <li>实战：构建企业级可升级稳定币</li>
                </ul>
            </div>

            <h3>3.1 标准代币接口深度解析</h3>
            
            <h4>3.1.1 ERC-20标准的演进历程</h4>
            <p>ERC-20标准诞生于2015年11月，由Fabian Vogelsteller提出，成为以太坊生态系统中最成功的标准之一。让我们深入了解其技术细节和在稳定币中的特殊应用。</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">基础ERC-20接口定义 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    // 查询代币总供应量
    function totalSupply() external view returns (uint256);
    
    // 查询账户余额
    function balanceOf(address account) external view returns (uint256);
    
    // 转账函数
    function transfer(address to, uint256 amount) external returns (bool);
    
    // 查询授权额度
    function allowance(address owner, address spender) external view returns (uint256);
    
    // 授权函数
    function approve(address spender, uint256 amount) external returns (bool);
    
    // 授权转账
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    
    // 事件定义
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.2 稳定币特有的扩展功能</h4>
            <p>稳定币在实现ERC-20标准的基础上，通常需要添加额外的功能以满足合规和运营需求：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">稳定币扩展功能实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract StablecoinBase is ERC20, Pausable, AccessControl {
    // 角色定义
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");
    
    // 黑名单映射
    mapping(address => bool) private _blacklisted;
    
    // 铸币限额管理
    mapping(address => uint256) private _minterAllowances;
    
    // 事件
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    event MinterConfigured(address indexed minter, uint256 allowance);
    event MinterRemoved(address indexed minter);
    
    // 修饰器：检查黑名单
    modifier notBlacklisted(address account) {
        require(!_blacklisted[account], "Account is blacklisted");
        _;
    }
    
    // 铸币功能（带限额控制）
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE) 
        whenNotPaused 
        notBlacklisted(to) 
    {
        require(amount <= _minterAllowances[msg.sender], "Exceeds minter allowance");
        _minterAllowances[msg.sender] -= amount;
        _mint(to, amount);
    }
    
    // 销毁功能
    function burn(uint256 amount) external whenNotPaused {
        _burn(msg.sender, amount);
    }
    
    // 黑名单管理
    function blacklist(address account) external onlyRole(BLACKLISTER_ROLE) {
        _blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    // 重写transfer以检查黑名单
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);
        require(!_blacklisted[from] && !_blacklisted[to], "Blacklisted address");
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.3 Gas优化技巧</h4>
            <p>稳定币通常有高频交易需求，Gas优化至关重要：</p>
            
            <div class="tip">
                💡 关键洞察：通过批量操作和存储优化，可以将Gas消耗降低30-50%。
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Gas优化实现示例 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract GasOptimizedStablecoin is StablecoinBase {
    // 使用packed结构体减少存储槽
    struct UserInfo {
        uint128 balance;      // 足够存储大部分余额
        uint64 lastTransfer;  // 时间戳
        bool isBlacklisted;   // 黑名单状态
        bool isWhitelisted;   // 白名单状态（免Gas费）
    }
    
    mapping(address => UserInfo) private _userInfo;
    
    // 批量转账（节省基础Gas开销）
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused {
        require(recipients.length == amounts.length, "Length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount;
        for (uint256 i = 0; i < amounts.length; ) {
            totalAmount += amounts[i];
            unchecked { ++i; }
        }
        
        require(_userInfo[msg.sender].balance >= totalAmount, "Insufficient balance");
        
        // 使用unchecked节省溢出检查Gas
        unchecked {
            _userInfo[msg.sender].balance -= uint128(totalAmount);
        }
        
        for (uint256 i = 0; i < recipients.length; ) {
            _userInfo[recipients[i]].balance += uint128(amounts[i]);
            emit Transfer(msg.sender, recipients[i], amounts[i]);
            unchecked { ++i; }
        }
    }
    
    // 使用assembly优化的余额查询
    function balanceOf(address account) public view returns (uint256 balance) {
        assembly {
            // 直接读取存储槽
            let slot := _userInfo.slot
            let key := account
            mstore(0x00, key)
            mstore(0x20, slot)
            let location := keccak256(0x00, 0x40)
            balance := shr(128, sload(location))
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>3.2 可升级模式深度实践</h3>
            
            <h4>3.2.1 代理模式对比分析</h4>
            <p>稳定币合约的可升级性是一个关键特性，让我们深入比较不同的升级模式：</p>
            
            <table class="comparison-table">
                <tr>
                    <th>升级模式</th>
                    <th>Gas成本</th>
                    <th>复杂度</th>
                    <th>存储冲突风险</th>
                    <th>适用场景</th>
                </tr>
                <tr>
                    <td>透明代理（Transparent Proxy）</td>
                    <td>~2300 Gas额外开销</td>
                    <td>中等</td>
                    <td>低</td>
                    <td>USDC、USDT等主流稳定币</td>
                </tr>
                <tr>
                    <td>UUPS（Universal Upgradeable Proxy）</td>
                    <td>~1000 Gas额外开销</td>
                    <td>高</td>
                    <td>中</td>
                    <td>Gas敏感的DeFi协议</td>
                </tr>
                <tr>
                    <td>钻石标准（Diamond/EIP-2535）</td>
                    <td>~2500 Gas额外开销</td>
                    <td>很高</td>
                    <td>很低</td>
                    <td>复杂的模块化系统</td>
                </tr>
                <tr>
                    <td>Beacon代理</td>
                    <td>~2100 Gas额外开销</td>
                    <td>中等</td>
                    <td>低</td>
                    <td>多实例部署场景</td>
                </tr>
            </table>
            
            <h4>3.2.2 UUPS模式实现</h4>
            <p>UUPS模式将升级逻辑放在实现合约中，提供更好的Gas效率：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">UUPS可升级稳定币实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 使用OpenZeppelin的UUPS实现
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract StablecoinV1 is 
    Initializable,
    ERC20Upgradeable,
    PausableUpgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable 
{
    // 存储布局版本控制
    uint256 private constant STORAGE_VERSION = 1;
    
    // 状态变量（注意顺序很重要）
    mapping(address => bool) public blacklisted;
    mapping(address => uint256) public minterAllowance;
    address[] public minters;
    
    // 初始化函数（代替构造函数）
    function initialize(
        string memory name,
        string memory symbol
    ) public initializer {
        __ERC20_init(name, symbol);
        __Pausable_init();
        __Ownable_init();
        __UUPSUpgradeable_init();
    }
    
    // 升级授权（只有owner可以升级）
    function _authorizeUpgrade(address newImplementation)
        internal
        onlyOwner
        override
    {}
    
    // 获取实现版本
    function version() external pure returns (string memory) {
        return "1.0.0";
    }
}

// V2版本示例（添加新功能）
contract StablecoinV2 is StablecoinV1 {
    // 新增状态变量（只能在最后添加）
    mapping(address => uint256) public dailyTransferLimit;
    mapping(address => uint256) public dailyTransferAmount;
    mapping(address => uint256) public lastTransferDay;
    
    // 新增功能：每日转账限额
    function setDailyLimit(address user, uint256 limit) external onlyOwner {
        dailyTransferLimit[user] = limit;
    }
    
    // 重写transfer以实现限额检查
    function transfer(address to, uint256 amount) 
        public 
        override 
        returns (bool) 
    {
        _checkDailyLimit(msg.sender, amount);
        return super.transfer(to, amount);
    }
    
    function _checkDailyLimit(address user, uint256 amount) private {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTransferDay[user] < today) {
            dailyTransferAmount[user] = 0;
            lastTransferDay[user] = today;
        }
        
        require(
            dailyTransferAmount[user] + amount <= dailyTransferLimit[user],
            "Daily limit exceeded"
        );
        
        dailyTransferAmount[user] += amount;
    }
    
    function version() external pure override returns (string memory) {
        return "2.0.0";
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.2.3 存储冲突防护</h4>
            <p>升级合约时最大的风险是存储冲突，这里是防护措施：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">存储间隙模式（Storage Gap） <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract StablecoinStorageV1 {
    // 状态变量
    mapping(address => uint256) internal _balances;
    mapping(address => mapping(address => uint256)) internal _allowances;
    uint256 internal _totalSupply;
    
    // 存储间隙：预留升级空间
    uint256[47] private __gap;  // 50 - 3 = 47
}

abstract contract StablecoinStorageV2 is StablecoinStorageV1 {
    // 新增状态变量
    mapping(address => bool) internal _frozen;
    uint256 internal _maxSupply;
    
    // 更新存储间隙
    uint256[45] private __gap;  // 47 - 2 = 45
}

// 使用非结构化存储（Unstructured Storage）
contract DiamondStorage {
    struct DiamondStorageStruct {
        mapping(address => uint256) balances;
        mapping(address => bool) blacklisted;
        uint256 totalSupply;
        address admin;
    }
    
    function diamondStorage() 
        internal 
        pure 
        returns (DiamondStorageStruct storage ds) 
    {
        bytes32 position = keccak256("diamond.standard.diamond.storage");
        assembly {
            ds.slot := position
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>3.3 跨链标准与实现</h3>
            
            <h4>3.3.1 主流跨链协议对比</h4>
            <p>稳定币的跨链需求日益增长，让我们深入了解各种跨链解决方案：</p>
            
            <table class="comparison-table">
                <tr>
                    <th>跨链协议</th>
                    <th>安全模型</th>
                    <th>延迟</th>
                    <th>支持链数</th>
                    <th>去中心化程度</th>
                </tr>
                <tr>
                    <td>LayerZero</td>
                    <td>Oracle + Relayer</td>
                    <td>几分钟</td>
                    <td>40+</td>
                    <td>中等</td>
                </tr>
                <tr>
                    <td>Axelar</td>
                    <td>PoS验证者集</td>
                    <td>5-30分钟</td>
                    <td>30+</td>
                    <td>高</td>
                </tr>
                <tr>
                    <td>Wormhole</td>
                    <td>Guardian网络</td>
                    <td>几分钟</td>
                    <td>20+</td>
                    <td>中等</td>
                </tr>
                <tr>
                    <td>IBC (Cosmos)</td>
                    <td>轻客户端</td>
                    <td>几秒</td>
                    <td>50+ (Cosmos生态)</td>
                    <td>很高</td>
                </tr>
            </table>
            
            <h4>3.3.2 LayerZero集成实现</h4>
            <p>LayerZero提供了灵活的跨链消息传递，适合稳定币的全链部署：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">LayerZero OFT稳定币实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">import "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTV2.sol";

contract OmniChainStablecoin is OFTV2, Pausable {
    // 链ID到地址的映射（用于限额管理）
    mapping(uint16 => address) public trustedRemotes;
    
    // 每条链的铸币限额
    mapping(uint16 => uint256) public chainMintLimit;
    mapping(uint16 => uint256) public chainMintAmount;
    
    // 跨链转账费用（基点）
    uint256 public bridgeFee = 10; // 0.1%
    address public feeCollector;
    
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address _lzEndpoint
    ) OFTV2(_name, _symbol, _decimals, _lzEndpoint) {
        feeCollector = msg.sender;
    }
    
    // 设置可信远程合约
    function setTrustedRemote(
        uint16 _chainId,
        bytes calldata _path
    ) external onlyOwner {
        trustedRemotes[_chainId] = address(bytes20(_path));
        trustedRemote[_chainId] = _path;
    }
    
    // 重写发送函数以实现费用收取
    function _send(
        address _from,
        uint16 _dstChainId,
        bytes32 _toAddress,
        uint256 _amount,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes memory _adapterParams
    ) internal override returns (uint256 amount) {
        // 计算并收取跨链费用
        uint256 fee = (_amount * bridgeFee) / 10000;
        uint256 amountAfterFee = _amount - fee;
        
        if (fee > 0) {
            _transfer(_from, feeCollector, fee);
        }
        
        // 检查目标链限额
        require(
            chainMintAmount[_dstChainId] + amountAfterFee <= chainMintLimit[_dstChainId],
            "Chain mint limit exceeded"
        );
        
        chainMintAmount[_dstChainId] += amountAfterFee;
        
        return super._send(
            _from,
            _dstChainId,
            _toAddress,
            amountAfterFee,
            _refundAddress,
            _zroPaymentAddress,
            _adapterParams
        );
    }
    
    // 估算跨链费用
    function estimateSendFee(
        uint16 _dstChainId,
        bytes32 _toAddress,
        uint256 _amount,
        bool _useZro,
        bytes calldata _adapterParams
    ) public view override returns (uint256 nativeFee, uint256 zroFee) {
        uint256 amountAfterFee = _amount - (_amount * bridgeFee) / 10000;
        return super.estimateSendFee(
            _dstChainId,
            _toAddress,
            amountAfterFee,
            _useZro,
            _adapterParams
        );
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.3.3 IBC协议集成（Cosmos生态）</h4>
            <p>IBC提供了最去中心化的跨链解决方案，特别适合Cosmos生态：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">CosmWasm IBC稳定币合约 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-rust">use cosmwasm_std::{
    entry_point, to_binary, Binary, Deps, DepsMut, 
    Env, MessageInfo, Response, StdResult, Uint128,
    IbcMsg, IbcTimeout, CosmosMsg,
};
use cw20::{Cw20Contract, Cw20ExecuteMsg};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IbcTransferMsg {
    pub channel_id: String,
    pub to_address: String,
    pub amount: Uint128,
    pub timeout: IbcTimeout,
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::IbcTransfer(transfer_msg) => {
            execute_ibc_transfer(deps, env, info, transfer_msg)
        }
        _ => handle_cw20_execute(deps, env, info, msg),
    }
}

fn execute_ibc_transfer(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: IbcTransferMsg,
) -> Result<Response, ContractError> {
    // 检查余额
    let balance = BALANCES.load(deps.storage, &info.sender)?;
    if balance < msg.amount {
        return Err(ContractError::InsufficientFunds {});
    }
    
    // 扣除余额
    BALANCES.update(
        deps.storage,
        &info.sender,
        |balance| -> StdResult<_> {
            Ok(balance.unwrap_or_default() - msg.amount)
        },
    )?;
    
    // 构建IBC消息
    let ibc_msg = IbcMsg::Transfer {
        channel_id: msg.channel_id,
        to_address: msg.to_address,
        amount: coin(msg.amount.u128(), "ustable"),
        timeout: msg.timeout,
    };
    
    Ok(Response::new()
        .add_message(ibc_msg)
        .add_attribute("action", "ibc_transfer")
        .add_attribute("from", info.sender)
        .add_attribute("amount", msg.amount))
}

// IBC包接收处理
#[entry_point]
pub fn ibc_packet_receive(
    deps: DepsMut,
    _env: Env,
    msg: IbcPacketReceiveMsg,
) -> Result<IbcReceiveResponse, Never> {
    // 解析接收的数据
    let packet: TransferPacket = from_slice(&msg.packet.data)?;
    
    // 铸造代币给接收者
    BALANCES.update(
        deps.storage,
        &packet.receiver,
        |balance| -> StdResult<_> {
            Ok(balance.unwrap_or_default() + packet.amount)
        },
    )?;
    
    Ok(IbcReceiveResponse::new()
        .set_ack(to_binary(&TransferAck::Success)?)
        .add_attribute("action", "receive")
        .add_attribute("receiver", packet.receiver)
        .add_attribute("amount", packet.amount))
}</code></pre>
                </div>
            </div>
            
            <h3>3.4 实践项目：构建企业级可升级稳定币</h3>
            
            <h4>3.4.1 项目需求分析</h4>
            <p>我们将构建一个具备以下特性的企业级稳定币：</p>
            <ul>
                <li>符合监管要求的KYC/AML功能</li>
                <li>可升级架构，支持功能迭代</li>
                <li>多链部署，支持主流公链</li>
                <li>完善的权限管理系统</li>
                <li>紧急暂停和恢复机制</li>
            </ul>
            
            <h4>3.4.2 完整实现</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">企业级稳定币完整实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract EnterpriseStablecoin is 
    Initializable,
    ERC20Upgradeable,
    PausableUpgradeable,
    AccessControlUpgradeable,
    UUPSUpgradeable 
{
    using ECDSA for bytes32;
    
    // 角色定义
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");
    bytes32 public constant KYC_ROLE = keccak256("KYC_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    
    // 状态变量
    mapping(address => bool) public blacklisted;
    mapping(address => bool) public kycApproved;
    mapping(address => uint256) public minterAllowance;
    mapping(address => uint256) public lastActivity;
    
    // 交易限制
    uint256 public maxTransactionAmount;
    uint256 public dailyTransferLimit;
    mapping(address => uint256) public dailyTransferred;
    mapping(address => uint256) public lastTransferDay;
    
    // 合规功能
    bool public kycRequired;
    uint256 public inactivityThreshold;
    
    // 签名nonce（防重放）
    mapping(address => uint256) public nonces;
    
    // 事件
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    event KYCApproved(address indexed account);
    event KYCRevoked(address indexed account);
    event ComplianceConfigUpdated(bool kycRequired, uint256 inactivityThreshold);
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(
        string memory name,
        string memory symbol,
        bool _kycRequired
    ) public initializer {
        __ERC20_init(name, symbol);
        __Pausable_init();
        __AccessControl_init();
        __UUPSUpgradeable_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, msg.sender);
        
        kycRequired = _kycRequired;
        maxTransactionAmount = 1000000 * 10**decimals(); // 1M默认限额
        dailyTransferLimit = 5000000 * 10**decimals();   // 5M每日限额
        inactivityThreshold = 365 days;                  // 1年不活跃阈值
    }
    
    // 铸币功能
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE)
        whenNotPaused 
    {
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!kycRequired || kycApproved[to], "KYC not approved");
        require(amount <= minterAllowance[msg.sender], "Exceeds allowance");
        
        minterAllowance[msg.sender] -= amount;
        _mint(to, amount);
        lastActivity[to] = block.timestamp;
    }
    
    // 带签名的铸币（链下授权）
    function mintWithSignature(
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external whenNotPaused {
        require(block.timestamp <= deadline, "Signature expired");
        
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Mint(address to,uint256 amount,uint256 nonce,uint256 deadline)"),
                to,
                amount,
                nonces[to]++,
                deadline
            )
        );
        
        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = hash.recover(v, r, s);
        
        require(hasRole(MINTER_ROLE, signer), "Invalid signer");
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!kycRequired || kycApproved[to], "KYC not approved");
        
        _mint(to, amount);
        lastActivity[to] = block.timestamp;
    }
    
    // 重写transfer函数
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(!blacklisted[from] && !blacklisted[to], "Blacklisted address");
        require(!kycRequired || (kycApproved[from] && kycApproved[to]), "KYC required");
        require(amount <= maxTransactionAmount, "Exceeds max transaction");
        
        // 检查每日限额
        _checkDailyLimit(from, amount);
        
        super._transfer(from, to, amount);
        
        // 更新活动时间
        lastActivity[from] = block.timestamp;
        lastActivity[to] = block.timestamp;
    }
    
    // 每日限额检查
    function _checkDailyLimit(address user, uint256 amount) private {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTransferDay[user] < today) {
            dailyTransferred[user] = 0;
            lastTransferDay[user] = today;
        }
        
        require(
            dailyTransferred[user] + amount <= dailyTransferLimit,
            "Daily limit exceeded"
        );
        
        dailyTransferred[user] += amount;
    }
    
    // 冻结不活跃账户的资金
    function freezeInactiveAccount(address account) 
        external 
        onlyRole(BLACKLISTER_ROLE) 
    {
        require(
            block.timestamp - lastActivity[account] > inactivityThreshold,
            "Account still active"
        );
        blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    // 批量KYC审批
    function batchApproveKYC(address[] calldata accounts) 
        external 
        onlyRole(KYC_ROLE) 
    {
        for (uint256 i = 0; i < accounts.length; i++) {
            kycApproved[accounts[i]] = true;
            emit KYCApproved(accounts[i]);
        }
    }
    
    // 紧急提取（仅限被黑名单地址）
    function emergencyWithdraw(address blacklistedAccount, address to) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(blacklisted[blacklistedAccount], "Account not blacklisted");
        uint256 amount = balanceOf(blacklistedAccount);
        _burn(blacklistedAccount, amount);
        _mint(to, amount);
    }
    
    // 升级授权
    function _authorizeUpgrade(address newImplementation)
        internal
        onlyRole(UPGRADER_ROLE)
        override
    {}
    
    // 暂停功能
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }
    
    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }
    
    // 获取版本
    function version() external pure returns (string memory) {
        return "1.0.0";
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.4.3 部署和测试脚本</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Hardhat部署和测试脚本 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-javascript">// deploy/01_deploy_stablecoin.js
const { ethers, upgrades } = require("hardhat");

module.exports = async ({ getNamedAccounts, deployments }) => {
    const { deploy } = deployments;
    const { deployer } = await getNamedAccounts();
    
    // 部署实现合约
    const EnterpriseStablecoin = await ethers.getContractFactory(
        "EnterpriseStablecoin"
    );
    
    const proxy = await upgrades.deployProxy(
        EnterpriseStablecoin,
        ["USD Stablecoin", "USDS", true], // 启用KYC
        { 
            initializer: "initialize",
            kind: "uups" 
        }
    );
    
    await proxy.deployed();
    console.log("Proxy deployed to:", proxy.address);
    
    // 获取实现地址
    const implementationAddress = await upgrades.erc1967.getImplementationAddress(
        proxy.address
    );
    console.log("Implementation deployed to:", implementationAddress);
    
    // 配置角色
    const MINTER_ROLE = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes("MINTER_ROLE")
    );
    const KYC_ROLE = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes("KYC_ROLE")
    );
    
    // 设置铸币者
    await proxy.grantRole(MINTER_ROLE, deployer);
    await proxy.setMinterAllowance(deployer, ethers.utils.parseUnits("1000000", 6));
    
    // 保存部署信息
    deployments.save("EnterpriseStablecoin", {
        address: proxy.address,
        implementation: implementationAddress,
        abi: EnterpriseStablecoin.interface.format("json"),
    });
};

// test/EnterpriseStablecoin.test.js
const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");

describe("EnterpriseStablecoin", function () {
    let stablecoin;
    let owner, minter, user1, user2, blacklister;
    let MINTER_ROLE, BLACKLISTER_ROLE, KYC_ROLE;
    
    beforeEach(async function () {
        [owner, minter, user1, user2, blacklister] = await ethers.getSigners();
        
        const EnterpriseStablecoin = await ethers.getContractFactory(
            "EnterpriseStablecoin"
        );
        stablecoin = await upgrades.deployProxy(
            EnterpriseStablecoin,
            ["Test USD", "TUSD", true],
            { kind: "uups" }
        );
        
        // 获取角色常量
        MINTER_ROLE = await stablecoin.MINTER_ROLE();
        BLACKLISTER_ROLE = await stablecoin.BLACKLISTER_ROLE();
        KYC_ROLE = await stablecoin.KYC_ROLE();
        
        // 配置角色
        await stablecoin.grantRole(MINTER_ROLE, minter.address);
        await stablecoin.grantRole(BLACKLISTER_ROLE, blacklister.address);
        await stablecoin.grantRole(KYC_ROLE, owner.address);
    });
    
    describe("KYC功能", function () {
        it("未通过KYC不能接收代币", async function () {
            await stablecoin.setMinterAllowance(
                minter.address, 
                ethers.utils.parseUnits("1000", 6)
            );
            
            await expect(
                stablecoin.connect(minter).mint(
                    user1.address, 
                    ethers.utils.parseUnits("100", 6)
                )
            ).to.be.revertedWith("KYC not approved");
        });
        
        it("通过KYC后可以正常交易", async function () {
            // 批准KYC
            await stablecoin.batchApproveKYC([user1.address, user2.address]);
            
            // 设置铸币额度
            await stablecoin.setMinterAllowance(
                minter.address, 
                ethers.utils.parseUnits("1000", 6)
            );
            
            // 铸币
            await stablecoin.connect(minter).mint(
                user1.address, 
                ethers.utils.parseUnits("100", 6)
            );
            
            // 转账
            await stablecoin.connect(user1).transfer(
                user2.address, 
                ethers.utils.parseUnits("50", 6)
            );
            
            expect(await stablecoin.balanceOf(user2.address))
                .to.equal(ethers.utils.parseUnits("50", 6));
        });
    });
    
    describe("升级功能", function () {
        it("可以升级到新版本", async function () {
            const EnterpriseStablecoinV2 = await ethers.getContractFactory(
                "EnterpriseStablecoinV2"
            );
            
            const upgraded = await upgrades.upgradeProxy(
                stablecoin.address,
                EnterpriseStablecoinV2
            );
            
            expect(await upgraded.version()).to.equal("2.0.0");
        });
    });
});</code></pre>
                </div>
            </div>
            
            <h3>练习题</h3>
            
            <div class="exercise">
                <h4>练习 3.1：ERC-20扩展实现</h4>
                <p>实现一个支持以下功能的ERC-20扩展：</p>
                <ul>
                    <li>批量转账功能（单笔交易中向多个地址转账）</li>
                    <li>转账备注功能（在链上记录转账备注信息）</li>
                    <li>定时锁定功能（代币在指定时间后才能转移）</li>
                </ul>
                <p>要求：Gas优化，支持紧急暂停。</p>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract ExtendedERC20 is ERC20, Pausable, Ownable {
    // 转账备注
    mapping(bytes32 => string) public transferNotes;
    
    // 时间锁
    struct TimeLock {
        uint256 amount;
        uint256 releaseTime;
    }
    mapping(address => TimeLock[]) public timeLocks;
    
    // 事件
    event TransferWithNote(address indexed from, address indexed to, uint256 value, string note);
    event TokensLocked(address indexed account, uint256 amount, uint256 releaseTime);
    event TokensUnlocked(address indexed account, uint256 amount);
    
    // 批量转账
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused returns (bool) {
        require(recipients.length == amounts.length, "Length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount;
        for (uint256 i = 0; i < amounts.length; ) {
            totalAmount += amounts[i];
            unchecked { ++i; }
        }
        
        require(balanceOf(msg.sender) >= totalAmount, "Insufficient balance");
        
        for (uint256 i = 0; i < recipients.length; ) {
            _transfer(msg.sender, recipients[i], amounts[i]);
            unchecked { ++i; }
        }
        
        return true;
    }
    
    // 带备注的转账
    function transferWithNote(
        address to,
        uint256 amount,
        string calldata note
    ) external whenNotPaused returns (bool) {
        _transfer(msg.sender, to, amount);
        
        bytes32 txHash = keccak256(
            abi.encodePacked(msg.sender, to, amount, block.timestamp)
        );
        transferNotes[txHash] = note;
        
        emit TransferWithNote(msg.sender, to, amount, note);
        return true;
    }
    
    // 锁定代币
    function lockTokens(uint256 amount, uint256 lockDuration) external {
        require(amount > 0, "Amount must be positive");
        require(lockDuration > 0, "Duration must be positive");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        _transfer(msg.sender, address(this), amount);
        
        timeLocks[msg.sender].push(TimeLock({
            amount: amount,
            releaseTime: block.timestamp + lockDuration
        }));
        
        emit TokensLocked(msg.sender, amount, block.timestamp + lockDuration);
    }
    
    // 解锁代币
    function unlockTokens() external {
        TimeLock[] storage locks = timeLocks[msg.sender];
        uint256 totalUnlocked;
        
        for (uint256 i = 0; i < locks.length; ) {
            if (locks[i].releaseTime <= block.timestamp && locks[i].amount > 0) {
                totalUnlocked += locks[i].amount;
                locks[i].amount = 0;
            }
            unchecked { ++i; }
        }
        
        require(totalUnlocked > 0, "No tokens to unlock");
        _transfer(address(this), msg.sender, totalUnlocked);
        
        emit TokensUnlocked(msg.sender, totalUnlocked);
    }
    
    // 查询锁定的代币
    function getLockedBalance(address account) external view returns (uint256) {
        TimeLock[] memory locks = timeLocks[account];
        uint256 locked;
        
        for (uint256 i = 0; i < locks.length; i++) {
            if (locks[i].releaseTime > block.timestamp) {
                locked += locks[i].amount;
            }
        }
        
        return locked;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>练习 3.2：跨链桥实现</h4>
                <p>设计并实现一个简化的跨链桥，支持：</p>
                <ul>
                    <li>在源链锁定代币</li>
                    <li>在目标链铸造包装代币</li>
                    <li>实现简单的验证机制</li>
                    <li>处理跨链失败的情况</li>
                </ul>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">// 源链合约
contract SourceBridge is Ownable, Pausable {
    IERC20 public token;
    mapping(bytes32 => bool) public processedTransfers;
    uint256 public nonce;
    
    event TokensLocked(
        address indexed from,
        address indexed to,
        uint256 amount,
        uint256 targetChain,
        uint256 nonce
    );
    
    constructor(address _token) {
        token = IERC20(_token);
    }
    
    function lockTokens(
        address targetAddress,
        uint256 amount,
        uint256 targetChain
    ) external whenNotPaused {
        require(amount > 0, "Amount must be positive");
        require(token.transferFrom(msg.sender, address(this), amount), "Transfer failed");
        
        emit TokensLocked(msg.sender, targetAddress, amount, targetChain, ++nonce);
    }
    
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), "Withdraw failed");
    }
}

// 目标链合约
contract TargetBridge is Ownable, Pausable {
    mapping(address => bool) public validators;
    mapping(bytes32 => uint256) public confirmations;
    mapping(bytes32 => bool) public processedTransfers;
    
    uint256 public requiredConfirmations = 3;
    WrappedToken public wrappedToken;
    
    event TokensMinted(address indexed to, uint256 amount, bytes32 transferId);
    event TransferConfirmed(bytes32 transferId, address validator);
    
    constructor(string memory name, string memory symbol) {
        wrappedToken = new WrappedToken(name, symbol);
    }
    
    function addValidator(address validator) external onlyOwner {
        validators[validator] = true;
    }
    
    function confirmTransfer(
        address to,
        uint256 amount,
        uint256 sourceChain,
        uint256 nonce
    ) external {
        require(validators[msg.sender], "Not a validator");
        
        bytes32 transferId = keccak256(
            abi.encodePacked(to, amount, sourceChain, nonce)
        );
        
        require(!processedTransfers[transferId], "Already processed");
        
        confirmations[transferId]++;
        emit TransferConfirmed(transferId, msg.sender);
        
        if (confirmations[transferId] >= requiredConfirmations) {
            processedTransfers[transferId] = true;
            wrappedToken.mint(to, amount);
            emit TokensMinted(to, amount, transferId);
        }
    }
}

// 包装代币合约
contract WrappedToken is ERC20, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
    
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>练习 3.3：Gas优化挑战</h4>
                <p>给定一个低效的ERC-20实现，将其Gas消耗优化至少30%：</p>
                <pre><code class="language-solidity">// 低效实现
contract InefficientToken is ERC20 {
    mapping(address => bool) public whitelist;
    uint256[] public transferHistory;
    mapping(address => uint256[]) public userTransfers;
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(whitelist[msg.sender] || whitelist[to], "Not whitelisted");
        
        transferHistory.push(block.timestamp);
        userTransfers[msg.sender].push(amount);
        userTransfers[to].push(amount);
        
        return super.transfer(to, amount);
    }
}</code></pre>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract OptimizedToken is ERC20 {
    // 使用bitmap替代mapping节省存储
    mapping(uint256 => uint256) private whitelistBitmap;
    
    // 事件替代存储历史记录
    event TransferRecorded(address indexed from, address indexed to, uint256 amount, uint256 timestamp);
    
    // 只存储必要的统计信息
    mapping(address => uint256) public transferCount;
    
    function setWhitelist(address account, bool status) external onlyOwner {
        uint256 index = uint256(uint160(account));
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        
        if (status) {
            whitelistBitmap[wordIndex] |= (1 << bitIndex);
        } else {
            whitelistBitmap[wordIndex] &= ~(1 << bitIndex);
        }
    }
    
    function isWhitelisted(address account) public view returns (bool) {
        uint256 index = uint256(uint160(account));
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        uint256 word = whitelistBitmap[wordIndex];
        return (word & (1 << bitIndex)) != 0;
    }
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        // 使用局部变量缓存状态
        bool senderWhitelisted = isWhitelisted(msg.sender);
        bool recipientWhitelisted = isWhitelisted(to);
        
        require(senderWhitelisted || recipientWhitelisted, "Not whitelisted");
        
        // 使用事件记录历史，而不是存储
        emit TransferRecorded(msg.sender, to, amount, block.timestamp);
        
        // 使用unchecked节省Gas
        unchecked {
            transferCount[msg.sender]++;
            transferCount[to]++;
        }
        
        return super.transfer(to, amount);
    }
    
    // 批量检查白名单状态
    function batchCheckWhitelist(address[] calldata accounts) 
        external 
        view 
        returns (bool[] memory) 
    {
        bool[] memory results = new bool[](accounts.length);
        for (uint256 i = 0; i < accounts.length; ) {
            results[i] = isWhitelisted(accounts[i]);
            unchecked { ++i; }
        }
        return results;
    }
}</code></pre>
                    <p><strong>优化说明：</strong></p>
                    <ul>
                        <li>使用bitmap存储白名单，每个地址只需1bit而不是256bit</li>
                        <li>用事件替代数组存储，节省大量存储Gas</li>
                        <li>使用unchecked块避免不必要的溢出检查</li>
                        <li>缓存存储读取结果，避免重复SLOAD</li>
                        <li>移除不必要的动态数组操作</li>
                    </ul>
                </div>
            </div>
            
            <h3>本章小结</h3>
            <div class="summary-box">
                <h4>核心要点回顾：</h4>
                <ul>
                    <li><strong>ERC-20标准：</strong>稳定币的基础接口，需要扩展以支持合规功能</li>
                    <li><strong>可升级架构：</strong>UUPS模式提供最佳Gas效率，适合高频交易场景</li>
                    <li><strong>跨链互操作：</strong>LayerZero和IBC提供不同的安全性和去中心化权衡</li>
                    <li><strong>Gas优化：</strong>通过存储打包、批量操作和事件日志可大幅降低成本</li>
                    <li><strong>合规功能：</strong>KYC、AML、黑名单是企业级稳定币的必备功能</li>
                </ul>
                
                <h4>下一步学习：</h4>
                <p>在掌握了ERC-20标准和可升级架构后，下一章我们将深入探讨抵押型稳定币的设计，包括金库机制、清算引擎和预言机集成。</p>
            </div>
            
            <h3>术语速查表</h3>
            <table class="glossary-table">
                <tr>
                    <th>术语</th>
                    <th>英文</th>
                    <th>解释</th>
                </tr>
                <tr>
                    <td>代理模式</td>
                    <td>Proxy Pattern</td>
                    <td>通过代理合约调用实现合约，实现可升级性</td>
                </tr>
                <tr>
                    <td>存储槽</td>
                    <td>Storage Slot</td>
                    <td>EVM中的256位存储单位，每个槽消耗20000 Gas</td>
                </tr>
                <tr>
                    <td>轻客户端</td>
                    <td>Light Client</td>
                    <td>只存储区块头的客户端，用于验证跨链消息</td>
                </tr>
                <tr>
                    <td>包装代币</td>
                    <td>Wrapped Token</td>
                    <td>在目标链上代表源链资产的合成代币</td>
                </tr>
                <tr>
                    <td>时间锁</td>
                    <td>Timelock</td>
                    <td>延迟执行机制，增加安全性和可预测性</td>
                </tr>
            </table>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script>
        function toggleAnswer(answerId) {
            const answerElement = document.getElementById(answerId);
            answerElement.classList.toggle('show');
        }
        
        function toggleCode(btn) {
            const codeContent = btn.parentElement.nextElementSibling;
            const isCollapsed = codeContent.classList.contains('collapsed');
            
            if (isCollapsed) {
                codeContent.classList.remove('collapsed');
                btn.textContent = '折叠';
            } else {
                codeContent.classList.add('collapsed');
                btn.textContent = '展开';
            }
        }
        
        // 导航栏切换
        function toggleNav() {
            const navMenu = document.getElementById('navMenu');
            const navToggle = document.querySelector('.nav-toggle');
            navMenu.classList.toggle('active');
            navToggle.classList.toggle('active');
        }
        
        // 监听滚动，更新活动导航项
        function updateActiveNav() {
            const sections = document.querySelectorAll('.chapter');
            const navLinks = document.querySelectorAll('.nav-link');
            const chapterLinks = document.querySelectorAll('.chapter-list a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
            
            chapterLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        }
        
        // Initialize all code blocks
        document.addEventListener('DOMContentLoaded', function() {
            // Convert existing code blocks to new structure
            const codeBlocks = document.querySelectorAll('.code-block');
            codeBlocks.forEach((block, index) => {
                // Skip if already has the new structure
                if (block.querySelector('.code-header')) return;
                
                // Get the code content
                const codeText = block.textContent || block.innerText;
                
                // Determine language from code content
                let language = 'javascript';
                if (codeText.includes('pragma solidity') || codeText.includes('contract ')) {
                    language = 'solidity';
                } else if (codeText.includes('npm ') || codeText.includes('npx ')) {
                    language = 'bash';
                } else if (codeText.includes('import pandas') || codeText.includes('def ')) {
                    language = 'python';
                }
                
                // Create new structure
                block.innerHTML = `
                    <div class="code-header">
                        <span class="code-language">${language}</span>
                        <button class="code-toggle" onclick="toggleCode(this)">展开</button>
                    </div>
                    <div class="code-content collapsed">
                        <pre><code class="language-${language}">${codeText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>
                    </div>
                `;
            });
            
            // Apply syntax highlighting
            Prism.highlightAll();
            
            // 添加滚动监听
            window.addEventListener('scroll', updateActiveNav);
            updateActiveNav();
            
            // 点击导航链接后关闭移动端菜单
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => {
                link.addEventListener('click', () => {
                    const navMenu = document.getElementById('navMenu');
                    const navToggle = document.querySelector('.nav-toggle');
                    navMenu.classList.remove('active');
                    navToggle.classList.remove('active');
                });
            });
        });
    </script>
</body>
</html>