<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>区块链稳定币智能合约教程</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --background-color: #f8fafc;
            --text-color: #1e293b;
            --code-bg: #1e293b;
            --border-color: #e2e8f0;
            --success-color: #10b981;
            --warning-color: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            border-radius: 0 0 20px 20px;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .chapter {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            font-size: 2rem;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        h3 {
            color: var(--secondary-color);
            margin: 1.5rem 0 1rem;
            font-size: 1.5rem;
        }

        .theory-section {
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid var(--primary-color);
        }

        .practice-section {
            background: #fef3c7;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid var(--warning-color);
        }

        .code-block {
            background: var(--code-bg);
            color: #f8f8f2;
            border-radius: 8px;
            margin: 1rem 0;
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0f172a;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #334155;
        }
        
        .code-language {
            color: #94a3b8;
            font-size: 0.875rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .code-toggle {
            background: #1e293b;
            border: 1px solid #475569;
            color: #94a3b8;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        .code-toggle:hover {
            background: #334155;
            color: #e2e8f0;
        }
        
        .code-content {
            padding: 1.5rem;
            overflow-x: auto;
            max-height: 400px;
            transition: max-height 0.3s ease-in-out;
        }
        
        .code-content.collapsed {
            max-height: 100px;
            overflow: hidden;
            position: relative;
        }
        
        .code-content.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(transparent, var(--code-bg));
        }
        
        .code-content pre {
            margin: 0;
            overflow: visible;
            white-space: pre;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .exercise {
            background: #dbeafe;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .exercise-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .exercise-icon {
            font-size: 1.5rem;
        }

        .answer-toggle {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
        }

        .answer-toggle:hover {
            background: var(--secondary-color);
        }

        .answer-content {
            display: none;
            background: white;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .answer-content.show {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .highlight {
            background: #fef3c7;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-weight: 600;
        }

        .tip {
            background: #d1fae5;
            border-left: 4px solid var(--success-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .warning {
            background: #fee2e2;
            border-left: 4px solid #ef4444;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }
        
        .tip {
            background: #e0f2fe;
            border-left: 4px solid #0284c7;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
            color: #075985;
        }
        
        .tip strong {
            color: #0c4a6e;
        }

        code {
            background: #e2e8f0;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .code-block code {
            background: none;
            padding: 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .chapter {
                padding: 1.5rem;
            }
        }
        
        /* 列表缩进样式 */
        ul, ol {
            margin-left: 1.5rem;
            padding-left: 0;
        }
        
        ul ul, ol ol, ul ol, ol ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        li {
            margin-bottom: 0.5rem;
            line-height: 1.8;
        }
        
        li > ul, li > ol {
            margin-top: 0.5rem;
        }
        
        /* 确保嵌套列表有适当的缩进 */
        .theory-section ul ul,
        .theory-section ol ol {
            margin-left: 2rem;
        }
        
        .theory-section ul ul ul,
        .theory-section ol ol ol {
            margin-left: 2rem;
        }
        
        /* 导航栏样式 */
        nav {
            background: #0f172a;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .nav-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }
        
        .nav-title {
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            text-decoration: none;
        }
        
        .nav-menu {
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 2rem;
        }
        
        .nav-item {
            position: relative;
        }
        
        .nav-link {
            color: #cbd5e1;
            text-decoration: none;
            padding: 0.5rem 0;
            transition: color 0.3s;
            font-size: 0.95rem;
        }
        
        .nav-link:hover,
        .nav-link.active {
            color: white;
        }
        
        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-color);
        }
        
        /* 移动端菜单按钮 */
        .nav-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }
        
        .nav-toggle span {
            display: block;
            width: 25px;
            height: 3px;
            background: white;
            margin: 5px 0;
            transition: 0.3s;
        }
        
        /* 章节指示器 */
        .chapter-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 200px;
            z-index: 100;
        }
        
        .chapter-indicator h4 {
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            color: var(--text-color);
        }
        
        .chapter-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.85rem;
        }
        
        .chapter-list li {
            padding: 0.3rem 0;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .chapter-list li:last-child {
            border-bottom: none;
        }
        
        .chapter-list a {
            color: #64748b;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .chapter-list a:hover,
        .chapter-list a.active {
            color: var(--primary-color);
        }
        
        /* 移动端响应式 */
        @media (max-width: 768px) {
            .nav-menu {
                position: fixed;
                top: 60px;
                left: -100%;
                width: 100%;
                height: calc(100vh - 60px);
                background: #0f172a;
                flex-direction: column;
                padding: 2rem;
                gap: 1rem;
                transition: left 0.3s;
                overflow-y: auto;
            }
            
            .nav-menu.active {
                left: 0;
            }
            
            .nav-toggle {
                display: block;
            }
            
            .nav-toggle.active span:nth-child(1) {
                transform: rotate(-45deg) translate(-5px, 6px);
            }
            
            .nav-toggle.active span:nth-child(2) {
                opacity: 0;
            }
            
            .nav-toggle.active span:nth-child(3) {
                transform: rotate(45deg) translate(-5px, -6px);
            }
            
            .chapter-indicator {
                display: none;
            }
            
            header {
                margin-bottom: 0;
            }
            
            .container {
                padding-top: 10px;
            }
        }
        
        /* 平滑滚动 */
        html {
            scroll-behavior: smooth;
            scroll-padding-top: 80px;
        }
        
        /* 调整header样式以配合导航栏 */
        header {
            margin-bottom: 0;
        }
        
        /* 章节顶部间距 */
        .chapter {
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <!-- 导航栏 -->
    <nav>
        <div class="nav-container">
            <div class="nav-content">
                <a href="#top" class="nav-title">稳定币教程</a>
                <button class="nav-toggle" onclick="toggleNav()">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <ul class="nav-menu" id="navMenu">
                    <li class="nav-item">
                        <a href="#intro" class="nav-link">引言</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter1" class="nav-link">第一章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter2" class="nav-link">第二章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter3" class="nav-link">第三章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter4" class="nav-link">第四章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter5" class="nav-link">第五章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter6" class="nav-link">第六章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter7" class="nav-link">第七章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter8" class="nav-link">第八章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter9" class="nav-link">第九章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter10" class="nav-link">第十章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter11" class="nav-link">第十一章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter12" class="nav-link">第十二章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter13" class="nav-link">第十三章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter14" class="nav-link">第十四章</a>
                    </li>
                    <li class="nav-item">
                        <a href="#chapter15" class="nav-link">第十五章</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    
    <!-- 章节指示器 -->
    <div class="chapter-indicator" id="chapterIndicator">
        <h4>章节导航</h4>
        <ul class="chapter-list">
            <li><a href="#intro">引言：稳定币历史与概念</a></li>
            <li><a href="#chapter1">1. 区块链基础</a></li>
            <li><a href="#chapter2">2. 稳定币分类</a></li>
            <li><a href="#chapter3">3. ERC-20标准</a></li>
            <li><a href="#chapter4">4. 抵押机制</a></li>
            <li><a href="#chapter5">5. 数学模型</a></li>
            <li><a href="#chapter6">6. AMM集成</a></li>
            <li><a href="#chapter7">7. 借贷协议</a></li>
            <li><a href="#chapter8">8. 收益策略</a></li>
            <li><a href="#chapter9">9. 智能合约安全</a></li>
            <li><a href="#chapter10">10. 经济攻击防御</a></li>
            <li><a href="#chapter11">11. 跨链稳定币</a></li>
            <li><a href="#chapter12">12. 监管合规</a></li>
            <li><a href="#chapter13">13. 替代平台</a></li>
            <li><a href="#chapter14">14. 市场分析</a></li>
            <li><a href="#chapter15">15. 案例研究</a></li>
        </ul>
    </div>
    
    <header id="top">
        <div class="container">
            <h1>区块链稳定币智能合约：从理论到实践</h1>
        </div>
    </header>

    <div class="container">
        <div class="chapter" id="intro">
            <h2>引言：稳定币的历史、概念与市场格局</h2>
            
            <div class="intro-box">
                <strong>本章概览：</strong>
                <ul>
                    <li>稳定币的定义与核心价值主张</li>
                    <li>稳定币发展历史与重要里程碑</li>
                    <li>稳定币不可能三角理论</li>
                    <li>2024年全球稳定币市场格局与监管现状</li>
                    <li>稳定币与传统金融的关系</li>
                </ul>
            </div>
            
            <div class="theory-section">
                <h3>基础概念厘清</h3>
                <p>在深入稳定币之前，让我们快速厘清几个基础概念：</p>
                
                <h4>比特币（Bitcoin）</h4>
                <ul>
                    <li><strong>本质</strong>：第一个成功的去中心化数字货币，2009年由中本聪创造</li>
                    <li><strong>核心创新</strong>：解决了双重支付问题，无需可信第三方</li>
                    <li><strong>技术基础</strong>：工作量证明（PoW）+ UTXO模型 + P2P网络</li>
                    <li><strong>与稳定币关系</strong>：比特币的价格波动性（日波动可达10%+）催生了稳定币需求</li>
                </ul>
                
                <h4>区块链（Blockchain）</h4>
                <ul>
                    <li><strong>本质</strong>：分布式账本技术，按时间顺序链接的数据块</li>
                    <li><strong>关键特性</strong>：
                        <ul>
                            <li>不可篡改性：通过密码学哈希链接</li>
                            <li>透明性：所有节点可验证</li>
                            <li>去中心化：无单点控制</li>
                        </ul>
                    </li>
                    <li><strong>演进</strong>：
                        <ul>
                            <li>区块链1.0：数字货币（比特币）</li>
                            <li>区块链2.0：智能合约（以太坊）</li>
                            <li>区块链3.0：可扩展应用（Solana、Cosmos等）</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>为什么需要稳定币？</h4>
                <div style="background: #fef3c7; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <p><strong>核心矛盾</strong>：加密货币要成为真正的"货币"，需要满足三个功能：</p>
                    <ol>
                        <li><strong>交换媒介</strong>：比特币波动太大，商家不愿接受</li>
                        <li><strong>价值储存</strong>：今天1 BTC可能买一辆车，明天可能只够买辆自行车</li>
                        <li><strong>记账单位</strong>：无法用波动资产定价商品</li>
                    </ol>
                    <p><strong>稳定币的使命</strong>：在保留区块链技术优势的同时，提供价格稳定的数字货币。</p>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>常见误区澄清</h3>
                
                <h4>Q币、购物卡是稳定币吗？</h4>
                <div class="exercise" style="background: #f3f4f6; border: 2px solid #94a3b8;">
                    <p><strong>问题：</strong>腾讯Q币、商家购物充值卡算不算稳定币？</p>
                    
                    <div style="margin-top: 1rem;">
                        <p><strong>答案：不算。</strong>虽然它们都锚定法币（1Q币=1元人民币），但本质区别在于：</p>
                        
                        <table style="width: 100%; margin-top: 1rem;">
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px;">特征</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Q币/购物卡</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">区块链稳定币</th>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">技术基础</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">中心化数据库</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">分布式账本</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">可转让性</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">受限（通常不可转让）</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">自由转让</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">使用范围</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">单一平台/商家</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">全球通用</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">可编程性</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">无</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">智能合约集成</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">透明度</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">不透明</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">链上可审计</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;">监管性质</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">预付卡/积分</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">数字资产/证券</td>
                            </tr>
                        </table>
                        
                        <div class="tip" style="margin-top: 1rem;">
                            <strong>💡 核心区别：</strong>Q币是"封闭系统内的积分"，而稳定币是"开放网络上的可编程货币"。这就像局域网内的文件共享vs互联网上的网站。
                        </div>
                    </div>
                </div>
                
                <h4>稳定币是新的ICO造富神话吗？</h4>
                <div class="warning" style="margin: 1rem 0;">
                    <p><strong>答案：绝对不是。</strong>稳定币与ICO有本质区别：</p>
                    
                    <ul>
                        <li><strong>ICO（Initial Coin Offering）</strong>：
                            <ul>
                                <li>目的：融资，承诺未来收益</li>
                                <li>价格：期望大幅升值</li>
                                <li>风险：95%+项目失败或诈骗</li>
                                <li>监管：多数被定性为非法证券发行</li>
                            </ul>
                        </li>
                        <li><strong>稳定币</strong>：
                            <ul>
                                <li>目的：提供稳定支付工具</li>
                                <li>价格：锚定法币，不升值</li>
                                <li>收益：仅来自利息或手续费</li>
                                <li>监管：逐步合规化</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <p><strong>投资角度：</strong></p>
                    <ul>
                        <li>持有稳定币不会让你暴富（设计目标就是保值）</li>
                        <li>稳定币项目方盈利来自：铸币税、利息收入、交易费用</li>
                        <li>用户使用稳定币是为了：避险、支付、DeFi收益</li>
                    </ul>
                    
                    <p style="color: #dc2626; font-weight: bold;">⚠️ 警告：任何承诺"稳定币投资高回报"的都是骗局！</p>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>稳定币发展简史</h3>
                
                <div style="background: #e0f2fe; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                    <h4>📊 稳定币市场增长数据</h4>
                    <ul>
                        <li>2017年：总市值 ~$10亿（主要是USDT）</li>
                        <li>2020年：总市值 ~$280亿（DeFi推动，增长28倍）</li>
                        <li>2021年：总市值 ~$1,800亿（牛市顶峰，单年增长6.4倍）</li>
                        <li>2024年：总市值 ~$1,600亿（市场成熟，日交易量超$700亿）</li>
                    </ul>
                    <p><strong>年复合增长率（CAGR）</strong>：2017-2024约为155%</p>
                </div>
                
                <h4>早期探索（2014-2017）：从概念验证到商业应用</h4>
                <ul>
                    <li><strong>2014年7月 - Tether (USDT)</strong>：中心化稳定币的开创者
                        <ul>
                            <li>技术架构演进：Omni Layer（比特币二层）→ ERC20（以太坊代币标准）（2017）→ TRC20（波场代币标准）（2019）→ 多链部署（30+条链）</li>
                            <li>储备演变：100%美元现金（声称）→ 商业票据+国债+现金（2021披露）→ 美国国债为主（2023）</li>
                            <li>关键里程碑：
                                <ul>
                                    <li>2017年：日交易量首次超过比特币</li>
                                    <li>2019年：承认仅74%现金支持</li>
                                    <li>2021年：与纽约州检察长达成和解，罚款$1850万</li>
                                    <li>2024年：持有超$900亿美国国债，成为第16大持有者</li>
                                </ul>
                            </li>
                            <li>技术创新：引入"授权铸造"模式，特定地址可铸造/销毁</li>
                        </ul>
                    </li>
                    <li><strong>2014年9月 - BitUSD</strong>：去中心化稳定币的先驱
                        <ul>
                            <li>基于BitShares的DPoS共识（21个见证人，3秒出块）</li>
                            <li>抵押机制：175%初始抵押率，110%强制清算线</li>
                            <li>价格反馈系统：见证人喂价，中位数定价，1小时更新</li>
                            <li>创新功能：
                                <ul>
                                    <li>强制平仓：任何人可以以110%抵押率强制平仓</li>
                                    <li>黑天鹅保护：全局结算机制</li>
                                    <li>做市商激励：价差收益归做市商</li>
                                </ul>
                            </li>
                            <li>失败教训：2018年BTS暴跌90%，大规模清算导致BitUSD长期溢价交易</li>
                        </ul>
                    </li>
                    <li><strong>2017年12月 - DAI (单抵押版)</strong>：智能合约稳定币的里程碑
                        <ul>
                            <li>技术突破：
                                <ul>
                                    <li>目标价格反馈机制（TRFM）：动态调整目标价格</li>
                                    <li>敏感度参数：控制反馈强度</li>
                                    <li>全局结算：紧急关停保护用户资产</li>
                                </ul>
                            </li>
                            <li>智能合约架构：
                                <ul>
                                    <li>CDP引擎：管理抵押品和债务</li>
                                    <li>价格预言机：14个独立喂价节点</li>
                                    <li>清算引擎：3%罚金 + 荷兰拍卖</li>
                                </ul>
                            </li>
                            <li>治理代币MKR：风险参数投票、紧急关停权限、稳定费收入销毁</li>
                        </ul>
                    </li>
                </ul>

                <h4>快速扩张期（2018-2020）：从实验到主流采用</h4>
                <ul>
                    <li><strong>2018年9月 - 合规稳定币元年</strong>
                        <ul>
                            <li><strong>USDC (Centre联盟)</strong>
                                <ul>
                                    <li>技术架构：可升级代理合约，支持暂停、黑名单功能</li>
                                    <li>合规措施：KYC/AML合作伙伴，月度审计报告</li>
                                    <li>初期增长：3个月达到$1亿市值，主要用于交易所间套利</li>
                                </ul>
                            </li>
                            <li><strong>PAX (Paxos Standard)</strong>
                                <ul>
                                    <li>监管创新：首个获NYDFS批准的ERC-20稳定币</li>
                                    <li>技术特色：智能合约可冻结特定地址，符合执法要求</li>
                                    <li>市场定位：机构级托管，与Revolut等金融科技合作</li>
                                </ul>
                            </li>
                            <li><strong>GUSD (Gemini Dollar)</strong>
                                <ul>
                                    <li>安全机制：离线签名铸造，多重签名销毁</li>
                                    <li>保险覆盖：FDIC保险（最高$250,000）</li>
                                    <li>应用场景：Flexa支付网络，BlockFi借贷</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2019年11月 - 多抵押DAI（MCD）革命</strong>
                        <ul>
                            <li><strong>架构升级</strong>
                                <ul>
                                    <li>模块化设计：独立的抵押品适配器（Join Adapters）</li>
                                    <li>拍卖引擎：盈余拍卖（FLAP）、债务拍卖（FLOP）、清算拍卖（FLIP）</li>
                                    <li>预言机安全模块（OSM，延迟价格更新以防止操纵）：1小时价格延迟，防闪电贷攻击</li>
                                </ul>
                            </li>
                            <li><strong>风险参数</strong>
                                <ul>
                                    <li>稳定费率（借出DAI的利息）：2-20%年化（根据抵押品类型）</li>
                                    <li>清算罚金：13%（防止系统性风险）</li>
                                    <li>债务上限：每种抵押品独立设置</li>
                                </ul>
                            </li>
                            <li><strong>DSR创新</strong>
                                <ul>
                                    <li>实现机制：通过pot合约累积利息</li>
                                    <li>利率决策：MKR持有者投票，2-8%区间</li>
                                    <li>市场影响：$1亿+DAI锁定，成为无风险利率基准</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2020年6-12月 - DeFi夏天：稳定币大爆发</strong>
                        <ul>
                            <li><strong>关键里程碑</strong>
                                <ul>
                                    <li>6月15日：Compound启动COMP挖矿，稳定币APY达40%</li>
                                    <li>7月17日：YFI发布，yUSD金库年化1000%+</li>
                                    <li>8月13日：Curve CRV上线，3pool（DAI/USDC/USDT）TVL $5亿</li>
                                    <li>9月17日：Uniswap UNI空投，稳定币对日交易量$10亿</li>
                                </ul>
                            </li>
                            <li><strong>创新机制</strong>
                                <ul>
                                    <li>Curve StableSwap：A参数动态调整，降低滑点100倍</li>
                                    <li>Ampleforth：弹性供应稳定币，每日rebase机制</li>
                                    <li>算法稳定币实验：ESD（优惠券机制）、DSD（债券系统）、Basis Cash（三币模型）</li>
                                </ul>
                            </li>
                            <li><strong>数据统计</strong>
                                <ul>
                                    <li>稳定币供应量：$50亿→$250亿（500%增长）</li>
                                    <li>DeFi锁仓价值：$10亿→$150亿，稳定币占40%</li>
                                    <li>日均交易笔数：10万→100万笔</li>
                                    <li>Gas消耗：稳定币转账占以太坊总Gas的30%</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>动荡与监管（2021-2023）：从狂热到理性回归</h4>
                <ul>
                    <li><strong>2021年 - 算法稳定币创新巅峰</strong>
                        <ul>
                            <li><strong>UST/Terra生态爆发</strong>
                                <ul>
                                    <li>市值增长：$1.8亿(1月)→$180亿(12月)，成为第四大稳定币</li>
                                    <li>Anchor Protocol：提供19.5%固定年化收益，TVL达$170亿</li>
                                    <li>生态扩张：支持Ethereum、Solana、Avalanche等10+条链</li>
                                    <li>比特币储备：Luna Foundation Guard购买$35亿BTC作为储备</li>
                                </ul>
                            </li>
                            <li><strong>FRAX革命性创新</strong>
                                <ul>
                                    <li>部分储备机制：初始100%抵押→逐步降至85%</li>
                                    <li>算法市场操作(AMO)：协议直接在Curve等部署流动性</li>
                                    <li><span class="tooltip">ve经济模型<span class="tooltip-content">Vote-Escrowed，锁定代币获得投票权</span></span>：veFXS锁定机制，最长4年</li>
                                    <li>收益分配：协议收入100%分配给veFXS持有者</li>
                                </ul>
                            </li>
                            <li><strong>其他创新项目</strong>
                                <ul>
                                    <li>MIM (Abracadabra)：利用生息资产作抵押，市值达$50亿</li>
                                    <li>FEI Protocol：PCV（协议控制价值）概念，$13亿创世发行</li>
                                    <li>LUSD (Liquity)：无治理、不可变合约，110%最低抵押率</li>
                                    <li>alUSD (Alchemix)：自我偿还贷款，未来收益作抵押</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2022年5月 - UST/LUNA死亡螺旋详解</strong>
                        <ul>
                            <li><strong>崩盘前奏（5月1-7日）</strong>
                                <ul>
                                    <li>4pool提案失败：Curve战争失利，UST失去流动性护城河</li>
                                    <li>大额提款：$1.5亿UST从Anchor提出并抛售</li>
                                    <li>LFG错误决策：动用BTC储备防守而非UST回购</li>
                                </ul>
                            </li>
                            <li><strong>崩盘过程（5月8-13日）</strong>
                                <ul>
                                    <li>5月8日：UST脱锚至$0.985，24小时交易量$20亿</li>
                                    <li>5月9日：LUNA从$80跌至$30，市值蒸发$300亿</li>
                                    <li>5月10日：铸币机制失效，LUNA供应量增加10倍</li>
                                    <li>5月11日：主要交易所暂停LUNA/UST交易</li>
                                    <li>5月13日：Terra链暂停出块，LUNA接近归零</li>
                                </ul>
                            </li>
                            <li><strong>连锁效应</strong>
                                <ul>
                                    <li>直接损失：$600亿市值归零，200万+用户受影响</li>
                                    <li>机构倒闭：Three Arrows($100亿)、Celsius($120亿)、Voyager($50亿)</li>
                                    <li>市场恐慌：BTC跌至$25,000，总市值缩水$1万亿</li>
                                    <li>信任危机：算法稳定币整体受质疑，FRAX等被迫增加抵押率</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>2023年 - 全球监管框架加速成型</strong>
                        <ul>
                            <li><strong>美国监管收紧</strong>
                                <ul>
                                    <li>BUSD事件：2月13日，纽约州要求Paxos停止发行BUSD</li>
                                    <li>稳定币法案：要求发行方持有银行牌照或信托牌照</li>
                                    <li>SEC执法：起诉多个算法稳定币项目</li>
                                    <li>银行危机影响：3月硅谷银行倒闭，USDC短暂脱锚至$0.87</li>
                                </ul>
                            </li>
                            <li><strong>欧盟MiCA实施</strong>
                                <ul>
                                    <li>6月生效：全球首个综合性加密资产监管框架</li>
                                    <li>EMT要求：电子货币代币需持牌，储备金托管</li>
                                    <li>ART限制：资产参考代币日交易量上限€2亿</li>
                                    <li>过渡期：现有稳定币18个月内需合规</li>
                                </ul>
                            </li>
                            <li><strong>亚太地区进展</strong>
                                <ul>
                                    <li>香港：发布稳定币监管咨询总结，2024年实施牌照制</li>
                                    <li>新加坡：要求单一货币稳定币按面值赎回</li>
                                    <li>日本：只允许日元、美元等主要货币稳定币</li>
                                    <li>韩国：要求100%法币储备，禁止算法稳定币</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>

                <div class="tip">
                    <strong>💡 历史教训：</strong>稳定币的发展历程表明，技术创新必须与风险管理并重。UST的崩溃提醒我们，没有充分抵押品支撑的算法稳定机制在极端市场条件下极其脆弱。
                </div>
            </div>

            <div class="theory-section">
                <h3>核心概念回顾</h3>
                
                <h4>稳定币三元悖论（Stablecoin Trilemma）</h4>
                <p>在深入技术细节之前，我们需要理解稳定币设计的根本性约束。类似于区块链的"不可能三角"，稳定币也面临自己的三元悖论：</p>
                
                <div style="text-align: center; margin: 2rem 0;">
                    <svg width="400" height="350" viewBox="0 0 400 350">
                        <!-- 三角形 -->
                        <polygon points="200,50 350,300 50,300" fill="none" stroke="#2563eb" stroke-width="2"/>
                        
                        <!-- 三个顶点的圆圈和文字 -->
                        <circle cx="200" cy="50" r="40" fill="#2563eb" opacity="0.1" stroke="#2563eb" stroke-width="2"/>
                        <text x="200" y="55" text-anchor="middle" fill="#2563eb" font-weight="bold">去中心化</text>
                        <text x="200" y="20" text-anchor="middle" fill="#666" font-size="12">Decentralization</text>
                        
                        <circle cx="350" cy="300" r="40" fill="#2563eb" opacity="0.1" stroke="#2563eb" stroke-width="2"/>
                        <text x="350" y="305" text-anchor="middle" fill="#2563eb" font-weight="bold">资本效率</text>
                        <text x="350" y="330" text-anchor="middle" fill="#666" font-size="12">Capital Efficiency</text>
                        
                        <circle cx="50" cy="300" r="40" fill="#2563eb" opacity="0.1" stroke="#2563eb" stroke-width="2"/>
                        <text x="50" y="305" text-anchor="middle" fill="#2563eb" font-weight="bold">价格稳定</text>
                        <text x="50" y="330" text-anchor="middle" fill="#666" font-size="12">Price Stability</text>
                        
                        <!-- 中心文字 -->
                        <text x="200" y="200" text-anchor="middle" fill="#1e40af" font-size="16" font-weight="bold">最多选择两个</text>
                    </svg>
                </div>
                
                <div class="tip">
                    <strong>💡 关键洞察：</strong>任何稳定币项目都无法同时完美实现这三个目标。理解这个三元悖论是评估不同稳定币设计的基础框架。
                </div>
                
                <h4>三元悖论的深度技术解析</h4>
                <ul>
                    <li><strong>去中心化（Decentralization）- 技术维度分析</strong>
                        <ul>
                            <li><strong>量化指标</strong>：
                                <ul>
                                    <li>中本聪系数：需要多少个实体合谋才能控制系统</li>
                                    <li>基尼系数：代币分布的集中程度（0=完全平等，1=完全集中）</li>
                                    <li>治理参与率：实际参与投票的代币比例</li>
                                </ul>
                            </li>
                            <li><strong>技术实现</strong>：
                                <ul>
                                    <li>多签钱包：Gnosis Safe（2/3, 3/5, 4/7等配置）</li>
                                    <li>时间锁：24-72小时延迟执行，社区可审查</li>
                                    <li>DAO治理：链上提案、投票、执行全流程</li>
                                </ul>
                            </li>
                            <li><strong>攻击向量</strong>：
                                <ul>
                                    <li>治理攻击：购买足够代币控制投票</li>
                                    <li>预言机操纵：控制价格源影响系统</li>
                                    <li>MEV攻击：通过交易排序获利</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>资本效率（Capital Efficiency）- 经济模型分析</strong>
                        <ul>
                            <li><strong>效率计算公式</strong>：
                                <div class="code-block">
资本效率 = 稳定币流通量 / 锁定抵押品总价值
示例：
- USDT: $95B / $95B = 100%（完全储备）
- DAI: $5B / $7.5B = 66.7%（150%超额抵押）
- FRAX: $1B / $0.85B = 117%（部分算法）</div>
                            </li>
                            <li><strong>优化技术</strong>：
                                <ul>
                                    <li>PSM（Peg Stability Module）：1:1兑换其他稳定币</li>
                                    <li>D3M（Direct Deposit Module）：直接向借贷协议供应</li>
                                    <li>递归杠杆：循环借贷提高资本利用率</li>
                                </ul>
                            </li>
                            <li><strong>风险/收益权衡</strong>：
                                <ul>
                                    <li>高效率→高系统性风险（UST教训）</li>
                                    <li>低效率→高稳定性但机会成本大</li>
                                    <li>动态调整：根据市场条件改变抵押率</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>价格稳定（Price Stability）- 机制设计分析</strong>
                        <ul>
                            <li><strong>稳定性指标</strong>：
                                <ul>
                                    <li>日波动率：σ = √(Σ(xi - μ)²/n)</li>
                                    <li>最大偏离：max(|price - $1|)</li>
                                    <li>恢复时间：从脱锚到恢复$0.995-$1.005的时长</li>
                                    <li>深度指标：2%滑点所需交易量</li>
                                </ul>
                            </li>
                            <li><strong>稳定机制</strong>：
                                <ul>
                                    <li>一级市场：直接铸造/赎回套利</li>
                                    <li>二级市场：AMM流动性池套利</li>
                                    <li>稳定费调节：通过利率影响供需</li>
                                    <li>紧急机制：全局清算、紧急暂停</li>
                                </ul>
                            </li>
                            <li><strong>历史表现数据</strong>：
                                <ul>
                                    <li>USDC：年化波动率0.1%，最大偏离$0.13（SVB事件）</li>
                                    <li>DAI：年化波动率0.8%，最大偏离$0.05</li>
                                    <li>FRAX：年化波动率1.2%，最大偏离$0.03</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                
                <div style="background: #f1f5f9; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0; border-left: 4px solid #2563eb;">
                    <h5>稳定币三元悖论的形式化定义</h5>
                    <p><strong>定理：</strong>任何稳定币系统最多只能同时优化以下三个属性中的两个：</p>
                    <ol>
                        <li><strong>去中心化（Decentralization）</strong>：系统控制权的分散程度</li>
                        <li><strong>资本效率（Capital Efficiency）</strong>：抵押资产与稳定币发行量的比率</li>
                        <li><strong>价格稳定（Price Stability）</strong>：维持与目标价格锚定的能力</li>
                    </ol>
                    <p><strong>数学约束：</strong>若 D + C + P ≤ 2，其中 D、C、P ∈ [0,1] 分别代表三个属性的实现程度</p>
                </div>
                
                <h4>现有稳定币的三元悖论权衡分析</h4>
                
                <div style="background: #fafbfc; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                        <tr style="background: #e0f2fe;">
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: left;">稳定币项目</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: center;">去中心化</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: center;">资本效率</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6; text-align: center;">价格稳定</th>
                            <th style="padding: 12px; border: 2px solid #3b82f6;">技术实现特点</th>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">USDT/USDC</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #dc2626;">❌</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：单一owner地址控制mint/burn/blacklist<br/>
                                <strong>储备</strong>：链下银行账户持有等值美元<br/>
                                <strong>稳定</strong>：依赖发行方信誉和监管合规
                            </td>
                        </tr>
                        <tr style="background: #f8fafc;">
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">DAI</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #dc2626;">❌</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：MakerDAO治理投票决定参数<br/>
                                <strong>储备</strong>：链上智能合约锁定ETH/WBTC等<br/>
                                <strong>稳定</strong>：利率调节 + 清算机制 + PSM模块
                            </td>
                        </tr>
                        <tr>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">UST<br/><span style="font-size: 0.8rem; color: #dc2626;">(已崩溃)</span></td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #dc2626;">❌</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：算法自动执行，无需人工干预<br/>
                                <strong>储备</strong>：LUNA代币作为弹性供应调节器<br/>
                                <strong>稳定</strong>：套利机制失效导致死亡螺旋
                            </td>
                        </tr>
                        <tr style="background: #f8fafc;">
                            <td style="padding: 12px; border: 1px solid #cbd5e1; font-weight: bold;">FRAX</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #f59e0b;">⚡</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #f59e0b;">⚡</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1; text-align: center; color: #16a34a;">✅</td>
                            <td style="padding: 12px; border: 1px solid #cbd5e1;">
                                <strong>控制</strong>：部分去中心化，团队保留关键权限<br/>
                                <strong>储备</strong>：USDC（88%）+ FXS算法调节<br/>
                                <strong>稳定</strong>：混合机制，动态调整抵押率
                            </td>
                        </tr>
                    </table>
                    <p style="margin-top: 1rem; font-size: 0.9rem; color: #64748b;">
                        <strong>图例：</strong>✅ 优化 | ❌ 牺牲 | ⚡ 部分实现
                    </p>
                </div>
                
                <h4>为什么不能三者兼得？</h4>
                <div style="background: #fef3c7; padding: 1.5rem; border-radius: 8px; margin: 1.5rem 0;">
                    <p><strong>三元悖论的经济学解释：</strong></p>
                    <ul>
                        <li><strong>去中心化 + 资本效率 → 价格不稳定</strong>
                            <p style="margin-left: 1.5rem; color: #666;">没有超额抵押缓冲，市场波动直接影响价格。当抵押品价值下跌时，系统缺乏足够的安全边际来维持锚定。UST的崩溃完美诠释了这一点。</p>
                        </li>
                        <li><strong>去中心化 + 价格稳定 → 资本效率低</strong>
                            <p style="margin-left: 1.5rem; color: #666;">需要超额抵押来应对市场波动，如DAI的150%最低抵押率。这意味着每生成$1的稳定币，需要锁定至少$1.5的资产，造成大量资本闲置。</p>
                        </li>
                        <li><strong>资本效率 + 价格稳定 → 中心化</strong>
                            <p style="margin-left: 1.5rem; color: #666;">需要可信第三方持有和管理储备资产，如USDC由Circle公司控制。中心化实体可以灵活调整储备，快速响应赎回需求。</p>
                        </li>
                    </ul>
                </div>

                <h4>抵押机制深度对比分析</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <tr>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">类型</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">抵押率</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">例子</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">优势</th>
                        <th style="border: 1px solid #ddd; padding: 12px; background: #f3f4f6;">劣势</th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">法币抵押</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">100%</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">USDT, USDC</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">简单稳定</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">中心化风险</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">加密货币超额抵押</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">150-200%</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">DAI, LUSD</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">去中心化</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">资本效率低</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">算法调节</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">0-100%</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">FRAX, FEI</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">资本效率高</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">机制复杂</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">混合型</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">可变</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">FRAX, USDD</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">灵活性</td>
                        <td style="border: 1px solid #ddd; padding: 12px;">治理复杂</td>
                    </tr>
                </table>

                <h4>关键机制</h4>
                <ol>
                    <li><strong>价格预言机（Oracle）- 稳定币的眼睛</strong>
                        <p>预言机是连接区块链与现实世界的桥梁，对稳定币至关重要。它们提供抵押品价格、汇率等关键数据。</p>
                        
                        <div style="background: #f3f4f6; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                            <h5>主要预言机方案对比</h5>
                            <ul>
                                <li><strong>Chainlink</strong>
                                    <ul>
                                        <li>原理：多节点聚合，去中心化网络</li>
                                        <li>优势：高可用性，抗操纵性强</li>
                                        <li>劣势：成本较高，更新延迟</li>
                                        <li>攻击面：节点串谋、数据源污染</li>
                                    </ul>
                                </li>
                                <li><strong>Uniswap V3 TWAP</strong>
                                    <ul>
                                        <li>原理：链上交易对的时间加权平均价格</li>
                                        <li>优势：完全去中心化，防闪电贷攻击</li>
                                        <li>劣势：需要足够流动性，易受长期操纵</li>
                                        <li>攻击面：流动性枯竭、长时间价格操纵</li>
                                    </ul>
                                </li>
                                <li><strong>Maker Oracle V2</strong>
                                    <ul>
                                        <li>原理：白名单喂价者 + 中位数聚合</li>
                                        <li>优势：为MakerDAO定制，延迟机制</li>
                                        <li>劣势：相对中心化，依赖<span class="tooltip">可信喂价者<span class="tooltip-content">经过验证的价格数据提供方，通常需要质押保证金</span></span></li>
                                        <li>攻击面：喂价者密钥泄露、OSM延迟利用</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="warning">
                            <strong>⚠️ 预言机攻击案例：</strong>
                            <ul>
                                <li>2020年 Compound DAI 价格异常：Coinbase Pro闪崩导致清算</li>
                                <li>2021年 Cream Finance：通过操纵预言机价格盗取1.3亿美元</li>
                                <li>2022年 Mango Markets：预言机价格操纵损失1.16亿美元</li>
                            </ul>
                        </div>
                    </li>
                    <li><strong>清算机制</strong>
                        <ul>
                            <li>固定折扣清算（如早期MakerDAO）</li>
                            <li><span class="tooltip">荷兰式拍卖<span class="tooltip-content">价格从高到低递减的拍卖方式，直到有人愿意购买</span></span>（如Liquity）</li>
                            <li>渐进式清算（如新版MakerDAO）</li>
                        </ul>
                    </li>
                    <li><strong>稳定机制</strong>
                        <ul>
                            <li>利率调节（DSR存款利率, 稳定费即借款利率）</li>
                            <li>铸币税/销毁机制</li>
                            <li>套利激励</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="theory-section">
                <h3>市场主要参与者</h3>
                
                <h4>2024年市场份额（按市值）</h4>
                <div style="background: #f9fafb; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <ul>
                        <li><strong>USDT (Tether)</strong> - $95B+ (约45%)
                            <ul>
                                <li>发行方：Tether Limited（香港）</li>
                                <li>支持链：Ethereum, Tron, BSC, Avalanche等15+条链</li>
                                <li>储备：美国国债、商业票据、现金等</li>
                            </ul>
                        </li>
                        <li><strong>USDC (USD Coin)</strong> - $25B+ (约12%)
                            <ul>
                                <li>发行方：Circle（美国）</li>
                                <li>支持链：Ethereum, Solana, Avalanche等</li>
                                <li>储备：100%现金和短期美国国债</li>
                            </ul>
                        </li>
                        <li><strong>DAI</strong> - $5B+ (约2.5%)
                            <ul>
                                <li>发行方：MakerDAO（去中心化）</li>
                                <li>支持链：Ethereum L1 + 多个L2</li>
                                <li>抵押品：ETH, WBTC（Wrapped Bitcoin - 以太坊上的比特币代币）, USDC, RWA（Real World Assets - 现实世界资产）等</li>
                            </ul>
                        </li>
                        <li><strong>FDUSD</strong> - $3B+ (约1.5%)
                            <ul>
                                <li>发行方：First Digital（香港）</li>
                                <li>特点：亚洲市场主导</li>
                            </ul>
                        </li>
                        <li><strong>其他</strong> - 包括TUSD, FRAX, LUSD, crvUSD等</li>
                    </ul>
                </div>

                <h4>技术创新者</h4>
                <ul>
                    <li><strong>Frax Finance</strong>
                        <ul>
                            <li>首个部分算法稳定币</li>
                            <li>动态调整抵押率</li>
                            <li>创新的AMO（Algorithmic Market Operations，算法市场操作 - 自动调节市场供需）机制</li>
                        </ul>
                    </li>
                    <li><strong>Curve Finance (crvUSD)</strong>
                        <ul>
                            <li>LLAMMA（Lending-Liquidating AMM Algorithm，借贷清算自动做市商算法 - 将清算过程变为渐进式）</li>
                            <li>软清算机制，减少清算损失</li>
                            <li>与Curve生态深度整合</li>
                        </ul>
                    </li>
                    <li><strong>Aave (GHO)</strong>
                        <ul>
                            <li>基于Aave V3的原生稳定币</li>
                            <li>利用Aave的风险管理框架</li>
                            <li>Facilitator模式（促进者模式 - 授权实体可以铸造和销毁GHO）分散风险</li>
                        </ul>
                    </li>
                </ul>

                <div class="warning">
                    <strong>⚠️ 市场集中度风险：</strong>USDT和USDC合计占据稳定币市场超过55%的份额，这种中心化给DeFi生态系统带来系统性风险。2023年3月Silicon Valley Bank倒闭期间，USDC一度脱锚至$0.87，影响整个DeFi生态。
                </div>
            </div>

            <div class="theory-section">
                <h3>全球监管现状</h3>
                
                <h4>主要司法管辖区监管框架</h4>
                
                <h5>🇺🇸 美国</h5>
                <ul>
                    <li><strong>现状</strong>：分散监管，多头管理
                        <ul>
                            <li>州级：纽约BitLicense（加密货币许可证）, 怀俄明州SPDI（特殊目的存款机构）</li>
                            <li>联邦级：尚无统一立法</li>
                        </ul>
                    </li>
                    <li><strong>关键法案</strong>：
                        <ul>
                            <li>Stablecoin TRUST Act（参议院）</li>
                            <li>Clarity for Payment Stablecoins Act（众议院）</li>
                            <li>STABLE Act（提案阶段）</li>
                        </ul>
                    </li>
                    <li><strong>监管重点</strong>：
                        <ul>
                            <li>储备资产透明度</li>
                            <li>赎回权保障</li>
                            <li>系统重要性机构认定</li>
                        </ul>
                    </li>
                </ul>

                <h5>🇪🇺 欧盟</h5>
                <ul>
                    <li><strong>MiCA法规</strong>（2024年生效）
                        <ul>
                            <li>统一的稳定币监管框架</li>
                            <li>区分EMT（E-Money Token，电子货币代币 - 锚定单一法币）和ART（Asset-Referenced Token，资产参考代币 - 锚定多种资产）</li>
                            <li>严格的储备和审计要求</li>
                        </ul>
                    </li>
                    <li><strong>关键要求</strong>：
                        <ul>
                            <li>1:1储备，存放于托管机构</li>
                            <li>每日市值上限（EMT: 2亿欧元）</li>
                            <li>白皮书审批制度</li>
                        </ul>
                    </li>
                </ul>

                <h5>🇨🇳 中国</h5>
                <ul>
                    <li>禁止所有加密货币交易和ICO</li>
                    <li>积极推进央行数字货币（数字人民币）</li>
                    <li>香港特区：
                        <ul>
                            <li>2023年6月实施稳定币监管制度</li>
                            <li>要求持牌经营</li>
                            <li>储备资产必须高质量、高流动性</li>
                        </ul>
                    </li>
                </ul>

                <h5>🇯🇵 日本</h5>
                <ul>
                    <li>2023年6月修订《资金结算法》</li>
                    <li>稳定币分类：
                        <ul>
                            <li>银行发行（存款型）</li>
                            <li>信托公司发行（信托型）</li>
                        </ul>
                    </li>
                    <li>禁止算法稳定币</li>
                </ul>

                <h5>🇸🇬 新加坡</h5>
                <ul>
                    <li>MAS（金管局）监管框架</li>
                    <li>单一货币支持的稳定币需申请牌照</li>
                    <li>储备要求：至少100%的低风险资产</li>
                </ul>

                <div class="tip">
                    <strong>💡 监管趋势：</strong>全球监管正在从"观望"转向"行动"。主要趋势包括：(1)要求100%法币储备，(2)禁止或限制算法稳定币，(3)强调用户资产保护，(4)防止系统性风险。开发者需要在创新和合规之间找到平衡。
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 0.1：监管影响分析</h4>
                </div>
                <p>假设你是一个DeFi协议的架构师，需要设计一个新的稳定币系统。考虑以下场景：</p>
                <ol>
                    <li>如果欧盟MiCA要求每日交易上限2亿欧元，你如何设计系统确保合规同时不影响用户体验？</li>
                    <li>如果美国要求所有稳定币发行方成为银行，对DeFi生态会有什么影响？</li>
                    <li>设计一个能同时满足美国、欧盟、新加坡监管要求的稳定币架构</li>
                </ol>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-0-1')">查看参考答案</button>
                <div id="answer-0-1" class="answer-content">
                    <h5>参考答案：</h5>
                    
                    <h6>1. 应对欧盟交易上限</h6>
                    <div class="code-block">
contract MiCACompliantStablecoin {
    uint256 constant DAILY_LIMIT = 200_000_000e6; // 2亿欧元
    mapping(uint256 => uint256) public dailyVolume; // day => volume
    
    modifier checkDailyLimit(uint256 amount) {
        uint256 today = block.timestamp / 1 days;
        require(
            dailyVolume[today] + amount <= DAILY_LIMIT,
            "Daily limit exceeded"
        );
        _;
    }
    
    // 解决方案1：多代币策略
    // 发行 EURS-1, EURS-2 等多个代币，每个有独立限额
    
    // 解决方案2：Layer 2 批处理
    function batchedTransfer(
        bytes calldata transferData
    ) external {
        // 在L2处理小额交易，定期结算到L1
        // L1只记录净额变化，不超限
    }
    
    // 解决方案3：时区轮转
    function getAvailableLimit() view returns (uint256) {
        // 根据用户时区分配限额
        // 亚洲、欧洲、美洲错峰使用
    }
}
</div>
                    
                    <h6>2. 银行牌照要求的影响</h6>
                    <ul>
                        <li><strong>直接影响</strong>：
                            <ul>
                                <li>去中心化稳定币（如DAI）可能被迫关闭或迁移</li>
                                <li>创新速度大幅降低</li>
                                <li>准入门槛提高，小团队无法参与</li>
                            </ul>
                        </li>
                        <li><strong>应对策略</strong>：
                            <ul>
                                <li>协议层与发行层分离</li>
                                <li>使用合规稳定币作为抵押品</li>
                                <li>开发"wrapped"版本的稳定币</li>
                                <li>探索DAO控制的特殊目的银行</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h6>3. 多司法区合规架构</h6>
                    <div class="code-block">
// 模块化合规架构
contract UniversalCompliantStablecoin {
    // 核心模块
    IReserveManager public reserveManager;
    IComplianceEngine public complianceEngine;
    IRedemptionGateway public redemptionGateway;
    
    // 司法区适配器
    mapping(string => IJurisdictionAdapter) public jurisdictions;
    
    struct TransferContext {
        address from;
        address to;
        uint256 amount;
        string fromJurisdiction;
        string toJurisdiction;
    }
    
    function transfer(TransferContext memory ctx) public {
        // 1. 检查发送方司法区规则
        require(
            jurisdictions[ctx.fromJurisdiction]
                .canSend(ctx.from, ctx.amount),
            "Sender jurisdiction check failed"
        );
        
        // 2. 检查接收方司法区规则
        require(
            jurisdictions[ctx.toJurisdiction]
                .canReceive(ctx.to, ctx.amount),
            "Receiver jurisdiction check failed"
        );
        
        // 3. 执行跨司法区合规检查
        complianceEngine.checkCrossBorder(ctx);
        
        // 4. 更新储备报告
        reserveManager.recordTransfer(ctx);
        
        // 5. 执行转账
        _executeTransfer(ctx);
    }
    
    // 司法区特定功能
    function enableJurisdiction(
        string memory code,
        IJurisdictionAdapter adapter
    ) external onlyGovernance {
        // 动态添加新司法区支持
        jurisdictions[code] = adapter;
    }
}

// 示例：欧盟适配器
contract EUAdapter is IJurisdictionAdapter {
    uint256 constant DAILY_LIMIT = 200_000_000e6;
    mapping(uint256 => uint256) public dailyVolume;
    
    function canSend(address user, uint256 amount) 
        external view returns (bool) {
        // 检查KYC状态
        if (!kycRegistry.isVerified(user)) return false;
        
        // 检查日限额
        uint256 today = block.timestamp / 1 days;
        if (dailyVolume[today] + amount > DAILY_LIMIT) {
            return false;
        }
        
        return true;
    }
}
</div>
                    
                    <h5>架构特点：</h5>
                    <ol>
                        <li><strong>模块化设计</strong>：不同功能模块可独立更新</li>
                        <li><strong>司法区隔离</strong>：各地区规则互不影响</li>
                        <li><strong>动态适配</strong>：可快速响应新法规</li>
                        <li><strong>审计友好</strong>：清晰的合规检查路径</li>
                        <li><strong>用户体验</strong>：自动路由最优合规路径</li>
                    </ol>
                </div>
            </div>
        </div>

        <div class="chapter" id="chapter1">
            <h2>第一章：稳定币的区块链基础</h2>
            
            <div class="intro-box">
                <strong>本章概览：</strong>
                <ul>
                    <li>共识机制对稳定币设计的影响分析</li>
                    <li>智能合约执行模型跨链对比</li>
                    <li>实践：部署第一个稳定币合约</li>
                    <li>Gas经济学与优化策略</li>
                    <li>稳定币与区块链特性的深度关联</li>
                </ul>
            </div>
            
            <div class="theory-section">
                <h3>1.1 共识机制及其对稳定币设计的影响</h3>
                
                <p>作为资深程序员和AI科学家，你可能已经熟悉基本的区块链概念。让我们直接深入探讨共识机制如何影响稳定币的设计选择。</p>
                
                <h4>共识机制深度技术分析与性能指标</h4>
                
                <div style="background: #f0f9ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                    <h5>🔍 关键性能指标对比</h5>
                    <table style="width: 100%; font-size: 0.9rem;">
                        <tr>
                            <th style="padding: 8px; text-align: left;">共识机制</th>
                            <th style="padding: 8px;">TPS</th>
                            <th style="padding: 8px;">最终性</th>
                            <th style="padding: 8px;">去中心化度</th>
                            <th style="padding: 8px;">能耗</th>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>PoW (Bitcoin)</strong></td>
                            <td style="padding: 8px; text-align: center;">7</td>
                            <td style="padding: 8px; text-align: center;">60分钟</td>
                            <td style="padding: 8px; text-align: center;">极高</td>
                            <td style="padding: 8px; text-align: center;">110 TWh/年</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>PoS (Ethereum)</strong></td>
                            <td style="padding: 8px; text-align: center;">30</td>
                            <td style="padding: 8px; text-align: center;">15分钟</td>
                            <td style="padding: 8px; text-align: center;">高</td>
                            <td style="padding: 8px; text-align: center;">0.01 TWh/年</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>Tendermint (Cosmos)</strong></td>
                            <td style="padding: 8px; text-align: center;">10,000</td>
                            <td style="padding: 8px; text-align: center;">6秒</td>
                            <td style="padding: 8px; text-align: center;">中</td>
                            <td style="padding: 8px; text-align: center;">低</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px;"><strong>DPoS (Solana)</strong></td>
                            <td style="padding: 8px; text-align: center;">65,000</td>
                            <td style="padding: 8px; text-align: center;">400毫秒</td>
                            <td style="padding: 8px; text-align: center;">低</td>
                            <td style="padding: 8px; text-align: center;">低</td>
                        </tr>
                    </table>
                </div>
                
                <ul>
                    <li><strong>工作量证明（PoW）- 安全性的黄金标准</strong>
                        <ul>
                            <li><strong>技术特性</strong>：
                                <ul>
                                    <li>中本聪共识：最长链原则</li>
                                    <li>概率性最终性：6个区块确认≈99.9%安全</li>
                                    <li>51%攻击成本：比特币约$150亿/天</li>
                                </ul>
                            </li>
                            <li><strong>对稳定币的影响</strong>：
                                <ul>
                                    <li>交易成本：$1-50（动态费用市场）</li>
                                    <li>确认时间：10-60分钟（不适合即时支付）</li>
                                    <li>MEV风险：三明治攻击可能影响大额交易</li>
                                    <li>适用场景：大额结算、跨境转账</li>
                                </ul>
                            </li>
                            <li><strong>实际案例</strong>：
                                <ul>
                                    <li>Omni USDT：基于比特币，日交易量$1-5亿</li>
                                    <li>WBTC：以太坊上的比特币，用于DeFi</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    
                    <li><strong>权益证明（PoS）- 效率与去中心化的平衡</strong>
                        <ul>
                            <li><strong>技术特性</strong>：
                                <ul>
                                    <li>验证者选择：基于质押量的随机算法</li>
                                    <li>罚没机制：恶意行为导致质押损失</li>
                                    <li>分叉选择规则：LMD-GHOST（以太坊）</li>
                                </ul>
                            </li>
                            <li><strong>对稳定币的影响</strong>：
                                <ul>
                                    <li>Gas优化空间：EIP-1559后更可预测</li>
                                    <li>MEV-Boost：建设者分离带来的新机会</li>
                                    <li>Layer2集成：Optimism/Arbitrum上的稳定币</li>
                                    <li>流动性质押：stETH作为抵押品</li>
                                </ul>
                            </li>
                            <li><strong>性能优化</strong>：
                                <ul>
                                    <li>账户抽象（ERC-4337）：无Gas费稳定币交易</li>
                                    <li>Proto-danksharding：降低L2成本90%+</li>
                                    <li>并行EVM：多核处理提升TPS</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    
                    <li><strong>Byzantine Fault Tolerance (BFT)变种 - 即时最终性</strong>
                        <ul>
                            <li><strong>Tendermint Core（Cosmos生态）</strong>：
                                <ul>
                                    <li>1/3容错：最多33%恶意节点</li>
                                    <li>两阶段提交：propose → prevote → precommit</li>
                                    <li>IBC协议：原生跨链稳定币（如IST）</li>
                                </ul>
                            </li>
                            <li><strong>HotStuff（Diem/Aptos）</strong>：
                                <ul>
                                    <li>线性通信复杂度：O(n)vs O(n²)</li>
                                    <li>流水线共识：3阶段并行</li>
                                    <li>亚秒级最终性：适合支付场景</li>
                                </ul>
                            </li>
                            <li><strong>稳定币优势</strong>：
                                <ul>
                                    <li>确定性结算：无需等待确认</li>
                                    <li>可预测成本：固定手续费</li>
                                    <li>原子互换：跨链DvP（Delivery vs Payment）</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    
                    <li><strong>高性能共识 - 为稳定币优化</strong>
                        <ul>
                            <li><strong>Solana (Proof of History + PoS)</strong>：
                                <ul>
                                    <li>时间戳证明：无需等待网络同步</li>
                                    <li>Gulf Stream：提前转发交易</li>
                                    <li>并行处理：Sealevel运行时</li>
                                    <li>稳定币表现：USDC日交易$50亿+，费用<$0.001</li>
                                </ul>
                            </li>
                            <li><strong>Avalanche (雪崩共识)</strong>：
                                <ul>
                                    <li>亚秒级最终性：重复采样达成共识</li>
                                    <li>子网架构：定制化稳定币链</li>
                                    <li>C-Chain兼容EVM：无缝迁移</li>
                                </ul>
                            </li>
                            <li><strong>Sui/Aptos (并行执行)</strong>：
                                <ul>
                                    <li>Move语言：资产安全性保证</li>
                                    <li>对象模型：稳定币并行转账</li>
                                    <li>状态同步：增量更新降低延迟</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                
                <div class="code-block">
// 共识机制对稳定币设计的影响矩阵
interface ConsensusImpact {
    mechanism: string;
    stablecoin_suitability: {
        micropayments: number;      // 0-10分
        defi_integration: number;   // 0-10分
        cross_border: number;       // 0-10分
        censorship_resistance: number; // 0-10分
    };
    technical_constraints: {
        min_transaction_size: string;  // 经济可行的最小交易
        finality_time: string;         // 最终确认时间
        throughput: string;            // 实际TPS
        mev_exposure: string;          // MEV风险等级
    };
}

const consensusAnalysis: ConsensusImpact[] = [
    {
        mechanism: "Bitcoin PoW",
        stablecoin_suitability: {
            micropayments: 2,
            defi_integration: 3,
            cross_border: 9,
            censorship_resistance: 10
        },
        technical_constraints: {
            min_transaction_size: "$50+ (高手续费)",
            finality_time: "60分钟 (6确认)",
            throughput: "7 TPS",
            mev_exposure: "低 (无智能合约)"
        }
    },
    {
        mechanism: "Ethereum PoS",
        stablecoin_suitability: {
            micropayments: 5,
            defi_integration: 10,
            cross_border: 7,
            censorship_resistance: 8
        },
        technical_constraints: {
            min_transaction_size: "$1+ (L2: $0.01+)",
            finality_time: "15分钟 (2 epochs)",
            throughput: "30 TPS (L1), 2000+ TPS (L2)",
            mev_exposure: "高 (MEV-Boost)"
        }
    },
    {
        mechanism: "Solana PoH+PoS",
        stablecoin_suitability: {
            micropayments: 10,
            defi_integration: 8,
            cross_border: 8,
            censorship_resistance: 5
        },
        technical_constraints: {
            min_transaction_size: "$0.00001+",
            finality_time: "400ms",
            throughput: "5000+ TPS (实际)",
            mev_exposure: "中 (Jito Labs)"
        }
    }
];
                </div>

                <div class="tip">
                    <strong>💡 关键洞察：</strong>共识机制直接影响稳定币的最终性（finality）。在PoW链上，稳定币转账可能需要等待多个区块确认；而在Tendermint等具有即时最终性的共识机制上，稳定币可以实现近乎即时的结算。
                </div>

                <h4>最终性与稳定币设计</h4>
                <p>不同的最终性模型对稳定币系统产生深远影响：</p>
                
                <div class="code-block">
// 伪代码：不同最终性模型下的稳定币转账确认
interface FinalityModel {
    // 概率性最终性（如比特币、以太坊PoW）
    probabilistic: {
        confirmations_needed: 6-12,  // 区块确认数
        reorg_risk: "decreases exponentially",  // 重组风险（区块链回滚的可能性）
        settlement_time: "10-120 minutes"
    },
    
    // 确定性最终性（如Tendermint、以太坊PoS）
    deterministic: {
        confirmations_needed: 1,
        reorg_risk: "none after finalization",
        settlement_time: "6-12 seconds"
    }
}                </div>
            </div>

            <div class="theory-section">
                <h3>1.3 稳定币与PoW、比特币的关系</h3>
                
                <h4>稳定币对PoW的依赖程度</h4>
                <p><strong>结论：稳定币对PoW没有直接依赖，但存在间接关系。</strong></p>
                
                <div style="background: #e0f2fe; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
                    <h5>直接关系分析</h5>
                    <ul>
                        <li><strong>技术层面</strong>：
                            <ul>
                                <li>主流稳定币（USDT、USDC、DAI）主要部署在以太坊（已转PoS）</li>
                                <li>即使在比特币上发行（如Omni USDT），也只是利用其账本功能</li>
                                <li>稳定币的核心功能不依赖于PoW的安全性</li>
                            </ul>
                        </li>
                        <li><strong>实际分布</strong>：
                            <ul>
                                <li>90%+的稳定币在非PoW链上（以太坊PoS、Tron DPoS、BSC PoSA）</li>
                                <li>选择标准是交易成本和速度，而非共识机制</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h5>间接关系</h5>
                    <ul>
                        <li><strong>历史渊源</strong>：稳定币诞生于PoW主导的时代（2014年）</li>
                        <li><strong>信任传递</strong>：比特币的成功证明了区块链可行性</li>
                        <li><strong>基础设施</strong>：早期稳定币借用比特币网络（如Omni Layer）</li>
                        <li><strong>市场需求</strong>：比特币的波动性催生了稳定币需求</li>
                    </ul>
                </div>
                
                <h4>稳定币与比特币的共生关系</h4>
                
                <h5>1. 交易对关系</h5>
                <ul>
                    <li><strong>BTC/USDT</strong>：最大交易对，日交易量$10B+</li>
                    <li><strong>价格发现</strong>：稳定币成为BTC定价基准</li>
                    <li><strong>流动性桥梁</strong>：法币→稳定币→BTC的主要通道</li>
                </ul>
                
                <h5>2. 功能互补</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">特性</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">比特币</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">稳定币</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">角色</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">价值存储、数字黄金</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">交换媒介、记账单位</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">波动性</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">高</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">低</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">使用场景</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">长期投资、对冲通胀</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">日常支付、DeFi操作</td>
                    </tr>
                </table>
                
                <h5>3. 市场行为模式</h5>
                <ul>
                    <li><strong>牛市</strong>：BTC上涨→获利了结到稳定币</li>
                    <li><strong>熊市</strong>：稳定币避险→等待BTC抄底机会</li>
                    <li><strong>震荡</strong>：BTC/稳定币高频交易套利</li>
                </ul>
                
                <h5>稳定币在各链的分布（2024年数据）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">区块链</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">共识机制</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">市场份额</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Ethereum</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoS</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">45%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Tron</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">DPoS</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">35%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">BSC</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoSA</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">10%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Solana</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoH</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Avalanche</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Avalanche共识</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Bitcoin</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PoW（仅Omni/RGB）</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">&lt;1%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">其他</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Various</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">1%</td>
                    </tr>
                </table>
                
                <h4>未来展望：后PoW时代的稳定币</h4>
                <div class="warning">
                    <p><strong>关键趋势：</strong></p>
                    <ul>
                        <li><strong>脱离PoW</strong>：以太坊转PoS后，稳定币与PoW的联系进一步减弱</li>
                        <li><strong>多链部署</strong>：追求低成本和高性能，而非特定共识机制</li>
                        <li><strong>Layer 2主导</strong>：Arbitrum、Optimism等L2成为稳定币主战场</li>
                        <li><strong>专用链探索</strong>：如Circle计划的USDC专用链</li>
                    </ul>
                    
                    <p><strong>结论：</strong>稳定币的未来不依赖于PoW，但会继续与比特币保持共生关系——比特币提供价值存储，稳定币提供流动性和可用性。</p>
                </div>
                
                <div class="tip">
                    <strong>💡 思考：</strong>如果比特币也转向PoS（理论假设），对稳定币生态会有什么影响？答案可能是：几乎没有直接影响，因为稳定币已经建立了独立的生态系统。
                </div>
            </div>
            
            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 1.1：共识机制分析</h4>
                </div>
                <p>假设你要设计一个用于跨境支付的稳定币系统，日交易量预计达到100万笔。请分析在以下三种区块链上部署的优缺点：</p>
                <ol>
                    <li>比特币（使用RGB协议或闪电网络）</li>
                    <li>以太坊L1</li>
                    <li>Solana</li>
                </ol>
                <p>考虑因素：交易成本、最终性时间、去中心化程度、开发生态系统</p>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-1')">查看参考答案</button>
                <div id="answer-1-1" class="answer-content">
                    <h5>参考答案：</h5>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <th style="border: 1px solid #ddd; padding: 8px;">特性</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">比特币+闪电网络</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">以太坊L1</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Solana</th>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">交易成本</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">极低（闪电网络）</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">高（$5-50）</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">极低（<$0.01）</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">最终性</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">即时（闪电）/60分钟（L1）</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">12秒</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">400毫秒</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">去中心化</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">最高</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">高</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">中等</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">推荐方案</td>
                            <td colspan="3" style="border: 1px solid #ddd; padding: 8px;">Solana最适合高频交易，但需要额外的去中心化措施。可考虑混合方案：Solana处理日常交易，以太坊作为结算层。</td>
                        </tr>
                    </table>
                    
                    <h5>为什么比特币+闪电网络没有被选中？</h5>
                    <div style="background: #f3f4f6; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                        <p><strong>技术限制：</strong></p>
                        <ul>
                            <li><strong>智能合约能力有限</strong>：比特币脚本语言（Script）功能受限，无法实现复杂的稳定币逻辑（如自动清算、利率调节等）</li>
                            <li><strong>闪电网络的流动性问题</strong>：
                                <ul>
                                    <li>需要预先锁定资金在通道中</li>
                                    <li>大额支付可能找不到足够容量的路由路径</li>
                                    <li>100万笔/天的交易量需要大量流动性提供者</li>
                                </ul>
                            </li>
                            <li><strong>稳定币功能缺失</strong>：
                                <ul>
                                    <li>RGB协议仍在早期，生态不成熟</li>
                                    <li>缺乏原生的价格预言机支持</li>
                                    <li>无法实现自动化的稳定机制（如抵押清算）</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <p><strong>实际考虑：</strong></p>
                        <ul>
                            <li><strong>开发生态</strong>：相比以太坊和Solana，比特币的DeFi开发工具和库极其有限</li>
                            <li><strong>互操作性</strong>：稳定币需要与DeFi生态集成（DEX、借贷等），比特币生态缺乏这些基础设施</li>
                            <li><strong>监管合规</strong>：在比特币上实现KYC/AML等合规功能更加困难</li>
                        </ul>
                        
                        <p><strong>适用场景：</strong></p>
                        <p>比特币+闪电网络更适合：</p>
                        <ul>
                            <li>点对点的小额支付（如小费、微支付）</li>
                            <li>不需要复杂金融逻辑的简单转账</li>
                            <li>强调去中心化和抗审查的场景</li>
                        </ul>
                        
                        <p>但对于需要<strong>日交易量100万笔</strong>的<strong>稳定币系统</strong>，需要：</p>
                        <ul>
                            <li>丰富的智能合约功能</li>
                            <li>成熟的DeFi生态集成</li>
                            <li>高效的批量处理能力</li>
                            <li>灵活的合规工具</li>
                        </ul>
                        <p>这些正是Solana和以太坊的优势所在。</p>
                    </div>
                    </table>
                </div>
            </div>

            <div class="theory-section">
                <h3>1.2 智能合约执行模型跨链对比</h3>
                
                <p>不同区块链的智能合约执行模型对稳定币功能实现有重要影响：</p>

                <h4>账户模型 vs UTXO模型</h4>
                
                <div class="code-block">
// 以太坊账户模型示例
contract AccountBasedStablecoin {
    mapping(address => uint256) public balances;
    
    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}

// Cardano UTXO模型伪代码
UTXOStablecoin {
    // 每个UTXO包含：
    struct UTXO {
        address: ScriptAddress,
        value: {
            ada: Integer,
            stablecoin: Integer
        },
        datum: StablecoinDatum
    }
    
    // 转账需要消费旧UTXO，创建新UTXO
    validator transfer(datum: Datum, redeemer: Redeemer, context: ScriptContext) {
        // 验证签名、金额等
        // 确保输入UTXO总和 = 输出UTXO总和
    }
}                </div>

                <div class="warning">
                    <strong>⚠️ 重要区别：</strong>UTXO模型天然支持并行处理，但实现复杂的DeFi逻辑更困难。账户模型编程直观，但容易产生竞态条件。
                </div>
                
                <h4>深入理解：UTXO vs 账户模型的权衡</h4>
                
                <h5>并行处理能力对比</h5>
                <p><strong>UTXO模型的并行优势：</strong></p>
                <ul>
                    <li><strong>交易独立性</strong>：每个UTXO只能被花费一次，不同UTXO的交易可以并行验证
                        <ul>
                            <li>示例：Alice→Bob和Carol→Dave的交易使用不同UTXO，可同时处理</li>
                            <li>结果：理论吞吐量更高，适合支付场景</li>
                        </ul>
                    </li>
                    <li><strong>无状态竞争</strong>：不存在账户余额的读写竞争
                        <ul>
                            <li>每笔交易明确指定输入输出</li>
                            <li>验证只需检查UTXO是否未花费</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>账户模型的串行瓶颈：</strong></p>
                <ul>
                    <li><strong>状态依赖</strong>：多笔交易修改同一账户时必须串行执行
                        <ul>
                            <li>示例：Alice同时向Bob和Carol转账，需要顺序更新Alice余额</li>
                            <li>以太坊的nonce机制强制交易顺序</li>
                        </ul>
                    </li>
                    <li><strong>竞态条件风险</strong>：
                        <ul>
                            <li>MEV（最大可提取价值）攻击利用交易顺序</li>
                            <li>三明治攻击在DeFi中普遍存在</li>
                        </ul>
                    </li>
                </ul>
                
                <h5>DeFi编程复杂度分析</h5>
                <p><strong>UTXO模型的DeFi挑战：</strong></p>
                <ul>
                    <li><strong>状态管理困难</strong>：
                        <ul>
                            <li>无全局状态概念，需要通过UTXO链传递状态</li>
                            <li>示例：实现ERC20需要为每个余额创建独立UTXO</li>
                        </ul>
                    </li>
                    <li><strong>复杂交互受限</strong>：
                        <ul>
                            <li>多方交互需要预先协调（如原子交换）</li>
                            <li>难以实现复杂的DeFi协议（如Uniswap V3）</li>
                        </ul>
                    </li>
                    <li><strong>解决方案</strong>：
                        <ul>
                            <li>扩展UTXO（eUTXO）：Cardano的Plutus添加datum存储状态</li>
                            <li>Cell模型：Nervos CKB的通用化UTXO</li>
                            <li>RGB协议：在Bitcoin上实现智能合约</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>账户模型的DeFi优势：</strong></p>
                <ul>
                    <li><strong>直观的编程模型</strong>：
                        <ul>
                            <li>合约即账户，拥有持久存储</li>
                            <li>函数调用模式符合传统编程习惯</li>
                        </ul>
                    </li>
                    <li><strong>复杂逻辑支持</strong>：
                        <ul>
                            <li>轻松实现多方交互（如AMM、借贷协议）</li>
                            <li>状态机模型适合复杂业务逻辑</li>
                        </ul>
                    </li>
                    <li><strong>生态系统成熟</strong>：
                        <ul>
                            <li>丰富的开发工具和框架</li>
                            <li>大量可复用的合约库（OpenZeppelin等）</li>
                        </ul>
                    </li>
                </ul>
                
                <h5>稳定币设计的模型选择</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">场景</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">推荐模型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">原因</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">支付型稳定币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">UTXO</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">高并发、隐私性好、防双花</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">DeFi稳定币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">账户</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">复杂交互、可组合性、生态丰富</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">跨链稳定币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">混合</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">不同链采用不同模型，通过桥接适配</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">CBDC</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">UTXO</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">监管友好、审计清晰、批量处理</td>
                    </tr>
                </table>
            </div>

            <div class="practice-section">
                <h3>1.3 实践：在本地Hardhat节点部署"Hello Stablecoin"</h3>
                
                <p>让我们快速搭建开发环境并部署第一个稳定币合约。</p>

                <h4>步骤1：环境搭建</h4>
                <div class="code-block">
# 安装必要工具
npm init -y
npm install --save-dev hardhat @openzeppelin/contracts
npm install --save-dev @nomicfoundation/hardhat-toolbox

# 初始化Hardhat项目
npx hardhat init
# 选择 "Create a JavaScript project"                </div>

                <h4>步骤2：编写最小化的中心化稳定币合约</h4>
                <p>让我们实现一个更贴近真实USDT/USDC的合约，展示中心化稳定币的核心特征：</p>
                
                <div class="code-block">
// contracts/CentralizedStablecoin.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// 导入OpenZeppelin标准合约库 - 行业最佳实践
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title CentralizedStablecoin
 * @dev 最小化的法币抵押型稳定币实现
 * 展示了USDT/USDC等中心化稳定币的核心机制
 */
contract CentralizedStablecoin is ERC20, Ownable, Pausable {
    // 状态变量
    uint8 private constant DECIMALS = 6;  // USDC标准精度
    mapping(address => bool) public blacklisted;  // 黑名单机制
    
    // 事件定义 - 用于链上活动追踪
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed from, uint256 amount);
    event Blacklist(address indexed account, bool status);
    event Redeem(address indexed from, uint256 amount, string txId);
    
    // 修饰符 - 可重用的访问控制
    modifier notBlacklisted(address account) {
        require(!blacklisted[account], "Account is blacklisted");
        _;
    }
    
    constructor() ERC20("Centralized Stablecoin", "CSTABLE") Ownable(msg.sender) {
        // 部署时不铸造初始供应量 - 符合真实稳定币模式
    }
    
    function decimals() public pure override returns (uint8) {
        return DECIMALS;
    }
    
    /**
     * @notice 铸造新代币 - 对应用户存入法币
     * @dev 只有owner可调用，模拟KYC后的法币存入流程
     * @param to 接收代币的地址
     * @param amount 铸造数量（最小单位）
     */
    function mint(address to, uint256 amount) 
        external 
        onlyOwner 
        notBlacklisted(to) 
        whenNotPaused 
    {
        _mint(to, amount);
        emit Mint(to, amount);
    }
    
    /**
     * @notice 销毁代币并记录赎回请求
     * @dev 实际稳定币需要链下处理法币提现
     * @param amount 销毁数量
     * @param txId 链下银行转账ID（用于审计）
     */
    function redeem(uint256 amount, string memory txId) 
        external 
        notBlacklisted(msg.sender) 
        whenNotPaused 
    {
        _burn(msg.sender, amount);
        emit Redeem(msg.sender, amount, txId);
    }
    
    /**
     * @notice 黑名单管理 - 合规要求
     * @dev 被黑名单的地址无法转账
     */
    function setBlacklist(address account, bool status) 
        external 
        onlyOwner 
    {
        blacklisted[account] = status;
        emit Blacklist(account, status);
    }
    
    /**
     * @notice 紧急暂停 - 应对安全事件
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @notice 重写transfer函数，加入黑名单和暂停检查
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);
        
        require(!paused(), "Token transfers are paused");
        require(!blacklisted[from], "Sender is blacklisted");
        require(!blacklisted[to], "Recipient is blacklisted");
    }
}

// 思考题：
// 1. 这个合约的中心化风险点在哪里？如何通过多签改进？
// 2. 如何实现合约升级？（提示：代理模式）
// 3. 黑名单机制的法律和道德影响是什么？
// 4. 如何增加审计日志功能来提高透明度？
                </div>
                
                <div class="tip">
                    <strong>💡 关键洞察：</strong>这个合约展示了中心化稳定币的核心特征：
                    <ul>
                        <li>单点控制（owner权限）</li>
                        <li>合规功能（黑名单、暂停）</li>
                        <li>链上记账，链下结算的模式</li>
                        <li>信任依赖于发行方而非代码</li>
                    </ul>
                </div>
                
                <h4>链上 vs 链下：理解稳定币的双重世界</h4>
                <div style="background: #e0f2fe; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
                    <p><strong>关键概念澄清：</strong></p>
                    <ul>
                        <li><strong>链上（On-chain）</strong>：
                            <ul>
                                <li>ERC-20合约是一个<strong>权威的IOU（我欠你）记账本</strong></li>
                                <li><code>balanceOf</code>返回的不是美元，而是<strong>发行方承诺兑付的美元债权</strong></li>
                                <li><code>transfer</code>转移的是<strong>债权记录</strong>，不是实际美元</li>
                            </ul>
                        </li>
                        <li><strong>链下（Off-chain）</strong>：
                            <ul>
                                <li>真实的美元储备在传统银行账户中</li>
                                <li>KYC/AML合规流程完全在链外进行</li>
                                <li>审计报告、监管文件等都是链下活动</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <div class="warning" style="margin-top: 1rem;">
                        <strong>⚠️ 常见误解：</strong>智能合约本身<strong>不知道</strong>也<strong>不保管</strong>任何美元。它只是一个由中心化实体控制的数字账本。用户的信任基础是发行方的信誉、监管合规和审计报告，而非智能合约代码。
                    </div>
                </div>

                <h4>步骤3：部署脚本</h4>
                <div class="code-block">
// scripts/deploy.js
async function main() {
    const [deployer] = await ethers.getSigners();
    console.log("部署账户:", deployer.address);
    
    const HelloStablecoin = await ethers.getContractFactory("HelloStablecoin");
    const stablecoin = await HelloStablecoin.deploy();
    await stablecoin.deployed();
    
    console.log("HelloStablecoin 部署地址:", stablecoin.address);
    
    // 验证初始余额
    const balance = await stablecoin.balanceOf(deployer.address);
    console.log("部署者余额:", ethers.utils.formatUnits(balance, 6), "HELLO");
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});                </div>

                <h4>步骤4：运行本地节点并部署</h4>
                <div class="code-block">
# 终端1：启动本地节点
npx hardhat node

# 终端2：部署合约
npx hardhat run scripts/deploy.js --network localhost                </div>
                
                <h4>步骤5：编写测试用例</h4>
                <p>专业的智能合约开发必须包含完整的测试。让我们为核心功能编写测试：</p>
                
                <div class="code-block">
// test/CentralizedStablecoin.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("CentralizedStablecoin", function () {
    let stablecoin;
    let owner;
    let addr1;
    let addr2;
    
    beforeEach(async function () {
        // 获取测试账户
        [owner, addr1, addr2] = await ethers.getSigners();
        
        // 部署合约
        const CentralizedStablecoin = await ethers.getContractFactory("CentralizedStablecoin");
        stablecoin = await CentralizedStablecoin.deploy();
        await stablecoin.deployed();
    });
    
    describe("铸造功能", function () {
        it("只有owner可以铸造", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            
            // owner铸造成功
            await expect(stablecoin.mint(addr1.address, amount))
                .to.emit(stablecoin, "Mint")
                .withArgs(addr1.address, amount);
            
            // 非owner铸造失败
            await expect(
                stablecoin.connect(addr1).mint(addr2.address, amount)
            ).to.be.revertedWith("Ownable: caller is not the owner");
        });
        
        it("不能向黑名单地址铸造", async function () {
            // 先将addr1加入黑名单
            await stablecoin.setBlacklist(addr1.address, true);
            
            // 尝试铸造应该失败
            await expect(
                stablecoin.mint(addr1.address, 1000)
            ).to.be.revertedWith("Account is blacklisted");
        });
    });
    
    describe("黑名单功能", function () {
        it("黑名单地址无法转账", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            
            // 先铸造一些代币
            await stablecoin.mint(addr1.address, amount);
            
            // 正常转账应该成功
            await stablecoin.connect(addr1).transfer(addr2.address, amount);
            
            // 将addr1加入黑名单
            await stablecoin.setBlacklist(addr1.address, true);
            
            // 黑名单地址转账应该失败
            await expect(
                stablecoin.connect(addr2).transfer(addr1.address, amount)
            ).to.be.revertedWith("Recipient is blacklisted");
        });
    });
    
    describe("暂停功能", function () {
        it("暂停时无法转账", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            await stablecoin.mint(addr1.address, amount);
            
            // 暂停合约
            await stablecoin.pause();
            
            // 转账应该失败
            await expect(
                stablecoin.connect(addr1).transfer(addr2.address, amount)
            ).to.be.revertedWith("Token transfers are paused");
            
            // 恢复后可以转账
            await stablecoin.unpause();
            await expect(
                stablecoin.connect(addr1).transfer(addr2.address, amount)
            ).to.not.be.reverted;
        });
    });
    
    describe("赎回功能", function () {
        it("可以销毁代币并记录赎回请求", async function () {
            const amount = ethers.utils.parseUnits("1000", 6);
            const txId = "BANK_TX_12345";
            
            // 铸造代币
            await stablecoin.mint(addr1.address, amount);
            
            // 赎回
            await expect(
                stablecoin.connect(addr1).redeem(amount, txId)
            )
                .to.emit(stablecoin, "Redeem")
                .withArgs(addr1.address, amount, txId);
            
            // 检查余额为0
            expect(await stablecoin.balanceOf(addr1.address)).to.equal(0);
        });
    });
});

// 运行测试
// npx hardhat test
// 运行测试并查看覆盖率
// npx hardhat coverage
                </div>
                
                <div class="tip">
                    <strong>💡 测试最佳实践：</strong>
                    <ul>
                        <li>使用<code>beforeEach</code>确保每个测试的独立性</li>
                        <li>测试正常情况和异常情况</li>
                        <li>使用事件断言验证状态变化</li>
                        <li>测试访问控制和权限管理</li>
                        <li>追求高测试覆盖率（>95%）</li>
                    </ul>
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 1.2：扩展功能</h4>
                </div>
                <p>基于HelloStablecoin，实现以下功能：</p>
                <ol>
                    <li>添加暂停（pause）功能，允许所有者在紧急情况下暂停所有转账</li>
                    <li>实现黑名单机制，被加入黑名单的地址无法发送或接收代币</li>
                    <li>添加转账费用功能，每次转账收取0.1%的费用到指定地址</li>
                </ol>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-2')">查看参考答案</button>
                <div id="answer-1-2" class="answer-content">
                    <h5>参考答案：</h5>
                    <div class="code-block">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract AdvancedHelloStablecoin is ERC20, Ownable, Pausable {
    uint8 private constant DECIMALS = 6;
    uint256 private constant FEE_RATE = 10; // 0.1% = 10/10000
    
    address public feeCollector;
    mapping(address => bool) public blacklist;
    
    event AddedToBlacklist(address indexed account);
    event RemovedFromBlacklist(address indexed account);
    event FeeCollectorUpdated(address indexed newCollector);
    event FeesCollected(address indexed from, address indexed to, uint256 feeAmount);
    
    modifier notBlacklisted(address account) {
        require(!blacklist[account], "Account is blacklisted");
        _;
    }
    
    constructor(address _feeCollector) ERC20("Advanced Hello Stablecoin", "AHELLO") {
        require(_feeCollector != address(0), "Invalid fee collector");
        feeCollector = _feeCollector;
        _mint(msg.sender, 1000000 * 10**DECIMALS);
    }
    
    function decimals() public pure override returns (uint8) {
        return DECIMALS;
    }
    
    // 暂停功能
    function pause() public onlyOwner {
        _pause();
    }
    
    function unpause() public onlyOwner {
        _unpause();
    }
    
    // 黑名单管理
    function addToBlacklist(address account) public onlyOwner {
        require(account != address(0), "Invalid address");
        require(!blacklist[account], "Already blacklisted");
        blacklist[account] = true;
        emit AddedToBlacklist(account);
    }
    
    function removeFromBlacklist(address account) public onlyOwner {
        require(blacklist[account], "Not blacklisted");
        blacklist[account] = false;
        emit RemovedFromBlacklist(account);
    }
    
    // 更新费用收集地址
    function updateFeeCollector(address newCollector) public onlyOwner {
        require(newCollector != address(0), "Invalid fee collector");
        feeCollector = newCollector;
        emit FeeCollectorUpdated(newCollector);
    }
    
    // 重写transfer函数以添加费用逻辑
    function transfer(address to, uint256 amount) public override 
        whenNotPaused 
        notBlacklisted(msg.sender) 
        notBlacklisted(to) 
        returns (bool) 
    {
        uint256 feeAmount = (amount * FEE_RATE) / 10000;
        uint256 netAmount = amount - feeAmount;
        
        // 转账净额给接收者
        super.transfer(to, netAmount);
        
        // 如果有费用，转给费用收集者
        if (feeAmount > 0) {
            super.transfer(feeCollector, feeAmount);
            emit FeesCollected(msg.sender, to, feeAmount);
        }
        
        return true;
    }
    
    // 重写transferFrom函数
    function transferFrom(address from, address to, uint256 amount) public override 
        whenNotPaused 
        notBlacklisted(from) 
        notBlacklisted(to) 
        returns (bool) 
    {
        uint256 feeAmount = (amount * FEE_RATE) / 10000;
        uint256 netAmount = amount - feeAmount;
        
        // 使用批准的额度进行转账
        super.transferFrom(from, to, netAmount);
        
        // 如果有费用，从发送者转给费用收集者
        if (feeAmount > 0) {
            super.transferFrom(from, feeCollector, feeAmount);
            emit FeesCollected(from, to, feeAmount);
        }
        
        return true;
    }
    
    // 铸造和销毁功能
    function mint(address to, uint256 amount) public onlyOwner notBlacklisted(to) {
        _mint(to, amount);
    }
    
    function burn(uint256 amount) public notBlacklisted(msg.sender) {
        _burn(msg.sender, amount);
    }
}                    </div>
                    
                    <h5>测试脚本示例：</h5>
                    <div class="code-block">
const { expect } = require("chai");  // Chai测试断言库

describe("AdvancedHelloStablecoin", function () {
    let stablecoin, owner, addr1, addr2, feeCollector;
    
    beforeEach(async function () {
        [owner, addr1, addr2, feeCollector] = await ethers.getSigners();
        const Contract = await ethers.getContractFactory("AdvancedHelloStablecoin");
        stablecoin = await Contract.deploy(feeCollector.address);
        await stablecoin.deployed();
    });
    
    it("应该正确收取转账费用", async function () {
        const amount = ethers.utils.parseUnits("1000", 6);
        await stablecoin.transfer(addr1.address, amount);
        
        // addr1转账100 AHELLO给addr2
        const transferAmount = ethers.utils.parseUnits("100", 6);
        await stablecoin.connect(addr1).transfer(addr2.address, transferAmount);
        
        // 检查余额：addr2应该收到99.9，费用收集者收到0.1
        expect(await stablecoin.balanceOf(addr2.address))
            .to.equal(ethers.utils.parseUnits("99.9", 6));
        expect(await stablecoin.balanceOf(feeCollector.address))
            .to.equal(ethers.utils.parseUnits("0.1", 6));
    });
    
    it("黑名单地址无法转账", async function () {
        await stablecoin.addToBlacklist(addr1.address);
        await expect(
            stablecoin.transfer(addr1.address, 100)
        ).to.be.revertedWith("Account is blacklisted");
    });
});                    </div>
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>练习 1.3：Gas优化挑战</h4>
                </div>
                <p>上面的AdvancedHelloStablecoin实现有几个Gas优化的机会。请识别并实现至少3个优化点，使transfer函数的Gas消耗降低至少20%。</p>
                
                <p>提示：</p>
                <ul>
                    <li>存储槽打包</li>
                    <li>避免重复的存储读取</li>
                    <li>使用assembly进行关键操作</li>
                </ul>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-3')">查看参考答案</button>
                <div id="answer-1-3" class="answer-content">
                    <h5>优化版本：</h5>
                    <div class="code-block">
<code>contract GasOptimizedStablecoin is ERC20, Ownable, Pausable {
    // 优化1：将相关变量打包到一个存储槽
    struct Config {
        uint8 decimals;      // 1 byte
        uint16 feeRate;      // 2 bytes (允许更精确的费率)
        bool paused;         // 1 byte
        address feeCollector; // 20 bytes
    }
    Config public config;
    
    // 优化2：使用uint256而不是bool映射（某些情况下更高效）
    mapping(address => uint256) public blacklistStatus; // 0 = 未黑名单, 1 = 已黑名单
    
    // 优化3：缓存常用计算
    uint256 private constant FEE_DENOMINATOR = 100000; // 允许0.001%精度
    
    constructor(address _feeCollector) ERC20("Gas Optimized Stablecoin", "GSTABLE") {
        config = Config({
            decimals: 6,
            feeRate: 100, // 0.1% = 100/100000
            paused: false,
            feeCollector: _feeCollector
        });
        _mint(msg.sender, 1000000 * 10**6);
    }
    
    // 优化4：使用自定义错误而不是字符串（节省部署和运行时Gas）
    error Blacklisted(address account);
    error TransferPaused();
    error InvalidAmount();
    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal view override {
        // 优化5：单次存储读取
        Config memory _config = config;
        
        if (_config.paused) revert TransferPaused();
        if (blacklistStatus[from] == 1) revert Blacklisted(from);
        if (blacklistStatus[to] == 1) revert Blacklisted(to);
    }
    
    // 优化6：优化的transfer实现
    function transfer(address to, uint256 amount) public override returns (bool) {
        address owner = _msgSender();
        
        // 优化7：避免小额转账的费用计算
        if (amount < 1000) {
            _transfer(owner, to, amount);
            return true;
        }
        
        // 优化8：使用位运算计算费用（当费率是2的幂时）
        Config memory _config = config;
        uint256 feeAmount = (amount * _config.feeRate) / FEE_DENOMINATOR;
        uint256 netAmount;
        
        // 优化9：使用unchecked块避免溢出检查（已知安全）
        unchecked {
            netAmount = amount - feeAmount;
        }
        
        // 优化10：批量更新余额以减少SSTORE操作
        _transfer(owner, to, netAmount);
        if (feeAmount > 0) {
            _transfer(owner, _config.feeCollector, feeAmount);
        }
        
        return true;
    }
    
    // 优化11：使用assembly优化关键路径
    function balanceOf(address account) public view override returns (uint256) {
        uint256 balance;
        assembly {
            // 直接读取存储槽
            mstore(0x00, account)
            mstore(0x20, 0) // balances mapping的槽位
            let slot := keccak256(0x00, 0x40)
            balance := sload(slot)
        }
        return balance;
    }
}                    </div>
                    
                    <h5>Gas对比测试：</h5>
                    <div class="code-block">
// Gas消耗对比（近似值）
// 原始版本 transfer: ~65,000 gas
// 优化版本 transfer: ~48,000 gas
// 节省: ~26%

// 额外优化建议：
// 1. 使用专门的批量转账函数
// 2. 实现EIP-2612 permit功能，避免approve+transferFrom
// 3. 考虑使用代理模式分离逻辑和存储                    </div>
                </div>
            </div>

            <div class="theory-section">
                <h3>1.3 Gas经济学与优化策略</h3>
                
                <p>Gas优化对稳定币至关重要，因为它们通常有高频交易需求。让我们深入了解各种优化技术：</p>

                <h4>存储优化技术</h4>
                <div class="code-block">
// 存储槽打包示例
contract StorageOptimized {
    // 差劣实践：每个变量占用一个槽（32字节）
    uint8 public decimals;        // 槽0：使用1字节，浪费31字节
    address public owner;         // 槽1：使用20字节，浪费12字节  
    uint16 public feeRate;        // 槽2：使用2字节，浪费30字节
    bool public paused;           // 槽3：使用1字节，浪费31字节
    
    // 优化实践：打包到2个槽
    struct PackedData {
        uint8 decimals;    // 1字节
        bool paused;       // 1字节
        uint16 feeRate;    // 2字节
        address owner;     // 20字节
        uint64 timestamp;  // 8字节
        // 总计：32字节 = 1个槽
    }
}                </div>

                <div class="tip">
                    <strong>💡 EVM存储规则：</strong>
                    <ul>
                        <li>SSTORE（存储写入）：20,000 gas（冷槽）或 2,900 gas（热槽）</li>
                        <li>SLOAD（存储读取）：2,100 gas（冷槽）或 100 gas（热槽）</li>
                        <li>内存操作：3 gas per 32字节</li>
                    </ul>
                </div>
            </div>

            <div class="exercise">
                <div class="exercise-header">
                    <span class="exercise-icon">📝</span>
                    <h4>综合练习：设计高性能稳定币架构</h4>
                </div>
                <p>基于本章所学，设计一个能够支持以下需求的稳定币架构：</p>
                <ul>
                    <li>每秒处理10,000笔交易</li>
                    <li>平均交易成本低于$0.01</li>
                    <li>支持跨链转账（至少3条链）</li>
                    <li>具备紧急暂停和恢复机制</li>
                    <li>兼容主流DeFi协议</li>
                </ul>
                <p>请提供：架构图、核心合约接口、Gas估算、安全考虑</p>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer-1-4')">查看参考答案</button>
                <div id="answer-1-4" class="answer-content">
                    <h5>参考架构方案：</h5>
                    <pre>
┌─────────────────────────────────────────────────────────┐
│                     用户界面层                           │
├─────────────────────────────────────────────────────────┤
│                    路由器合约                            │
│  (智能路由选择最优链和Layer2)                           │
├──────────────┬──────────────┬───────────────────────────┤
│   Polygon    │  Arbitrum    │      Optimism            │
│  (高频小额)  │  (DeFi集成)  │    (通用交易)            │
├──────────────┴──────────────┴───────────────────────────┤
│                 跨链消息层 (LayerZero/Axelar)           │
├─────────────────────────────────────────────────────────┤
│                以太坊主网（结算层）                       │
│          - 主稳定币合约                                  │
│          - 抵押品管理                                    │
│          - 治理合约                                      │
└─────────────────────────────────────────────────────────┘
                    </pre>
                    
                    <h5>核心合约接口：</h5>
                    <div class="code-block">
<code>interface IHighPerformanceStablecoin {
    // 基础ERC20功能
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    
    // 批量操作（Gas优化）
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external returns (bool);
    
    // 跨链功能
    function crossChainTransfer(
        uint16 destChainId,
        address recipient,
        uint256 amount,
        bytes calldata adapterParams
    ) external payable;
    
    // Layer2优化
    function depositToL2(uint256 amount, uint16 l2ChainId) external;
    function withdrawFromL2(uint256 amount, bytes calldata proof) external;
    
    // 紧急控制
    function pause() external; // 仅治理可调用
    function unpause() external;
    
    // DeFi集成钩子
    function beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// L2优化版本
contract L2OptimizedStablecoin {
    // 使用压缩的余额存储（适合稳定币）
    mapping(address => uint128) private packedBalances;
    
    // 签名批量转账（类似Uniswap Permit2）
    function transferWithSignature(
        TransferData calldata transfer,
        bytes calldata signature
    ) external {
        // 验证签名并执行转账
        // 避免多次approve操作
    }
}                    </div>
                    
                    <h5>Gas成本估算：</h5>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <th style="border: 1px solid #ddd; padding: 8px;">操作</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">L1成本</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">L2成本</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">USD成本(@$2000 ETH)</th>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">单笔转账</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">65,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">21,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">$0.002</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">批量转账(10笔)</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">180,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">80,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">$0.008</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">跨链转账</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">150,000 gas</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">N/A</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">$0.015</td>
                        </tr>
                    </table>
                    
                    <h5>安全考虑：</h5>
                    <ol>
                        <li><strong>多签治理：</strong>关键操作需要3/5多签</li>
                        <li><strong>时间锁：</strong>所有治理操作48小时延迟</li>
                        <li><strong>断路器：</strong>异常大额转账自动暂停</li>
                        <li><strong>审计要求：</strong>每个L2部署独立审计</li>
                        <li><strong>跨链风险：</strong>设置每日跨链限额</li>
                    </ol>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>本章重点术语速查表</h3>
                
                <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                    <tr style="background: #f3f4f6;">
                        <th style="border: 1px solid #ddd; padding: 12px; width: 20%;">缩写/术语</th>
                        <th style="border: 1px solid #ddd; padding: 12px; width: 25%;">英文全称</th>
                        <th style="border: 1px solid #ddd; padding: 12px; width: 20%;">中文</th>
                        <th style="border: 1px solid #ddd; padding: 12px; width: 35%;">简要说明</th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>PoW</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Proof of Work</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">工作量证明</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">通过计算难题竞争记账权的共识机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>PoS</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Proof of Stake</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">权益证明</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">根据持币量和时间获得记账权的共识机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>DPoS</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Delegated Proof of Stake</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">委托权益证明</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">持币者投票选出验证者的共识机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>UTXO</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Unspent Transaction Output</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">未花费交易输出</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">比特币使用的账本模型</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>EVM</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Ethereum Virtual Machine</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">以太坊虚拟机</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">执行智能合约的运行环境</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>L1/L2</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Layer 1/Layer 2</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">第一层/第二层</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">主链/扩容解决方案</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>Gas</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">-</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">燃料费</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">执行交易或合约所需的计算费用</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>Oracle</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">-</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">预言机</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">向区块链提供外部数据的服务</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong><span class="tooltip">CDP<span class="tooltip-content">抵押债仓，锁定抵押品借出稳定币的智能合约仓位</span></span></strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Collateralized Debt Position</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">抵押债仓</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">锁定抵押品借出稳定币的仓位</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>DSR</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">DAI Savings Rate</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">DAI储蓄率</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">持有DAI获得的利息率</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>TWAP</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Time-Weighted Average Price</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">时间加权平均价格</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">防闪电贷攻击的价格计算方式</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>KYC/AML</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Know Your Customer/Anti-Money Laundering</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">了解你的客户/反洗钱</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">金融合规要求</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>RWA</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Real World Assets</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">现实世界资产</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">链下资产的链上表示</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>DEX</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Decentralized Exchange</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">去中心化交易所</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">无需信任第三方的交易平台</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>AMM</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Automated Market Maker</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">自动做市商</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">使用算法定价的交易机制</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>TVL</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Total Value Locked</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">总锁仓价值</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">DeFi协议中锁定的资产总值</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>APY/APR</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Annual Percentage Yield/Rate</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">年化收益率/年利率</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">复利收益率/简单利率</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><strong>BFT</strong></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Byzantine Fault Tolerance</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">拜占庭容错</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">容忍部分节点恶意行为的共识算法</td>
                    </tr>
                </table>
                
                <div class="tip" style="margin-top: 1rem;">
                    <strong>💡 学习建议：</strong>掌握这些术语是深入理解稳定币生态的基础。建议将此表作为参考，在阅读后续章节时随时查阅。
                </div>
            </div>
        </div>
        
        <!-- 第二章：稳定币分类与经济模型 -->
        <div class="chapter" id="chapter2">
            <h2>第二章：稳定币分类与经济模型</h2>
            
            <div class="intro-box">
                <strong>本章概览：</strong>
                <ul>
                    <li>法币抵押型稳定币深度解析（USDC、USDT、PYUSD）</li>
                    <li>加密货币抵押型稳定币机制（DAI、LUSD）</li>
                    <li>算法稳定币的兴衰与教训（UST、FRAX）</li>
                    <li>混合型模型与创新（Ethena、crvUSD）</li>
                    <li>2024年监管进展与市场趋势</li>
                </ul>
            </div>
            
            <div class="theory-section">
                <h3>2.1 法币抵押型稳定币（Fiat-Collateralized）</h3>
                
                <p>法币抵押型稳定币是最直观的稳定币模型，通过持有等值的法币储备来保证稳定币价值。这类稳定币是目前市场份额最大的类型。</p>
                
                <h4>核心机制</h4>
                <div style="background: #f0f9ff; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>1:1储备模型</strong>
                    <ul>
                        <li><strong>铸造（Mint）</strong>：用户存入$1法币 → 发行1个稳定币</li>
                        <li><strong>赎回（Redeem）</strong>：用户销毁1个稳定币 → 取回$1法币</li>
                        <li><strong>储备证明</strong>：定期审计确保100%储备率</li>
                    </ul>
                </div>
                
                <h4>主要代表：USDC（USD Coin）</h4>
                <h5>技术架构</h5>
                <div class="code-block">
// USDC核心合约简化版
contract FiatTokenV2_1 is FiatTokenV2 {
    // 关键角色
    address public masterMinter;    // 主铸币者
    mapping(address => bool) public minters;    // 授权铸币者
    mapping(address => uint256) public minterAllowed;    // 铸币配额
    
    // 铸币功能（仅授权铸币者）
    function mint(address _to, uint256 _amount) 
        external 
        onlyMinters 
        notBlacklisted(msg.sender) 
        notBlacklisted(_to) 
        returns (bool) {
        require(_to != address(0), "Mint to zero address");
        require(_amount > 0, "Mint amount not greater than 0");
        
        uint256 mintingAllowedAmount = minterAllowed[msg.sender];
        require(_amount <= mintingAllowedAmount, "Mint amount exceeds allowed");
        
        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);
        
        emit Mint(msg.sender, _to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }
    
    // 销毁功能（任何持币者）
    function burn(uint256 _amount) 
        external 
        whenNotPaused 
        notBlacklisted(msg.sender) {
        uint256 balance = balances[msg.sender];
        require(_amount > 0, "Burn amount not greater than 0");
        require(balance >= _amount, "Burn amount exceeds balance");
        
        totalSupply_ = totalSupply_.sub(_amount);
        balances[msg.sender] = balance.sub(_amount);
        
        emit Burn(msg.sender, _amount);
        emit Transfer(msg.sender, address(0), _amount);
    }
}
                </div>
                
                <h5>储备资产构成（2024年数据）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">资产类型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">比例</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">风险等级</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">现金存款</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">20%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">低</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">短期美国国债</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">80%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">极低</td>
                    </tr>
                </table>
                
                <h4>主要代表：USDT（Tether）</h4>
                <h5>储备资产构成（2024年Q1）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">资产类型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">金额（十亿美元）</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">比例</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">美国国债</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$90.9B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">84.5%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">隔夜逆回购</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$8.3B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">7.7%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">货币市场基金</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$5.3B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">4.9%</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">比特币</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$3.2B</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3.0%</td>
                    </tr>
                </table>
                
                <h4>优缺点分析</h4>
                <div class="tip">
                    <strong>优点：</strong>
                    <ul>
                        <li>简单直观，易于理解</li>
                        <li>价格稳定性最高</li>
                        <li>流动性充足</li>
                        <li>适合大额交易和机构使用</li>
                    </ul>
                </div>
                
                <div class="warning">
                    <strong>缺点与风险：</strong>
                    <ul>
                        <li><strong>中心化风险</strong>：单点故障，可能被冻结</li>
                        <li><strong>监管风险</strong>：受政府监管影响</li>
                        <li><strong>交易对手风险</strong>：银行破产风险（如2023年3月硅谷银行倒闭导致USDC脱锚）</li>
                        <li><strong>透明度问题</strong>：需要信任第三方审计</li>
                    </ul>
                </div>
                
                <h4>2024年最新发展：PayPal USD (PYUSD)</h4>
                <p>传统金融巨头进军稳定币市场的里程碑案例。</p>
                
                <h5>技术架构与合规性</h5>
                <ul>
                    <li><strong>发行方</strong>：Paxos Trust Company（受纽约州金融服务部NYDFS监管）</li>
                    <li><strong>技术标准</strong>：ERC-20代币，部署在以太坊主网</li>
                    <li><strong>独特之处</strong>：
                        <ul>
                            <li>PayPal生态内原生集成（3.8亿活跃用户）</li>
                            <li>支持PayPal内部转账免手续费</li>
                            <li>可在DeFi协议中使用（开放性）</li>
                        </ul>
                    </li>
                    <li><strong>战略意义</strong>：
                        <ul>
                            <li>TradFi与DeFi的桥梁</li>
                            <li>为其他支付公司提供参考模板</li>
                            <li>推动稳定币主流化采用</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>监管合规最新进展</h4>
                
                <h5>欧盟MiCA法规（2024年生效）</h5>
                <ul>
                    <li><strong>资产分类</strong>：
                        <ul>
                            <li>EMT（E-Money Token）：单一法币锚定</li>
                            <li>ART（Asset-Referenced Token）：多资产锚定</li>
                        </ul>
                    </li>
                    <li><strong>核心要求</strong>：
                        <ul>
                            <li>储备资产必须1:1支持，存放于受监管托管机构</li>
                            <li>每日交易上限：EMT为2亿欧元</li>
                            <li>白皮书必须获得监管批准</li>
                            <li>算法稳定币受到严格限制</li>
                        </ul>
                    </li>
                    <li><strong>影响</strong>：Circle已在法国申请许可，USDC将符合MiCA要求</li>
                </ul>
                
                <h5>美国监管动态</h5>
                <ul>
                    <li><strong>Stablecoin TRUST Act</strong>：要求100%现金或短期国债储备</li>
                    <li><strong>州级创新</strong>：怀俄明州SPDI（特殊目的存款机构）框架</li>
                    <li><strong>联邦层面</strong>：SEC与CFTC管辖权之争仍在继续</li>
                </ul>
            </div>
            
            <div class="theory-section">
                <h3>2.2 加密货币抵押型稳定币（Crypto-Collateralized）</h3>
                
                <p>加密货币抵押型稳定币通过超额抵押加密资产来维持价值稳定，是DeFi生态系统的核心组成部分。</p>
                
                <h4>核心概念：超额抵押</h4>
                <div style="background: #f0fdf4; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <p><strong>为什么需要超额抵押？</strong></p>
                    <ul>
                        <li>加密资产价格波动大</li>
                        <li>需要缓冲空间防止资不抵债</li>
                        <li>激励及时还款和风险管理</li>
                    </ul>
                    <p><strong>典型抵押率：</strong>150% - 200%（借$100需要抵押$150-$200的资产）</p>
                </div>
                
                <h4>主要代表：DAI（MakerDAO）</h4>
                <h5>系统架构</h5>
                <div class="code-block">
// Maker协议核心组件简化
contract Vat {  // 核心会计引擎
    // CDP（现称Vault）状态
    struct Ilk {  // 抵押品类型
        uint256 Art;   // 总债务
        uint256 rate;  // 累积稳定费率
        uint256 spot;  // 价格（带安全边际）
        uint256 line;  // 债务上限
        uint256 dust;  // 最小债务额
    }
    
    struct Urn {  // 用户金库
        uint256 ink;   // 抵押品数量
        uint256 art;   // 标准化债务
    }
    
    mapping (bytes32 => Ilk) public ilks;  // 抵押品类型
    mapping (bytes32 => mapping (address => Urn)) public urns;  // 用户金库
    
    // 开仓（抵押品锁定，DAI生成）
    function frob(
        bytes32 i,      // 抵押品类型
        address u,      // 金库地址
        address v,      // 抵押品来源
        address w,      // DAI接收地址
        int dink,       // 抵押品变化
        int dart        // 债务变化
    ) external {
        Urn memory urn = urns[i][u];
        Ilk memory ilk = ilks[i];
        
        urn.ink = add(urn.ink, dink);
        urn.art = add(urn.art, dart);
        ilk.Art = add(ilk.Art, dart);
        
        // 检查抵押率
        uint dtab = mul(ilk.rate, dart);
        uint tab = mul(ilk.rate, urn.art);
        require(either(dart <= 0, both(
            mul(ilk.Art, ilk.rate) <= ilk.line,  // 债务上限
            tab <= mul(urn.ink, ilk.spot)        // 抵押率要求
        )), "Vat/not-safe");
        
        require(either(dart <= 0, tab >= ilk.dust), "Vat/dust");
        
        urns[i][u] = urn;
        ilks[i] = ilk;
    }
}

// 清算模块
contract Dog {  // Liquidation Engine 2.0
    struct Ilk {
        address clip;  // 拍卖合约地址
        uint256 chop;  // 清算罚金
        uint256 hole;  // 最大同时拍卖金额
        uint256 dirt;  // 当前拍卖金额
    }
    
    // 触发清算
    function bark(
        bytes32 ilk,    // 抵押品类型
        address urn,    // 待清算金库
        address kpr     // 清算人（获得奖励）
    ) external returns (uint256 id) {
        require(live == 1, "Dog/not-live");
        
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        Ilk memory milk = ilks[ilk];
        uint256 dart = art;
        
        // 检查是否可清算
        require(milk.chop > 0, "Dog/ilk-not-init");
        uint256 room = sub(milk.hole, milk.dirt);
        require(room > 0 && dart > 0, "Dog/liquidation-limit-hit");
        
        // 计算清算金额
        uint256 dink = ink;
        if (milk.hole != type(uint256).max) {
            dart = min(dart, mul(room, WAD) / milk.rate / milk.chop);
            dink = mul(ink, dart) / art;
        }
        
        // 转移债务到拍卖模块
        vat.grab(ilk, urn, address(this), address(vow), -int256(dink), -int256(dart));
        
        // 启动拍卖
        uint256 due = mul(dart, milk.rate);
        id = Clipper(milk.clip).kick({
            tab: mul(due, milk.chop) / WAD,
            lot: dink,
            usr: urn,
            kpr: kpr
        });
    }
}
                </div>
                
                <h5>支持的抵押品类型</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">抵押品</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">最低抵押率</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">稳定费率（年化）</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">债务上限</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">ETH-A</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">145%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5.25%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">15B DAI</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">WBTC-A</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">145%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5.75%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">500M DAI</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">USDC-A</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">101%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">0%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">2B DAI</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">RWA（现实资产）</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">100%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3-7%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3B DAI</td>
                    </tr>
                </table>
                
                <h4>其他重要项目</h4>
                
                <h5>LUSD（Liquity）</h5>
                <ul>
                    <li><strong>单一抵押品</strong>：仅支持ETH</li>
                    <li><strong>最低抵押率</strong>：110%（更资本高效）</li>
                    <li><strong>无治理</strong>：参数固定，真正去中心化</li>
                    <li><strong>一次性费用</strong>：0.5%借款费，无利息</li>
                    <li><strong>稳定机制</strong>：
                        <ul>
                            <li>硬锚定：$1.10赎回上限，$0.95 LUSD/ETH流动性下限</li>
                            <li>软锚定：套利激励</li>
                        </ul>
                    </li>
                </ul>
                
                <div class="code-block">
// Liquity核心机制：Trove（金库）操作
contract BorrowerOperations {
    // 开仓参数
    struct OpenTroveParams {
        uint _maxFeePercentage;
        uint _collAmount;
        uint _LUSDAmount;
        address _upperHint;
        address _lowerHint;
    }
    
    function openTrove(OpenTroveParams memory params) external payable {
        require(params._collAmount == msg.value, "BorrowerOps: Coll != msg.value");
        
        // 计算复合债务（本金 + 200 LUSD gas补偿）
        uint LUSDFee = _triggerBorrowingFee(params._LUSDAmount, params._maxFeePercentage);
        uint netDebt = params._LUSDAmount;
        uint compositeDebt = netDebt.add(LUSD_GAS_COMPENSATION);
        
        // 检查最低债务要求（2000 LUSD）
        require(compositeDebt >= MIN_NET_DEBT, "BorrowerOps: Trove net debt < minimum");
        
        // 计算ICR（个人抵押率）
        uint ICR = LiquityMath._computeCR(params._collAmount, compositeDebt, price);
        require(ICR >= MCR, "BorrowerOps: ICR < MCR");  // MCR = 110%
        
        // 创建Trove
        contractsCache.troveManager.openTrove(
            msg.sender, 
            params._collAmount, 
            compositeDebt
        );
        
        // 发送LUSD给借款人
        contractsCache.lusdToken.mint(msg.sender, params._LUSDAmount);
        
        emit TroveCreated(msg.sender, compositeDebt, params._collAmount);
    }
}
                </div>
                
                <h5>sUSD（Synthetix）</h5>
                <ul>
                    <li><strong>抵押品</strong>：SNX代币</li>
                    <li><strong>抵押率</strong>：400%（非常保守）</li>
                    <li><strong>特殊机制</strong>：债务池共担模式</li>
                    <li><strong>用途</strong>：合成资产交易的基础货币</li>
                </ul>
                
                <div class="warning">
                    <strong>⚠️ 加密抵押型稳定币的独特风险：</strong>
                    <ul>
                        <li><strong>清算风险</strong>：市场剧烈波动时可能被清算</li>
                        <li><strong>预言机风险</strong>：价格数据错误可能导致不当清算</li>
                        <li><strong>智能合约风险</strong>：代码漏洞可能造成损失</li>
                        <li><strong>扩展性限制</strong>：受抵押品市值限制</li>
                    </ul>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>2.3 算法稳定币（Algorithmic Stablecoins）</h3>
                
                <p>算法稳定币试图通过算法和市场激励机制来维持价格稳定，不依赖抵押品或仅部分抵押。这是最具实验性和争议性的稳定币类型。</p>
                
                <h4>核心机制：供需调节</h4>
                <div style="background: #fef3c7; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>基本原理：</strong>
                    <ul>
                        <li><strong>价格 > $1</strong>：增加供应量，稀释价格</li>
                        <li><strong>价格 < $1</strong>：减少供应量，提升价格</li>
                        <li><strong>调节工具</strong>：铸币/销毁、债券、股份代币等</li>
                    </ul>
                </div>
                
                <h4>历史案例：UST（Terra USD）的兴衰</h4>
                
                <h5>机制设计</h5>
                <div class="code-block">
// Terra协议核心机制（简化版）
contract TerraStation {
    uint256 constant DECIMAL_PRECISION = 1e6;
    
    // 铸造UST（烧毁等值LUNA）
    function mintUST(uint256 lunaAmount) external {
        uint256 lunaPrice = getOraclePrice("LUNA");
        uint256 ustToMint = (lunaAmount * lunaPrice) / DECIMAL_PRECISION;
        
        // 烧毁LUNA
        LUNA.burnFrom(msg.sender, lunaAmount);
        
        // 铸造UST
        UST.mint(msg.sender, ustToMint);
        
        emit Swap(msg.sender, "LUNA", "UST", lunaAmount, ustToMint);
    }
    
    // 赎回LUNA（烧毁UST）
    function redeemLUNA(uint256 ustAmount) external {
        uint256 lunaPrice = getOraclePrice("LUNA");
        uint256 lunaToMint = (ustAmount * DECIMAL_PRECISION) / lunaPrice;
        
        // 烧毁UST
        UST.burnFrom(msg.sender, ustAmount);
        
        // 铸造LUNA
        LUNA.mint(msg.sender, lunaToMint);
        
        emit Swap(msg.sender, "UST", "LUNA", ustAmount, lunaToMint);
    }
}

// Anchor协议（提供20%年化收益）
contract AnchorProtocol {
    uint256 constant EARN_RATE = 20e16; // 20% APY
    
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public lastUpdate;
    
    function deposit(uint256 amount) external {
        UST.transferFrom(msg.sender, address(this), amount);
        
        // 更新余额和利息
        uint256 earned = calculateEarnings(msg.sender);
        deposits[msg.sender] += amount + earned;
        lastUpdate[msg.sender] = block.timestamp;
    }
}
                </div>
                
                <h5>崩盘时间线详细分析（2022年5月）</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">日期时间</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">关键事件</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">UST价格</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">LUNA价格</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">LUNA供应量</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月7日 21:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">巨鲸在Curve 4pool抛售1.5亿UST</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.985</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$64</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3.5亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月8日 14:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">LFG动用15亿美元BTC储备护盘</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.975</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$61</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">3.8亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月9日 08:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Anchor挤兑开始，TVL下降50%</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.65</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$30</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">11亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月10日 16:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Terra链暂停出块，死亡螺旋加速</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.30</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$1</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">1500亿</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">5月12日 23:00</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">LUNA超发至6.5万亿，完全崩溃</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.10</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">$0.0001</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">6.5万亿</td>
                    </tr>
                </table>
                
                <h5>死亡螺旋的数学分析</h5>
                <div class="code-block">
# UST崩盘的动力学模型
import numpy as np
import matplotlib.pyplot as plt

class USTDeathSpiral:
    """UST死亡螺旋的数学建模"""
    
    def __init__(self):
        self.luna_supply = 350e6  # 初始LUNA供应量：3.5亿
        self.luna_price = 64      # 初始LUNA价格：$64
        self.ust_supply = 18e9    # UST供应量：180亿
        self.ust_price = 1.0      # UST初始价格：$1
        
    def simulate_spiral(self, ust_redemption_rate, time_steps):
        """模拟死亡螺旋过程
        
        参数:
            ust_redemption_rate: 每时间步的UST赎回比例
            time_steps: 模拟步数
        """
        history = {
            'time': [], 'luna_price': [], 'luna_supply': [],
            'ust_price': [], 'market_cap': []
        }
        
        for t in range(time_steps):
            # 记录当前状态
            history['time'].append(t)
            history['luna_price'].append(self.luna_price)
            history['luna_supply'].append(self.luna_supply)
            history['ust_price'].append(self.ust_price)
            history['market_cap'].append(self.luna_price * self.luna_supply)
            
            # UST赎回量
            ust_redeemed = self.ust_supply * ust_redemption_rate
            
            # 按当前LUNA价格铸造新LUNA
            new_luna_minted = ust_redeemed / self.luna_price
            self.luna_supply += new_luna_minted
            
            # 市场冲击：供应增加导致价格下跌
            # 使用简化的价格弹性模型
            supply_increase_pct = new_luna_minted / self.luna_supply
            price_elasticity = -2.5  # 价格弹性系数
            self.luna_price *= (1 + supply_increase_pct * price_elasticity)
            
            # UST价格跟随LUNA市值/UST供应量的比例
            luna_market_cap = self.luna_price * self.luna_supply
            implied_ust_backing = luna_market_cap / self.ust_supply
            self.ust_price = min(1.0, implied_ust_backing)
            
            # 恐慌加速因子：UST脱锚越严重，赎回越快
            if self.ust_price < 0.95:
                ust_redemption_rate *= 1.5  # 恐慌加速
                
            # 防止价格为负
            self.luna_price = max(0.0001, self.luna_price)
            
        return history
    
    def plot_results(self, history):
        """可视化死亡螺旋过程"""
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # LUNA价格
        axes[0, 0].plot(history['time'], history['luna_price'])
        axes[0, 0].set_title('LUNA价格走势')
        axes[0, 0].set_ylabel('价格 ($)')
        axes[0, 0].set_yscale('log')
        
        # LUNA供应量
        axes[0, 1].plot(history['time'], history['luna_supply'])
        axes[0, 1].set_title('LUNA供应量（指数增长）')
        axes[0, 1].set_ylabel('供应量')
        axes[0, 1].set_yscale('log')
        
        # UST价格
        axes[1, 0].plot(history['time'], history['ust_price'])
        axes[1, 0].axhline(y=1.0, color='r', linestyle='--', label='锚定价格')
        axes[1, 0].set_title('UST价格（脱锚过程）')
        axes[1, 0].set_ylabel('价格 ($)')
        axes[1, 0].legend()
        
        # LUNA市值
        axes[1, 1].plot(history['time'], history['market_cap'])
        axes[1, 1].set_title('LUNA总市值')
        axes[1, 1].set_ylabel('市值 ($)')
        axes[1, 1].set_yscale('log')
        
        for ax in axes.flat:
            ax.set_xlabel('时间步')
            ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

# 模拟死亡螺旋
simulator = USTDeathSpiral()
results = simulator.simulate_spiral(ust_redemption_rate=0.05, time_steps=100)
# simulator.plot_results(results)
                </div>
                
                <div class="warning">
                    <strong>深入分析：UST崩盘的根本原因</strong>
                    <ul>
                        <li><strong>内生抵押品的脆弱性</strong>：
                            <ul>
                                <li>LUNA既是UST的抵押品，又是吸收UST赎回压力的缓冲器</li>
                                <li>这种自我引用创造了正反馈循环：价格下跌→信心丧失→更多赎回→更大跌幅</li>
                            </ul>
                        </li>
                        <li><strong>不可持续的收益率</strong>：
                            <ul>
                                <li>Anchor Protocol的20% APY靠协议补贴维持</li>
                                <li>储备资金在2022年3月已接近耗尽</li>
                                <li>高收益掩盖了系统性风险，吸引了大量投机资金</li>
                            </ul>
                        </li>
                        <li><strong>流动性陷阱</strong>：
                            <ul>
                                <li>Curve 4pool深度不足以承受大额抛售</li>
                                <li>CEX/DEX价格差异被套利者利用，加速抛压</li>
                            </ul>
                        </li>
                        <li><strong>治理失效</strong>：
                            <ul>
                                <li>Do Kwon拒绝社区提出的多项风险缓解提案</li>
                                <li>LFG的BTC储备使用不透明，护盘策略失败</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <h5>控制论视角：为什么算法稳定币容易失控</h5>
                <div class="code-block">
# 控制系统分析：稳定币作为反馈控制系统
class StablecoinControlSystem:
    """稳定币的控制论模型"""
    
    def __init__(self, mechanism_type):
        self.mechanism_type = mechanism_type
        
    def transfer_function(self, s):
        """系统传递函数 G(s)"""
        if self.mechanism_type == "fiat_backed":
            # 法币抵押：一阶系统，稳定
            return 1 / (s + 1)
            
        elif self.mechanism_type == "crypto_backed":
            # 加密抵押：二阶系统，有阻尼
            omega_n = 0.5  # 自然频率
            zeta = 0.7     # 阻尼比
            return omega_n**2 / (s**2 + 2*zeta*omega_n*s + omega_n**2)
            
        elif self.mechanism_type == "algorithmic":
            # 算法稳定币：可能不稳定的高阶系统
            # 包含延迟和非线性反馈
            delay = 0.1
            gain = 2.0  # 高增益可能导致振荡
            return gain * np.exp(-delay * s) / (s**3 + 2*s**2 + s + 0.5)
    
    def stability_analysis(self):
        """分析系统稳定性"""
        # 使用根轨迹、波特图等工具
        # 算法稳定币往往在相位裕度和增益裕度上表现差
        pass
                </div>
                
                <h4>部分算法稳定币：FRAX</h4>
                
                <p>FRAX采用部分抵押模式，根据市场条件动态调整抵押率，是算法稳定币的改进尝试。</p>
                
                <h5>核心创新：分数算法稳定币</h5>
                <div class="code-block">
// FRAX协议核心：动态抵押率
contract FRAXStablecoin {
    uint256 public global_collateral_ratio; // 全局抵押率（0-100%）
    
    // 铸造FRAX
    function mintFrax(
        uint256 collateral_amount,
        uint256 fxs_amount,
        uint256 slippage
    ) external {
        uint256 frax_price = getFRAXPrice();
        uint256 fxs_price = getFXSPrice();
        
        // 计算可铸造的FRAX数量
        uint256 c_value = collateral_amount * collateral_price / 1e6;
        uint256 fxs_value = fxs_amount * fxs_price / 1e6;
        
        // 根据抵押率计算
        uint256 calculated_frax = 0;
        if(global_collateral_ratio == 1e6) { // 100%抵押
            calculated_frax = c_value;
        } else if(global_collateral_ratio == 0) { // 0%抵押（纯算法）
            calculated_frax = fxs_value;
        } else { // 部分抵押
            uint256 c_portion = c_value * 1e6 / global_collateral_ratio;
            calculated_frax = c_portion;
        }
        
        // 检查滑点
        require(calculated_frax >= frax_out_min, "Slippage limit");
        
        // 转移抵押品和烧毁FXS
        if(collateral_amount > 0) {
            collateral_token.transferFrom(msg.sender, address(this), collateral_amount);
        }
        if(fxs_amount > 0) {
            FXS.burnFrom(msg.sender, fxs_amount);
        }
        
        // 铸造FRAX
        FRAX.mint(msg.sender, calculated_frax);
    }
    
    // 动态调整抵押率
    function refreshCollateralRatio() external {
        uint256 frax_price = getFRAXPrice();
        
        if(frax_price > 1.01e6) { // FRAX > $1.01
            // 降低抵押率（每次0.25%）
            if(global_collateral_ratio > 0.25e6) {
                global_collateral_ratio -= 0.25e6;
            } else {
                global_collateral_ratio = 0;
            }
        } else if(frax_price < 0.99e6) { // FRAX < $0.99
            // 提高抵押率（每次0.25%）
            if(global_collateral_ratio + 0.25e6 <= 1e6) {
                global_collateral_ratio += 0.25e6;
            } else {
                global_collateral_ratio = 1e6;
            }
        }
        
        emit CollateralRatioRefreshed(global_collateral_ratio);
    }
}

// AMO（算法市场操作）控制器
contract FraxAMOMinter {
    // AMO可以无抵押铸造FRAX用于特定用途
    function mintFraxForAMO(address destination, uint256 frax_amount) external onlyAMO {
        // 检查不会导致抵押不足
        uint256 total_supply = FRAX.totalSupply();
        uint256 global_collateral_value = getGlobalCollateralValue();
        uint256 effective_collateral_ratio = global_collateral_value * 1e6 / (total_supply + frax_amount);
        
        require(effective_collateral_ratio >= global_collateral_ratio, "Collateral ratio violated");
        
        FRAX.mint(destination, frax_amount);
    }
}
                </div>
                
                <h5>FRAX生态系统</h5>
                <ul>
                    <li><strong>FRAX</strong>：稳定币</li>
                    <li><strong>FXS</strong>：股份/治理代币，吸收波动性</li>
                    <li><strong>veFXS</strong>：锁定FXS获得治理权和收益</li>
                    <li><strong>frxETH</strong>：以太坊流动性质押衍生品</li>
                    <li><strong>FPI</strong>：锚定CPI的通胀调整稳定币</li>
                </ul>
                
                <h4>其他算法稳定币尝试</h4>
                
                <h5>Basis Cash（已失败）</h5>
                <ul>
                    <li>三代币系统：BAC（稳定币）、BAS（股份）、BAB（债券）</li>
                    <li>失败原因：死亡螺旋，缺乏真实需求</li>
                </ul>
                
                <h5>Empty Set Dollar（已失败）</h5>
                <ul>
                    <li>单代币模型，结合稳定币和股份功能</li>
                    <li>失败原因：机制过于复杂，难以维持锚定</li>
                </ul>
                
                <h5>AMPL（Ampleforth）</h5>
                <ul>
                    <li><strong>弹性供应</strong>：通过rebase调整所有持有者余额</li>
                    <li><strong>目标</strong>：追踪2019年CPI调整后的美元购买力</li>
                    <li><strong>特点</strong>：不是传统意义的稳定币，更像"稳定购买力"</li>
                </ul>
                
                <div class="tip">
                    <strong>💡 算法稳定币的未来方向：</strong>
                    <ul>
                        <li>部分抵押模式（如FRAX）</li>
                        <li>与RWA（现实世界资产）结合</li>
                        <li>更复杂的稳定机制（如Gyroscope的储备池）</li>
                        <li>跨链流动性聚合</li>
                    </ul>
                </div>
            </div>
            
            <div class="theory-section">
                <h3>2.4 混合模型与创新</h3>
                
                <p>随着稳定币生态的成熟，出现了结合多种机制优点的混合模型，以及针对特定用例的创新设计。</p>
                
                <h4>2024年最新创新：Ethena与合成美元</h4>
                
                <h5>USDe：Delta中性稳定币</h5>
                <p>Ethena Protocol推出的USDe代表了稳定币设计的新范式：通过衍生品对冲而非抵押品来维持稳定。</p>
                
                <div class="code-block">
// Ethena核心机制：Delta中性策略
contract EthenaProtocol {
    struct Position {
        uint256 stETHCollateral;     // 质押ETH现货
        int256 perpShortPosition;    // 永续合约空头
        uint256 fundingEarned;       // 累计资金费收益
        uint256 stakingRewards;      // 质押奖励
    }
    
    // 铸造USDe的核心逻辑
    function mintUSDe(uint256 ethAmount) external returns (uint256) {
        // 1. 接收ETH并质押获得stETH
        uint256 stETHAmount = stakingPool.stake{value: ethAmount}();
        
        // 2. 在衍生品交易所开立等值空头
        int256 shortSize = -int256(ethAmount * getETHPrice());
        perpExchange.openPosition(shortSize);
        
        // 3. 计算可铸造的USDe（扣除安全边际）
        uint256 netValue = calculateNetValue(stETHAmount, shortSize);
        uint256 usdeToMint = netValue * 90 / 100; // 10%安全边际
        
        // 4. 记录头寸
        positions[msg.sender] = Position({
            stETHCollateral: stETHAmount,
            perpShortPosition: shortSize,
            fundingEarned: 0,
            stakingRewards: 0
        });
        
        // 5. 铸造USDe
        _mint(msg.sender, usdeToMint);
        return usdeToMint;
    }
    
    // 收益分配机制
    function distributeYield() external {
        uint256 totalYield = 0;
        
        // 1. 收集质押奖励（约4% APY）
        uint256 stakingYield = stakingPool.claimRewards();
        totalYield += stakingYield;
        
        // 2. 收集资金费（可变，牛市可达20%+ APY）
        uint256 fundingYield = perpExchange.collectFunding();
        totalYield += fundingYield;
        
        // 3. 扣除协议费用
        uint256 protocolFee = totalYield * 10 / 100;
        uint256 userYield = totalYield - protocolFee;
        
        // 4. 分配给sUSDe持有者
        sUsdeVault.depositYield(userYield);
    }
}
                </div>
                
                <h5>风险分析：与UST的对比</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">风险类型</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">UST</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">USDe</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押品风险</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">内生（LUNA），死亡螺旋</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">外生（ETH），但有质押风险</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">收益来源</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">不可持续的补贴</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">市场资金费+质押收益</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">主要风险</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">银行挤兑、信心崩溃</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">负资金费、交易所风险</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">脱锚保护</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">依赖套利者</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">保险基金+OTC赎回</td>
                    </tr>
                </table>
                
                <h4>混合抵押模型</h4>
                
                <h5>crvUSD（Curve Finance）</h5>
                <p>Curve的稳定币采用创新的LLAMMA（Lending-Liquidating AMM Algorithm）机制，实现软清算。</p>
                
                <div class="code-block">
// LLAMMA核心概念：连续清算
contract LLAMMA {
    struct Band {
        uint256 stablecoin_amount;  // 稳定币数量
        uint256 collateral_amount;  // 抵押品数量
    }
    
    mapping(int256 => Band) public bands;  // 价格区间
    
    // 软清算机制
    function deposit_collateral(uint256 amount, uint256 debt, int256 n_bands) external {
        uint256 amount_per_band = amount / uint256(n_bands);
        int256 active_band = price_oracle.active_band();
        
        // 在多个价格区间分散抵押品
        for(int256 i = 0; i < n_bands; i++) {
            int256 band = active_band - i;
            bands[band].collateral_amount += amount_per_band;
        }
        
        // 铸造crvUSD
        crvUSD.mint(msg.sender, debt);
    }
    
    // 自动做市商功能
    function exchange(int256 band) internal {
        Band storage b = bands[band];
        uint256 p_oracle = price_oracle.price();
        uint256 p_band_up = get_p(band + 1);
        uint256 p_band_down = get_p(band);
        
        if(p_oracle > p_band_up) {
            // 卖出所有稳定币买入抵押品
            uint256 collateral_to_buy = b.stablecoin_amount * 1e18 / p_oracle;
            b.collateral_amount += collateral_to_buy;
            b.stablecoin_amount = 0;
        } else if(p_oracle < p_band_down) {
            // 卖出所有抵押品买入稳定币
            uint256 stablecoin_to_buy = b.collateral_amount * p_oracle / 1e18;
            b.stablecoin_amount += stablecoin_to_buy;
            b.collateral_amount = 0;
        } else {
            // 部分转换（AMM逻辑）
            rebalance_band(band, p_oracle);
        }
    }
}
                </div>
                
                <h5>关键创新点</h5>
                <ul>
                    <li><strong>连续清算</strong>：避免瞬间大额清算造成的滑点</li>
                    <li><strong>AMM集成</strong>：清算过程即是做市过程</li>
                    <li><strong>自动再平衡</strong>：根据价格自动调整抵押品/债务比例</li>
                    <li><strong>无需清算人</strong>：系统自动处理风险头寸</li>
                </ul>
                
                <h4>特定用途稳定币</h4>
                
                <h5>GHO（Aave）</h5>
                <ul>
                    <li><strong>原生集成</strong>：与Aave借贷协议深度整合</li>
                    <li><strong>利率折扣</strong>：stkAAVE持有者享受借款利率优惠</li>
                    <li><strong>Facilitator模式</strong>：多个授权实体可铸造GHO</li>
                </ul>
                
                <h5>DOLA（Inverse Finance）</h5>
                <ul>
                    <li><strong>跨链原生</strong>：通过债务桥实现跨链</li>
                    <li><strong>Fed模式</strong>：协议控制的流动性管理</li>
                </ul>
                
                <h4>跨链稳定币</h4>
                
                <h5>跨链桥接模型</h5>
                <div class="code-block">
// 跨链稳定币标准接口
interface ICrossChainStablecoin {
    // 锁定并桥接
    function bridgeOut(
        uint256 amount,
        uint256 toChainId,
        address toAddress
    ) external;
    
    // 接收跨链铸造
    function bridgeIn(
        uint256 amount,
        address toAddress,
        bytes32 txHash
    ) external onlyBridge;
}

// LayerZero实现示例
contract LayerZeroStablecoin is OFT {  // Omnichain Fungible Token
    function sendFrom(
        address _from,
        uint16 _dstChainId,
        bytes calldata _toAddress,
        uint256 _amount,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes calldata _adapterParams
    ) public payable virtual override {
        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);
    }
    
    function _nonblockingLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal virtual override {
        uint16 packetType;
        assembly {
            packetType := mload(add(_payload, 32))
        }
        
        if (packetType == PT_SEND) {
            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);
        }
    }
}
                </div>
                
                <h4>创新稳定机制</h4>
                
                <h5>Gyroscope Protocol</h5>
                <ul>
                    <li><strong>储备池分层</strong>：多层次风险隔离</li>
                    <li><strong>动态定价</strong>：基于储备健康度的赎回定价</li>
                    <li><strong>E-CLP</strong>：椭圆集中流动性池</li>
                </ul>
                
                <h5>Reserve Protocol (RSR/RSV)</h5>
                <ul>
                    <li><strong>资产篮子</strong>：多样化抵押品降低风险</li>
                    <li><strong>保险机制</strong>：RSR作为最后的资本缓冲</li>
                    <li><strong>可配置</strong>：任何人可创建新的稳定币配置</li>
                </ul>
            </div>
            
            <div class="theory-section">
                <h3>2.5 AI/机器学习在稳定币中的应用</h3>
                
                <p>随着DeFi系统复杂性增加，AI和机器学习技术在稳定币风险管理、参数优化和市场预测中扮演越来越重要的角色。</p>
                
                <h4>风险预测与异常检测</h4>
                <div class="code-block">
# 使用LSTM预测稳定币脱锚风险
import torch
import torch.nn as nn
import numpy as np
from sklearn.preprocessing import StandardScaler

class StablecoinRiskPredictor(nn.Module):
    """基于LSTM的稳定币风险预测模型"""
    
    def __init__(self, input_features=10, hidden_size=64, num_layers=2):
        super().__init__()
        self.lstm = nn.LSTM(input_features, hidden_size, num_layers, 
                           batch_first=True, dropout=0.2)
        self.attention = nn.MultiheadAttention(hidden_size, num_heads=4)
        self.fc = nn.Sequential(
            nn.Linear(hidden_size, 32),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(32, 3)  # 输出：[正常, 警告, 危险]
        )
        
    def forward(self, x, market_context=None):
        # x shape: (batch, sequence_length, features)
        lstm_out, (h_n, c_n) = self.lstm(x)
        
        # 自注意力机制捕捉长期依赖
        attn_out, _ = self.attention(lstm_out, lstm_out, lstm_out)
        
        # 使用最后时间步的输出
        risk_scores = self.fc(attn_out[:, -1, :])
        return torch.softmax(risk_scores, dim=1)
    
    def extract_features(self, market_data):
        """特征工程：提取风险相关特征"""
        features = {
            # 价格相关
            'price_deviation': abs(market_data['price'] - 1.0),
            'price_volatility': market_data['price'].rolling(24).std(),
            'volume_spike': market_data['volume'] / market_data['volume'].rolling(168).mean(),
            
            # 链上指标
            'mint_burn_ratio': market_data['mints'] / (market_data['burns'] + 1e-8),
            'whale_concentration': market_data['top_10_holdings'] / market_data['total_supply'],
            'velocity': market_data['transfer_volume'] / market_data['total_supply'],
            
            # DeFi集成
            'liquidity_depth': market_data['amm_liquidity'],
            'utilization_rate': market_data['borrowed'] / market_data['supplied'],
            
            # 市场情绪
            'funding_rate': market_data['perp_funding'],
            'cex_premium': market_data['cex_price'] - market_data['dex_price']
        }
        return features

# 强化学习优化稳定币参数
class StablecoinRLAgent:
    """使用PPO算法优化稳定币参数"""
    
    def __init__(self, state_dim=20, action_dim=5):
        self.policy_net = self._build_network(state_dim, action_dim)
        self.value_net = self._build_network(state_dim, 1)
        self.optimizer = torch.optim.Adam(
            list(self.policy_net.parameters()) + 
            list(self.value_net.parameters()), 
            lr=3e-4
        )
        
    def _build_network(self, input_dim, output_dim):
        return nn.Sequential(
            nn.Linear(input_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, output_dim)
        )
    
    def get_action(self, state):
        """根据当前状态决定参数调整
        
        动作空间:
        - 调整抵押率要求
        - 修改稳定费率
        - 改变清算罚金
        - 调节债务上限
        - 修改预言机参数
        """
        state_tensor = torch.FloatTensor(state)
        action_probs = torch.softmax(self.policy_net(state_tensor), dim=-1)
        action = torch.multinomial(action_probs, 1).item()
        return action
    
    def optimize_parameters(self, env, episodes=1000):
        """通过与环境交互学习最优参数"""
        for episode in range(episodes):
            state = env.reset()
            episode_reward = 0
            
            while not env.done:
                action = self.get_action(state)
                next_state, reward, done = env.step(action)
                
                # 奖励设计：平衡稳定性、资本效率和用户体验
                stability_reward = -abs(env.price - 1.0) * 100
                efficiency_reward = env.utilization_rate * 10
                safety_reward = -env.liquidations * 50
                
                total_reward = stability_reward + efficiency_reward + safety_reward
                episode_reward += total_reward
                
                # PPO更新（简化版）
                self._update_policy(state, action, total_reward, next_state)
                state = next_state
                
            print(f"Episode {episode}: Reward = {episode_reward:.2f}")
                </div>
                
                <h4>博弈论分析：清算人激励机制</h4>
                <div class="code-block">
# 清算拍卖的博弈论模型
class LiquidationAuction:
    """分析清算人（Keepers）的最优策略"""
    
    def __init__(self, collateral_value, debt_value, num_keepers):
        self.collateral_value = collateral_value
        self.debt_value = debt_value
        self.num_keepers = num_keepers
        
    def calculate_nash_equilibrium(self):
        """计算纳什均衡出价策略
        
        假设：
        - 第一价格密封拍卖
        - 私有价值模型
        - 对称均衡
        """
        # 在均衡状态下，每个keeper的最优出价
        # b(v) = v - ∫[v_min to v] F(x)^(n-1) dx / F(v)^(n-1)
        
        # 简化：假设均匀分布的估值
        expected_profit_margin = 1 / (self.num_keepers + 1)
        equilibrium_bid = self.collateral_value * (1 - expected_profit_margin)
        
        return {
            'equilibrium_bid': equilibrium_bid,
            'expected_profit': self.collateral_value - equilibrium_bid,
            'protocol_recovery': equilibrium_bid / self.debt_value
        }
    
    def simulate_dutch_auction(self, start_price, decay_rate):
        """荷兰式拍卖模拟（如Liquity）"""
        time_steps = []
        prices = []
        
        current_price = start_price
        t = 0
        
        while current_price > self.debt_value * 0.9:  # 最低价格限制
            # 每个keeper的参与概率
            participation_prob = self._keeper_participation_probability(
                current_price, t
            )
            
            if np.random.random() < participation_prob:
                return {
                    'winning_price': current_price,
                    'time_to_clear': t,
                    'keeper_profit': self.collateral_value - current_price
                }
            
            # 价格衰减
            current_price *= (1 - decay_rate)
            t += 1
            
            time_steps.append(t)
            prices.append(current_price)
            
        return {'failed': True, 'final_price': current_price}
                </div>
                
                <h4>实际应用案例：MakerDAO的AutoLine</h4>
                <p>MakerDAO使用自动化系统调整债务上限，这是AI在稳定币治理中的实际应用。</p>
                
                <div class="code-block">
// Solidity实现：自动债务上限调整
contract AutoLine {
    struct CollateralConfig {
        uint256 line;      // 当前债务上限
        uint256 gap;       // 每次增加量
        uint256 ttl;       // 冷却时间
        uint256 last;      // 上次调整时间
        uint256 maxLine;   // 最大上限
    }
    
    mapping(bytes32 => CollateralConfig) public configs;
    
    function exec(bytes32 ilk) external returns (uint256) {
        CollateralConfig memory cfg = configs[ilk];
        
        // 获取当前使用情况
        (uint256 Art, uint256 rate,, uint256 line,) = vat.ilks(ilk);
        uint256 debt = Art * rate;
        
        // 如果使用率超过90%且未达到最大值，增加上限
        if (debt > line * 90 / 100 && line < cfg.maxLine) {
            // 检查冷却时间
            require(block.timestamp > cfg.last + cfg.ttl, "AutoLine/cooldown");
            
            // 增加债务上限
            uint256 newLine = Math.min(line + cfg.gap, cfg.maxLine);
            vat.file(ilk, "line", newLine);
            
            // 更新时间戳
            configs[ilk].last = block.timestamp;
            
            emit LineUpdate(ilk, line, newLine);
            return newLine;
        }
        
        return line;
    }
}
                </div>
            </div>
            
            <div class="practice-section">
                <h3>2.6 实践：分析历史锚定数据与DeFi集成</h3>
                
                <p>通过分析真实的历史数据和DeFi协议集成，深入理解稳定币在实际应用中的表现。</p>
                
                <h4>链上数据分析实战</h4>
                <div class="code-block">
# 使用Python分析稳定币锚定历史
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt

# 稳定币价格偏离分析
class StablecoinAnalyzer:
    def __init__(self):
        self.stablecoins = ['USDT', 'USDC', 'DAI', 'FRAX', 'LUSD']
        
    def calculate_peg_deviation(self, prices):
        """计算锚定偏离度"""
        deviations = abs(prices - 1.0)
        return {
            'mean_deviation': deviations.mean(),
            'max_deviation': deviations.max(),
            'volatility': prices.std(),
            'days_off_peg': (deviations > 0.01).sum()  # 偏离1%的天数
        }
    
    def analyze_depeg_events(self, prices, threshold=0.03):
        """分析脱锚事件"""
        depeg_mask = abs(prices - 1.0) > threshold
        depeg_events = []
        
        i = 0
        while i < len(prices):
            if depeg_mask.iloc[i]:
                start = i
                while i < len(prices) and depeg_mask.iloc[i]:
                    i += 1
                end = i - 1
                
                depeg_events.append({
                    'start_date': prices.index[start],
                    'end_date': prices.index[end],
                    'duration_days': end - start + 1,
                    'max_deviation': abs(prices.iloc[start:end+1] - 1.0).max(),
                    'min_price': prices.iloc[start:end+1].min(),
                    'max_price': prices.iloc[start:end+1].max()
                })
            else:
                i += 1
                
        return depeg_events
    
    def correlation_analysis(self, price_data):
        """分析稳定币之间的相关性"""
        correlations = price_data.corr()
        
        # 危机期间的相关性（2022年5月UST崩盘期间）
        crisis_start = '2022-05-07'
        crisis_end = '2022-05-15'
        crisis_data = price_data[crisis_start:crisis_end]
        crisis_corr = crisis_data.corr()
        
        return {
            'normal_correlation': correlations,
            'crisis_correlation': crisis_corr
        }

# 可视化分析
def plot_stablecoin_comparison(data):
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # 1. 价格历史
    ax1 = axes[0, 0]
    for coin in data.columns:
        ax1.plot(data.index, data[coin], label=coin, alpha=0.7)
    ax1.axhline(y=1.0, color='black', linestyle='--', alpha=0.5)
    ax1.set_title('稳定币价格历史')
    ax1.set_ylabel('价格 (USD)')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # 2. 偏离度分布
    ax2 = axes[0, 1]
    deviations = abs(data - 1.0)
    deviations.plot(kind='box', ax=ax2)
    ax2.set_title('锚定偏离度分布')
    ax2.set_ylabel('偏离度')
    
    # 3. 滚动波动率
    ax3 = axes[1, 0]
    rolling_vol = data.rolling(window=30).std()
    for coin in rolling_vol.columns:
        ax3.plot(rolling_vol.index, rolling_vol[coin], label=coin)
    ax3.set_title('30天滚动波动率')
    ax3.set_ylabel('波动率')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # 4. 脱锚事件统计
    ax4 = axes[1, 1]
    depeg_counts = {}
    for coin in data.columns:
        analyzer = StablecoinAnalyzer()
        events = analyzer.analyze_depeg_events(data[coin])
        depeg_counts[coin] = len(events)
    
    ax4.bar(depeg_counts.keys(), depeg_counts.values())
    ax4.set_title('脱锚事件次数（>3%偏离）')
    ax4.set_ylabel('事件数量')
    
    plt.tight_layout()
    plt.show()

# 风险指标计算
def calculate_risk_metrics(prices):
    """计算稳定币风险指标"""
    metrics = {}
    
    # 1. 最大回撤
    cummax = prices.cummax()
    drawdown = (prices - cummax) / cummax
    metrics['max_drawdown'] = drawdown.min()
    
    # 2. 恢复时间
    recovery_times = []
    for i in range(len(prices)):
        if prices.iloc[i] < 0.99:  # 脱锚
            for j in range(i+1, len(prices)):
                if prices.iloc[j] >= 0.995:  # 恢复
                    recovery_times.append(j - i)
                    break
    
    metrics['avg_recovery_time'] = np.mean(recovery_times) if recovery_times else 0
    
    # 3. 下行风险（仅计算负偏离）
    negative_deviations = prices[prices < 1.0] - 1.0
    metrics['downside_volatility'] = negative_deviations.std()
    
    # 4. 尾部风险（VaR和CVaR）
    returns = prices.pct_change().dropna()
    metrics['var_95'] = np.percentile(returns, 5)
    metrics['cvar_95'] = returns[returns <= metrics['var_95']].mean()
    
    return metrics

# 实时监控示例
class StablecoinMonitor:
    def __init__(self, alert_threshold=0.02):
        self.alert_threshold = alert_threshold
        self.alerts = []
        
    def check_peg(self, current_prices):
        """检查当前锚定状态"""
        for coin, price in current_prices.items():
            deviation = abs(price - 1.0)
            if deviation > self.alert_threshold:
                alert = {
                    'timestamp': datetime.now(),
                    'coin': coin,
                    'price': price,
                    'deviation': deviation,
                    'severity': 'HIGH' if deviation > 0.05 else 'MEDIUM'
                }
                self.alerts.append(alert)
                self.send_alert(alert)
                
    def send_alert(self, alert):
        """发送警报（实际应用中可以接入通知系统）"""
        print(f"⚠️ ALERT: {alert['coin']} at ${alert['price']:.4f} "
              f"({alert['deviation']*100:.2f}% deviation) - {alert['severity']}")
                </div>
                
                <h4>练习题</h4>
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">📝</span>
                        <h5>练习 2.1：深度分析 - 清算机制对比</h5>
                    </div>
                    <p>比较分析MakerDAO、Liquity和crvUSD的清算机制，从以下维度进行评估：</p>
                    <ol>
                        <li>资本效率（最低抵押率）</li>
                        <li>清算过程对市场的影响</li>
                        <li>清算人（Keeper）的激励设计</li>
                        <li>在极端市场条件下的表现</li>
                    </ol>
                    <p>要求：用数学模型量化分析每种机制的优劣，并提出改进建议。</p>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_1')">查看答案</button>
                    <div id="answer2_1" class="answer-content">
                        <h6>清算机制对比分析</h6>
                        
                        <table style="width: 100%; margin: 1rem 0;">
                            <tr>
                                <th style="padding: 0.5rem; background: #f1f5f9;">特性</th>
                                <th style="padding: 0.5rem; background: #f1f5f9;">MakerDAO</th>
                                <th style="padding: 0.5rem; background: #f1f5f9;">Liquity</th>
                                <th style="padding: 0.5rem; background: #f1f5f9;">crvUSD</th>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;"><strong>最低抵押率</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">150%（ETH-A）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">110%</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">~117%（动态）</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;"><strong>清算类型</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">拍卖（Clipper）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">固定折扣</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">连续清算（LLAMMA）</td>
                            </tr>
                            <tr>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;"><strong>市场影响</strong></td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">中等（批量清算）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">高（瞬时清算）</td>
                                <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">低（平滑转换）</td>
                            </tr>
                        </table>
                        
                        <h6>数学分析</h6>
                        
                        <p><strong>1. MakerDAO - 荷兰式拍卖模型：</strong></p>
                        <pre>价格函数: P(t) = P₀ × (1 - λt)
其中：P₀ = 初始价格（市场价×缓冲系数）
     λ = 衰减率
     t = 时间
                        
预期收益: E[R] = ∫₀ᵀ P(t) × f(t) dt
其中：f(t) = keeper参与的概率密度函数</pre>
                        
                        <p><strong>2. Liquity - 固定折扣模型：</strong></p>
                        <pre>清算价格 = 债务价值 × 0.995（0.5%奖励）
稳定池激励 = 200 LUSD（gas补偿）

博弈论分析：
- Nash均衡：所有keeper同时监控
- 最优策略：gas价格优化 + MEV利用</pre>
                        
                        <p><strong>3. crvUSD - LLAMMA连续清算：</strong></p>
                        <pre>价格区间：[p_down, p_up]
AMM函数：x × y = k（在每个band内）

软清算优势量化：
- 滑点减少：~90%（相比硬清算）
- 资本效率提升：~35%（更低的安全边际需求）</pre>
                        
                        <h6>改进建议</h6>
                        <ol>
                            <li><strong>混合机制</strong>：结合LLAMMA的平滑性和Liquity的简单性</li>
                            <li><strong>动态参数</strong>：基于市场波动率自动调整清算参数</li>
                            <li><strong>MEV保护</strong>：使用commit-reveal或批量清算减少抢跑</li>
                            <li><strong>保险基金</strong>：建立协议级保险池吸收极端损失</li>
                        </ol>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">💻</span>
                        <h5>练习 2.2：实现简单的法币抵押稳定币</h5>
                    </div>
                    <p>完成以下合约，实现一个基本的法币抵押稳定币：</p>
                    <div class="code-block">
contract SimpleStablecoin is ERC20, Ownable {
    // TODO: 实现以下功能
    // 1. 添加铸币者管理
    // 2. 实现铸币功能（需要权限控制）
    // 3. 实现销毁功能（任何人可销毁自己的代币）
    // 4. 添加黑名单功能
    // 5. 实现暂停/恢复功能
    // 6. 添加事件日志
}
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_2')">查看答案</button>
                    <div id="answer2_2" class="answer-content">
                        <div class="code-block">
contract SimpleStablecoin is ERC20, Ownable, Pausable {
    // 铸币者管理
    mapping(address => bool) public minters;
    mapping(address => uint256) public mintingAllowance;
    
    // 黑名单
    mapping(address => bool) public blacklisted;
    
    // 事件
    event MinterConfigured(address indexed minter, uint256 allowance);
    event MinterRemoved(address indexed minter);
    event Mint(address indexed minter, address indexed to, uint256 amount);
    event Burn(address indexed burner, uint256 amount);
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    
    // 修饰器
    modifier onlyMinters() {
        require(minters[msg.sender], "Not a minter");
        _;
    }
    
    modifier notBlacklisted(address account) {
        require(!blacklisted[account], "Account is blacklisted");
        _;
    }
    
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    // 铸币者管理
    function configureMinter(address minter, uint256 allowance) external onlyOwner {
        minters[minter] = true;
        mintingAllowance[minter] = allowance;
        emit MinterConfigured(minter, allowance);
    }
    
    function removeMinter(address minter) external onlyOwner {
        minters[minter] = false;
        mintingAllowance[minter] = 0;
        emit MinterRemoved(minter);
    }
    
    // 铸币功能
    function mint(address to, uint256 amount) 
        external 
        onlyMinters 
        whenNotPaused
        notBlacklisted(msg.sender)
        notBlacklisted(to)
        returns (bool) 
    {
        require(to != address(0), "Mint to zero address");
        require(amount > 0, "Amount must be greater than 0");
        require(amount <= mintingAllowance[msg.sender], "Exceeds minting allowance");
        
        mintingAllowance[msg.sender] -= amount;
        _mint(to, amount);
        
        emit Mint(msg.sender, to, amount);
        return true;
    }
    
    // 销毁功能
    function burn(uint256 amount) 
        external 
        whenNotPaused
        notBlacklisted(msg.sender)
    {
        require(amount > 0, "Amount must be greater than 0");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        _burn(msg.sender, amount);
        emit Burn(msg.sender, amount);
    }
    
    // 黑名单管理
    function blacklist(address account) external onlyOwner {
        blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    function unBlacklist(address account) external onlyOwner {
        blacklisted[account] = false;
        emit UnBlacklisted(account);
    }
    
    // 重写transfer函数以检查黑名单
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);
        
        require(!blacklisted[from], "Sender is blacklisted");
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!paused(), "Token transfers are paused");
    }
    
    // 暂停功能（继承自Pausable）
    function pause() external onlyOwner {
        _pause();
    }
    
    function unpause() external onlyOwner {
        _unpause();
    }
}
                        </div>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">🔍</span>
                        <h5>练习 2.3：分析UST崩盘机制</h5>
                    </div>
                    <p>UST使用以下公式维持锚定：</p>
                    <pre>1 UST = $1 worth of LUNA (可相互转换)</pre>
                    <p>假设初始状态：LUNA价格$60，UST供应量100亿，LUNA供应量5亿</p>
                    <p>问题：</p>
                    <ol>
                        <li>如果有20亿UST被赎回成LUNA，LUNA供应量会增加多少？</li>
                        <li>假设市场只能吸收10%的新增LUNA供应而不影响价格，实际LUNA价格会跌到多少？</li>
                        <li>在新价格下，剩余80亿UST的抵押品价值是多少？</li>
                        <li>这会引发什么连锁反应？</li>
                    </ol>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_3')">查看答案</button>
                    <div id="answer2_3" class="answer-content">
                        <ol>
                            <li><strong>LUNA供应量增加计算：</strong>
                                <ul>
                                    <li>20亿UST ÷ $60/LUNA = 3333万LUNA</li>
                                    <li>新LUNA供应量 = 5亿 + 0.33亿 = 5.33亿</li>
                                    <li>供应量增加了6.67%</li>
                                </ul>
                            </li>
                            <li><strong>价格影响分析：</strong>
                                <ul>
                                    <li>如果市场深度只能吸收10%的新供应</li>
                                    <li>实际抛压 = 90% × 3333万 = 3000万LUNA</li>
                                    <li>假设价格弹性为-2（供应增1%，价格跌2%）</li>
                                    <li>价格跌幅 = 6% × 2 = 12%</li>
                                    <li>新LUNA价格 ≈ $60 × 0.88 = $52.8</li>
                                </ul>
                            </li>
                            <li><strong>抵押品价值：</strong>
                                <ul>
                                    <li>LUNA总市值 = 5.33亿 × $52.8 = 281亿美元</li>
                                    <li>UST市值需求 = 80亿美元</li>
                                    <li>理论上足够，但信心已受损</li>
                                </ul>
                            </li>
                            <li><strong>死亡螺旋：</strong>
                                <ul>
                                    <li>价格下跌→更多UST持有者恐慌赎回</li>
                                    <li>更多赎回→更多LUNA增发→价格进一步下跌</li>
                                    <li>Anchor协议挤兑加速UST抛售</li>
                                    <li>LUNA价格崩溃→UST完全失去支撑</li>
                                    <li>最终：LUNA接近归零，UST严重脱锚</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>关键教训：</strong>纯算法稳定币在极端市场条件下极其脆弱，死亡螺旋一旦开始很难停止。</p>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-header">
                        <span class="exercise-icon">⚡</span>
                        <h5>练习 2.4：设计改进的稳定币机制</h5>
                    </div>
                    <p>基于本章学习的内容，设计一个结合多种机制优点的新型稳定币。要求：</p>
                    <ol>
                        <li>描述核心稳定机制</li>
                        <li>说明如何避免死亡螺旋</li>
                        <li>设计应急机制</li>
                        <li>考虑监管合规</li>
                    </ol>
                    <button class="answer-toggle" onclick="toggleAnswer('answer2_4')">查看答案</button>
                    <div id="answer2_4" class="answer-content">
                        <h5>混合稳定币设计方案</h5>
                        
                        <h6>1. 核心稳定机制（三层防御）</h6>
                        <ul>
                            <li><strong>第一层：部分法币储备（40%）</strong>
                                <ul>
                                    <li>USDC/美国国债作为硬底</li>
                                    <li>提供基础信心和流动性</li>
                                </ul>
                            </li>
                            <li><strong>第二层：加密资产超额抵押（40%）</strong>
                                <ul>
                                    <li>ETH/BTC等主流资产</li>
                                    <li>150%最低抵押率</li>
                                    <li>软清算机制（类似crvUSD）</li>
                                </ul>
                            </li>
                            <li><strong>第三层：算法调节（20%）</strong>
                                <ul>
                                    <li>协议控制的资金（PCV）</li>
                                    <li>动态调节供应量</li>
                                    <li>但不超过总供应的20%</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h6>2. 避免死亡螺旋的机制</h6>
                        <ul>
                            <li><strong>熔断机制</strong>：24小时内赎回量超过10%时暂停大额赎回</li>
                            <li><strong>时间锁</strong>：大额赎回需要7天等待期</li>
                            <li><strong>费率调节</strong>：市场压力时提高赎回费用（最高5%）</li>
                            <li><strong>储备比率下限</strong>：法币储备不得低于30%</li>
                        </ul>
                        
                        <h6>3. 应急机制</h6>
                        <ul>
                            <li><strong>保险基金</strong>：协议收入的50%进入保险基金</li>
                            <li><strong>紧急暂停</strong>：多签控制的紧急暂停功能</li>
                            <li><strong>渐进式清算</strong>：避免大规模同时清算</li>
                            <li><strong>备用稳定模块（BSM）</strong>：
                                <pre>如果价格 < $0.95：激活1:1 USDC兑换（有限额）
如果价格 > $1.05：激活1:1 USDC铸造（有限额）</pre>
                            </li>
                        </ul>
                        
                        <h6>4. 监管合规设计</h6>
                        <ul>
                            <li><strong>可选KYC层</strong>：
                                <ul>
                                    <li>基础功能无需KYC（DeFi友好）</li>
                                    <li>大额交易和法币出入金需要KYC</li>
                                </ul>
                            </li>
                            <li><strong>透明度</strong>：
                                <ul>
                                    <li>实时链上储备证明</li>
                                    <li>月度第三方审计</li>
                                </ul>
                            </li>
                            <li><strong>管辖权考虑</strong>：
                                <ul>
                                    <li>基金会设立在瑞士/新加坡</li>
                                    <li>遵守当地稳定币法规</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h6>实现草图</h6>
                        <div class="code-block">
contract HybridStablecoin {
    // 储备类型
    struct Reserve {
        uint256 fiatBacked;      // USDC等
        uint256 cryptoBacked;    // ETH等的美元价值
        uint256 algorithmic;     // 协议控制价值
    }
    
    // 稳定机制
    function mint(uint256 amount, uint256 collateralType) external {
        if (collateralType == FIAT) {
            // 1:1 铸造
            require(USDC.transferFrom(msg.sender, reserves, amount));
        } else if (collateralType == CRYPTO) {
            // 超额抵押铸造
            uint256 requiredCollateral = amount * 150 / 100;
            // ... 抵押逻辑
        } else {
            // 算法铸造（有限额）
            require(algorithmicSupply + amount <= maxAlgorithmicSupply);
            // ... 算法逻辑
        }
    }
    
    // 紧急机制
    function emergencyPause() external onlyGuardian {
        require(getPrice() < 0.90 || systemHealthScore() < 50);
        _pause();
        emit EmergencyPauseActivated();
    }
}
                        </div>
                    </div>
                </div>
                
                <h3>本章小结</h3>
                <div class="tip">
                    <strong>关键要点：</strong>
                    <ul>
                        <li><strong>法币抵押型</strong>：最稳定但中心化，适合大额交易和合规需求</li>
                        <li><strong>加密抵押型</strong>：去中心化但资本效率低，是DeFi的基石</li>
                        <li><strong>算法稳定币</strong>：资本效率高但风险大，纯算法模式已被证明不可行</li>
                        <li><strong>混合模型</strong>：结合多种机制，是未来发展方向</li>
                        <li><strong>风险意识</strong>：每种模型都有其特定风险，没有完美的稳定币</li>
                    </ul>
                </div>
                
                <h3>术语速查</h3>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">术语</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">英文</th>
                        <th style="text-align: left; padding: 0.5rem; background: #f1f5f9;">含义</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">锚定</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Peg</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">稳定币维持1:1美元价值</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">铸造/销毁</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Mint/Burn</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">创建/销毁稳定币的过程</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押率</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Collateral Ratio</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押品价值/债务价值</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">清算</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Liquidation</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">抵押不足时强制平仓</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">死亡螺旋</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Death Spiral</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">价格下跌引发的恶性循环</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">软清算</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">Soft Liquidation</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">渐进式清算，减少市场冲击</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">协议控制价值</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">PCV</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">协议直接拥有的资产</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">算法市场操作</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">AMO</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">协议自动化市场干预</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- 第三章：ERC-20标准与扩展 -->
        <div class="chapter" id="chapter3">
            <h2>第三章：ERC-20标准与扩展</h2>
            
            <div class="intro-box">
                <strong>本章概览：</strong>
                <ul>
                    <li>深入理解ERC-20标准及其在稳定币中的应用</li>
                    <li>探索代理模式和可升级合约架构</li>
                    <li>跨链标准与互操作性解决方案</li>
                    <li>实战：构建企业级可升级稳定币</li>
                </ul>
            </div>

            <h3>3.1 标准代币接口深度解析</h3>
            
            <h4>3.1.1 ERC-20标准的演进历程</h4>
            <p>ERC-20标准诞生于2015年11月，由Fabian Vogelsteller提出，成为以太坊生态系统中最成功的标准之一。让我们深入了解其技术细节和在稳定币中的特殊应用。</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">基础ERC-20接口定义 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    // 查询代币总供应量
    function totalSupply() external view returns (uint256);
    
    // 查询账户余额
    function balanceOf(address account) external view returns (uint256);
    
    // 转账函数
    function transfer(address to, uint256 amount) external returns (bool);
    
    // 查询授权额度
    function allowance(address owner, address spender) external view returns (uint256);
    
    // 授权函数
    function approve(address spender, uint256 amount) external returns (bool);
    
    // 授权转账
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    
    // 事件定义
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.2 稳定币特有的扩展功能</h4>
            <p>稳定币在实现ERC-20标准的基础上，通常需要添加额外的功能以满足合规和运营需求：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">稳定币扩展功能实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract StablecoinBase is ERC20, Pausable, AccessControl {
    // 角色定义
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");
    
    // 黑名单映射
    mapping(address => bool) private _blacklisted;
    
    // 铸币限额管理
    mapping(address => uint256) private _minterAllowances;
    
    // 事件
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    event MinterConfigured(address indexed minter, uint256 allowance);
    event MinterRemoved(address indexed minter);
    
    // 修饰器：检查黑名单
    modifier notBlacklisted(address account) {
        require(!_blacklisted[account], "Account is blacklisted");
        _;
    }
    
    // 铸币功能（带限额控制）
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE) 
        whenNotPaused 
        notBlacklisted(to) 
    {
        require(amount <= _minterAllowances[msg.sender], "Exceeds minter allowance");
        _minterAllowances[msg.sender] -= amount;
        _mint(to, amount);
    }
    
    // 销毁功能
    function burn(uint256 amount) external whenNotPaused {
        _burn(msg.sender, amount);
    }
    
    // 黑名单管理
    function blacklist(address account) external onlyRole(BLACKLISTER_ROLE) {
        _blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    // 重写transfer以检查黑名单
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);
        require(!_blacklisted[from] && !_blacklisted[to], "Blacklisted address");
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.3 ERC-2612 Permit扩展</h4>
            <p>ERC-2612允许用户通过签名授权代币转移，无需预先的approve交易，极大改善了用户体验：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">ERC-2612 Permit实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract ERC20Permit is ERC20, IERC20Permit {
    using ECDSA for bytes32;
    
    bytes32 public constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );
    
    mapping(address => uint256) public nonces;
    
    // EIP-712 Domain
    bytes32 private immutable DOMAIN_SEPARATOR;
    
    constructor() {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes(name())),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );
    }
    
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
        
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                owner,
                spender,
                value,
                nonces[owner]++,
                deadline
            )
        );
        
        bytes32 hash = keccak256(
            abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash)
        );
        
        address signer = hash.recover(v, r, s);
        require(signer == owner, "ERC20Permit: invalid signature");
        
        _approve(owner, spender, value);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.4 Gas优化技巧</h4>
            <p>稳定币通常有高频交易需求，Gas优化至关重要：</p>
            
            <div class="tip">
                💡 关键洞察：通过批量操作和存储优化，可以将Gas消耗降低30-50%。2024年新增的瞬时存储（EIP-1153）可进一步优化复杂交易流。
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Gas优化实现示例 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract GasOptimizedStablecoin is StablecoinBase {
    // 使用packed结构体减少存储槽
    struct UserInfo {
        uint128 balance;      // 足够存储大部分余额
        uint64 lastTransfer;  // 时间戳
        bool isBlacklisted;   // 黑名单状态
        bool isWhitelisted;   // 白名单状态（免Gas费）
    }
    
    mapping(address => UserInfo) private _userInfo;
    
    // 批量转账（节省基础Gas开销）
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused {
        require(recipients.length == amounts.length, "Length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount;
        for (uint256 i = 0; i < amounts.length; ) {
            totalAmount += amounts[i];
            unchecked { ++i; }
        }
        
        require(_userInfo[msg.sender].balance >= totalAmount, "Insufficient balance");
        
        // 使用unchecked节省溢出检查Gas
        unchecked {
            _userInfo[msg.sender].balance -= uint128(totalAmount);
        }
        
        for (uint256 i = 0; i < recipients.length; ) {
            _userInfo[recipients[i]].balance += uint128(amounts[i]);
            emit Transfer(msg.sender, recipients[i], amounts[i]);
            unchecked { ++i; }
        }
    }
    
    // 使用assembly优化的余额查询
    function balanceOf(address account) public view returns (uint256 balance) {
        assembly {
            // 直接读取存储槽
            let slot := _userInfo.slot
            let key := account
            mstore(0x00, key)
            mstore(0x20, slot)
            let location := keccak256(0x00, 0x40)
            balance := shr(128, sload(location))
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>3.2 可升级模式深度实践</h3>
            
            <h4>3.2.1 代理模式对比分析</h4>
            <p>稳定币合约的可升级性是一个关键特性，让我们深入比较不同的升级模式：</p>
            
            <table class="comparison-table">
                <tr>
                    <th>升级模式</th>
                    <th>Gas成本</th>
                    <th>复杂度</th>
                    <th>存储冲突风险</th>
                    <th>适用场景</th>
                </tr>
                <tr>
                    <td>透明代理（Transparent Proxy）</td>
                    <td>~2300 Gas额外开销</td>
                    <td>中等</td>
                    <td>低</td>
                    <td>USDC、USDT等主流稳定币</td>
                </tr>
                <tr>
                    <td>UUPS（Universal Upgradeable Proxy）</td>
                    <td>~1000 Gas额外开销</td>
                    <td>高</td>
                    <td>中</td>
                    <td>Gas敏感的DeFi协议</td>
                </tr>
                <tr>
                    <td>钻石标准（Diamond/EIP-2535）</td>
                    <td>~2500 Gas额外开销</td>
                    <td>很高</td>
                    <td>很低</td>
                    <td>复杂的模块化系统</td>
                </tr>
                <tr>
                    <td>Beacon代理</td>
                    <td>~2100 Gas额外开销</td>
                    <td>中等</td>
                    <td>低</td>
                    <td>多实例部署场景</td>
                </tr>
            </table>
            
            <h4>3.2.2 UUPS模式实现</h4>
            <p>UUPS模式将升级逻辑放在实现合约中，提供更好的Gas效率：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">UUPS可升级稳定币实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 使用OpenZeppelin的UUPS实现
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract StablecoinV1 is 
    Initializable,
    ERC20Upgradeable,
    PausableUpgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable 
{
    // 存储布局版本控制
    uint256 private constant STORAGE_VERSION = 1;
    
    // 状态变量（注意顺序很重要）
    mapping(address => bool) public blacklisted;
    mapping(address => uint256) public minterAllowance;
    address[] public minters;
    
    // 初始化函数（代替构造函数）
    function initialize(
        string memory name,
        string memory symbol
    ) public initializer {
        __ERC20_init(name, symbol);
        __Pausable_init();
        __Ownable_init();
        __UUPSUpgradeable_init();
    }
    
    // 升级授权（只有owner可以升级）
    function _authorizeUpgrade(address newImplementation)
        internal
        onlyOwner
        override
    {}
    
    // 获取实现版本
    function version() external pure returns (string memory) {
        return "1.0.0";
    }
}

// V2版本示例（添加新功能）
contract StablecoinV2 is StablecoinV1 {
    // 新增状态变量（只能在最后添加）
    mapping(address => uint256) public dailyTransferLimit;
    mapping(address => uint256) public dailyTransferAmount;
    mapping(address => uint256) public lastTransferDay;
    
    // 新增功能：每日转账限额
    function setDailyLimit(address user, uint256 limit) external onlyOwner {
        dailyTransferLimit[user] = limit;
    }
    
    // 重写transfer以实现限额检查
    function transfer(address to, uint256 amount) 
        public 
        override 
        returns (bool) 
    {
        _checkDailyLimit(msg.sender, amount);
        return super.transfer(to, amount);
    }
    
    function _checkDailyLimit(address user, uint256 amount) private {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTransferDay[user] < today) {
            dailyTransferAmount[user] = 0;
            lastTransferDay[user] = today;
        }
        
        require(
            dailyTransferAmount[user] + amount <= dailyTransferLimit[user],
            "Daily limit exceeded"
        );
        
        dailyTransferAmount[user] += amount;
    }
    
    function version() external pure override returns (string memory) {
        return "2.0.0";
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.2.3 存储冲突防护</h4>
            <p>升级合约时最大的风险是存储冲突，这里是防护措施：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">存储间隙模式（Storage Gap） <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract StablecoinStorageV1 {
    // 状态变量
    mapping(address => uint256) internal _balances;
    mapping(address => mapping(address => uint256)) internal _allowances;
    uint256 internal _totalSupply;
    
    // 存储间隙：预留升级空间
    uint256[47] private __gap;  // 50 - 3 = 47
}

abstract contract StablecoinStorageV2 is StablecoinStorageV1 {
    // 新增状态变量
    mapping(address => bool) internal _frozen;
    uint256 internal _maxSupply;
    
    // 更新存储间隙
    uint256[45] private __gap;  // 47 - 2 = 45
}

// 使用非结构化存储（Unstructured Storage）
contract DiamondStorage {
    struct DiamondStorageStruct {
        mapping(address => uint256) balances;
        mapping(address => bool) blacklisted;
        uint256 totalSupply;
        address admin;
    }
    
    function diamondStorage() 
        internal 
        pure 
        returns (DiamondStorageStruct storage ds) 
    {
        bytes32 position = keccak256("diamond.standard.diamond.storage");
        assembly {
            ds.slot := position
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>3.3 跨链标准与实现</h3>
            
            <h4>3.3.1 主流跨链协议对比</h4>
            <p>稳定币的跨链需求日益增长，让我们深入了解各种跨链解决方案：</p>
            
            <table class="comparison-table">
                <tr>
                    <th>跨链协议</th>
                    <th>安全模型</th>
                    <th>延迟</th>
                    <th>支持链数</th>
                    <th>去中心化程度</th>
                </tr>
                <tr>
                    <td>LayerZero</td>
                    <td>Oracle + Relayer</td>
                    <td>几分钟</td>
                    <td>40+</td>
                    <td>中等</td>
                </tr>
                <tr>
                    <td>Axelar</td>
                    <td>PoS验证者集</td>
                    <td>5-30分钟</td>
                    <td>30+</td>
                    <td>高</td>
                </tr>
                <tr>
                    <td>Wormhole</td>
                    <td>Guardian网络</td>
                    <td>几分钟</td>
                    <td>20+</td>
                    <td>中等</td>
                </tr>
                <tr>
                    <td>IBC (Cosmos)</td>
                    <td>轻客户端</td>
                    <td>几秒</td>
                    <td>50+ (Cosmos生态)</td>
                    <td>很高</td>
                </tr>
            </table>
            
            <h4>3.3.2 LayerZero集成实现</h4>
            <p>LayerZero提供了灵活的跨链消息传递，适合稳定币的全链部署：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">LayerZero OFT稳定币实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">import "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTV2.sol";

contract OmniChainStablecoin is OFTV2, Pausable {
    // 链ID到地址的映射（用于限额管理）
    mapping(uint16 => address) public trustedRemotes;
    
    // 每条链的铸币限额
    mapping(uint16 => uint256) public chainMintLimit;
    mapping(uint16 => uint256) public chainMintAmount;
    
    // 跨链转账费用（基点）
    uint256 public bridgeFee = 10; // 0.1%
    address public feeCollector;
    
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address _lzEndpoint
    ) OFTV2(_name, _symbol, _decimals, _lzEndpoint) {
        feeCollector = msg.sender;
    }
    
    // 设置可信远程合约
    function setTrustedRemote(
        uint16 _chainId,
        bytes calldata _path
    ) external onlyOwner {
        trustedRemotes[_chainId] = address(bytes20(_path));
        trustedRemote[_chainId] = _path;
    }
    
    // 重写发送函数以实现费用收取
    function _send(
        address _from,
        uint16 _dstChainId,
        bytes32 _toAddress,
        uint256 _amount,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes memory _adapterParams
    ) internal override returns (uint256 amount) {
        // 计算并收取跨链费用
        uint256 fee = (_amount * bridgeFee) / 10000;
        uint256 amountAfterFee = _amount - fee;
        
        if (fee > 0) {
            _transfer(_from, feeCollector, fee);
        }
        
        // 检查目标链限额
        require(
            chainMintAmount[_dstChainId] + amountAfterFee <= chainMintLimit[_dstChainId],
            "Chain mint limit exceeded"
        );
        
        chainMintAmount[_dstChainId] += amountAfterFee;
        
        return super._send(
            _from,
            _dstChainId,
            _toAddress,
            amountAfterFee,
            _refundAddress,
            _zroPaymentAddress,
            _adapterParams
        );
    }
    
    // 估算跨链费用
    function estimateSendFee(
        uint16 _dstChainId,
        bytes32 _toAddress,
        uint256 _amount,
        bool _useZro,
        bytes calldata _adapterParams
    ) public view override returns (uint256 nativeFee, uint256 zroFee) {
        uint256 amountAfterFee = _amount - (_amount * bridgeFee) / 10000;
        return super.estimateSendFee(
            _dstChainId,
            _toAddress,
            amountAfterFee,
            _useZro,
            _adapterParams
        );
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.3.3 IBC协议集成（Cosmos生态）</h4>
            <p>IBC提供了最去中心化的跨链解决方案，特别适合Cosmos生态：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">CosmWasm IBC稳定币合约 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-rust">use cosmwasm_std::{
    entry_point, to_binary, Binary, Deps, DepsMut, 
    Env, MessageInfo, Response, StdResult, Uint128,
    IbcMsg, IbcTimeout, CosmosMsg,
};
use cw20::{Cw20Contract, Cw20ExecuteMsg};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IbcTransferMsg {
    pub channel_id: String,
    pub to_address: String,
    pub amount: Uint128,
    pub timeout: IbcTimeout,
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::IbcTransfer(transfer_msg) => {
            execute_ibc_transfer(deps, env, info, transfer_msg)
        }
        _ => handle_cw20_execute(deps, env, info, msg),
    }
}

fn execute_ibc_transfer(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: IbcTransferMsg,
) -> Result<Response, ContractError> {
    // 检查余额
    let balance = BALANCES.load(deps.storage, &info.sender)?;
    if balance < msg.amount {
        return Err(ContractError::InsufficientFunds {});
    }
    
    // 扣除余额
    BALANCES.update(
        deps.storage,
        &info.sender,
        |balance| -> StdResult<_> {
            Ok(balance.unwrap_or_default() - msg.amount)
        },
    )?;
    
    // 构建IBC消息
    let ibc_msg = IbcMsg::Transfer {
        channel_id: msg.channel_id,
        to_address: msg.to_address,
        amount: coin(msg.amount.u128(), "ustable"),
        timeout: msg.timeout,
    };
    
    Ok(Response::new()
        .add_message(ibc_msg)
        .add_attribute("action", "ibc_transfer")
        .add_attribute("from", info.sender)
        .add_attribute("amount", msg.amount))
}

// IBC包接收处理
#[entry_point]
pub fn ibc_packet_receive(
    deps: DepsMut,
    _env: Env,
    msg: IbcPacketReceiveMsg,
) -> Result<IbcReceiveResponse, Never> {
    // 解析接收的数据
    let packet: TransferPacket = from_slice(&msg.packet.data)?;
    
    // 铸造代币给接收者
    BALANCES.update(
        deps.storage,
        &packet.receiver,
        |balance| -> StdResult<_> {
            Ok(balance.unwrap_or_default() + packet.amount)
        },
    )?;
    
    Ok(IbcReceiveResponse::new()
        .set_ack(to_binary(&TransferAck::Success)?)
        .add_attribute("action", "receive")
        .add_attribute("receiver", packet.receiver)
        .add_attribute("amount", packet.amount))
}</code></pre>
                </div>
            </div>
            
            <h3>3.4 实践项目：构建企业级可升级稳定币</h3>
            
            <h4>3.4.1 项目需求分析</h4>
            <p>我们将构建一个具备以下特性的企业级稳定币：</p>
            <ul>
                <li>符合监管要求的KYC/AML功能</li>
                <li>可升级架构，支持功能迭代</li>
                <li>多链部署，支持主流公链</li>
                <li>完善的权限管理系统</li>
                <li>紧急暂停和恢复机制</li>
            </ul>
            
            <h4>3.4.2 完整实现</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">企业级稳定币完整实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract EnterpriseStablecoin is 
    Initializable,
    ERC20Upgradeable,
    PausableUpgradeable,
    AccessControlUpgradeable,
    UUPSUpgradeable 
{
    using ECDSA for bytes32;
    
    // 角色定义
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");
    bytes32 public constant KYC_ROLE = keccak256("KYC_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    
    // 状态变量
    mapping(address => bool) public blacklisted;
    mapping(address => bool) public kycApproved;
    mapping(address => uint256) public minterAllowance;
    mapping(address => uint256) public lastActivity;
    
    // 交易限制
    uint256 public maxTransactionAmount;
    uint256 public dailyTransferLimit;
    mapping(address => uint256) public dailyTransferred;
    mapping(address => uint256) public lastTransferDay;
    
    // 合规功能
    bool public kycRequired;
    uint256 public inactivityThreshold;
    
    // 签名nonce（防重放）
    mapping(address => uint256) public nonces;
    
    // 事件
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    event KYCApproved(address indexed account);
    event KYCRevoked(address indexed account);
    event ComplianceConfigUpdated(bool kycRequired, uint256 inactivityThreshold);
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(
        string memory name,
        string memory symbol,
        bool _kycRequired
    ) public initializer {
        __ERC20_init(name, symbol);
        __Pausable_init();
        __AccessControl_init();
        __UUPSUpgradeable_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, msg.sender);
        
        kycRequired = _kycRequired;
        maxTransactionAmount = 1000000 * 10**decimals(); // 1M默认限额
        dailyTransferLimit = 5000000 * 10**decimals();   // 5M每日限额
        inactivityThreshold = 365 days;                  // 1年不活跃阈值
    }
    
    // 铸币功能
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE)
        whenNotPaused 
    {
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!kycRequired || kycApproved[to], "KYC not approved");
        require(amount <= minterAllowance[msg.sender], "Exceeds allowance");
        
        minterAllowance[msg.sender] -= amount;
        _mint(to, amount);
        lastActivity[to] = block.timestamp;
    }
    
    // 带签名的铸币（链下授权）
    function mintWithSignature(
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external whenNotPaused {
        require(block.timestamp <= deadline, "Signature expired");
        
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Mint(address to,uint256 amount,uint256 nonce,uint256 deadline)"),
                to,
                amount,
                nonces[to]++,
                deadline
            )
        );
        
        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = hash.recover(v, r, s);
        
        require(hasRole(MINTER_ROLE, signer), "Invalid signer");
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!kycRequired || kycApproved[to], "KYC not approved");
        
        _mint(to, amount);
        lastActivity[to] = block.timestamp;
    }
    
    // 重写transfer函数
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(!blacklisted[from] && !blacklisted[to], "Blacklisted address");
        require(!kycRequired || (kycApproved[from] && kycApproved[to]), "KYC required");
        require(amount <= maxTransactionAmount, "Exceeds max transaction");
        
        // 检查每日限额
        _checkDailyLimit(from, amount);
        
        super._transfer(from, to, amount);
        
        // 更新活动时间
        lastActivity[from] = block.timestamp;
        lastActivity[to] = block.timestamp;
    }
    
    // 每日限额检查
    function _checkDailyLimit(address user, uint256 amount) private {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTransferDay[user] < today) {
            dailyTransferred[user] = 0;
            lastTransferDay[user] = today;
        }
        
        require(
            dailyTransferred[user] + amount <= dailyTransferLimit,
            "Daily limit exceeded"
        );
        
        dailyTransferred[user] += amount;
    }
    
    // 冻结不活跃账户的资金
    function freezeInactiveAccount(address account) 
        external 
        onlyRole(BLACKLISTER_ROLE) 
    {
        require(
            block.timestamp - lastActivity[account] > inactivityThreshold,
            "Account still active"
        );
        blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    // 批量KYC审批
    function batchApproveKYC(address[] calldata accounts) 
        external 
        onlyRole(KYC_ROLE) 
    {
        for (uint256 i = 0; i < accounts.length; i++) {
            kycApproved[accounts[i]] = true;
            emit KYCApproved(accounts[i]);
        }
    }
    
    // 紧急提取（仅限被黑名单地址）
    function emergencyWithdraw(address blacklistedAccount, address to) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(blacklisted[blacklistedAccount], "Account not blacklisted");
        uint256 amount = balanceOf(blacklistedAccount);
        _burn(blacklistedAccount, amount);
        _mint(to, amount);
    }
    
    // 升级授权
    function _authorizeUpgrade(address newImplementation)
        internal
        onlyRole(UPGRADER_ROLE)
        override
    {}
    
    // 暂停功能
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }
    
    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }
    
    // 获取版本
    function version() external pure returns (string memory) {
        return "1.0.0";
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.4.3 部署和测试脚本</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Hardhat部署和测试脚本 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-javascript">// deploy/01_deploy_stablecoin.js
const { ethers, upgrades } = require("hardhat");

module.exports = async ({ getNamedAccounts, deployments }) => {
    const { deploy } = deployments;
    const { deployer } = await getNamedAccounts();
    
    // 部署实现合约
    const EnterpriseStablecoin = await ethers.getContractFactory(
        "EnterpriseStablecoin"
    );
    
    const proxy = await upgrades.deployProxy(
        EnterpriseStablecoin,
        ["USD Stablecoin", "USDS", true], // 启用KYC
        { 
            initializer: "initialize",
            kind: "uups" 
        }
    );
    
    await proxy.deployed();
    console.log("Proxy deployed to:", proxy.address);
    
    // 获取实现地址
    const implementationAddress = await upgrades.erc1967.getImplementationAddress(
        proxy.address
    );
    console.log("Implementation deployed to:", implementationAddress);
    
    // 配置角色
    const MINTER_ROLE = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes("MINTER_ROLE")
    );
    const KYC_ROLE = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes("KYC_ROLE")
    );
    
    // 设置铸币者
    await proxy.grantRole(MINTER_ROLE, deployer);
    await proxy.setMinterAllowance(deployer, ethers.utils.parseUnits("1000000", 6));
    
    // 保存部署信息
    deployments.save("EnterpriseStablecoin", {
        address: proxy.address,
        implementation: implementationAddress,
        abi: EnterpriseStablecoin.interface.format("json"),
    });
};

// test/EnterpriseStablecoin.test.js
const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");

describe("EnterpriseStablecoin", function () {
    let stablecoin;
    let owner, minter, user1, user2, blacklister;
    let MINTER_ROLE, BLACKLISTER_ROLE, KYC_ROLE;
    
    beforeEach(async function () {
        [owner, minter, user1, user2, blacklister] = await ethers.getSigners();
        
        const EnterpriseStablecoin = await ethers.getContractFactory(
            "EnterpriseStablecoin"
        );
        stablecoin = await upgrades.deployProxy(
            EnterpriseStablecoin,
            ["Test USD", "TUSD", true],
            { kind: "uups" }
        );
        
        // 获取角色常量
        MINTER_ROLE = await stablecoin.MINTER_ROLE();
        BLACKLISTER_ROLE = await stablecoin.BLACKLISTER_ROLE();
        KYC_ROLE = await stablecoin.KYC_ROLE();
        
        // 配置角色
        await stablecoin.grantRole(MINTER_ROLE, minter.address);
        await stablecoin.grantRole(BLACKLISTER_ROLE, blacklister.address);
        await stablecoin.grantRole(KYC_ROLE, owner.address);
    });
    
    describe("KYC功能", function () {
        it("未通过KYC不能接收代币", async function () {
            await stablecoin.setMinterAllowance(
                minter.address, 
                ethers.utils.parseUnits("1000", 6)
            );
            
            await expect(
                stablecoin.connect(minter).mint(
                    user1.address, 
                    ethers.utils.parseUnits("100", 6)
                )
            ).to.be.revertedWith("KYC not approved");
        });
        
        it("通过KYC后可以正常交易", async function () {
            // 批准KYC
            await stablecoin.batchApproveKYC([user1.address, user2.address]);
            
            // 设置铸币额度
            await stablecoin.setMinterAllowance(
                minter.address, 
                ethers.utils.parseUnits("1000", 6)
            );
            
            // 铸币
            await stablecoin.connect(minter).mint(
                user1.address, 
                ethers.utils.parseUnits("100", 6)
            );
            
            // 转账
            await stablecoin.connect(user1).transfer(
                user2.address, 
                ethers.utils.parseUnits("50", 6)
            );
            
            expect(await stablecoin.balanceOf(user2.address))
                .to.equal(ethers.utils.parseUnits("50", 6));
        });
    });
    
    describe("升级功能", function () {
        it("可以升级到新版本", async function () {
            const EnterpriseStablecoinV2 = await ethers.getContractFactory(
                "EnterpriseStablecoinV2"
            );
            
            const upgraded = await upgrades.upgradeProxy(
                stablecoin.address,
                EnterpriseStablecoinV2
            );
            
            expect(await upgraded.version()).to.equal("2.0.0");
        });
    });
});</code></pre>
                </div>
            </div>
            
            <h3>练习题</h3>
            
            <div class="exercise">
                <h4>练习 3.1：ERC-20扩展实现</h4>
                <p>实现一个支持以下功能的ERC-20扩展：</p>
                <ul>
                    <li>批量转账功能（单笔交易中向多个地址转账）</li>
                    <li>转账备注功能（在链上记录转账备注信息）</li>
                    <li>定时锁定功能（代币在指定时间后才能转移）</li>
                </ul>
                <p>要求：Gas优化，支持紧急暂停。</p>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract ExtendedERC20 is ERC20, Pausable, Ownable {
    // 转账备注
    mapping(bytes32 => string) public transferNotes;
    
    // 时间锁
    struct TimeLock {
        uint256 amount;
        uint256 releaseTime;
    }
    mapping(address => TimeLock[]) public timeLocks;
    
    // 事件
    event TransferWithNote(address indexed from, address indexed to, uint256 value, string note);
    event TokensLocked(address indexed account, uint256 amount, uint256 releaseTime);
    event TokensUnlocked(address indexed account, uint256 amount);
    
    // 批量转账
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused returns (bool) {
        require(recipients.length == amounts.length, "Length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount;
        for (uint256 i = 0; i < amounts.length; ) {
            totalAmount += amounts[i];
            unchecked { ++i; }
        }
        
        require(balanceOf(msg.sender) >= totalAmount, "Insufficient balance");
        
        for (uint256 i = 0; i < recipients.length; ) {
            _transfer(msg.sender, recipients[i], amounts[i]);
            unchecked { ++i; }
        }
        
        return true;
    }
    
    // 带备注的转账
    function transferWithNote(
        address to,
        uint256 amount,
        string calldata note
    ) external whenNotPaused returns (bool) {
        _transfer(msg.sender, to, amount);
        
        bytes32 txHash = keccak256(
            abi.encodePacked(msg.sender, to, amount, block.timestamp)
        );
        transferNotes[txHash] = note;
        
        emit TransferWithNote(msg.sender, to, amount, note);
        return true;
    }
    
    // 锁定代币
    function lockTokens(uint256 amount, uint256 lockDuration) external {
        require(amount > 0, "Amount must be positive");
        require(lockDuration > 0, "Duration must be positive");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        _transfer(msg.sender, address(this), amount);
        
        timeLocks[msg.sender].push(TimeLock({
            amount: amount,
            releaseTime: block.timestamp + lockDuration
        }));
        
        emit TokensLocked(msg.sender, amount, block.timestamp + lockDuration);
    }
    
    // 解锁代币
    function unlockTokens() external {
        TimeLock[] storage locks = timeLocks[msg.sender];
        uint256 totalUnlocked;
        
        for (uint256 i = 0; i < locks.length; ) {
            if (locks[i].releaseTime <= block.timestamp && locks[i].amount > 0) {
                totalUnlocked += locks[i].amount;
                locks[i].amount = 0;
            }
            unchecked { ++i; }
        }
        
        require(totalUnlocked > 0, "No tokens to unlock");
        _transfer(address(this), msg.sender, totalUnlocked);
        
        emit TokensUnlocked(msg.sender, totalUnlocked);
    }
    
    // 查询锁定的代币
    function getLockedBalance(address account) external view returns (uint256) {
        TimeLock[] memory locks = timeLocks[account];
        uint256 locked;
        
        for (uint256 i = 0; i < locks.length; i++) {
            if (locks[i].releaseTime > block.timestamp) {
                locked += locks[i].amount;
            }
        }
        
        return locked;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>练习 3.2：跨链桥实现</h4>
                <p>设计并实现一个简化的跨链桥，支持：</p>
                <ul>
                    <li>在源链锁定代币</li>
                    <li>在目标链铸造包装代币</li>
                    <li>实现简单的验证机制</li>
                    <li>处理跨链失败的情况</li>
                </ul>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">// 源链合约
contract SourceBridge is Ownable, Pausable {
    IERC20 public token;
    mapping(bytes32 => bool) public processedTransfers;
    uint256 public nonce;
    
    event TokensLocked(
        address indexed from,
        address indexed to,
        uint256 amount,
        uint256 targetChain,
        uint256 nonce
    );
    
    constructor(address _token) {
        token = IERC20(_token);
    }
    
    function lockTokens(
        address targetAddress,
        uint256 amount,
        uint256 targetChain
    ) external whenNotPaused {
        require(amount > 0, "Amount must be positive");
        require(token.transferFrom(msg.sender, address(this), amount), "Transfer failed");
        
        emit TokensLocked(msg.sender, targetAddress, amount, targetChain, ++nonce);
    }
    
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), "Withdraw failed");
    }
}

// 目标链合约
contract TargetBridge is Ownable, Pausable {
    mapping(address => bool) public validators;
    mapping(bytes32 => uint256) public confirmations;
    mapping(bytes32 => bool) public processedTransfers;
    
    uint256 public requiredConfirmations = 3;
    WrappedToken public wrappedToken;
    
    event TokensMinted(address indexed to, uint256 amount, bytes32 transferId);
    event TransferConfirmed(bytes32 transferId, address validator);
    
    constructor(string memory name, string memory symbol) {
        wrappedToken = new WrappedToken(name, symbol);
    }
    
    function addValidator(address validator) external onlyOwner {
        validators[validator] = true;
    }
    
    function confirmTransfer(
        address to,
        uint256 amount,
        uint256 sourceChain,
        uint256 nonce
    ) external {
        require(validators[msg.sender], "Not a validator");
        
        bytes32 transferId = keccak256(
            abi.encodePacked(to, amount, sourceChain, nonce)
        );
        
        require(!processedTransfers[transferId], "Already processed");
        
        confirmations[transferId]++;
        emit TransferConfirmed(transferId, msg.sender);
        
        if (confirmations[transferId] >= requiredConfirmations) {
            processedTransfers[transferId] = true;
            wrappedToken.mint(to, amount);
            emit TokensMinted(to, amount, transferId);
        }
    }
}

// 包装代币合约
contract WrappedToken is ERC20, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
    
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>练习 3.3：Gas优化挑战</h4>
                <p>给定一个低效的ERC-20实现，将其Gas消耗优化至少30%：</p>
                <pre><code class="language-solidity">// 低效实现
contract InefficientToken is ERC20 {
    mapping(address => bool) public whitelist;
    uint256[] public transferHistory;
    mapping(address => uint256[]) public userTransfers;
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(whitelist[msg.sender] || whitelist[to], "Not whitelisted");
        
        transferHistory.push(block.timestamp);
        userTransfers[msg.sender].push(amount);
        userTransfers[to].push(amount);
        
        return super.transfer(to, amount);
    }
}</code></pre>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract OptimizedToken is ERC20 {
    // 使用bitmap替代mapping节省存储
    mapping(uint256 => uint256) private whitelistBitmap;
    
    // 事件替代存储历史记录
    event TransferRecorded(address indexed from, address indexed to, uint256 amount, uint256 timestamp);
    
    // 只存储必要的统计信息
    mapping(address => uint256) public transferCount;
    
    function setWhitelist(address account, bool status) external onlyOwner {
        uint256 index = uint256(uint160(account));
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        
        if (status) {
            whitelistBitmap[wordIndex] |= (1 << bitIndex);
        } else {
            whitelistBitmap[wordIndex] &= ~(1 << bitIndex);
        }
    }
    
    function isWhitelisted(address account) public view returns (bool) {
        uint256 index = uint256(uint160(account));
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        uint256 word = whitelistBitmap[wordIndex];
        return (word & (1 << bitIndex)) != 0;
    }
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        // 使用局部变量缓存状态
        bool senderWhitelisted = isWhitelisted(msg.sender);
        bool recipientWhitelisted = isWhitelisted(to);
        
        require(senderWhitelisted || recipientWhitelisted, "Not whitelisted");
        
        // 使用事件记录历史，而不是存储
        emit TransferRecorded(msg.sender, to, amount, block.timestamp);
        
        // 使用unchecked节省Gas
        unchecked {
            transferCount[msg.sender]++;
            transferCount[to]++;
        }
        
        return super.transfer(to, amount);
    }
    
    // 批量检查白名单状态
    function batchCheckWhitelist(address[] calldata accounts) 
        external 
        view 
        returns (bool[] memory) 
    {
        bool[] memory results = new bool[](accounts.length);
        for (uint256 i = 0; i < accounts.length; ) {
            results[i] = isWhitelisted(accounts[i]);
            unchecked { ++i; }
        }
        return results;
    }
}</code></pre>
                    <p><strong>优化说明：</strong></p>
                    <ul>
                        <li>使用bitmap存储白名单，每个地址只需1bit而不是256bit</li>
                        <li>用事件替代数组存储，节省大量存储Gas</li>
                        <li>使用unchecked块避免不必要的溢出检查</li>
                        <li>缓存存储读取结果，避免重复SLOAD</li>
                        <li>移除不必要的动态数组操作</li>
                    </ul>
                </div>
            </div>
            
            <h3>3.5 Gas优化高级技术</h3>
            
            <h4>3.5.1 EIP-1153 瞬时存储</h4>
            
            <div class="tip-box">
                <strong>⚡ EIP-1153 核心概念：</strong>
                <ul>
                    <li><strong>TSTORE/TLOAD：</strong>在同一笔交易内保存临时数据，交易结束后自动清除</li>
                    <li><strong>Gas成本：</strong>TSTORE 100 gas，TLOAD 100 gas（vs SSTORE 20,000 gas）</li>
                    <li><strong>应用场景：</strong>重入锁、临时标记、跨函数数据传递</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">使用EIP-1153优化的稳定币 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract GasOptimizedStablecoin {
    // 传统存储变量
    mapping(address => uint256) public balances;
    
    // 瞬时存储键
    uint256 constant REENTRANCY_GUARD_SLOT = uint256(keccak256("reentrancy.guard"));
    uint256 constant TEMP_ALLOWANCE_SLOT = uint256(keccak256("temp.allowance"));
    
    // 使用瞬时存储的重入锁
    modifier nonReentrant() {
        assembly {
            if tload(REENTRANCY_GUARD_SLOT) {
                revert(0, 0)
            }
            tstore(REENTRANCY_GUARD_SLOT, 1)
        }
        _;
        assembly {
            tstore(REENTRANCY_GUARD_SLOT, 0)
        }
    }
    
    // 复杂的批量转账操作
    function batchTransferWithKYC(
        address[] calldata recipients,
        uint256[] calldata amounts,
        bytes[] calldata kycProofs
    ) external nonReentrant {
        require(recipients.length == amounts.length, "Length mismatch");
        
        uint256 totalAmount;
        
        // 第一次遍历：验证KYC并计算总额
        for (uint256 i = 0; i < recipients.length; i++) {
            // 使用瞬时存储缓存KYC验证结果
            bytes32 kycKey = keccak256(abi.encode(recipients[i], "kyc"));
            
            assembly {
                // 检查是否已验证
                if iszero(tload(kycKey)) {
                    // 验证KYC（简化版）
                    let kycValid := 1 // 假设验证通过
                    tstore(kycKey, kycValid)
                }
            }
            
            totalAmount += amounts[i];
        }
        
        // 检查总余额
        require(balances[msg.sender] >= totalAmount, "Insufficient balance");
        
        // 第二次遍历：执行转账
        for (uint256 i = 0; i < recipients.length; i++) {
            _transferOptimized(msg.sender, recipients[i], amounts[i]);
        }
    }
    
    // 优化的转账函数
    function _transferOptimized(
        address from,
        address to,
        uint256 amount
    ) internal {
        assembly {
            // 加载余额
            let fromBalance := sload(add(balances.slot, from))
            let toBalance := sload(add(balances.slot, to))
            
            // 检查余额
            if lt(fromBalance, amount) {
                revert(0, 0)
            }
            
            // 使用unchecked数学
            let newFromBalance := sub(fromBalance, amount)
            let newToBalance := add(toBalance, amount)
            
            // 存储新余额
            sstore(add(balances.slot, from), newFromBalance)
            sstore(add(balances.slot, to), newToBalance)
        }
    }
    
    // 使用瞬时存储的闪电贷
    function flashLoan(
        address receiver,
        uint256 amount,
        bytes calldata data
    ) external nonReentrant {
        uint256 balanceBefore = balances[address(this)];
        
        // 使用瞬时存储记录贷款信息
        assembly {
            tstore(TEMP_ALLOWANCE_SLOT, amount)
        }
        
        // 发送代币
        balances[address(this)] -= amount;
        balances[receiver] += amount;
        
        // 调用接收者
        IFlashLoanReceiver(receiver).onFlashLoan(amount, data);
        
        // 检查还款
        uint256 fee = amount * 3 / 1000; // 0.3% 费用
        require(
            balances[address(this)] >= balanceBefore + fee,
            "Flash loan not repaid"
        );
        
        // 清除瞬时存储
        assembly {
            tstore(TEMP_ALLOWANCE_SLOT, 0)
        }
    }
}

// 存储槽打包优化示例
contract StoragePackingExample {
    // 未优化：3个存储槽
    struct BadPacking {
        uint256 amount;     // 槽0
        bool active;        // 槽1
        uint128 limit;      // 槽2
    }
    
    // 优化后：2个存储槽
    struct GoodPacking {
        uint256 amount;     // 槽0
        uint128 limit;      // 槽1的前128位
        bool active;        // 槽1的第129位
        uint120 reserved;   // 槽1的剩余位
    }
    
    // 最优化：一个槽存储多个小数据
    struct UltraPacking {
        uint128 balance;
        uint64 lastUpdate;
        uint32 nonce;
        uint16 flags;
        uint8 decimals;
        uint8 version;
    } // 正好256位，一个槽
}</code></pre>
                </div>
            </div>
            
            <h4>3.5.2 汇编优化技巧</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">汇编级别的Gas优化 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract AssemblyOptimized {
    // 优化的批量余额查询
    function balanceOfBatch(
        address[] calldata accounts
    ) external view returns (uint256[] memory balances_) {
        assembly {
            let length := calldataload(add(accounts.offset, sub(0x20, 0x04)))
            
            // 分配内存
            balances_ := mload(0x40)
            let dataPtr := add(balances_, 0x20)
            mstore(0x40, add(dataPtr, mul(length, 0x20)))
            mstore(balances_, length)
            
            // 遍历账户
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                let account := calldataload(add(accounts.offset, mul(i, 0x20)))
                
                // 计算存储位置
                mstore(0x00, account)
                mstore(0x20, balances.slot)
                let slot := keccak256(0x00, 0x40)
                
                // 读取并存储余额
                mstore(add(dataPtr, mul(i, 0x20)), sload(slot))
            }
        }
    }
    
    // 优化的余额更新（避免零到非零的SSTORE）
    function updateBalance(
        address account,
        uint256 newBalance
    ) external {
        assembly {
            // 计算存储位置
            mstore(0x00, account)
            mstore(0x20, balances.slot)
            let slot := keccak256(0x00, 0x40)
            
            let oldBalance := sload(slot)
            
            // 如果从零到非零，使用更贵的操作码
            // 如果从非零到零，可以获得gas退款
            switch newBalance
            case 0 {
                // 清零操作
                if oldBalance {
                    sstore(slot, 0)
                    // 获得退款
                }
            }
            default {
                // 更新操作
                if iszero(eq(oldBalance, newBalance)) {
                    sstore(slot, newBalance)
                }
            }
        }
    }
}

// EVM操作码成本对比
contract OpcodesCost {
    // 存储操作成本
    // SLOAD: 2100 gas (温读取) / 2600 gas (冷读取)
    // SSTORE: 2900 gas (温写入) / 22100 gas (冷写入从零到非零)
    // TLOAD: 100 gas
    // TSTORE: 100 gas
    
    // 内存操作成本
    // MLOAD: 3 gas
    // MSTORE: 3 gas
    // MSTORE8: 3 gas
    
    // 计算操作成本
    // ADD/SUB: 3 gas
    // MUL: 5 gas
    // DIV: 5 gas
    // EXP: 10 gas + 50 gas per byte
}</code></pre>
                </div>
            </div>
            
            <h3>3.6 安全最佳实践</h3>
            
            <div class="tip-box">
                <strong>🔒 审计中常见的安全问题：</strong>
                <ul>
                    <li><strong>中心化风险：</strong>单一EOA控制关键权限 → 使用多签+时间锁</li>
                    <li><strong>权限过大：</strong>onlyOwner滥用 → 使用细粒度AccessControl</li>
                    <li><strong>三明治攻击：</strong>DEX交互无滑点保护 → 添加minAmountOut参数</li>
                    <li><strong>精度损失：</strong>复杂计算四舍五入 → 使用安全数学库</li>
                    <li><strong>重入攻击：</strong>状态更新顺序错误 → CEI模式+重入锁</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">安全模式实例 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract SecureStablecoin {
    using SafeMath for uint256;
    
    // 滑点保护
    function swapToUSDC(
        uint256 amount,
        uint256 minAmountOut,
        uint256 deadline
    ) external returns (uint256 amountOut) {
        require(block.timestamp <= deadline, "Expired");
        
        // 执行交换
        amountOut = IUniswapV2Router(router).swapExactTokensForTokens(
            amount,
            minAmountOut,  // 滑点保护
            path,
            msg.sender,
            deadline
        )[1];
        
        require(amountOut >= minAmountOut, "Slippage too high");
    }
    
    // CEI模式 (Checks-Effects-Interactions)
    function withdraw(uint256 amount) external nonReentrant {
        // Checks
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(amount > 0, "Zero amount");
        
        // Effects
        balances[msg.sender] = balances[msg.sender].sub(amount);
        totalSupply = totalSupply.sub(amount);
        
        // Interactions
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        emit Withdrawal(msg.sender, amount);
    }
    
    // 防止前端跑跑
    mapping(address => uint256) private lastActionBlock;
    
    modifier antiMEV() {
        require(
            lastActionBlock[msg.sender] < block.number,
            "Same block action"
        );
        lastActionBlock[msg.sender] = block.number;
        _;
    }
    
    // 严格的访问控制
    mapping(address => mapping(bytes4 => bool)) private permissions;
    
    modifier onlyPermitted(bytes4 selector) {
        require(
            permissions[msg.sender][selector],
            "No permission"
        );
        _;
    }
    
    // 参数验证
    modifier validAddress(address addr) {
        require(addr != address(0), "Zero address");
        require(addr != address(this), "Invalid target");
        _;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="practice-section">
                <h3>📝 第三章练习题</h3>
                
                <div class="exercise">
                    <h4>练习 3.1：实现完整的ERC-2612 Permit功能</h4>
                    <p>为你的稳定币添加ERC-2612 Permit支持，实现链下签名授权。</p>
                    <p>要求：</p>
                    <ul>
                        <li>实现permit函数和nonces管理</li>
                        <li>支持EIP-712结构化签名</li>
                        <li>实现deadline检查</li>
                        <li>编写前端签名代码</li>
                    </ul>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <pre><code class="language-solidity">// 合约实现
abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
    mapping(address => uint256) private _nonces;
    
    bytes32 private constant _PERMIT_TYPEHASH =
        keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    
    constructor(string memory name) EIP712(name, "1") {}
    
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
        
        bytes32 structHash = keccak256(abi.encode(
            _PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            _useNonce(owner),
            deadline
        ));
        
        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = ECDSA.recover(hash, v, r, s);
        require(signer == owner, "ERC20Permit: invalid signature");
        
        _approve(owner, spender, value);
    }
    
    function nonces(address owner) public view override returns (uint256) {
        return _nonces[owner];
    }
    
    function DOMAIN_SEPARATOR() external view override returns (bytes32) {
        return _domainSeparatorV4();
    }
    
    function _useNonce(address owner) internal returns (uint256 current) {
        current = _nonces[owner];
        _nonces[owner]++;
    }
}

// 前端签名代码
const domain = {
    name: 'USD Stablecoin',
    version: '1',
    chainId: 1,
    verifyingContract: stablecoinAddress
};

const types = {
    Permit: [
        { name: 'owner', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' }
    ]
};

const value = {
    owner: ownerAddress,
    spender: spenderAddress,
    value: amount,
    nonce: await stablecoin.nonces(ownerAddress),
    deadline: Math.floor(Date.now() / 1000) + 3600 // 1小时后过期
};

const signature = await signer._signTypedData(domain, types, value);
const { v, r, s } = ethers.utils.splitSignature(signature);

await stablecoin.permit(
    ownerAddress,
    spenderAddress,
    amount,
    value.deadline,
    v, r, s
);</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>练习 3.2：设计并实现紧急断路器</h4>
                    <p>实现一个符合EIP-7265标准的紧急断路器机制。</p>
                    <p>要求：</p>
                    <ul>
                        <li>检测异常大额转账</li>
                        <li>短时间内频繁铸币自动触发</li>
                        <li>代币价格脱锚超过5%时激活</li>
                        <li>支持多级响应机制</li>
                    </ul>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <pre><code class="language-solidity">contract CircuitBreaker {
    enum AlertLevel { NORMAL, WARNING, CRITICAL, EMERGENCY }
    
    AlertLevel public currentLevel = AlertLevel.NORMAL;
    
    // 阈值配置
    uint256 public largeTransferThreshold = 1000000 * 10**6; // 100万
    uint256 public mintRateThreshold = 10000000 * 10**6 / 1 hours; // 每小时10M
    uint256 public priceDeviationThreshold = 500; // 5%
    
    // 监控数据
    uint256 public recentMintAmount;
    uint256 public recentMintTimestamp;
    uint256 public lastPriceCheckTimestamp;
    
    // 检测大额转账
    function checkLargeTransfer(uint256 amount) internal {
        if (amount > largeTransferThreshold) {
            if (currentLevel == AlertLevel.NORMAL) {
                currentLevel = AlertLevel.WARNING;
                emit AlertLevelChanged(AlertLevel.WARNING, "Large transfer detected");
            }
        }
    }
    
    // 检测铸币速率
    function checkMintRate(uint256 amount) internal {
        if (block.timestamp > recentMintTimestamp + 1 hours) {
            recentMintAmount = 0;
            recentMintTimestamp = block.timestamp;
        }
        
        recentMintAmount += amount;
        
        if (recentMintAmount > mintRateThreshold) {
            if (currentLevel < AlertLevel.CRITICAL) {
                currentLevel = AlertLevel.CRITICAL;
                emit AlertLevelChanged(AlertLevel.CRITICAL, "High mint rate");
            }
        }
    }
    
    // 检测价格脱锚
    function checkPriceDeviation() internal {
        if (block.timestamp < lastPriceCheckTimestamp + 5 minutes) {
            return;
        }
        
        uint256 price = getOraclePrice();
        uint256 targetPrice = 1e18; // $1
        
        uint256 deviation = price > targetPrice ? 
            ((price - targetPrice) * 10000) / targetPrice :
            ((targetPrice - price) * 10000) / targetPrice;
        
        if (deviation > priceDeviationThreshold) {
            currentLevel = AlertLevel.EMERGENCY;
            _pause(); // 自动暂停
            emit AlertLevelChanged(AlertLevel.EMERGENCY, "Price deviation");
        }
        
        lastPriceCheckTimestamp = block.timestamp;
    }
    
    // 响应机制
    modifier circuitBreakerCheck(uint256 amount) {
        checkLargeTransfer(amount);
        checkPriceDeviation();
        
        if (currentLevel == AlertLevel.WARNING) {
            require(amount < largeTransferThreshold / 2, "Reduced limits");
        } else if (currentLevel == AlertLevel.CRITICAL) {
            require(hasRole(OPERATOR_ROLE, msg.sender), "Only operators");
        } else if (currentLevel == AlertLevel.EMERGENCY) {
            revert("System paused");
        }
        
        _;
    }
    
    // 恢复机制
    function recover() external onlyRole(EMERGENCY_ROLE) {
        require(currentLevel != AlertLevel.NORMAL, "Already normal");
        
        // 检查恢复条件
        uint256 price = getOraclePrice();
        uint256 deviation = calculateDeviation(price);
        require(deviation < 200, "Price still unstable"); // 2%以内
        
        currentLevel = AlertLevel.NORMAL;
        _unpause();
        emit SystemRecovered(block.timestamp);
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>练习 3.3：优化Gas消耗</h4>
                    <p>使用各种技术优化以下合约的Gas消耗，使其比原版节省至少50%。</p>
                    <pre><code class="language-solidity">// 原始版本
contract ExpensiveToken {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    mapping(address => bool) public isWhitelisted;
    mapping(address => uint256) public lastTransferTime;
    
    uint256 public totalSupply;
    address public owner;
    bool public paused;
    
    function transfer(address to, uint256 amount) public {
        require(!paused, "Paused");
        require(isWhitelisted[msg.sender], "Not whitelisted");
        require(isWhitelisted[to], "Recipient not whitelisted");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] = balances[msg.sender] - amount;
        balances[to] = balances[to] + amount;
        lastTransferTime[msg.sender] = block.timestamp;
        lastTransferTime[to] = block.timestamp;
    }
}</code></pre>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <pre><code class="language-solidity">// 优化版本
contract OptimizedToken {
    // 存储槽打包
    struct AccountData {
        uint128 balance;
        uint64 lastTransferTime;
        bool isWhitelisted;
        // 63 bits 剩余
    }
    
    mapping(address => AccountData) public accounts;
    mapping(address => mapping(address => uint256)) public allowances;
    
    // 打包状态变量
    uint128 public totalSupply;
    address public owner;
    bool public paused;
    // 7 bits 剩余
    
    // 使用modifier减少重复代码
    modifier whenNotPaused() {
        assembly {
            // 直接读取packed slot
            let slot := sload(owner.slot)
            let isPaused := and(shr(160, slot), 1)
            if isPaused { revert(0, 0) }
        }
        _;
    }
    
    function transfer(address to, uint256 amount) external whenNotPaused {
        // 使用assembly优化
        assembly {
            // 计算sender的存储位置
            mstore(0x00, caller())
            mstore(0x20, accounts.slot)
            let senderSlot := keccak256(0x00, 0x40)
            
            // 计算receiver的存储位置
            mstore(0x00, to)
            let receiverSlot := keccak256(0x00, 0x40)
            
            // 读取数据
            let senderData := sload(senderSlot)
            let receiverData := sload(receiverSlot)
            
            // 解析数据
            let senderBalance := and(senderData, 0xffffffffffffffffffffffffffffffff)
            let senderWhitelisted := and(shr(192, senderData), 1)
            let receiverWhitelisted := and(shr(192, receiverData), 1)
            
            // 检查白名单
            if iszero(senderWhitelisted) { revert(0, 0) }
            if iszero(receiverWhitelisted) { revert(0, 0) }
            
            // 检查余额
            if lt(senderBalance, amount) { revert(0, 0) }
            
            // 计算新余额
            let newSenderBalance := sub(senderBalance, amount)
            let receiverBalance := and(receiverData, 0xffffffffffffffffffffffffffffffff)
            let newReceiverBalance := add(receiverBalance, amount)
            
            // 更新时间戳
            let timestamp := timestamp()
            
            // 重新打包数据
            let newSenderData := or(
                or(newSenderBalance, shl(128, timestamp)),
                shl(192, senderWhitelisted)
            )
            let newReceiverData := or(
                or(newReceiverBalance, shl(128, timestamp)),
                shl(192, receiverWhitelisted)
            )
            
            // 写入存储
            sstore(senderSlot, newSenderData)
            sstore(receiverSlot, newReceiverData)
        }
    }
    
    // 批量操作减少交易次数
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused {
        uint256 length = recipients.length;
        require(length == amounts.length, "Length mismatch");
        
        // 使用瞬时存储缓存总额
        assembly {
            let totalAmount := 0
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                let amount := calldataload(add(amounts.offset, mul(i, 0x20)))
                totalAmount := add(totalAmount, amount)
            }
            tstore(0, totalAmount)
        }
        
        // 执行转账
        for (uint256 i; i < length; ) {
            _optimizedTransfer(recipients[i], amounts[i]);
            unchecked { ++i; }
        }
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>练习 3.4：跨链稳定币设计</h4>
                    <p>设计一个支持多链部署的原生稳定币系统，避免传统桥接模式的风险。</p>
                    <p>要求：</p>
                    <ul>
                        <li>每条链上独立铸币/销毁</li>
                        <li>跨链转账通过销毁-铸造模式</li>
                        <li>全局供应量同步</li>
                        <li>支持故障恢复</li>
                    </ul>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <pre><code class="language-solidity">// 主合约部署在所有链上
contract NativeMultichainStablecoin {
    using LayerZeroEndpoint for address;
    
    // 链信息
    struct ChainInfo {
        uint256 localSupply;    // 本链供应量
        uint256 mintCap;        // 铸币上限
        uint256 dailyLimit;     // 每日跨链限额
        uint256 dailyVolume;    // 今日跨链量
        uint256 lastResetTime;  // 上次重置时间
    }
    
    mapping(uint16 => ChainInfo) public chains;
    mapping(uint16 => mapping(bytes32 => bool)) public processedMessages;
    
    uint256 public globalSupply; // 全局总供应量
    uint16 public immutable currentChainId;
    
    // 跨链消息类型
    enum MessageType { TRANSFER, SUPPLY_SYNC, EMERGENCY }
    
    // 本地铸币
    function mintLocal(address to, uint256 amount) external onlyMinter {
        ChainInfo storage chain = chains[currentChainId];
        require(chain.localSupply + amount <= chain.mintCap, "Exceeds cap");
        
        _mint(to, amount);
        chain.localSupply += amount;
        
        // 广播供应量更新
        _broadcastSupplyUpdate();
    }
    
    // 跨链转账
    function crossChainTransfer(
        uint16 destChainId,
        address recipient,
        uint256 amount
    ) external payable {
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        // 检查日限额
        _checkDailyLimit(destChainId, amount);
        
        // 销毁本地代币
        _burn(msg.sender, amount);
        chains[currentChainId].localSupply -= amount;
        
        // 构建跨链消息
        bytes memory payload = abi.encode(
            MessageType.TRANSFER,
            recipient,
            amount,
            block.timestamp
        );
        
        // 发送LayerZero消息
        _lzSend(
            destChainId,
            payload,
            payable(msg.sender),
            address(0),
            bytes(""),
            msg.value
        );
        
        emit CrossChainTransfer(msg.sender, destChainId, recipient, amount);
    }
    
    // 接收跨链消息
    function _nonblockingLzReceive(
        uint16 srcChainId,
        bytes memory srcAddress,
        uint64 nonce,
        bytes memory payload
    ) internal override {
        // 防重放
        bytes32 messageId = keccak256(abi.encode(srcChainId, nonce));
        require(!processedMessages[srcChainId][messageId], "Duplicate");
        processedMessages[srcChainId][messageId] = true;
        
        (MessageType msgType, ) = abi.decode(payload, (MessageType, bytes));
        
        if (msgType == MessageType.TRANSFER) {
            _handleTransfer(srcChainId, payload);
        } else if (msgType == MessageType.SUPPLY_SYNC) {
            _handleSupplySync(srcChainId, payload);
        } else if (msgType == MessageType.EMERGENCY) {
            _handleEmergency(srcChainId, payload);
        }
    }
    
    // 处理转账
    function _handleTransfer(
        uint16 srcChainId,
        bytes memory payload
    ) internal {
        (, address recipient, uint256 amount, ) = abi.decode(
            payload,
            (MessageType, address, uint256, uint256)
        );
        
        // 铸造新币
        _mint(recipient, amount);
        chains[currentChainId].localSupply += amount;
        
        emit CrossChainReceived(srcChainId, recipient, amount);
    }
    
    // 供应量同步
    function _broadcastSupplyUpdate() internal {
        bytes memory payload = abi.encode(
            MessageType.SUPPLY_SYNC,
            currentChainId,
            chains[currentChainId].localSupply,
            block.timestamp
        );
        
        // 向所有链广播
        uint16[] memory chainIds = getActiveChains();
        for (uint i = 0; i < chainIds.length; i++) {
            if (chainIds[i] != currentChainId) {
                _lzSend(chainIds[i], payload, payable(address(this)), address(0), bytes(""), 0);
            }
        }
    }
    
    // 紧急暂停
    function emergencyPause(string memory reason) external onlyEmergency {
        _pause();
        
        // 广播紧急消息
        bytes memory payload = abi.encode(
            MessageType.EMERGENCY,
            currentChainId,
            reason,
            block.timestamp
        );
        
        _broadcastEmergency(payload);
    }
    
    // 故障恢复机制
    function recoverFromFailure(
        uint16 failedChainId,
        uint256 lastKnownSupply
    ) external onlyRole(RECOVERY_ROLE) {
        // 更新失败链的供应量信息
        chains[failedChainId].localSupply = lastKnownSupply;
        
        // 重新计算全局供应量
        _recalculateGlobalSupply();
        
        emit ChainRecovered(failedChainId, lastKnownSupply);
    }
}</code></pre>
                    </div>
                </div>
            </div>
            
            <h3>本章小结</h3>
            <div class="summary-box">
                <h4>核心要点回顾：</h4>
                <ul>
                    <li><strong>ERC-20标准：</strong>稳定币的基础接口，需要扩展以支持合规功能</li>
                    <li><strong>可升级架构：</strong>UUPS模式提供最佳Gas效率，适合高频交易场景</li>
                    <li><strong>跨链互操作：</strong>LayerZero和IBC提供不同的安全性和去中心化权衡</li>
                    <li><strong>Gas优化：</strong>通过存储打包、批量操作和事件日志可大幅降低成本</li>
                    <li><strong>合规功能：</strong>KYC、AML、黑名单是企业级稳定币的必备功能</li>
                </ul>
                
                <h4>下一步学习：</h4>
                <p>在掌握了ERC-20标准和可升级架构后，下一章我们将深入探讨抵押型稳定币的设计，包括金库机制、清算引擎和预言机集成。</p>
            </div>
            
            <h3>术语速查表</h3>
            <table class="glossary-table">
                <tr>
                    <th>术语</th>
                    <th>英文</th>
                    <th>解释</th>
                </tr>
                <tr>
                    <td>代理模式</td>
                    <td>Proxy Pattern</td>
                    <td>通过代理合约调用实现合约，实现可升级性</td>
                </tr>
                <tr>
                    <td>存储槽</td>
                    <td>Storage Slot</td>
                    <td>EVM中的256位存储单位，每个槽消耗20000 Gas</td>
                </tr>
                <tr>
                    <td>轻客户端</td>
                    <td>Light Client</td>
                    <td>只存储区块头的客户端，用于验证跨链消息</td>
                </tr>
                <tr>
                    <td>包装代币</td>
                    <td>Wrapped Token</td>
                    <td>在目标链上代表源链资产的合成代币</td>
                </tr>
                <tr>
                    <td>时间锁</td>
                    <td>Timelock</td>
                    <td>延迟执行机制，增加安全性和可预测性</td>
                </tr>
            </table>
        </div>

        <!-- 第四章：抵押型稳定币设计 -->
        <div class="chapter" id="chapter4">
            <h2>第四章：抵押型稳定币设计</h2>
            
            <div class="intro-box">
                <strong>本章概览：</strong>
                <ul>
                    <li>深入理解金库(Vault)机制和CDP系统</li>
                    <li>清算引擎设计与Keeper激励机制</li>
                    <li>预言机集成和价格喂价策略</li>
                    <li>锚定稳定模块(PSM)与真实世界资产(RWA)</li>
                    <li>实战：构建类似MakerDAO的超额抵押稳定币系统</li>
                </ul>
            </div>
            
            <div class="tip-box">
                <strong>🎯 章节目标：</strong>
                <p>本章不仅要让您理解“如何实现”抵押型稳定币，更重要的是理解“为何如此设计”以及“有何权衡”。我们将通过量化风险建模、真实案例分析和最新实践，帮助您构建对这一复杂系统的深刻理解。</p>
            </div>

            <h3>4.1 金库机制与CDP系统</h3>
            
            <h4>4.1.1 抵押债仓位(CDP)核心概念</h4>
            <p>CDP（Collateralized Debt Position，抵押债仓位）是抵押型稳定币的核心机制，允许用户通过锁定抵押品来铸造稳定币。让我们深入了解其工作原理：</p>
            
            <div class="tip">
                💡 关键洞察：CDP本质上是一个智能合约控制的贷款系统，用户的抵押品被锁定在合约中，作为铸造稳定币的担保。
            </div>
            
            <h4>4.1.2 风险参数五元组</h4>
            <p>抵押型稳定币的安全性依赖于精心设计的风险参数。这些参数不是孤立的，而是相互影响的：</p>
            
            <table class="comparison-table">
                <tr>
                    <th>参数名称</th>
                    <th>含义</th>
                    <th>典型值</th>
                    <th>设定依据</th>
                </tr>
                <tr>
                    <td>债务上限 (Debt Ceiling)</td>
                    <td>该抵押品类型可铸造的最大稳定币数量</td>
                    <td>100M - 5B DAI</td>
                    <td>抵押品流动性、市场规模</td>
                </tr>
                <tr>
                    <td>清算线 (Liquidation Ratio)</td>
                    <td>触发清算的最低抵押率</td>
                    <td>130% - 175%</td>
                    <td>资产波动性、VaR模型</td>
                </tr>
                <tr>
                    <td>稳定费 (Stability Fee)</td>
                    <td>借款利率，作为货币政策工具</td>
                    <td>0.5% - 20% APR</td>
                    <td>市场利率、价格锚定情况</td>
                </tr>
                <tr>
                    <td>清算罚金 (Liquidation Penalty)</td>
                    <td>清算时的额外费用</td>
                    <td>5% - 13%</td>
                    <td>激励Keeper、补偿系统风险</td>
                </tr>
                <tr>
                    <td>目标抵押率 (Target CR)</td>
                    <td>建议的安全抵押率</td>
                    <td>150% - 200%</td>
                    <td>给用户缓冲空间</td>
                </tr>
            </table>
            
            <div class="tip-box">
                <strong>📊 量化风险建模：</strong>
                <p>这些参数的设定不是任意的，而是基于：</p>
                <ul>
                    <li><strong>Value-at-Risk (VaR)：</strong>通过历史数据模拟极端市场情况下的损失概率</li>
                    <li><strong>Monte Carlo模拟：</strong>随机生成价格路径，评估系统在不同场景下的表现</li>
                    <li><strong>市场深度分析：</strong>考虑大规模清算对市场的冲击</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">CDP核心数据结构设计 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CDPEngine {
    // CDP核心数据结构
    struct CDP {
        uint256 collateral;      // 抵押品数量
        uint256 debt;           // 债务数量（铸造的稳定币）
        uint256 accumulatedRate; // 累积利率（用于计算利息）
    }
    
    // 抵押品类型信息 - 风险参数五元组
    struct CollateralType {
        // 风险参数
        uint256 debtCeiling;        // 债务上限
        uint256 liquidationRatio;   // 清算比率（如150%）
        uint256 stabilityFee;       // 稳定费率（年化）
        uint256 liquidationPenalty; // 清算罚金（如13%）
        uint256 targetRatio;        // 目标抵押率（如175%）
        
        // 状态变量
        uint256 totalCollateral;     // 该类型总抵押量
        uint256 totalDebt;          // 该类型总债务
        uint256 debtFloor;          // 最小债务量
        uint256 accumulatedRate;    // 累积利率
        uint256 lastUpdateTime;     // 上次更新时间
        
        // 配置
        address priceOracle;        // 价格预言机地址
        address gemAdapter;         // 抵押品适配器
        bool isActive;              // 是否激活
    }
    
    // 状态变量
    mapping(bytes32 => CollateralType) public collateralTypes;
    mapping(bytes32 => mapping(address => CDP)) public cdps;
    mapping(address => uint256) public systemDebt;  // 系统债务
    mapping(address => uint256) public systemSurplus; // 系统盈余
    
    uint256 public globalDebtCeiling;  // 全局债务上限
    uint256 public baseRate = 1e27;    // 基础利率（Ray单位）
    uint256 constant RAY = 1e27;       // Ray精度
    
    // 事件
    event CDPOpened(bytes32 indexed ilk, address indexed user);
    event CollateralLocked(bytes32 indexed ilk, address indexed user, uint256 amount);
    event DebtGenerated(bytes32 indexed ilk, address indexed user, uint256 amount);
    event CDPClosed(bytes32 indexed ilk, address indexed user);
    
    // 开启新的CDP
    function openCDP(bytes32 ilk) external returns (uint256 cdpId) {
        require(collateralTypes[ilk].debtCeiling > 0, "Collateral type not initialized");
        
        // 初始化用户的CDP
        cdps[ilk][msg.sender] = CDP({
            collateral: 0,
            debt: 0,
            accumulatedRate: collateralTypes[ilk].accumulatedRate
        });
        
        emit CDPOpened(ilk, msg.sender);
    }
    
    // 锁定抵押品
    function lockCollateral(bytes32 ilk, uint256 amount) external {
        CDP storage cdp = cdps[ilk][msg.sender];
        CollateralType storage collType = collateralTypes[ilk];
        
        // 从用户转入抵押品（需要先approve）
        // 这里假设有一个gem adapter处理不同类型的抵押品
        IGemAdapter(collType.gemAdapter).join(msg.sender, amount);
        
        cdp.collateral += amount;
        collType.totalCollateral += amount;
        
        emit CollateralLocked(ilk, msg.sender, amount);
    }
    
    // 计算CDP的抵押率
    function getCDPStatus(bytes32 ilk, address user) 
        public 
        view 
        returns (
            uint256 collateralValue,
            uint256 debtValue,
            uint256 collateralizationRatio,
            bool isSafe
        ) 
    {
        CDP memory cdp = cdps[ilk][user];
        CollateralType memory collType = collateralTypes[ilk];
        
        // 获取抵押品价格
        uint256 price = IPriceOracle(collType.priceOracle).getPrice(ilk);
        
        // 计算价值
        collateralValue = cdp.collateral * price / 1e18;
        debtValue = cdp.debt * collType.accumulatedRate / RAY;
        
        // 计算抵押率
        if (debtValue > 0) {
            collateralizationRatio = collateralValue * 100 / debtValue;
        } else {
            collateralizationRatio = type(uint256).max;
        }
        
        // 检查是否安全
        isSafe = collateralizationRatio >= collType.liquidationRatio;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.1.2 利率累积机制</h4>
            <p>稳定费（Stability Fee）是抵押型稳定币的重要收入来源，通过复利计算实现精确的利息累积：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">利率累积计算实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">library RateMath {
    uint256 constant RAY = 1e27;
    uint256 constant YEAR = 365 days;
    
    // 计算复利
    function compound(uint256 principal, uint256 rate, uint256 time) 
        internal 
        pure 
        returns (uint256) 
    {
        // 使用泰勒级数近似计算 e^(rate * time)
        // 对于小的rate * time，这个近似非常准确
        uint256 ratePerSecond = rate / YEAR;
        uint256 exp = time * ratePerSecond / RAY;
        
        // e^x ≈ 1 + x + x^2/2 + x^3/6 + ...
        uint256 result = RAY + exp;
        uint256 term = exp;
        
        // 计算前几项以提高精度
        for (uint256 i = 2; i <= 6; i++) {
            term = term * exp / (i * RAY);
            result += term;
            
            // 如果项太小，停止计算
            if (term < 1) break;
        }
        
        return principal * result / RAY;
    }
}

contract StabilityFeeCollector {
    using RateMath for uint256;
    
    struct RateUpdate {
        uint256 rate;           // 当前利率
        uint256 accumulated;    // 累积因子
        uint256 lastUpdate;     // 上次更新时间
    }
    
    mapping(bytes32 => RateUpdate) public rates;
    
    // 更新累积利率
    function updateAccumulatedRate(bytes32 ilk) public returns (uint256) {
        RateUpdate storage r = rates[ilk];
        
        if (block.timestamp > r.lastUpdate) {
            uint256 timeDelta = block.timestamp - r.lastUpdate;
            
            // 计算新的累积因子
            uint256 newAccumulated = r.accumulated.compound(
                r.rate,
                timeDelta
            );
            
            r.accumulated = newAccumulated;
            r.lastUpdate = block.timestamp;
        }
        
        return r.accumulated;
    }
    
    // 计算债务的当前价值（包含利息）
    function debtWithInterest(
        bytes32 ilk,
        uint256 principal
    ) public view returns (uint256) {
        RateUpdate memory r = rates[ilk];
        uint256 timeDelta = block.timestamp - r.lastUpdate;
        
        uint256 currentAccumulated = r.accumulated.compound(
            r.rate,
            timeDelta
        );
        
        return principal * currentAccumulated / RAY;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.1.3 债务和盈余管理</h4>
            <p>系统需要精确管理全局债务和盈余，确保整体偿付能力：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">债务会计系统 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract DebtAccounting {
    // 系统会计变量
    mapping(address => uint256) public dai;      // DAI余额
    mapping(address => uint256) public sin;      // 坏账（系统债务）
    uint256 public vice;                         // 全局未拍卖坏账
    uint256 public surplus;                      // 系统盈余
    
    uint256 constant RAD = 1e45;                 // 高精度单位
    
    // 铸造稳定币
    function mint(address user, uint256 amount) internal {
        dai[user] += amount;
        
        // 同时增加等额的系统债务
        sin[address(this)] += amount;
    }
    
    // 销毁稳定币偿还债务
    function burn(address user, uint256 amount) internal {
        require(dai[user] >= amount, "Insufficient balance");
        
        dai[user] -= amount;
        sin[address(this)] -= amount;
    }
    
    // 处理盈余
    function handleSurplus() external {
        // 当系统有盈余时，可以：
        // 1. 销毁MKR代币（通过拍卖）
        // 2. 增加储备金
        // 3. 降低稳定费率
        
        if (surplus > surplusBuffer) {
            uint256 auctionAmount = surplus - surplusBuffer;
            // 启动盈余拍卖...
        }
    }
    
    // 处理坏账
    function handleBadDebt() external {
        // 当系统有坏账时，需要：
        // 1. 铸造MKR代币（通过拍卖）
        // 2. 使用储备金
        // 3. 提高稳定费率
        
        if (vice > debtBuffer) {
            uint256 auctionAmount = vice - debtBuffer;
            // 启动债务拍卖...
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.2 清算引擎与Keeper激励</h3>
            
            <h4>4.2.0 清算机制对比分析</h4>
            <p>在深入实现之前，让我们先从多个维度对比不同的清算机制：</p>
            
            <table class="comparison-table">
                <tr>
                    <th>清算机制</th>
                    <th>资本效率</th>
                    <th>Gas成本</th>
                    <th>市场操纵风险</th>
                    <th>清算速度</th>
                    <th>Keeper要求</th>
                    <th>适用场景</th>
                </tr>
                <tr>
                    <td>荷兰拍卖</td>
                    <td>中等</td>
                    <td>高</td>
                    <td>低</td>
                    <td>慢</td>
                    <td>复杂</td>
                    <td>大额清算</td>
                </tr>
                <tr>
                    <td>英式拍卖 (Liquidation 2.0)</td>
                    <td>高</td>
                    <td>中</td>
                    <td>低</td>
                    <td>中</td>
                    <td>简单</td>
                    <td>MakerDAO现行方案</td>
                </tr>
                <tr>
                    <td>固定价差</td>
                    <td>低</td>
                    <td>低</td>
                    <td>中</td>
                    <td>快</td>
                    <td>简单</td>
                    <td>小额高频</td>
                </tr>
                <tr>
                    <td>AMM清算</td>
                    <td>最高</td>
                    <td>中</td>
                    <td>最低</td>
                    <td>即时</td>
                    <td>无</td>
                    <td>Curve crvUSD</td>
                </tr>
            </table>
            
            <div class="tip-box">
                <strong>🎨 MakerDAO Liquidation 2.0：</strong>
                <p>MakerDAO已经从Liquidation 1.0的荷兰拍卖升级到了2.0的英式拍卖系统：</p>
                <ul>
                    <li>固定折扣的英式拍卖，减少市场冲击</li>
                    <li>即时清算，无需等待拍卖结束</li>
                    <li>支持部分清算，提高用户体验</li>
                    <li>更高的资本效率和更低的清算损失</li>
                </ul>
            </div>
            
            <h4>4.2.1 清算触发条件</h4>
            <p>当CDP的抵押率低于清算线时，系统需要及时清算以保护整体偿付能力：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">清算引擎核心逻辑 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract LiquidationEngine {
    struct Auction {
        uint256 collateralAmount;  // 拍卖的抵押品数量
        uint256 debtAmount;        // 需要偿还的债务
        address cdpOwner;          // CDP原主人
        uint256 startTime;         // 拍卖开始时间
        uint256 startPrice;        // 起始价格
        uint256 endTime;           // 拍卖结束时间
        address highBidder;        // 最高出价者
        uint256 highBid;           // 最高出价
    }
    
    mapping(uint256 => Auction) public auctions;
    uint256 public nextAuctionId;
    
    // 清算参数
    uint256 public liquidationPenalty = 13e16;  // 13%罚金
    uint256 public auctionDuration = 6 hours;    // 拍卖持续时间
    uint256 public bufferPercentage = 3e16;      // 3%缓冲
    
    // 触发清算
    function liquidate(bytes32 ilk, address user) external returns (uint256 auctionId) {
        // 检查CDP状态
        (uint256 collateralValue, uint256 debtValue, uint256 ratio, bool isSafe) = 
            cdpEngine.getCDPStatus(ilk, user);
        
        require(!isSafe, "CDP is safe");
        
        CDP storage cdp = cdpEngine.cdps(ilk, user);
        CollateralType memory collType = cdpEngine.collateralTypes(ilk);
        
        // 计算清算金额
        uint256 debtToRecover = cdp.debt * collType.accumulatedRate / RAY;
        uint256 penaltyAmount = debtToRecover * liquidationPenalty / 1e18;
        uint256 totalDebtWithPenalty = debtToRecover + penaltyAmount;
        
        // 计算需要拍卖的抵押品
        uint256 collateralPrice = oracle.getPrice(ilk);
        uint256 collateralToAuction = totalDebtWithPenalty * 1e18 / collateralPrice;
        
        // 如果需要的抵押品超过CDP拥有的，拍卖全部
        if (collateralToAuction > cdp.collateral) {
            collateralToAuction = cdp.collateral;
        }
        
        // 创建拍卖
        auctionId = nextAuctionId++;
        auctions[auctionId] = Auction({
            collateralAmount: collateralToAuction,
            debtAmount: debtToRecover,
            cdpOwner: user,
            startTime: block.timestamp,
            startPrice: collateralPrice * (100 + bufferPercentage) / 100,
            endTime: block.timestamp + auctionDuration,
            highBidder: address(0),
            highBid: 0
        });
        
        // 从CDP中移除抵押品
        cdp.collateral -= collateralToAuction;
        
        emit LiquidationStarted(ilk, user, auctionId, collateralToAuction, debtToRecover);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.2.2 拍卖机制设计</h4>
            <p>MakerDAO使用三种拍卖机制：抵押品拍卖（Collateral Auction）、债务拍卖（Debt Auction）和盈余拍卖（Surplus Auction）：</p>
            
            <table class="comparison-table">
                <tr>
                    <th>拍卖类型</th>
                    <th>触发条件</th>
                    <th>拍卖标的</th>
                    <th>支付方式</th>
                    <th>目标</th>
                </tr>
                <tr>
                    <td>抵押品拍卖</td>
                    <td>CDP被清算</td>
                    <td>抵押品</td>
                    <td>DAI</td>
                    <td>回收债务+罚金</td>
                </tr>
                <tr>
                    <td>债务拍卖</td>
                    <td>系统坏账过多</td>
                    <td>MKR代币</td>
                    <td>DAI</td>
                    <td>填补坏账缺口</td>
                </tr>
                <tr>
                    <td>盈余拍卖</td>
                    <td>系统盈余过多</td>
                    <td>DAI</td>
                    <td>MKR代币</td>
                    <td>销毁MKR</td>
                </tr>
            </table>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">荷兰式拍卖实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract DutchAuction {
    // 荷兰式拍卖：价格随时间线性下降
    function getCurrentPrice(Auction memory auction) 
        public 
        view 
        returns (uint256) 
    {
        if (block.timestamp >= auction.endTime) {
            // 拍卖结束，返回最低价
            return auction.startPrice / 2;
        }
        
        uint256 elapsed = block.timestamp - auction.startTime;
        uint256 duration = auction.endTime - auction.startTime;
        
        // 线性下降到50%
        uint256 priceDrop = auction.startPrice * elapsed / (2 * duration);
        return auction.startPrice - priceDrop;
    }
    
    // 竞拍
    function bid(uint256 auctionId, uint256 amount) external {
        Auction storage auction = auctions[auctionId];
        require(block.timestamp < auction.endTime, "Auction ended");
        
        uint256 currentPrice = getCurrentPrice(auction);
        uint256 collateralWanted = amount * 1e18 / currentPrice;
        
        require(collateralWanted <= auction.collateralAmount, "Not enough collateral");
        
        // 转入DAI
        dai.transferFrom(msg.sender, address(this), amount);
        
        // 转出抵押品
        collateral.transfer(msg.sender, collateralWanted);
        
        // 更新拍卖状态
        auction.collateralAmount -= collateralWanted;
        
        // 如果债务已完全偿还，结束拍卖
        if (amount >= auction.debtAmount) {
            // 返还剩余抵押品给原主人
            if (auction.collateralAmount > 0) {
                collateral.transfer(auction.cdpOwner, auction.collateralAmount);
            }
            
            // 多余的DAI作为系统盈余
            if (amount > auction.debtAmount) {
                surplus += amount - auction.debtAmount;
            }
            
            delete auctions[auctionId];
        } else {
            auction.debtAmount -= amount;
        }
        
        emit BidPlaced(auctionId, msg.sender, amount, collateralWanted);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.2.3 Keeper激励机制与MEV防护</h4>
            <p>Keeper是维护系统健康的关键参与者，但也可能成为MEV攻击的来源。我们需要在激励和防护之间找到平衡：</p>
            
            <div class="tip-box">
                <strong>🕸️ MEV在清算中的两种主要形式：</strong>
                <ul>
                    <li><strong>抢跑 (Front-running)：</strong>Keeper监控内存池，抢先执行有利可图的清算</li>
                    <li><strong>三明治攻击 (Sandwiching)：</strong>在预言机更新前后操纵价格触发清算</li>
                </ul>
                <p><strong>缓解策略：</strong></p>
                <ul>
                    <li>批量拍卖：减少单个交易的MEV机会</li>
                    <li>Commit-Reveal：隐藏意图直到执行</li>
                    <li>Flashbots Protect：使用加密内存池</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Keeper激励系统 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract KeeperIncentives {
    // Keeper奖励参数
    uint256 public liquidationReward = 3e16;     // 3%奖励
    uint256 public priceUpdateReward = 1e15;     // 0.1%奖励
    uint256 public gasCompensation = 200000;     // Gas补偿
    
    mapping(address => uint256) public keeperRewards;
    mapping(address => uint256) public keeperReputation;
    
    // 清算奖励
    function rewardLiquidation(address keeper, uint256 debtAmount) internal {
        uint256 reward = debtAmount * liquidationReward / 1e18;
        keeperRewards[keeper] += reward;
        keeperReputation[keeper] += 1;
        
        emit KeeperRewarded(keeper, "liquidation", reward);
    }
    
    // 价格更新奖励
    function rewardPriceUpdate(address keeper) internal {
        uint256 reward = priceUpdateReward;
        keeperRewards[keeper] += reward;
        
        emit KeeperRewarded(keeper, "price_update", reward);
    }
    
    // MEV保护：使用commit-reveal机制
    mapping(bytes32 => uint256) public commitments;
    uint256 public revealDelay = 2; // 区块延迟
    
    // 批量拍卖机制
    struct BatchAuction {
        uint256 startBlock;
        uint256 endBlock;
        bytes32[] liquidations;
        mapping(address => uint256) bids;
        uint256 totalBids;
        bool settled;
    }
    
    mapping(uint256 => BatchAuction) public batches;
    uint256 public currentBatch;
    
    // 加密订单流
    function submitEncryptedBid(
        uint256 batchId,
        bytes32 encryptedBid
    ) external {
        require(block.number < batches[batchId].endBlock, "Batch ended");
        // 存储加密竞价
        encryptedBids[batchId][msg.sender] = encryptedBid;
    }
    
    // 使用VDF延迟揭示
    function revealWithVDF(
        uint256 batchId,
        uint256 bid,
        uint256 nonce,
        bytes memory vdfProof
    ) external {
        // 验证VDF证明
        require(verifyVDF(vdfProof, block.number - batches[batchId].endBlock), "Invalid VDF");
        
        // 验证加密竞价
        bytes32 commitment = keccak256(abi.encodePacked(bid, nonce));
        require(encryptedBids[batchId][msg.sender] == commitment, "Invalid reveal");
        
        batches[batchId].bids[msg.sender] = bid;
        batches[batchId].totalBids += bid;
    }
    
    function commitLiquidation(bytes32 commitment) external {
        commitments[commitment] = block.number;
    }
    
    function revealLiquidation(
        bytes32 ilk,
        address user,
        uint256 nonce
    ) external {
        bytes32 commitment = keccak256(abi.encodePacked(ilk, user, nonce, msg.sender));
        require(commitments[commitment] > 0, "Invalid commitment");
        require(block.number >= commitments[commitment] + revealDelay, "Too early");
        require(block.number <= commitments[commitment] + revealDelay + 10, "Too late");
        
        // 执行清算
        liquidationEngine.liquidate(ilk, user);
        
        // 奖励keeper
        rewardLiquidation(msg.sender, debtAmount);
        
        delete commitments[commitment];
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.3 预言机集成与价格喂价</h3>
            
            <h4>4.3.1 预言机架构设计</h4>
            <p>价格预言机是抵押型稳定币的关键组件，需要确保价格的准确性和抗操纵性：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">预言机系统架构 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract PriceOracleSystem {
    struct PriceFeed {
        uint256 value;          // 当前价格
        uint256 timestamp;      // 更新时间
        bool isActive;          // 是否活跃
    }
    
    struct OracleConfig {
        address[] oracles;      // 预言机地址列表
        uint256 quorum;         // 最小数量要求
        uint256 priceDeviation; // 允许的价格偏差
        uint256 stalePeriod;    // 价格过期时间
    }
    
    mapping(bytes32 => PriceFeed) public priceFeeds;
    mapping(bytes32 => OracleConfig) public oracleConfigs;
    mapping(bytes32 => mapping(address => uint256)) public oracleSubmissions;
    
    // 中位数价格计算
    function updatePrice(bytes32 asset) external {
        OracleConfig memory config = oracleConfigs[asset];
        
        uint256[] memory prices = new uint256[](config.oracles.length);
        uint256 validSubmissions = 0;
        
        // 收集所有有效的价格提交
        for (uint256 i = 0; i < config.oracles.length; i++) {
            uint256 submission = oracleSubmissions[asset][config.oracles[i]];
            
            // 检查提交是否在有效期内
            if (submission > 0 && block.timestamp - submission <= config.stalePeriod) {
                prices[validSubmissions++] = submission;
            }
        }
        
        require(validSubmissions >= config.quorum, "Insufficient oracle submissions");
        
        // 计算中位数
        uint256 medianPrice = calculateMedian(prices, validSubmissions);
        
        // 检查价格偏差
        PriceFeed storage feed = priceFeeds[asset];
        if (feed.value > 0) {
            uint256 deviation = medianPrice > feed.value 
                ? (medianPrice - feed.value) * 1e18 / feed.value
                : (feed.value - medianPrice) * 1e18 / feed.value;
                
            require(deviation <= config.priceDeviation, "Price deviation too high");
        }
        
        // 更新价格
        feed.value = medianPrice;
        feed.timestamp = block.timestamp;
        feed.isActive = true;
        
        emit PriceUpdated(asset, medianPrice, validSubmissions);
    }
    
    // 安全的价格获取
    function getPrice(bytes32 asset) external view returns (uint256) {
        PriceFeed memory feed = priceFeeds[asset];
        require(feed.isActive, "Price feed not active");
        require(block.timestamp - feed.timestamp <= oracleConfigs[asset].stalePeriod, 
                "Price is stale");
        
        return feed.value;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.3.2 Chainlink集成</h4>
            <p>集成Chainlink预言机提供可靠的价格数据：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Chainlink预言机适配器 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract ChainlinkPriceAdapter {
    struct ChainlinkFeed {
        AggregatorV3Interface priceFeed;
        uint256 heartbeat;      // 最大更新间隔
        uint256 decimals;       // 价格精度
        bool isInverse;         // 是否需要取倒数（如USD/ETH）
    }
    
    mapping(bytes32 => ChainlinkFeed) public chainlinkFeeds;
    uint256 constant PRICE_DECIMALS = 1e18;
    
    // 配置Chainlink数据源
    function setChainlinkFeed(
        bytes32 asset,
        address feedAddress,
        uint256 heartbeat,
        bool isInverse
    ) external onlyOwner {
        AggregatorV3Interface feed = AggregatorV3Interface(feedAddress);
        uint256 decimals = feed.decimals();
        
        chainlinkFeeds[asset] = ChainlinkFeed({
            priceFeed: feed,
            heartbeat: heartbeat,
            decimals: 10 ** decimals,
            isInverse: isInverse
        });
    }
    
    // 获取Chainlink价格
    function getChainlinkPrice(bytes32 asset) public view returns (uint256) {
        ChainlinkFeed memory feed = chainlinkFeeds[asset];
        require(address(feed.priceFeed) != address(0), "Feed not configured");
        
        (
            uint80 roundId,
            int256 price,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = feed.priceFeed.latestRoundData();
        
        // 验证数据有效性
        require(price > 0, "Invalid price");
        require(updatedAt > 0, "Round not complete");
        require(block.timestamp - updatedAt <= feed.heartbeat, "Price stale");
        
        // 标准化价格到18位小数
        uint256 normalizedPrice = uint256(price) * PRICE_DECIMALS / feed.decimals;
        
        // 如果需要取倒数（如USD/ETH转换为ETH/USD）
        if (feed.isInverse) {
            normalizedPrice = PRICE_DECIMALS * PRICE_DECIMALS / normalizedPrice;
        }
        
        return normalizedPrice;
    }
    
    // 聚合多个价格源
    function getAggregatedPrice(bytes32 asset) external view returns (uint256) {
        uint256 chainlinkPrice = getChainlinkPrice(asset);
        uint256 internalPrice = priceOracle.getPrice(asset);
        
        // 简单平均，实际可以使用加权平均或其他算法
        return (chainlinkPrice + internalPrice) / 2;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.3.3 TWAP价格保护</h4>
            <p>使用时间加权平均价格（TWAP）防止价格操纵：</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">TWAP实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract TWAPOracle {
    struct Observation {
        uint256 timestamp;
        uint256 priceCumulative;
        uint256 price;
    }
    
    struct TWAPData {
        Observation[] observations;
        uint256 windowSize;        // TWAP窗口大小（秒）
        uint256 granularity;       // 观察点数量
    }
    
    mapping(bytes32 => TWAPData) public twapData;
    
    // 更新TWAP
    function updateTWAP(bytes32 asset, uint256 currentPrice) external {
        TWAPData storage data = twapData[asset];
        
        // 计算时间间隔
        uint256 timeElapsed = block.timestamp - data.observations[data.observations.length - 1].timestamp;
        require(timeElapsed > 0, "Time not elapsed");
        
        // 计算累积价格
        uint256 priceCumulative = data.observations[data.observations.length - 1].priceCumulative + 
                                 currentPrice * timeElapsed;
        
        // 添加新观察点
        data.observations.push(Observation({
            timestamp: block.timestamp,
            priceCumulative: priceCumulative,
            price: currentPrice
        }));
        
        // 移除超出窗口的旧观察点
        while (data.observations.length > 0 && 
               block.timestamp - data.observations[0].timestamp > data.windowSize) {
            // 移除第一个元素（最旧的）
            for (uint i = 0; i < data.observations.length - 1; i++) {
                data.observations[i] = data.observations[i + 1];
            }
            data.observations.pop();
        }
    }
    
    // 获取TWAP价格
    function getTWAP(bytes32 asset) external view returns (uint256) {
        TWAPData storage data = twapData[asset];
        require(data.observations.length >= 2, "Insufficient observations");
        
        uint256 firstIndex = 0;
        uint256 lastIndex = data.observations.length - 1;
        
        // 找到窗口起始点
        for (uint i = lastIndex; i > 0; i--) {
            if (block.timestamp - data.observations[i].timestamp >= data.windowSize) {
                firstIndex = i;
                break;
            }
        }
        
        Observation memory first = data.observations[firstIndex];
        Observation memory last = data.observations[lastIndex];
        
        // 计算TWAP
        uint256 timeDelta = last.timestamp - first.timestamp;
        uint256 priceDelta = last.priceCumulative - first.priceCumulative;
        
        return priceDelta / timeDelta;
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.4 锚定稳定模块(PSM)与真实世界资产(RWA)</h3>
            
            <h4>4.4.1 锚定稳定模块(PSM)</h4>
            <p>PSM是现代抵押稳定币维持价格稳定的最重要机制之一，允许用户1:1的固定汇率兑换其他受信任的稳定币：</p>
            
            <div class="tip-box">
                <strong>🎯 PSM核心机制：</strong>
                <ul>
                    <li><strong>价格套利通道：</strong>当DAI > $1时，用户可以用USDC铸造DAI并卖出套利</li>
                    <li><strong>即时流动性：</strong>提供大量即时可用的流动性</li>
                    <li><strong>中心化风险：</strong>依赖于USDC等中心化稳定币</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">锚定稳定模块实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract PegStabilityModule {
    // 状态变量
    IERC20 public immutable dai;
    IERC20 public immutable usdc;
    IVat public immutable vat;
    
    uint256 public tin;  // 兑入费率 (swap USDC -> DAI)
    uint256 public tout; // 兑出费率 (swap DAI -> USDC)
    
    uint256 public line; // 债务上限
    uint256 public buf;  // USDC目标余额
    
    mapping(address => uint256) public wards;
    
    // 常量
    uint256 constant WAD = 10**18;
    uint256 constant RAY = 10**27;
    uint256 constant TOLL_ONE_PCT = RAY / 100;
    
    // 事件
    event BuyGem(address indexed owner, uint256 value, uint256 fee);
    event SellGem(address indexed owner, uint256 value, uint256 fee);
    
    constructor(
        address dai_,
        address usdc_,
        address vat_
    ) {
        dai = IERC20(dai_);
        usdc = IERC20(usdc_);
        vat = IVat(vat_);
        
        // 初始费率设置为0.1%
        tin = TOLL_ONE_PCT / 10;
        tout = TOLL_ONE_PCT / 10;
    }
    
    // USDC -> DAI (1:1 - 费率)
    function buyGem(address usr, uint256 gemAmt) external {
        require(vat.dai(address(this)) >= gemAmt * RAY, "PSM/insufficient-dai");
        
        uint256 fee = gemAmt * tin / RAY;
        uint256 daiAmt = gemAmt - fee;
        
        // 转入USDC
        usdc.transferFrom(msg.sender, address(this), gemAmt);
        
        // 从Vat中释放DAI
        vat.move(address(this), usr, daiAmt * RAY);
        vat.move(address(this), address(vow), fee * RAY); // 费用给协议
        
        emit BuyGem(usr, gemAmt, fee);
    }
    
    // DAI -> USDC (1:1 - 费率)
    function sellGem(address usr, uint256 daiAmt) external {
        uint256 gemAmt = daiAmt * (RAY - tout) / RAY;
        require(usdc.balanceOf(address(this)) >= gemAmt, "PSM/insufficient-usdc");
        
        // 转入DAI到Vat
        dai.transferFrom(msg.sender, address(this), daiAmt);
        vat.move(msg.sender, address(this), daiAmt * RAY);
        
        // 转出USDC
        usdc.transfer(usr, gemAmt);
        
        uint256 fee = daiAmt - gemAmt;
        emit SellGem(usr, gemAmt, fee);
    }
    
    // 自动补充USDC储备
    function fill() external returns (uint256 wad) {
        uint256 balance = usdc.balanceOf(address(this));
        
        if (balance < buf) {
            wad = buf - balance;
            require(wad <= line, "PSM/over-line");
            
            // 从Vat铸造DAI以购买USDC
            vat.mint(address(this), wad * RAY);
            
            // 通过DEX购买USDC
            // ...
        }
    }
    
    // 紧急冻结
    function cage() external auth {
        live = 0;
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.4.2 真实世界资产(RWA)</h4>
            <p>RWA是2023-2024年DeFi最重要的趋势，MakerDAO已经将大量国库券、房地产贷款等RWA作为抵押品：</p>
            
            <div class="tip-box">
                <strong>🏦 RWA带来的机遇与挑战：</strong>
                <ul>
                    <li><strong>机遇：</strong>更稳定的收益、更大的资产规模、更低的波动性</li>
                    <li><strong>挑战：</strong>对手方风险、法律风险、托管风险、链上表示复杂性</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">RWA抵押品适配器 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// RWA代币化合约
contract RWAToken is ERC721, AccessControl {
    struct RealWorldAsset {
        string assetType;      // “T-Bill”, “RealEstate”, etc
        uint256 maturityDate;  // 到期日
        uint256 principal;     // 本金
        uint256 interestRate;  // 利率
        string legalDocs;      // IPFS hash of legal documents
        address custodian;     // 托管机构
        bool isActive;
    }
    
    mapping(uint256 => RealWorldAsset) public assets;
    mapping(address => bool) public trustedOriginators;
    
    // 发行RWA代币
    function mintRWA(
        address to,
        string memory assetType,
        uint256 maturityDate,
        uint256 principal,
        uint256 interestRate,
        string memory legalDocs
    ) external onlyRole(ORIGINATOR_ROLE) returns (uint256 tokenId) {
        tokenId = _nextTokenId++;
        
        assets[tokenId] = RealWorldAsset({
            assetType: assetType,
            maturityDate: maturityDate,
            principal: principal,
            interestRate: interestRate,
            legalDocs: legalDocs,
            custodian: msg.sender,
            isActive: true
        });
        
        _safeMint(to, tokenId);
        emit RWAMinted(tokenId, assetType, principal);
    }
    
    // 计算当前价值（包括应计利息）
    function currentValue(uint256 tokenId) public view returns (uint256) {
        RealWorldAsset memory asset = assets[tokenId];
        require(asset.isActive, "Asset not active");
        
        if (block.timestamp >= asset.maturityDate) {
            return asset.principal;
        }
        
        // 简单线性计息
        uint256 timeElapsed = block.timestamp - _mintTimestamp[tokenId];
        uint256 totalTime = asset.maturityDate - _mintTimestamp[tokenId];
        uint256 earnedInterest = asset.principal * asset.interestRate * timeElapsed / (totalTime * 10000);
        
        return asset.principal + earnedInterest;
    }
}

// RWA抵押品适配器
contract RWACollateralAdapter {
    IVat public immutable vat;
    RWAToken public immutable rwaToken;
    
    mapping(uint256 => address) public ownership; // tokenId => CDP owner
    
    // 将RWA作为抵押品
    function join(address usr, uint256 tokenId) external {
        require(rwaToken.ownerOf(tokenId) == msg.sender, "Not token owner");
        
        // 转移代币到适配器
        rwaToken.transferFrom(msg.sender, address(this), tokenId);
        ownership[tokenId] = usr;
        
        // 获取代币价值
        uint256 value = rwaToken.currentValue(tokenId);
        
        // 在Vat中增加抵押品
        vat.slip("RWA", usr, int256(value));
    }
    
    // 提取RWA
    function exit(address usr, uint256 tokenId) external {
        require(ownership[tokenId] == usr, "Not owner");
        
        uint256 value = rwaToken.currentValue(tokenId);
        
        // 从Vat中减少抵押品
        vat.slip("RWA", usr, -int256(value));
        
        // 返还代币
        rwaToken.transferFrom(address(this), usr, tokenId);
        delete ownership[tokenId];
    }
    
    // 定期更新价值
    function revalue(uint256 tokenId) external {
        address usr = ownership[tokenId];
        require(usr != address(0), "Token not deposited");
        
        uint256 oldValue = vat.gem("RWA", usr);
        uint256 newValue = rwaToken.currentValue(tokenId);
        
        int256 diff = int256(newValue) - int256(oldValue);
        if (diff != 0) {
            vat.slip("RWA", usr, diff);
            emit Revalued(tokenId, oldValue, newValue);
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.5 实践项目：构建超额抵押稳定币系统</h3>
            
            <h4>4.4.1 系统架构设计</h4>
            <p>我们将构建一个完整的超额抵押稳定币系统，包含以下核心组件：</p>
            
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <pre style="margin: 0; font-family: monospace; line-height: 1.5;">
┌─────────────────────────────────────────────────────────┐
│                    用户界面                              │
├─────────────────────────────────────────────────────────┤
│                  CDP Manager                             │
│  - 开仓/关仓    - 存入/提取抵押品    - 铸造/偿还DAI      │
├──────────────┬──────────────┬───────────────────────────┤
│   金库引擎    │   清算引擎    │      稳定模块            │
│  (Vat.sol)   │  (Dog.sol)   │    (PSM.sol)            │
├──────────────┴──────────────┴───────────────────────────┤
│                  价格预言机系统                           │
│        Chainlink │ Uniswap V3 │ 内部预言机              │
├─────────────────────────────────────────────────────────┤
│                   拍卖系统                               │
│     抵押品拍卖 │ 债务拍卖 │ 盈余拍卖                    │
└─────────────────────────────────────────────────────────┘
                </pre>
            </div>
            
            <h4>4.4.2 完整实现</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">超额抵押稳定币完整实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// 主金库合约
contract Vat {
    // 核心数据结构
    struct Ilk {  // 抵押品类型
        uint256 Art;   // 总标准化债务
        uint256 rate;  // 累积稳定费率
        uint256 spot;  // 价格安全边际
        uint256 line;  // 债务上限
        uint256 dust;  // 最小债务量
    }
    
    struct Urn {  // CDP
        uint256 ink;   // 锁定的抵押品
        uint256 art;   // 标准化债务
    }
    
    mapping(bytes32 => Ilk) public ilks;
    mapping(bytes32 => mapping(address => Urn)) public urns;
    mapping(address => uint256) public dai;
    mapping(address => uint256) public sin;
    
    uint256 public Line;  // 全局债务上限
    uint256 public live = 1;  // 系统状态
    
    // 常量
    uint256 constant RAY = 10 ** 27;
    uint256 constant WAD = 10 ** 18;
    
    // 权限管理
    mapping(address => uint256) public wards;
    modifier auth() {
        require(wards[msg.sender] == 1, "Vat/not-authorized");
        _;
    }
    
    // 初始化抵押品类型
    function init(bytes32 ilk) external auth {
        require(ilks[ilk].rate == 0, "Vat/ilk-already-init");
        ilks[ilk].rate = RAY;
    }
    
    // 修改CDP
    function frob(
        bytes32 i,
        address u,
        address v,
        address w,
        int256 dink,
        int256 dart
    ) external {
        require(live == 1, "Vat/not-live");
        
        Urn memory urn = urns[i][u];
        Ilk memory ilk = ilks[i];
        
        urn.ink = _add(urn.ink, dink);
        urn.art = _add(urn.art, dart);
        ilk.Art = _add(ilk.Art, dart);
        
        int256 dtab = _mul(ilk.rate, dart);
        uint256 tab = _mul(ilk.rate, urn.art);
        
        // 债务上限检查
        require(ilk.Art * ilk.rate <= ilk.line, "Vat/ilk-line-exceeded");
        require(Line >= dai[address(this)], "Vat/global-line-exceeded");
        
        // 抵押率检查
        require(either(dart <= 0, tab <= _mul(urn.ink, ilk.spot)), "Vat/not-safe");
        
        // 最小债务检查
        require(either(urn.art == 0, tab >= ilk.dust), "Vat/dust");
        
        // 转移抵押品
        if (dink != 0) {
            gem[i][v] = _sub(gem[i][v], dink);
            gem[i][w] = _add(gem[i][w], dink);
        }
        
        // 转移债务
        if (dtab != 0) {
            dai[v] = _sub(dai[v], dtab);
            dai[w] = _add(dai[w], dtab);
        }
        
        urns[i][u] = urn;
        ilks[i] = ilk;
    }
    
    // 没收CDP（清算时调用）
    function grab(
        bytes32 i,
        address u,
        address v,
        address w,
        int256 dink,
        int256 dart
    ) external auth {
        Urn storage urn = urns[i][u];
        Ilk storage ilk = ilks[i];
        
        urn.ink = _add(urn.ink, dink);
        urn.art = _add(urn.art, dart);
        ilk.Art = _add(ilk.Art, dart);
        
        int256 dtab = _mul(ilk.rate, dart);
        
        gem[i][v] = _sub(gem[i][v], dink);
        sin[w] = _sub(sin[w], dtab);
    }
}

// DAI代币合约
contract Dai is ERC20 {
    // 映射Vat授权
    mapping(address => uint256) public wards;
    modifier auth() {
        require(wards[msg.sender] == 1, "Dai/not-authorized");
        _;
    }
    
    constructor() ERC20("Dai Stablecoin", "DAI") {
        wards[msg.sender] = 1;
    }
    
    // 从Vat铸造DAI
    function mint(address usr, uint256 wad) external auth {
        _mint(usr, wad);
    }
    
    // 销毁DAI返还给Vat
    function burn(address usr, uint256 wad) external {
        _burn(usr, wad);
    }
}

// CDP管理接口
contract CDPManager {
    Vat public vat;
    mapping(uint256 => address) public cdps;
    mapping(address => uint256[]) public userCdps;
    uint256 public nextCdpId = 1;
    
    // 开启CDP
    function openCDP(bytes32 ilk) external returns (uint256 cdpId) {
        cdpId = nextCdpId++;
        cdps[cdpId] = msg.sender;
        userCdps[msg.sender].push(cdpId);
        
        emit CDPOpened(cdpId, msg.sender, ilk);
    }
    
    // 存入抵押品并借出DAI
    function lockAndDraw(
        uint256 cdpId,
        uint256 collateralAmount,
        uint256 daiAmount
    ) external {
        require(cdps[cdpId] == msg.sender, "Not CDP owner");
        
        // 转入抵押品
        collateral.transferFrom(msg.sender, address(this), collateralAmount);
        
        // 在Vat中记账
        vat.frob(
            ilk,
            msg.sender,
            address(this),
            msg.sender,
            int256(collateralAmount),
            int256(daiAmount)
        );
        
        // 铸造DAI给用户
        dai.mint(msg.sender, daiAmount);
    }
    
    // 偿还DAI并取回抵押品
    function wipeAndFree(
        uint256 cdpId,
        uint256 collateralAmount,
        uint256 daiAmount
    ) external {
        require(cdps[cdpId] == msg.sender, "Not CDP owner");
        
        // 销毁DAI
        dai.burn(msg.sender, daiAmount);
        
        // 在Vat中记账
        vat.frob(
            ilk,
            msg.sender,
            msg.sender,
            address(this),
            -int256(collateralAmount),
            -int256(daiAmount)
        );
        
        // 返还抵押品
        collateral.transfer(msg.sender, collateralAmount);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>4.4.3 部署和测试脚本</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">部署脚本 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-javascript">const { ethers } = require("hardhat");

async function main() {
    const [deployer] = await ethers.getSigners();
    
    console.log("Deploying contracts with account:", deployer.address);
    
    // 1. 部署核心合约
    const Vat = await ethers.getContractFactory("Vat");
    const vat = await Vat.deploy();
    await vat.deployed();
    console.log("Vat deployed to:", vat.address);
    
    // 2. 部署DAI
    const Dai = await ethers.getContractFactory("Dai");
    const dai = await Dai.deploy();
    await dai.deployed();
    console.log("DAI deployed to:", dai.address);
    
    // 3. 部署价格预言机
    const Oracle = await ethers.getContractFactory("PriceOracle");
    const oracle = await Oracle.deploy();
    await oracle.deployed();
    console.log("Oracle deployed to:", oracle.address);
    
    // 4. 部署清算引擎
    const Dog = await ethers.getContractFactory("LiquidationEngine");
    const dog = await Dog.deploy(vat.address);
    await dog.deployed();
    console.log("Dog deployed to:", dog.address);
    
    // 5. 部署CDP管理器
    const CDPManager = await ethers.getContractFactory("CDPManager");
    const cdpManager = await CDPManager.deploy(vat.address, dai.address);
    await cdpManager.deployed();
    console.log("CDPManager deployed to:", cdpManager.address);
    
    // 6. 配置权限
    await vat.rely(dog.address);
    await vat.rely(cdpManager.address);
    await dai.rely(cdpManager.address);
    
    // 7. 初始化抵押品类型（ETH）
    const ethIlk = ethers.utils.formatBytes32String("ETH-A");
    await vat.init(ethIlk);
    
    // 设置抵押品参数
    await vat.file(ethIlk, "line", ethers.utils.parseEther("1000000")); // 100万债务上限
    await vat.file(ethIlk, "dust", ethers.utils.parseEther("100"));     // 最小100 DAI
    await vat.file(ethIlk, "spot", ethers.utils.parseEther("1.5"));     // 150%抵押率
    
    // 8. 设置预言机价格
    await oracle.setPrice(ethIlk, ethers.utils.parseEther("2000")); // ETH = $2000
    
    console.log("Deployment complete!");
    
    // 保存部署地址
    const addresses = {
        vat: vat.address,
        dai: dai.address,
        oracle: oracle.address,
        dog: dog.address,
        cdpManager: cdpManager.address
    };
    
    const fs = require("fs");
    fs.writeFileSync(
        "./deployments/addresses.json",
        JSON.stringify(addresses, null, 2)
    );
}

main()
    .then(() => process.exit(0))
    .catch(error => {
        console.error(error);
        process.exit(1);
    });</code></pre>
                </div>
            </div>
            
            <h3>练习题</h3>
            
            <div class="exercise">
                <h4>练习 4.1：实现动态稳定费</h4>
                <p>设计并实现一个动态调整稳定费的机制，根据以下因素自动调整：</p>
                <ul>
                    <li>DAI的市场价格偏离情况</li>
                    <li>系统总债务量</li>
                    <li>抵押品价格波动率</li>
                </ul>
                <p>要求：使用PID控制器或其他控制理论方法。</p>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract DynamicStabilityFee {
    // PID控制器参数
    struct PIDController {
        int256 kp;        // 比例系数
        int256 ki;        // 积分系数
        int256 kd;        // 微分系数
        int256 integral;  // 积分累积
        int256 lastError; // 上次误差
    }
    
    PIDController public feeController;
    uint256 public targetPrice = 1e18;  // 目标价格 $1
    uint256 public baseFee = 2e16;     // 基础费率 2%
    
    // 历史数据
    uint256[] public priceHistory;
    uint256[] public debtHistory;
    uint256 public constant HISTORY_SIZE = 24; // 24小时
    
    // 更新稳定费
    function updateStabilityFee() external {
        // 获取当前DAI价格
        uint256 currentPrice = oracle.getDaiPrice();
        
        // 计算价格误差
        int256 error = int256(targetPrice) - int256(currentPrice);
        
        // PID计算
        int256 proportional = feeController.kp * error / 1e18;
        
        feeController.integral += error;
        int256 integral = feeController.ki * feeController.integral / 1e18;
        
        int256 derivative = feeController.kd * (error - feeController.lastError) / 1e18;
        
        // 计算调整量
        int256 adjustment = proportional + integral + derivative;
        
        // 考虑其他因素
        uint256 volatilityMultiplier = calculateVolatility();
        uint256 debtMultiplier = calculateDebtPressure();
        
        // 计算新费率
        uint256 newFee = baseFee;
        if (adjustment > 0) {
            newFee += uint256(adjustment) * volatilityMultiplier / 1e18;
        } else {
            uint256 decrease = uint256(-adjustment) * volatilityMultiplier / 1e18;
            newFee = newFee > decrease ? newFee - decrease : baseFee / 2;
        }
        
        // 应用债务压力调整
        newFee = newFee * debtMultiplier / 1e18;
        
        // 限制费率范围
        if (newFee < 1e15) newFee = 1e15;       // 最低0.1%
        if (newFee > 20e16) newFee = 20e16;     // 最高20%
        
        // 更新费率
        updateIlkStabilityFee(newFee);
        
        feeController.lastError = error;
    }
    
    // 计算价格波动率
    function calculateVolatility() internal view returns (uint256) {
        if (priceHistory.length < 2) return 1e18;
        
        uint256 sum = 0;
        uint256 sumSquared = 0;
        
        for (uint i = 0; i < priceHistory.length; i++) {
            sum += priceHistory[i];
            sumSquared += priceHistory[i] ** 2;
        }
        
        uint256 mean = sum / priceHistory.length;
        uint256 variance = sumSquared / priceHistory.length - mean ** 2;
        uint256 stdDev = sqrt(variance);
        
        // 波动率越高，调整幅度越小
        return 1e18 * 1e18 / (1e18 + stdDev);
    }
    
    // 计算债务压力
    function calculateDebtPressure() internal view returns (uint256) {
        uint256 currentDebt = vat.debt();
        uint256 debtCeiling = vat.Line();
        
        uint256 utilization = currentDebt * 1e18 / debtCeiling;
        
        // 利用率越高，费率越高
        if (utilization > 80e16) {  // > 80%
            return 15e17;  // 1.5x
        } else if (utilization > 60e16) {  // > 60%
            return 12e17;  // 1.2x
        } else {
            return 1e18;   // 1x
        }
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>练习 4.2：实现闪电清算</h4>
                <p>设计一个闪电清算（Flash Liquidation）机制，允许清算者在单笔交易中：</p>
                <ul>
                    <li>借入DAI进行清算</li>
                    <li>获得折价抵押品</li>
                    <li>在DEX上卖出抵押品</li>
                    <li>偿还借入的DAI并获利</li>
                </ul>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract FlashLiquidator {
    IVat public vat;
    IDog public dog;
    IERC20 public dai;
    IUniswapV2Router public router;
    
    // 闪电清算
    function flashLiquidate(
        bytes32 ilk,
        address urn,
        address[] calldata swapPath
    ) external {
        // 1. 检查CDP是否可清算
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        (, uint256 rate, uint256 spot,,) = vat.ilks(ilk);
        
        require(ink * spot < art * rate, "CDP is safe");
        
        // 2. 计算需要的DAI
        uint256 dartNeeded = art;
        uint256 daiNeeded = dartNeeded * rate / RAY;
        
        // 3. 闪电贷DAI
        dai.flashLoan(address(this), daiNeeded, "");
    }
    
    // 闪电贷回调
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        require(msg.sender == address(dai), "Unknown lender");
        require(initiator == address(this), "Unknown initiator");
        
        (bytes32 ilk, address urn, address[] memory swapPath) = 
            abi.decode(data, (bytes32, address, address[]));
        
        // 4. 执行清算
        uint256 collateralReceived = dog.bark(ilk, urn);
        
        // 5. 在DEX卖出抵押品
        IERC20(swapPath[0]).approve(address(router), collateralReceived);
        
        uint256[] memory amounts = router.swapExactTokensForTokens(
            collateralReceived,
            amount + fee,  // 至少要换回贷款+手续费
            swapPath,
            address(this),
            block.timestamp
        );
        
        uint256 daiReceived = amounts[amounts.length - 1];
        require(daiReceived >= amount + fee, "Insufficient profit");
        
        // 6. 偿还闪电贷
        dai.approve(msg.sender, amount + fee);
        
        // 7. 转移利润
        uint256 profit = daiReceived - amount - fee;
        dai.transfer(tx.origin, profit);
        
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
    
    // 计算清算利润
    function calculateProfit(
        bytes32 ilk,
        address urn,
        address[] calldata swapPath
    ) external view returns (uint256) {
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        (, uint256 rate,,,) = vat.ilks(ilk);
        
        uint256 daiNeeded = art * rate / RAY;
        uint256 collateralReceived = ink;  // 简化，实际有罚金
        
        // 获取DEX报价
        uint256[] memory amounts = router.getAmountsOut(
            collateralReceived,
            swapPath
        );
        uint256 daiFromSwap = amounts[amounts.length - 1];
        
        // 扣除闪电贷费用（假设0.09%）
        uint256 flashFee = daiNeeded * 9 / 10000;
        
        if (daiFromSwap > daiNeeded + flashFee) {
            return daiFromSwap - daiNeeded - flashFee;
        }
        return 0;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>练习 4.3：实现多抵押品组合</h4>
                <p>扩展CDP系统支持多种抵押品组合在同一个CDP中，要求：</p>
                <ul>
                    <li>支持不同权重的抵押品</li>
                    <li>实现组合抵押率计算</li>
                    <li>支持部分清算不同抵押品</li>
                    <li>考虑抵押品之间的相关性</li>
                </ul>
                
                <div class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案 ▼</div>
                <div class="answer" style="display: none;">
                    <pre><code class="language-solidity">contract MultiCollateralCDP {
    struct CollateralPosition {
        uint256 amount;
        uint256 weight;      // 权重（基点）
        uint256 lastPrice;   // 上次价格
    }
    
    struct MultiCDP {
        mapping(bytes32 => CollateralPosition) collaterals;
        uint256 totalDebt;
        uint256 lastUpdateTime;
        bytes32[] collateralTypes;
    }
    
    mapping(address => mapping(uint256 => MultiCDP)) public cdps;
    mapping(bytes32 => mapping(bytes32 => uint256)) public correlations; // 相关性矩阵
    
    // 添加抵押品到CDP
    function addCollateral(
        uint256 cdpId,
        bytes32 ilk,
        uint256 amount
    ) external {
        MultiCDP storage cdp = cdps[msg.sender][cdpId];
        
        // 转入抵押品
        IERC20(collateralTokens[ilk]).transferFrom(
            msg.sender,
            address(this),
            amount
        );
        
        // 更新仓位
        if (cdp.collaterals[ilk].amount == 0) {
            cdp.collateralTypes.push(ilk);
        }
        
        cdp.collaterals[ilk].amount += amount;
        cdp.collaterals[ilk].lastPrice = getPrice(ilk);
        
        // 重新计算权重
        _updateWeights(cdpId);
    }
    
    // 计算组合抵押率（考虑相关性）
    function getPortfolioCollateralization(uint256 cdpId) 
        external 
        view 
        returns (uint256 ratio, uint256 var) 
    {
        MultiCDP storage cdp = cdps[msg.sender][cdpId];
        
        uint256 totalValue = 0;
        uint256 portfolioVariance = 0;
        
        // 计算总价值和方差
        for (uint i = 0; i < cdp.collateralTypes.length; i++) {
            bytes32 ilk1 = cdp.collateralTypes[i];
            CollateralPosition memory pos1 = cdp.collaterals[ilk1];
            uint256 value1 = pos1.amount * getPrice(ilk1) / 1e18;
            totalValue += value1;
            
            // 计算方差贡献
            uint256 vol1 = getVolatility(ilk1);
            portfolioVariance += (pos1.weight ** 2) * (vol1 ** 2) / 1e36;
            
            // 计算协方差贡献
            for (uint j = i + 1; j < cdp.collateralTypes.length; j++) {
                bytes32 ilk2 = cdp.collateralTypes[j];
                CollateralPosition memory pos2 = cdp.collaterals[ilk2];
                uint256 vol2 = getVolatility(ilk2);
                uint256 corr = correlations[ilk1][ilk2];
                
                portfolioVariance += 2 * pos1.weight * pos2.weight * 
                                   vol1 * vol2 * corr / 1e54;
            }
        }
        
        // 计算VaR调整后的抵押率
        uint256 portfolioVol = sqrt(portfolioVariance);
        uint256 varAdjustedValue = totalValue * (1e18 - 2 * portfolioVol) / 1e18;
        
        if (cdp.totalDebt > 0) {
            ratio = varAdjustedValue * 100 / cdp.totalDebt;
        } else {
            ratio = type(uint256).max;
        }
        
        var = portfolioVol;
    }
    
    // 部分清算
    function partialLiquidate(
        address owner,
        uint256 cdpId,
        bytes32 ilkToLiquidate,
        uint256 debtToRepay
    ) external {
        MultiCDP storage cdp = cdps[owner][cdpId];
        
        // 检查是否可清算
        (uint256 ratio,) = getPortfolioCollateralization(cdpId);
        require(ratio < liquidationRatio, "CDP is safe");
        
        // 计算要清算的抵押品数量
        uint256 price = getPrice(ilkToLiquidate);
        uint256 collateralNeeded = debtToRepay * 1e18 * 
                                  (100 + liquidationPenalty) / (price * 100);
        
        require(cdp.collaterals[ilkToLiquidate].amount >= collateralNeeded,
                "Insufficient collateral");
        
        // 执行清算
        dai.transferFrom(msg.sender, address(this), debtToRepay);
        cdp.totalDebt -= debtToRepay;
        
        cdp.collaterals[ilkToLiquidate].amount -= collateralNeeded;
        IERC20(collateralTokens[ilkToLiquidate]).transfer(
            msg.sender,
            collateralNeeded
        );
        
        // 如果抵押品清空，从列表中移除
        if (cdp.collaterals[ilkToLiquidate].amount == 0) {
            _removeCollateralType(cdp, ilkToLiquidate);
        }
        
        // 重新计算权重
        _updateWeights(cdpId);
    }
    
    // 更新权重
    function _updateWeights(uint256 cdpId) internal {
        MultiCDP storage cdp = cdps[msg.sender][cdpId];
        uint256 totalValue = 0;
        
        // 计算总价值
        for (uint i = 0; i < cdp.collateralTypes.length; i++) {
            bytes32 ilk = cdp.collateralTypes[i];
            uint256 value = cdp.collaterals[ilk].amount * getPrice(ilk) / 1e18;
            totalValue += value;
        }
        
        // 更新权重
        for (uint i = 0; i < cdp.collateralTypes.length; i++) {
            bytes32 ilk = cdp.collateralTypes[i];
            uint256 value = cdp.collaterals[ilk].amount * getPrice(ilk) / 1e18;
            cdp.collaterals[ilk].weight = value * 10000 / totalValue;
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>4.6 案例研究：2020年3月黑色星期四</h3>
            
            <div class="tip-box">
                <strong>📉 事件回顾：</strong>
                <p>2020年3月12-13日，加密市场经历了历史上最剧烈的价格暴跌：</p>
                <ul>
                    <li>ETH价格在24小时内从$194跌至$87，跌幅超过50%</li>
                    <li>Gas价格飙升至正常水平的100倍以上</li>
                    <li>MakerDAO系统出现$0竞价清算，造成$5.67M损失</li>
                    <li>DAI一度脱锚至$1.12</li>
                </ul>
            </div>
            
            <h4>4.6.1 问题分析</h4>
            <table class="comparison-table">
                <tr>
                    <th>问题类型</th>
                    <th>具体表现</th>
                    <th>根本原因</th>
                    <th>改进措施</th>
                </tr>
                <tr>
                    <td>预言机延迟</td>
                    <td>价格更新严重滞后</td>
                    <td>Gas价格过高，预言机无法更新</td>
                    <td>引入OSM 1小时延迟</td>
                </tr>
                <tr>
                    <td>Keeper失效</td>
                    <td>$0竞价成功</td>
                    <td>Keeper机器人配置不当</td>
                    <td>Liquidation 2.0</td>
                </tr>
                <tr>
                    <td>拍卖机制缺陷</td>
                    <td>大量抵押品被低价拍卖</td>
                    <td>拍卖时间过长，市场变化太快</td>
                    <td>固定折扣即时清算</td>
                </tr>
                <tr>
                    <td>系统坏账</td>
                    <td>$5.67M坏账</td>
                    <td>清算收入不足以覆盖债务</td>
                    <td>债务拍卖+紧急关停</td>
                </tr>
            </table>
            
            <h4>4.6.2 教训与改进</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">改进后的清算系统 (Liquidation 2.0) <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// Liquidation 2.0 核心改进
contract LiquidationEngine2 {
    // 主要改进点：
    // 1. 固定折扣价格而非拍卖
    // 2. 即时清算，无需等待
    // 3. 部分清算支持
    // 4. 更好的Keeper激励
    
    struct LiquidationConfig {
        uint256 discount;        // 清算折扣 (e.g., 5%)
        uint256 maxAuction;      // 单次最大清算量
        uint256 tip;             // Keeper小费
        uint256 chip;            // 每单位抵押品奖励
        uint256 hole;            // 总清算限额
    }
    
    // 即时清算函数
    function bark(
        bytes32 ilk,
        address urn,
        address kpr  // keeper地址
    ) external returns (uint256 id) {
        // 检查CDP是否可清算
        require(unsafe(ilk, urn), "CDP is safe");
        
        // 计算清算参数
        (uint256 ink, uint256 art) = vat.urns(ilk, urn);
        uint256 dart = min(art, config.maxAuction);
        uint256 dink = ink * dart / art;
        
        // 创建清算拍卖
        id = auctions.length++;
        auctions[id] = Auction({
            urn: urn,
            ink: dink,
            art: dart,
            usr: address(0),
            tic: 0,
            top: 0
        });
        
        // 即时奖励keeper
        uint256 reward = config.tip + (dink * config.chip);
        vat.mint(kpr, reward);
        
        emit Bark(ilk, urn, ink, art, dart, config.clip, id);
    }
    
    // 拍卖参与 (固定折扣)
    function take(
        uint256 id,
        uint256 amt,  // 想要的抵押品数量
        uint256 max,  // 愿意支付的最大DAI
        address who,  // 接收地址
        bytes calldata data
    ) external {
        Auction storage auction = auctions[id];
        
        // 计算价格 (市场价 * (1 - 折扣))
        uint256 price = oracle.price(ilk) * (100 - config.discount) / 100;
        
        // 计算实际数量
        uint256 slice = min(auction.ink, amt);
        uint256 owe = slice * price;
        
        require(owe <= max, "Price too high");
        require(owe <= auction.art, "Insufficient debt");
        
        // 执行清算
        auction.ink -= slice;
        auction.art -= owe;
        
        // 转移资产
        vat.flux(ilk, address(this), who, slice);
        vat.move(msg.sender, vow, owe);
        
        // 如果完全清算，返还剩余抵押品
        if (auction.art == 0 && auction.ink > 0) {
            vat.flux(ilk, address(this), auction.usr, auction.ink);
            auction.ink = 0;
        }
        
        emit Take(id, slice, owe, price);
    }
}</code></pre>
                </div>
            </div>
            
            <div class="practice-section">
                <h3>📝 第四章练习题</h3>
                
                <div class="exercise">
                    <h4>练习 4.1：实现局部清算机制</h4>
                    <p>设计并实现一个支持局部清算的CDP系统，允许用户通过部分偿还债务来避免全部清算。</p>
                    <p>要求：</p>
                    <ul>
                        <li>支持按比例清算部分抵押品</li>
                        <li>保留最低健康因子以上的部分</li>
                        <li>实现公平的奖励机制</li>
                        <li>防止恶意小额清算攻击</li>
                    </ul>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <pre><code class="language-solidity">contract PartialLiquidation {
    uint256 constant MIN_PARTIAL_LIQUIDATION = 1000 * 1e18; // 最小清算金额
    uint256 constant TARGET_HEALTH_FACTOR = 150; // 目标健康因子150%
    
    struct PartialLiquidationParams {
        uint256 maxLiquidationRatio; // 最大清算比例 (50%)
        uint256 minHealthFactor;     // 最低保留健康因子
        uint256 liquidatorBonus;     // 清算奖励 (5%)
        uint256 protocolFee;         // 协议费用 (1%)
    }
    
    function partialLiquidate(
        address user,
        bytes32 ilk,
        uint256 debtToRepay
    ) external {
        CDP storage cdp = cdps[ilk][user];
        require(getHealthFactor(ilk, user) < 100, "CDP is healthy");
        
        // 计算最大可清算金额
        uint256 maxLiquidation = cdp.debt * params.maxLiquidationRatio / 100;
        uint256 actualLiquidation = min(debtToRepay, maxLiquidation);
        
        // 确保满足最小清算金额
        require(actualLiquidation >= MIN_PARTIAL_LIQUIDATION, "Too small");
        
        // 计算需要的抵押品
        uint256 collateralPrice = getPrice(ilk);
        uint256 collateralNeeded = actualLiquidation * 1e18 / collateralPrice;
        uint256 liquidatorBonus = collateralNeeded * params.liquidatorBonus / 100;
        uint256 protocolFee = collateralNeeded * params.protocolFee / 100;
        
        uint256 totalCollateral = collateralNeeded + liquidatorBonus + protocolFee;
        require(cdp.collateral >= totalCollateral, "Insufficient collateral");
        
        // 检查剩余健康因子
        uint256 remainingCollateral = cdp.collateral - totalCollateral;
        uint256 remainingDebt = cdp.debt - actualLiquidation;
        uint256 remainingHealthFactor = (remainingCollateral * collateralPrice * 100) / (remainingDebt * 1e18);
        
        require(remainingHealthFactor >= params.minHealthFactor, "Would leave CDP too unhealthy");
        
        // 执行清算
        dai.transferFrom(msg.sender, address(this), actualLiquidation);
        cdp.debt -= actualLiquidation;
        
        cdp.collateral -= totalCollateral;
        collateralToken.transfer(msg.sender, collateralNeeded + liquidatorBonus);
        collateralToken.transfer(treasury, protocolFee);
        
        emit PartialLiquidation(user, ilk, actualLiquidation, totalCollateral);
    }
    
    // 自动计算最佳清算量
    function calculateOptimalLiquidation(
        address user,
        bytes32 ilk
    ) public view returns (uint256 optimalAmount) {
        CDP memory cdp = cdps[ilk][user];
        uint256 currentHealthFactor = getHealthFactor(ilk, user);
        
        if (currentHealthFactor >= 100) return 0;
        
        // 计算达到目标健康因子所需的清算量
        uint256 collateralPrice = getPrice(ilk);
        uint256 collateralValue = cdp.collateral * collateralPrice / 1e18;
        
        // 目标: (collateralValue - liquidationValue) / (debt - liquidationAmount) = 1.5
        // 求解 liquidationAmount
        uint256 targetDebt = collateralValue * 100 / TARGET_HEALTH_FACTOR;
        optimalAmount = cdp.debt - targetDebt;
        
        // 应用限制
        optimalAmount = min(optimalAmount, cdp.debt * params.maxLiquidationRatio / 100);
        optimalAmount = max(optimalAmount, MIN_PARTIAL_LIQUIDATION);
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>练习 4.2：设计抗MEV的清算系统</h4>
                    <p>设计一个能够抵抗MEV攻击的清算系统，保护被清算用户和诚实Keeper的利益。</p>
                    <p>要求：</p>
                    <ul>
                        <li>防止抢跑和三明治攻击</li>
                        <li>保护隐私和公平性</li>
                        <li>保持系统效率</li>
                        <li>实现去中心化</li>
                    </ul>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <pre><code class="language-solidity">contract MEVResistantLiquidation {
    using ECDSA for bytes32;
    
    // 时间加权竞拍
    struct TimeLockAuction {
        uint256 startTime;
        uint256 commitDeadline;
        uint256 revealDeadline;
        mapping(address => bytes32) commitments;
        mapping(address => Bid) bids;
        uint256 highestBid;
        address winner;
    }
    
    struct Bid {
        uint256 amount;
        uint256 nonce;
        bool revealed;
    }
    
    // VDF (可验证延迟函数) 参数
    uint256 constant VDF_DIFFICULTY = 1000000;
    
    // 批量清算池
    struct LiquidationBatch {
        uint256 startBlock;
        uint256 endBlock;
        address[] liquidatableUsers;
        mapping(address => uint256) liquidatorScores;
        bool settled;
    }
    
    // 提交加密竞价
    function commitBid(
        uint256 auctionId,
        bytes32 commitment
    ) external {
        TimeLockAuction storage auction = auctions[auctionId];
        require(block.timestamp < auction.commitDeadline, "Commit phase ended");
        
        auction.commitments[msg.sender] = commitment;
        emit BidCommitted(auctionId, msg.sender);
    }
    
    // 揭示竞价 (使用VDF延迟)
    function revealBid(
        uint256 auctionId,
        uint256 bidAmount,
        uint256 nonce,
        uint256 vdfOutput,
        bytes memory vdfProof
    ) external {
        TimeLockAuction storage auction = auctions[auctionId];
        require(block.timestamp >= auction.commitDeadline, "Still in commit phase");
        require(block.timestamp < auction.revealDeadline, "Reveal phase ended");
        
        // 验证commitment
        bytes32 commitment = keccak256(abi.encodePacked(bidAmount, nonce, msg.sender));
        require(auction.commitments[msg.sender] == commitment, "Invalid reveal");
        
        // 验证VDF
        require(verifyVDF(commitment, vdfOutput, vdfProof, VDF_DIFFICULTY), "Invalid VDF");
        
        // 记录竞价
        auction.bids[msg.sender] = Bid({
            amount: bidAmount,
            nonce: nonce,
            revealed: true
        });
        
        if (bidAmount > auction.highestBid) {
            auction.highestBid = bidAmount;
            auction.winner = msg.sender;
        }
    }
    
    // 批量清算处理
    function processBatchLiquidation(
        uint256 batchId
    ) external {
        LiquidationBatch storage batch = batches[batchId];
        require(block.number >= batch.endBlock, "Batch not ended");
        require(!batch.settled, "Already settled");
        
        // 使用加权随机选择
        uint256 seed = uint256(keccak256(abi.encode(block.timestamp, block.difficulty)));
        
        // 按照评分加权分配清算机会
        for (uint i = 0; i < batch.liquidatableUsers.length; i++) {
            address user = batch.liquidatableUsers[i];
            address selectedLiquidator = selectWeightedRandom(batch, seed + i);
            
            // 执行清算
            performLiquidation(user, selectedLiquidator);
        }
        
        batch.settled = true;
    }
    
    // 私密清算池
    function submitPrivateLiquidation(
        bytes calldata encryptedData,
        bytes calldata zkProof
    ) external {
        // 验证零知识证明
        require(verifyZKProof(zkProof), "Invalid proof");
        
        // 存储加密数据，等待批量处理
        privateLiquidations.push(encryptedData);
        
        // 当达到阈值时触发批处理
        if (privateLiquidations.length >= BATCH_SIZE) {
            processPrivateBatch();
        }
    }
    
    // 声誉系统
    mapping(address => uint256) public keeperReputation;
    
    function updateReputation(address keeper, bool success) internal {
        if (success) {
            keeperReputation[keeper] += 10;
        } else {
            keeperReputation[keeper] = keeperReputation[keeper] * 90 / 100; // -10%
        }
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>练习 4.3：实现动态稳定费率</h4>
                    <p>设计一个基于PID控制器的动态稳定费率系统，根据稳定币的市场价格自动调整利率。</p>
                    <p>要求：</p>
                    <ul>
                        <li>实现PID控制器逻辑</li>
                        <li>考虑市场供需关系</li>
                        <li>设置合理的参数范围</li>
                        <li>平滑调整避免震荡</li>
                    </ul>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <pre><code class="language-solidity">contract DynamicStabilityFee {
    // PID控制器参数
    struct PIDController {
        int256 kp;        // 比例系数
        int256 ki;        // 积分系数
        int256 kd;        // 微分系数
        int256 integral;  // 积分累积
        int256 lastError; // 上次误差
    }
    
    // 系统参数
    uint256 constant TARGET_PRICE = 1e18;  // $1
    uint256 constant UPDATE_INTERVAL = 1 hours;
    uint256 constant MAX_FEE = 20e16;     // 20% APR
    uint256 constant MIN_FEE = 0;          // 0% APR
    uint256 constant SMOOTHING_FACTOR = 10; // 平滑因子
    
    PIDController public controller = PIDController({
        kp: 1e15,  // 0.001
        ki: 1e14,  // 0.0001
        kd: 1e13,  // 0.00001
        integral: 0,
        lastError: 0
    });
    
    uint256 public currentFee;
    uint256 public lastUpdateTime;
    
    // 价格历史记录
    uint256[] public priceHistory;
    uint256 constant HISTORY_SIZE = 24; // 24小时
    
    // 更新稳定费率
    function updateStabilityFee() external {
        require(block.timestamp >= lastUpdateTime + UPDATE_INTERVAL, "Too soon");
        
        // 获取当前市场价格
        uint256 currentPrice = getMarketPrice();
        
        // 记录价格历史
        priceHistory.push(currentPrice);
        if (priceHistory.length > HISTORY_SIZE) {
            for (uint i = 0; i < priceHistory.length - 1; i++) {
                priceHistory[i] = priceHistory[i + 1];
            }
            priceHistory.pop();
        }
        
        // 计算PID输出
        int256 newFee = calculatePID(currentPrice);
        
        // 应用平滑
        uint256 smoothedFee = applySmooting(uint256(newFee));
        
        // 应用限制
        currentFee = bound(smoothedFee, MIN_FEE, MAX_FEE);
        
        // 更新所有CDP的累积利率
        updateAccumulatedRates();
        
        lastUpdateTime = block.timestamp;
        emit FeeUpdated(currentFee, currentPrice);
    }
    
    // PID计算
    function calculatePID(uint256 currentPrice) internal returns (int256) {
        // 计算误差 (price - target)
        int256 error = int256(currentPrice) - int256(TARGET_PRICE);
        
        // P项
        int256 p = controller.kp * error / 1e18;
        
        // I项
        controller.integral += error;
        // 防止积分饱和
        controller.integral = bound(controller.integral, -1e20, 1e20);
        int256 i = controller.ki * controller.integral / 1e18;
        
        // D项
        int256 d = controller.kd * (error - controller.lastError) / 1e18;
        controller.lastError = error;
        
        // PID总输出
        return p + i + d;
    }
    
    // 平滑处理
    function applySmooting(uint256 newFee) internal view returns (uint256) {
        // 使用指数移动平均
        uint256 smoothed = (currentFee * (SMOOTHING_FACTOR - 1) + newFee) / SMOOTHING_FACTOR;
        
        // 限制单次调整幅度
        uint256 maxChange = currentFee / 10; // 最多10%变化
        if (smoothed > currentFee + maxChange) {
            return currentFee + maxChange;
        } else if (smoothed < currentFee - maxChange) {
            return currentFee - maxChange;
        }
        
        return smoothed;
    }
    
    // 考虑供需关系
    function getMarketPrice() internal view returns (uint256) {
        // 综合多个数据源
        uint256 dexPrice = getDEXPrice();
        uint256 cexPrice = getCEXPrice();
        uint256 twapPrice = getTWAPPrice();
        
        // 加权平均
        return (dexPrice * 5 + cexPrice * 3 + twapPrice * 2) / 10;
    }
    
    // 获取历史波动性
    function getVolatility() public view returns (uint256) {
        if (priceHistory.length < 2) return 0;
        
        uint256 sum = 0;
        uint256 mean = 0;
        
        // 计算均值
        for (uint i = 0; i < priceHistory.length; i++) {
            mean += priceHistory[i];
        }
        mean /= priceHistory.length;
        
        // 计算标准差
        for (uint i = 0; i < priceHistory.length; i++) {
            uint256 diff = priceHistory[i] > mean ? 
                priceHistory[i] - mean : mean - priceHistory[i];
            sum += diff * diff;
        }
        
        return sqrt(sum / priceHistory.length);
    }
    
    // 动态调整PID参数
    function adaptPIDParameters() external {
        uint256 volatility = getVolatility();
        
        // 高波动时减小响应
        if (volatility > 5e16) { // 5%
            controller.kp = controller.kp * 8 / 10;
            controller.ki = controller.ki * 8 / 10;
        } else if (volatility < 1e16) { // 1%
            controller.kp = controller.kp * 12 / 10;
            controller.ki = controller.ki * 12 / 10;
        }
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>练习 4.4：构建完整的稳定币系统</h4>
                    <p>综合本章所学，设计并实现一个完整的超额抵押稳定币系统，包括PSM、RWA支持和现代化清算机制。</p>
                    <p>要求：</p>
                    <ul>
                        <li>多抵押品支持（包括RWA）</li>
                        <li>PSM保持价格稳定</li>
                        <li>Liquidation 2.0风格清算</li>
                        <li>完善的治理机制</li>
                        <li>紧急关停功能</li>
                    </ul>
                    <div class="answer">
                        <h4>参考答案：</h4>
                        <p>由于完整系统过于复杂，这里提供核心架构和关键组件：</p>
                        <pre><code class="language-solidity">// 系统核心架构
contract StablecoinCore {
    // 核心模块
    IVat public vat;                // 金库引擎
    IDog public dog;                // 清算引擎
    IVow public vow;                // 系统财务
    IPot public pot;                // 存款利率模块
    IEnd public end;                // 紧急关停
    
    // 辅助模块
    IPSM public psm;                // 锚定稳定模块
    IRWAAdapter public rwaAdapter;  // RWA适配器
    IPriceFeed public priceFeed;    // 价格预言机
    IGovernance public governance;  // 治理模块
    
    // 初始化系统
    function initialize() external {
        // 部署核心合约
        vat = new Vat();
        dog = new Dog(address(vat));
        vow = new Vow(address(vat));
        pot = new Pot(address(vat));
        end = new End(address(vat));
        
        // 配置抵押品类型
        setupCollateralTypes();
        
        // 设置治理
        setupGovernance();
    }
    
    // 配置抵押品
    function setupCollateralTypes() internal {
        // ETH
        vat.init("ETH-A");
        vat.file("ETH-A", "line", 500_000_000 * RAD); // 500M debt ceiling
        vat.file("ETH-A", "mat", 150 * RAY / 100);   // 150% liquidation ratio
        
        // WBTC
        vat.init("WBTC-A");
        vat.file("WBTC-A", "line", 100_000_000 * RAD);
        vat.file("WBTC-A", "mat", 175 * RAY / 100);
        
        // RWA - US Treasury Bills
        vat.init("RWA001-A");
        vat.file("RWA001-A", "line", 1_000_000_000 * RAD); // 1B
        vat.file("RWA001-A", "mat", 105 * RAY / 100);      // 105% (low risk)
        
        // USDC (for PSM)
        vat.init("PSM-USDC-A");
        vat.file("PSM-USDC-A", "line", 10_000_000_000 * RAD); // 10B
        vat.file("PSM-USDC-A", "mat", RAY); // 100% (no liquidation)
    }
}</code></pre>
                        <p>关键组件设计要点：</p>
                        <ul>
                            <li><strong>Vat：</strong>核心金库，管理所有CDP和债务</li>
                            <li><strong>Dog：</strong>Liquidation 2.0引擎，处理清算</li>
                            <li><strong>PSM：</strong>1:1兑换USDC，保持价格稳定</li>
                            <li><strong>RWA：</strong>通过信托和法律结构引入真实资产</li>
                            <li><strong>Governance：</strong>时间锁+多签，确保安全</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <h3>本章小结</h3>
            <div class="summary-box">
                <h4>核心要点回顾：</h4>
                <ul>
                    <li><strong>风险参数五元组：</strong>债务上限、清算线、稳定费、清算罚金、目标抵押率的协同设计</li>
                    <li><strong>清算机制演进：</strong>从荷兰拍卖到Liquidation 2.0的固定折扣即时清算</li>
                    <li><strong>MEV防护：</strong>通过commit-reveal、批量拍卖、加密订单流等机制保护参与者</li>
                    <li><strong>PSM机制：</strong>提供强大的价格套利通道，但引入中心化风险</li>
                    <li><strong>RWA集成：</strong>带来稳定收益的同时引入新型风险</li>
                    <li><strong>黑色星期四教训：</strong>系统设计必须考虑极端市场情况</li>
                </ul>
                
                <h4>下一步学习：</h4>
                <p>在掌握了抵押型稳定币的设计后，下一章我们将深入探讨数学模型和控制理论在稳定币中的应用，包括PID控制器、博弈论分析和风险模型。</p>
            </div>
            
            <h3>术语速查表</h3>
            <table class="glossary-table">
                <tr>
                    <th>术语</th>
                    <th>英文</th>
                    <th>解释</th>
                </tr>
                <tr>
                    <td>抵押债仓位</td>
                    <td>CDP</td>
                    <td>用户锁定抵押品铸造稳定币的智能合约账户</td>
                </tr>
                <tr>
                    <td>清算线</td>
                    <td>Liquidation Ratio</td>
                    <td>触发清算的最低抵押率阈值</td>
                </tr>
                <tr>
                    <td>稳定费</td>
                    <td>Stability Fee</td>
                    <td>CDP持有者需支付的利息</td>
                </tr>
                <tr>
                    <td>喂价</td>
                    <td>Price Feed</td>
                    <td>预言机提供的价格数据</td>
                </tr>
                <tr>
                    <td>荷兰式拍卖</td>
                    <td>Dutch Auction</td>
                    <td>价格随时间递减的拍卖方式</td>
                </tr>
            </table>
        </div>
        
        <!-- 第五章：数学模型与控制理论 -->
        <div class="chapter" id="chapter5">
        <h2>第五章：数学模型与控制理论</h2>
        
        <div class="intro-box">
            <strong>本章概览：</strong>
            <ul>
                <li>PID控制器在算法稳定币中的应用</li>
                <li>清算博弈论与最优策略分析</li>
                <li>Black-Scholes期权定价模型在抵押率设计中的应用</li>
                <li>市场压力测试与蒙特卡洛模拟</li>
                <li>实战：构建稳定币参数优化引擎</li>
            </ul>
        </div>
        
        <div class="tip-box">
            <strong>🎯 章节目标：</strong>
            <p>本章将深入探讨稳定币系统背后的数学原理。对于AI科学家和资深程序员，这些数学模型不仅是理论工具，更是设计和优化稳定币系统的实用方法。我们将通过实际代码和数据分析，展示如何将这些理论应用于实践。</p>
        </div>

        <div class="info-box">
            <h4>📊 链上环境与理论模型的差异</h4>
            <p>在将经典控制理论和金融模型应用于区块链时，需要考虑以下关键差异：</p>
            <ul>
                <li><strong>离散时间 vs 连续时间：</strong>区块链以区块为单位更新，而非连续</li>
                <li><strong>定点数 vs 浮点数：</strong>Solidity缺乏原生浮点支持，需要精度权衡</li>
                <li><strong>Gas限制：</strong>复杂计算可能超出单笔交易的Gas上限</li>
                <li><strong>预言机延迟：</strong>价格数据存在延迟和潜在的操纵风险</li>
                <li><strong>MEV影响：</strong>参数更新可能被抢先交易利用</li>
            </ul>
        </div>

        <h3>5.1 PID控制器在算法稳定币中的应用</h3>
        
        <h4>5.1.1 控制理论基础</h4>
        <p>PID（比例-积分-微分）控制器是工业控制中最常用的反馈控制器。在稳定币系统中，PID控制器可以用来动态调整参数以维持价格稳定。</p>
        
        <div class="tip">
            💡 <strong>关键洞察：</strong>稳定币价格稳定问题本质上是一个控制系统问题：我们需要通过调整系统参数（如稳定费率、抵押率等）来使输出（稳定币价格）跟踪参考值（1美元）。
        </div>
        
        <h4>5.1.2 PID控制器数学模型</h4>
        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <p><strong>连续时间PID控制器：</strong></p>
            <p style="text-align: center; font-size: 1.2em;">
                u(t) = K<sub>p</sub>e(t) + K<sub>i</sub>∫<sub>0</sub><sup>t</sup>e(τ)dτ + K<sub>d</sub>de(t)/dt
            </p>
            
            <p><strong>离散时间PID控制器（区块链适用）：</strong></p>
            <p style="text-align: center; font-size: 1.2em;">
                u[k] = K<sub>p</sub>e[k] + K<sub>i</sub>T<sub>s</sub>Σ<sub>j=0</sub><sup>k</sup>e[j] + K<sub>d</sub>(e[k]-e[k-1])/T<sub>s</sub>
            </p>
            
            <p>其中：</p>
            <ul>
                <li><strong>e(t) / e[k]</strong> = 误差信号 = 参考值(r) - 实际值(y)</li>
                <li><strong>K<sub>p</sub></strong> = 比例增益（快速响应）</li>
                <li><strong>K<sub>i</sub></strong> = 积分增益（消除稳态误差）</li>
                <li><strong>K<sub>d</sub></strong> = 微分增益（预测未来，减少超调）</li>
                <li><strong>T<sub>s</sub></strong> = 采样时间（区块时间）</li>
                <li><strong>u(t) / u[k]</strong> = 控制输出</li>
            </ul>
        </div>
        
        <h4>5.1.3 Python模拟环境</h4>
        <p>在实现链上版本前，我们先用Python建立直观理解：</p>
        
        <div class="code-block">
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import pandas as pd

class PIDController:
    """稳定币价格PID控制器模拟"""
    
    def __init__(self, Kp=0.01, Ki=0.001, Kd=0.005, 
                 target=1.0, dt=15.0, deadband=0.001):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.target = target
        self.dt = dt  # 区块时间（秒）
        self.deadband = deadband
        
        # 状态变量
        self.integral = 0
        self.last_error = 0
        self.output_limits = (-0.05, 0.05)  # ±5%调整限制
        
    def update(self, current_price):
        """计算PID输出"""
        error = self.target - current_price
        
        # 死区处理
        if abs(error) < self.deadband:
            return 0
        
        # P项
        P = self.Kp * error
        
        # I项（带抗积分饱和）
        self.integral += error * self.dt
        # 积分限幅
        integral_limit = self.output_limits[1] / self.Ki
        self.integral = np.clip(self.integral, -integral_limit, integral_limit)
        I = self.Ki * self.integral
        
        # D项（带滤波）
        if self.dt > 0:
            derivative = (error - self.last_error) / self.dt
            D = self.Kd * derivative
        else:
            D = 0
            
        # 计算总输出
        output = P + I + D
        
        # 输出限幅
        output = np.clip(output, self.output_limits[0], self.output_limits[1])
        
        # 更新状态
        self.last_error = error
        
        return output
    
    def reset(self):
        """重置控制器状态"""
        self.integral = 0
        self.last_error = 0

# 参数自动调优 - Ziegler-Nichols方法
def ziegler_nichols_tuning(system_response):
    """
    基于系统阶跃响应的Ziegler-Nichols调参
    返回推荐的PID参数
    """
    # 找到最大斜率点
    max_slope_idx = np.argmax(np.gradient(system_response))
    max_slope = np.gradient(system_response)[max_slope_idx]
    
    # 估计延迟和时间常数
    L = max_slope_idx * 0.1  # 假设0.1秒采样
    T = len(system_response) * 0.1 / 3  # 粗略估计
    
    # Ziegler-Nichols PID参数
    Kp = 1.2 * T / L
    Ki = Kp / (2 * L)
    Kd = Kp * L / 2
    
    return Kp, Ki, Kd

# 模拟稳定币系统
def simulate_stablecoin_system(controller, market_shocks, blocks=1000):
    """
    模拟稳定币价格控制系统
    包含市场冲击和噪声
    """
    prices = [1.0]  # 初始价格$1
    rates = [0.02]  # 初始稳定费率2%
    
    for i in range(blocks):
        # 当前价格 = 上一价格 + 市场力量 + 噪声
        market_pressure = market_shocks[i] if i < len(market_shocks) else 0
        noise = np.random.normal(0, 0.001)  # 0.1%标准差的噪声
        
        # 稳定费率对价格的影响（简化模型）
        rate_effect = -rates[-1] * 0.1  # 费率越高，卖压越大
        
        new_price = prices[-1] + market_pressure + noise + rate_effect
        
        # PID控制器输出
        rate_adjustment = controller.update(new_price)
        new_rate = max(0, rates[-1] + rate_adjustment)  # 费率不能为负
        
        prices.append(new_price)
        rates.append(new_rate)
    
    return np.array(prices), np.array(rates)

# 运行模拟
if __name__ == "__main__":
    # 创建市场冲击场景
    market_shocks = np.zeros(1000)
    market_shocks[100:150] = -0.02  # 5%的持续卖压
    market_shocks[500] = -0.05      # 5%的瞬间冲击
    market_shocks[700:750] = 0.01   # 1%的买压
    
    # 创建控制器
    pid = PIDController(Kp=0.02, Ki=0.002, Kd=0.01)
    
    # 运行模拟
    prices, rates = simulate_stablecoin_system(pid, market_shocks)
    
    # 可视化结果
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
    
    # 价格图
    ax1.plot(prices, label='稳定币价格')
    ax1.axhline(y=1.0, color='r', linestyle='--', label='目标价格 $1')
    ax1.fill_between(range(len(prices)), 0.99, 1.01, alpha=0.3, color='green')
    ax1.set_ylabel('价格 (USD)')
    ax1.set_title('PID控制下的稳定币价格')
    ax1.legend()
    ax1.grid(True)
    
    # 费率图
    ax2.plot(rates * 100, label='稳定费率')
    ax2.set_xlabel('区块数')
    ax2.set_ylabel('费率 (%)')
    ax2.set_title('动态调整的稳定费率')
    ax2.legend()
    ax2.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    # 计算性能指标
    rmse = np.sqrt(np.mean((prices - 1.0)**2))
    max_deviation = np.max(np.abs(prices - 1.0))
    settling_time = np.argmax(np.abs(prices[100:] - 1.0) < 0.01) if any(np.abs(prices[100:] - 1.0) < 0.01) else len(prices)
    
    print(f"RMSE: {rmse:.4f}")
    print(f"最大偏离: {max_deviation:.4f}")
    print(f"稳定时间: {settling_time} 区块")</code></pre>
        </div>
        
        <h4>5.1.4 高级控制模型展望</h4>
        <div class="info-box">
            <h5>🚀 超越PID：下一代控制策略</h5>
            <p>虽然PID控制器简单有效，但现代控制理论提供了更强大的工具：</p>
            
            <ul>
                <li><strong>模型预测控制（MPC）：</strong>考虑未来多步预测，优化控制序列
                    <pre><code class="language-python"># MPC伪代码
def mpc_controller(current_state, prediction_horizon=10):
    # 预测未来状态
    future_states = predict_system_evolution(current_state, horizon)
    # 优化控制序列
    optimal_controls = optimize_control_sequence(future_states)
    # 只执行第一步
    return optimal_controls[0]</code></pre>
                </li>
                
                <li><strong>强化学习（RL）控制器：</strong>通过与环境交互学习最优策略
                    <pre><code class="language-python"># RL控制器概念
class RLStablecoinController:
    def __init__(self):
        self.q_network = build_neural_network()
        self.replay_buffer = []
    
    def get_action(self, state):
        # ε-贪心策略
        if random.random() < self.epsilon:
            return random_action()
        return self.q_network.predict(state)</code></pre>
                </li>
                
                <li><strong>自适应控制：</strong>实时调整控制器参数
                    <ul>
                        <li>递归最小二乘（RLS）参数估计</li>
                        <li>卡尔曼滤波状态估计</li>
                        <li>贝叶斯优化参数调优</li>
                    </ul>
                </li>
            </ul>
            
            <p><strong>挑战：</strong>这些高级方法在链上实现面临Gas成本和计算复杂度限制，通常需要链下计算+链上验证的混合架构。</p>
        </div>
        
        <h4>5.1.5 Solidity实现</h4>
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">PID控制器完整实现 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PIDController {
    // PID参数
    int256 public Kp = 1e16;      // 比例系数 (0.01)
    int256 public Ki = 1e15;      // 积分系数 (0.001)
    int256 public Kd = 5e15;      // 微分系数 (0.005)
    
    // 状态变量
    int256 public integral;        // 积分项
    int256 public lastError;       // 上次误差
    uint256 public lastTime;       // 上次更新时间
    
    // 目标价格和界限
    uint256 public constant TARGET_PRICE = 1e18;  // 1 USD
    int256 public constant MAX_OUTPUT = 5e16;     // 最大调整5%
    int256 public constant MIN_OUTPUT = -5e16;    // 最小调整-5%
    
    // 死区设置（减少频繁调整）
    uint256 public constant DEADBAND = 1e15;      // 0.1%死区
    
    // 计算PID输出
    function computePID(uint256 currentPrice) public returns (int256) {
        require(currentPrice > 0, "Invalid price");
        
        uint256 currentTime = block.timestamp;
        uint256 deltaTime = currentTime - lastTime;
        
        // 计算误差（可以为负）
        int256 error = int256(TARGET_PRICE) - int256(currentPrice);
        
        // 死区处理
        if (abs(error) < int256(DEADBAND)) {
            return 0;
        }
        
        // 计算PID各项
        int256 proportional = Kp * error / 1e18;
        
        // 积分项（带抗积分饱和）
        integral += error * int256(deltaTime);
        // 限制积分项防止积分饱和
        if (integral > MAX_OUTPUT * 1e18 / Ki) {
            integral = MAX_OUTPUT * 1e18 / Ki;
        } else if (integral < MIN_OUTPUT * 1e18 / Ki) {
            integral = MIN_OUTPUT * 1e18 / Ki;
        }
        int256 integralTerm = Ki * integral / 1e18;
        
        // 微分项（带滤波）
        int256 derivative = 0;
        if (deltaTime > 0) {
            derivative = Kd * (error - lastError) * 1e18 / int256(deltaTime);
        }
        
        // 计算总输出
        int256 output = proportional + integralTerm + derivative;
        
        // 输出限幅
        if (output > MAX_OUTPUT) {
            output = MAX_OUTPUT;
        } else if (output < MIN_OUTPUT) {
            output = MIN_OUTPUT;
        }
        
        // 更新状态
        lastError = error;
        lastTime = currentTime;
        
        emit PIDComputed(currentPrice, error, output);
        
        return output;
    }
    
    // 参数自适应调整
    function adaptiveParameterTuning(
        uint256 volatility,
        uint256 volume
    ) external {
        // 高波动性时增加Kd，减少Ki
        if (volatility > 2e16) { // 2%波动率
            Kd = Kd * 12 / 10;    // 增加20%
            Ki = Ki * 8 / 10;     // 减少20%
        }
        
        // 低交易量时减少所有增益
        if (volume < 1e6 * 1e18) { // 少于100万美元
            Kp = Kp * 9 / 10;
            Ki = Ki * 9 / 10;
            Kd = Kd * 9 / 10;
        }
    }
    
    // 辅助函数：计算绝对值
    function abs(int256 x) private pure returns (int256) {
        return x >= 0 ? x : -x;
    }
    
    event PIDComputed(uint256 price, int256 error, int256 output);
}</code></pre>
            </div>
        </div>
        
        <h4>5.1.6 稳定费率动态调整</h4>
        <p>将PID控制器应用于稳定费率调整，实现价格的自动稳定：</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">稳定费率控制系统 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract StabilityFeeController {
    PIDController public pidController;
    IPriceOracle public priceOracle;
    
    // 费率参数
    uint256 public baseRate = 2e16;        // 基础费率2%
    uint256 public currentRate;            // 当前费率
    uint256 public minRate = 0;            // 最低费率0%
    uint256 public maxRate = 20e16;        // 最高费率20%
    
    // 更新频率控制
    uint256 public lastUpdate;
    uint256 public constant UPDATE_INTERVAL = 1 hours;
    
    // 历史数据记录（用于分析）
    struct RateHistory {
        uint256 timestamp;
        uint256 price;
        uint256 rate;
        int256 adjustment;
    }
    
    RateHistory[] public rateHistory;
    
    function updateStabilityFee() external {
        require(block.timestamp >= lastUpdate + UPDATE_INTERVAL, "Too frequent");
        
        // 获取当前价格（可能是TWAP）
        uint256 currentPrice = priceOracle.getPrice();
        
        // 计算PID输出
        int256 adjustment = pidController.computePID(currentPrice);
        
        // 应用调整
        if (adjustment > 0) {
            currentRate = currentRate + uint256(adjustment);
        } else {
            uint256 decrease = uint256(-adjustment);
            currentRate = currentRate > decrease ? currentRate - decrease : 0;
        }
        
        // 限制范围
        if (currentRate > maxRate) {
            currentRate = maxRate;
        } else if (currentRate < minRate) {
            currentRate = minRate;
        }
        
        // 记录历史
        rateHistory.push(RateHistory({
            timestamp: block.timestamp,
            price: currentPrice,
            rate: currentRate,
            adjustment: adjustment
        }));
        
        // 更新CDP系统的费率
        cdpEngine.updateStabilityFee(currentRate);
        
        lastUpdate = block.timestamp;
        
        emit StabilityFeeUpdated(currentRate, adjustment, currentPrice);
    }
    
    // 获取系统性能指标
    function getPerformanceMetrics(uint256 periods) 
        external 
        view 
        returns (
            uint256 avgPrice,
            uint256 priceStdDev,
            uint256 avgRate,
            uint256 adjustmentCount
        ) 
    {
        require(periods > 0 && periods <= rateHistory.length, "Invalid periods");
        
        uint256 startIdx = rateHistory.length - periods;
        uint256 sumPrice;
        uint256 sumRate;
        uint256 sumSquaredDev;
        
        // 计算平均值
        for (uint256 i = startIdx; i < rateHistory.length; i++) {
            sumPrice += rateHistory[i].price;
            sumRate += rateHistory[i].rate;
            if (rateHistory[i].adjustment != 0) {
                adjustmentCount++;
            }
        }
        
        avgPrice = sumPrice / periods;
        avgRate = sumRate / periods;
        
        // 计算标准差
        for (uint256 i = startIdx; i < rateHistory.length; i++) {
            int256 deviation = int256(rateHistory[i].price) - int256(avgPrice);
            sumSquaredDev += uint256(deviation * deviation);
        }
        
        priceStdDev = sqrt(sumSquaredDev / periods);
    }
    
    // 平方根函数（用于标准差计算）
    function sqrt(uint256 x) private pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}</code></pre>
            </div>
        </div>
        
        <h3>5.2 预言机安全与治理</h3>
        
        <h4>5.2.1 预言机在稳定币系统中的关键作用</h4>
        <p>预言机是稳定币系统的"眼睛"，提供链外世界的价格数据。其安全性直接影响整个系统的稳定性。</p>
        
        <div class="info-box">
            <h5>⚠️ 预言机风险分类</h5>
            <ul>
                <li><strong>技术风险：</strong>节点故障、网络延迟、数据源错误</li>
                <li><strong>经济攻击：</strong>价格操纵、闪电贷攻击、MEV抢先交易</li>
                <li><strong>治理风险：</strong>恶意提案、参数操纵、紧急响应延迟</li>
                <li><strong>系统性风险：</strong>级联故障、流动性枯竭、黑天鹅事件</li>
            </ul>
        </div>
        
        <h4>5.2.2 多层防御机制</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// 安全预言机聚合器
contract SecureOracleAggregator {
    using FixedPoint for uint256;
    
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;  // 置信度评分
        address source;
    }
    
    struct OracleConfig {
        address oracle;
        uint256 weight;      // 权重
        uint256 deviation;   // 允许偏差
        bool isActive;
    }
    
    // 多个预言机源
    OracleConfig[] public oracles;
    mapping(address => PriceData) public latestPrices;
    
    // 安全参数
    uint256 public constant MIN_SOURCES = 3;
    uint256 public constant MAX_DEVIATION = 0.05e18;  // 5%
    uint256 public constant PRICE_STALENESS = 3600;   // 1小时
    uint256 public constant EMERGENCY_PAUSE_THRESHOLD = 0.1e18;  // 10%
    
    // TWAP（时间加权平均价格）
    mapping(address => uint256[]) public priceHistory;
    uint256 public constant TWAP_WINDOW = 24;  // 24个数据点
    
    // 断路器状态
    bool public emergencyPause;
    uint256 public lastValidPrice;
    
    function getSecurePrice(address asset) external returns (uint256) {
        require(!emergencyPause, "Oracle paused");
        
        uint256[] memory prices = new uint256[](oracles.length);
        uint256[] memory weights = new uint256[](oracles.length);
        uint256 validSources = 0;
        
        // 收集所有活跃预言机的价格
        for (uint i = 0; i < oracles.length; i++) {
            if (!oracles[i].isActive) continue;
            
            try IOracle(oracles[i].oracle).getPrice(asset) returns (uint256 price) {
                // 检查价格时效性
                if (block.timestamp - latestPrices[oracles[i].oracle].timestamp < PRICE_STALENESS) {
                    prices[validSources] = price;
                    weights[validSources] = oracles[i].weight;
                    validSources++;
                    
                    // 更新价格记录
                    latestPrices[oracles[i].oracle] = PriceData({
                        price: price,
                        timestamp: block.timestamp,
                        confidence: calculateConfidence(price, asset),
                        source: oracles[i].oracle
                    });
                }
            } catch {
                // 记录失败但继续
                emit OracleFailure(oracles[i].oracle, asset);
            }
        }
        
        require(validSources >= MIN_SOURCES, "Insufficient oracle sources");
        
        // 计算加权中位数
        uint256 finalPrice = calculateWeightedMedian(prices, weights, validSources);
        
        // 异常检测
        if (lastValidPrice > 0) {
            uint256 priceChange = finalPrice > lastValidPrice 
                ? (finalPrice - lastValidPrice).div(lastValidPrice)
                : (lastValidPrice - finalPrice).div(lastValidPrice);
                
            if (priceChange > EMERGENCY_PAUSE_THRESHOLD) {
                emergencyPause = true;
                emit EmergencyPause(asset, lastValidPrice, finalPrice);
                return lastValidPrice;  // 返回最后有效价格
            }
        }
        
        // 更新TWAP
        updateTWAP(asset, finalPrice);
        lastValidPrice = finalPrice;
        
        return finalPrice;
    }
    
    // 计算加权中位数（抗操纵）
    function calculateWeightedMedian(
        uint256[] memory prices,
        uint256[] memory weights,
        uint256 count
    ) private pure returns (uint256) {
        // 排序价格数组（带权重）
        for (uint i = 0; i < count - 1; i++) {
            for (uint j = 0; j < count - i - 1; j++) {
                if (prices[j] > prices[j + 1]) {
                    // 交换价格和权重
                    (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]);
                    (weights[j], weights[j + 1]) = (weights[j + 1], weights[j]);
                }
            }
        }
        
        // 找到加权中位数
        uint256 totalWeight;
        for (uint i = 0; i < count; i++) {
            totalWeight += weights[i];
        }
        
        uint256 targetWeight = totalWeight / 2;
        uint256 cumulativeWeight;
        
        for (uint i = 0; i < count; i++) {
            cumulativeWeight += weights[i];
            if (cumulativeWeight >= targetWeight) {
                return prices[i];
            }
        }
        
        return prices[count - 1];
    }
    
    // MEV保护：延迟价格更新
    mapping(bytes32 => PriceCommitment) public priceCommitments;
    
    struct PriceCommitment {
        bytes32 commitment;
        uint256 revealDeadline;
        bool revealed;
    }
    
    function commitPrice(bytes32 commitment) external onlyOracle {
        priceCommitments[commitment] = PriceCommitment({
            commitment: commitment,
            revealDeadline: block.timestamp + 15 minutes,
            revealed: false
        });
    }
    
    function revealPrice(
        address asset,
        uint256 price,
        uint256 nonce
    ) external onlyOracle {
        bytes32 commitment = keccak256(abi.encodePacked(asset, price, nonce, msg.sender));
        PriceCommitment storage pc = priceCommitments[commitment];
        
        require(pc.commitment == commitment, "Invalid commitment");
        require(block.timestamp <= pc.revealDeadline, "Reveal deadline passed");
        require(!pc.revealed, "Already revealed");
        
        pc.revealed = true;
        // 处理揭示的价格...
    }
}</code></pre>
        </div>
        
        <h4>5.2.3 治理与紧急响应</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// 治理模块
contract OracleGovernance {
    using SafeMath for uint256;
    
    // 时间锁参数
    uint256 public constant MINIMUM_DELAY = 2 days;
    uint256 public constant MAXIMUM_DELAY = 30 days;
    uint256 public constant GRACE_PERIOD = 14 days;
    
    // 提案类型
    enum ProposalType {
        ADD_ORACLE,
        REMOVE_ORACLE,
        UPDATE_WEIGHT,
        UPDATE_PARAMETERS,
        EMERGENCY_ACTION
    }
    
    struct Proposal {
        ProposalType proposalType;
        address target;
        uint256 value;
        bytes data;
        uint256 eta;  // 执行时间
        bool executed;
        bool cancelled;
    }
    
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;
    
    // 紧急多签
    mapping(address => bool) public guardians;
    uint256 public constant GUARDIAN_THRESHOLD = 3;
    
    // 紧急暂停（需要多个守护者签名）
    function emergencyPause() external {
        require(guardians[msg.sender], "Not a guardian");
        
        bytes32 actionHash = keccak256(abi.encodePacked("EMERGENCY_PAUSE", block.timestamp));
        
        if (confirmations[actionHash].length >= GUARDIAN_THRESHOLD) {
            IOracle(oracleAggregator).pause();
            emit EmergencyActionExecuted("PAUSE", block.timestamp);
        } else {
            confirmations[actionHash].push(msg.sender);
            emit GuardianConfirmation(msg.sender, actionHash);
        }
    }
    
    // 参数更新的渐进式实施
    function executeParameterUpdate(
        uint256 proposalId
    ) external {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.executed, "Already executed");
        require(block.timestamp >= proposal.eta, "Too early");
        require(block.timestamp <= proposal.eta.add(GRACE_PERIOD), "Stale");
        
        // 渐进式更新，避免突变
        if (proposal.proposalType == ProposalType.UPDATE_PARAMETERS) {
            uint256 currentValue = IOracle(proposal.target).getParameter(proposal.data);
            uint256 targetValue = proposal.value;
            
            // 每次最多改变10%
            uint256 maxChange = currentValue.mul(10).div(100);
            uint256 actualChange = targetValue > currentValue
                ? Math.min(targetValue - currentValue, maxChange)
                : Math.min(currentValue - targetValue, maxChange);
                
            uint256 newValue = targetValue > currentValue
                ? currentValue.add(actualChange)
                : currentValue.sub(actualChange);
                
            IOracle(proposal.target).setParameter(proposal.data, newValue);
            
            // 如果还未达到目标，创建新提案
            if (newValue != targetValue) {
                _createFollowUpProposal(proposal, newValue, targetValue);
            }
        }
        
        proposal.executed = true;
    }
}</code></pre>
        </div>
        
        <h4>5.2.4 2024年预言机创新</h4>
        <div class="info-box">
            <h5>🔮 最新发展趋势</h5>
            <ul>
                <li><strong>零知识预言机：</strong>使用ZK证明验证链下计算，如zkOracles</li>
                <li><strong>TEE预言机：</strong>利用可信执行环境（如Intel SGX）保证数据完整性</li>
                <li><strong>AI增强预言机：</strong>使用机器学习检测异常和预测价格</li>
                <li><strong>跨链预言机标准：</strong>统一的预言机接口支持多链部署</li>
            </ul>
        </div>
        
        <h3>5.3 清算博弈论与激励机制</h3>
        
        <h4>5.3.1 清算博弈模型</h4>
        <p>清算过程可以建模为一个多方博弈，参与者包括：CDP持有者、Keeper（清算者）和协议本身。</p>
        
        <div class="tip-box">
            <strong>🎮 博弈论视角：</strong>
            <ul>
                <li><strong>CDP持有者：</strong>希望避免清算，但也希望最大化资本效率</li>
                <li><strong>Keeper：</strong>寻求清算利润，但需要承担Gas成本和价格风险</li>
                <li><strong>协议：</strong>需要平衡系统安全性和用户体验</li>
            </ul>
        </div>
        
        <h4>5.3.2 纳什均衡分析</h4>
        <div style="background: #fef3c7; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <p><strong>清算博弈的纳什均衡条件：</strong></p>
            <ol>
                <li><strong>Keeper参与条件：</strong>
                    <p>E[清算利润] > Gas成本 + 机会成本 + 风险溢价</p>
                </li>
                <li><strong>CDP持有者最优抵押率：</strong>
                    <p>边际收益率 = 清算概率 × 清算损失率</p>
                </li>
                <li><strong>协议最优参数：</strong>
                    <p>最小化（系统风险 + 用户成本）</p>
                </li>
            </ol>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">清算博弈建模 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract LiquidationGameTheory {
    using ABDKMath64x64 for int128;
    
    struct GameParameters {
        uint256 liquidationPenalty;    // 清算罚金
        uint256 gasPrice;             // 当前Gas价格
        uint256 volatility;           // 市场波动率
        uint256 keeperCount;          // 活跃Keeper数量
    }
    
    // 计算Keeper的期望收益
    function calculateKeeperExpectedProfit(
        uint256 collateralValue,
        uint256 debtValue,
        GameParameters memory params
    ) public pure returns (int256 expectedProfit) {
        // 清算折扣收益
        uint256 discount = collateralValue * params.liquidationPenalty / 1e18;
        
        // 预期Gas成本（考虑竞争）
        uint256 gasCost = estimateGasCost(params.gasPrice, params.keeperCount);
        
        // 价格滑点风险（基于波动率）
        uint256 slippageRisk = collateralValue * params.volatility / 1e18;
        
        // 竞争风险（其他Keeper抢先）
        uint256 competitionRisk = discount * min(params.keeperCount, 10) / 20;
        
        // 期望利润 = 折扣 - Gas成本 - 滑点风险 - 竞争风险
        expectedProfit = int256(discount) - int256(gasCost) - 
                        int256(slippageRisk) - int256(competitionRisk);
    }
    
    // 计算最优抵押率（CDP持有者视角）
    function calculateOptimalCollateralRatio(
        uint256 stabilityFee,      // 年化稳定费
        uint256 collateralReturn,  // 抵押品预期收益率
        uint256 volatility,        // 波动率
        uint256 liquidationRatio   // 清算线
    ) public pure returns (uint256 optimalRatio) {
        // 使用Kelly准则的变体
        // f* = (p*b - q) / b
        // 其中：p是盈利概率，b是盈亏比，q是亏损概率
        
        // 计算持有收益
        int256 holdingReturn = int256(collateralReturn) - int256(stabilityFee);
        
        // 计算清算概率（基于波动率和距离清算线的距离）
        uint256 liquidationProb = calculateLiquidationProbability(
            liquidationRatio,
            volatility
        );
        
        // Kelly准则计算
        if (holdingReturn > 0) {
            // 有正收益时的最优抵押率
            optimalRatio = liquidationRatio * (1e18 + volatility) / 1e18;
            
            // 加入安全边际
            optimalRatio = optimalRatio * 115 / 100; // 15%安全边际
        } else {
            // 负收益时保守策略
            optimalRatio = liquidationRatio * 150 / 100;
        }
    }
    
    // 计算清算概率（使用正态分布近似）
    function calculateLiquidationProbability(
        uint256 liquidationRatio,
        uint256 annualVolatility
    ) private pure returns (uint256) {
        // 将年化波动率转换为每日波动率
        uint256 dailyVol = annualVolatility * 1e18 / sqrt(365 * 1e18);
        
        // 计算到达清算线的概率（简化模型）
        // P(清算) ≈ Φ(-d), 其中d = ln(当前比率/清算比率) / σ
        
        // 这里使用近似公式
        uint256 distance = 1e18 - (1e36 / liquidationRatio);
        uint256 probability = distance * 1e18 / (dailyVol * 3); // 简化的概率估计
        
        return probability > 1e18 ? 1e18 : probability;
    }
    
    // 协议参数优化（多目标优化）
    function optimizeProtocolParameters(
        uint256 systemRisk,
        uint256 userCost,
        uint256 keeperProfit
    ) public pure returns (
        uint256 optimalPenalty,
        uint256 optimalLiquidationRatio
    ) {
        // 目标函数：minimize(α*systemRisk + β*userCost - γ*keeperProfit)
        // 其中α、β、γ是权重参数
        
        uint256 alpha = 5;  // 系统风险权重
        uint256 beta = 3;   // 用户成本权重
        uint256 gamma = 2;  // Keeper利润权重
        
        // 使用梯度下降或其他优化算法
        // 这里简化为规则基础的调整
        
        if (systemRisk > 1e16) { // 系统风险高于1%
            optimalLiquidationRatio = 150; // 提高到150%
            optimalPenalty = 15e16;        // 15%罚金
        } else if (userCost > 5e16) { // 用户成本过高
            optimalLiquidationRatio = 130; // 降低到130%
            optimalPenalty = 10e16;        // 10%罚金
        } else {
            optimalLiquidationRatio = 140; // 标准140%
            optimalPenalty = 13e16;        // 13%罚金
        }
    }
    
    // 辅助函数
    function min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function sqrt(uint256 x) private pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
    
    function estimateGasCost(uint256 gasPrice, uint256 keeperCount) 
        private 
        pure 
        returns (uint256) 
    {
        // 基础Gas消耗
        uint256 baseGas = 200000;
        
        // 竞争导致的Gas溢价
        uint256 premiumMultiplier = 100 + keeperCount * 10;
        
        return baseGas * gasPrice * premiumMultiplier / 100;
    }
}</code></pre>
            </div>
        </div>
        
        <h3>5.4 Black-Scholes模型在抵押率设计中的应用</h3>
        
        <h4>5.4.1 期权理论视角</h4>
        <p>CDP可以被视为一个期权结构：</p>
        <ul>
            <li>借款人持有一个<strong>看跌期权</strong>：有权以债务金额"卖出"抵押品给协议</li>
            <li>协议隐含地<strong>卖出了看跌期权</strong>：承担了抵押品价值下跌的风险</li>
        </ul>
        
        <div class="tip">
            💡 <strong>关键洞察：</strong>清算线的设定本质上是在为这个隐含期权定价。过高的清算线相当于期权费过高，降低了资本效率；过低则增加了协议的风险敞口。
        </div>
        
        <h4>5.4.2 Black-Scholes公式应用</h4>
        <div style="background: #e0e7ff; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <p><strong>适配后的Black-Scholes公式：</strong></p>
            <p>看跌期权价值 P = Ke<sup>-rt</sup>N(-d₂) - S₀N(-d₁)</p>
            <p>其中：</p>
            <ul>
                <li>S₀ = 抵押品当前价值</li>
                <li>K = 债务价值（行权价）</li>
                <li>r = 无风险利率</li>
                <li>t = 期限</li>
                <li>σ = 抵押品波动率</li>
                <li>d₁ = [ln(S₀/K) + (r + σ²/2)t] / (σ√t)</li>
                <li>d₂ = d₁ - σ√t</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Black-Scholes抵押率计算 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// 使用ABDKMath64x64库进行高精度数学计算
import "./ABDKMath64x64.sol";

contract BlackScholesCollateral {
    using ABDKMath64x64 for int128;
    
    // 常数
    int128 private constant ONE = 0x10000000000000000; // 1.0 in 64.64
    int128 private constant HALF = 0x8000000000000000; // 0.5 in 64.64
    
    struct OptionParameters {
        uint256 spotPrice;      // 抵押品现价
        uint256 strikePrice;    // 债务价值（行权价）
        uint256 timeToMaturity; // 到期时间（秒）
        uint256 volatility;     // 年化波动率（基点）
        uint256 riskFreeRate;   // 无风险利率（基点）
    }
    
    // 计算理论清算比率
    function calculateOptimalLiquidationRatio(
        OptionParameters memory params
    ) public pure returns (uint256 liquidationRatio) {
        // 转换参数为64.64定点数
        int128 S = ABDKMath64x64.divu(params.spotPrice, 1e18);
        int128 K = ABDKMath64x64.divu(params.strikePrice, 1e18);
        int128 t = ABDKMath64x64.divu(params.timeToMaturity, 365 days);
        int128 sigma = ABDKMath64x64.divu(params.volatility, 10000);
        int128 r = ABDKMath64x64.divu(params.riskFreeRate, 10000);
        
        // 计算d1和d2
        (int128 d1, int128 d2) = calculateD1D2(S, K, r, sigma, t);
        
        // 计算期权价值
        int128 putValue = calculatePutValue(S, K, r, t, d1, d2);
        
        // 清算比率 = (债务 + 期权价值) / 债务
        // 这确保了协议得到充分补偿
        int128 ratio = ONE.add(putValue.div(K));
        
        // 转换回uint256（基点）
        liquidationRatio = uint256(int256(ratio.mul(ABDKMath64x64.fromUInt(10000))));
        
        // 加入安全边际（根据波动率调整）
        uint256 safetyMargin = 10000 + params.volatility / 2; // 基础100% + 波动率的一半
        liquidationRatio = liquidationRatio * safetyMargin / 10000;
    }
    
    // 计算d1和d2
    function calculateD1D2(
        int128 S,
        int128 K,
        int128 r,
        int128 sigma,
        int128 t
    ) private pure returns (int128 d1, int128 d2) {
        // ln(S/K)
        int128 lnSK = S.div(K).ln();
        
        // (r + σ²/2)t
        int128 sigma2 = sigma.mul(sigma);
        int128 drift = r.add(sigma2.div(ABDKMath64x64.fromUInt(2))).mul(t);
        
        // σ√t
        int128 sigmaRootT = sigma.mul(t.sqrt());
        
        // d1 = [ln(S/K) + (r + σ²/2)t] / (σ√t)
        d1 = lnSK.add(drift).div(sigmaRootT);
        
        // d2 = d1 - σ√t
        d2 = d1.sub(sigmaRootT);
    }
    
    // 计算看跌期权价值
    function calculatePutValue(
        int128 S,
        int128 K,
        int128 r,
        int128 t,
        int128 d1,
        int128 d2
    ) private pure returns (int128) {
        // e^(-rt)
        int128 discountFactor = (r.neg()).mul(t).exp();
        
        // N(-d1) 和 N(-d2)
        int128 Nd1 = normalCDF(d1.neg());
        int128 Nd2 = normalCDF(d2.neg());
        
        // P = Ke^(-rt)N(-d2) - S*N(-d1)
        int128 putValue = K.mul(discountFactor).mul(Nd2).sub(S.mul(Nd1));
        
        return putValue;
    }
    
    // 正态分布累积分布函数（近似）
    function normalCDF(int128 x) private pure returns (int128) {
        // 使用Abramowitz和Stegun近似
        int128 L = x.abs();
        int128 K = ONE.div(ONE.add(L.mul(ABDKMath64x64.divu(2316419, 10000000))));
        
        int128 a1 = ABDKMath64x64.divu(319381530, 1000000000);
        int128 a2 = ABDKMath64x64.divu(356563782, 1000000000).neg();
        int128 a3 = ABDKMath64x64.divu(1781477937, 1000000000);
        int128 a4 = ABDKMath64x64.divu(1821255978, 1000000000).neg();
        int128 a5 = ABDKMath64x64.divu(1330274429, 1000000000);
        
        int128 K2 = K.mul(K);
        int128 K3 = K2.mul(K);
        int128 K4 = K3.mul(K);
        int128 K5 = K4.mul(K);
        
        int128 sum = a1.mul(K).add(a2.mul(K2)).add(a3.mul(K3))
                    .add(a4.mul(K4)).add(a5.mul(K5));
        
        // 1.0 - 1.0/√(2π) * e^(-L²/2) * sum
        int128 sqrtTwoPi = ABDKMath64x64.divu(2506628274, 1000000000);
        int128 expTerm = L.mul(L).div(ABDKMath64x64.fromUInt(2)).neg().exp();
        int128 result = ONE.sub(expTerm.div(sqrtTwoPi).mul(sum));
        
        return x >= 0 ? result : ONE.sub(result);
    }
    
    // 动态调整抵押率（基于市场条件）
    function dynamicCollateralAdjustment(
        uint256 currentVolatility,
        uint256 historicalVolatility,
        uint256 marketDepth,
        uint256 currentLiquidationRatio
    ) public pure returns (uint256 newLiquidationRatio) {
        // 波动率比率
        uint256 volRatio = currentVolatility * 1e18 / historicalVolatility;
        
        // 市场深度因子（流动性越差，需要越高的抵押率）
        uint256 depthFactor = 1e18 * 1e18 / (marketDepth + 1e18);
        
        // 调整因子 = √(波动率比率 * 深度因子)
        uint256 adjustmentFactor = sqrt(volRatio * depthFactor / 1e18);
        
        // 新抵押率 = 当前抵押率 * 调整因子
        newLiquidationRatio = currentLiquidationRatio * adjustmentFactor / 1e18;
        
        // 限制调整幅度（单次最多调整10%）
        uint256 maxChange = currentLiquidationRatio / 10;
        if (newLiquidationRatio > currentLiquidationRatio + maxChange) {
            newLiquidationRatio = currentLiquidationRatio + maxChange;
        } else if (newLiquidationRatio < currentLiquidationRatio - maxChange) {
            newLiquidationRatio = currentLiquidationRatio - maxChange;
        }
    }
    
    function sqrt(uint256 x) private pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
}</code></pre>
            </div>
        </div>
        
        <h4>5.4.3 Black-Scholes模型的局限性与DeFi适配</h4>
        <div class="info-box">
            <h5>⚠️ 传统模型假设 vs DeFi现实</h5>
            <table style="width: 100%; border-collapse: collapse;">
                <tr style="background: #f3f4f6;">
                    <th style="border: 1px solid #ddd; padding: 8px;">Black-Scholes假设</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">DeFi市场现实</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">适配方案</th>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">对数正态分布</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">肥尾分布、黑天鹅事件频发</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">使用跳跃扩散模型</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">恒定波动率</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">波动率微笑、时变波动率</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">隐含波动率曲面</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">无摩擦市场</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">高Gas费、滑点、MEV</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">交易成本调整</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">连续交易</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">区块时间离散性</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">离散时间模型</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">无风险利率</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">DeFi利率波动剧烈</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">动态利率模型</td>
                </tr>
            </table>
        </div>
        
        <div class="code-block">
            <pre><code class="language-python"># DeFi适配的期权定价模型
import numpy as np
from scipy.stats import norm
import pandas as pd

class DeFiOptionPricing:
    """考虑DeFi特性的期权定价模型"""
    
    def __init__(self, jump_intensity=0.1, jump_mean=-0.05, jump_std=0.1):
        self.jump_intensity = jump_intensity  # 跳跃强度（Lambda）
        self.jump_mean = jump_mean          # 平均跳跃幅度
        self.jump_std = jump_std            # 跳跃标准差
        
    def merton_jump_diffusion(self, S, K, T, r, sigma, div_yield=0):
        """
        Merton跳跃扩散模型
        适用于加密资产的肥尾分布
        """
        # 调整参数以考虑跳跃
        lambda_prime = self.jump_intensity * (1 + self.jump_mean)
        sigma_s = np.sqrt(sigma**2 + self.jump_intensity * self.jump_std**2)
        
        # 计算期权价值的级数展开
        option_value = 0
        for n in range(50):  # 通常50项足够收敛
            # 泊松概率
            prob_n = np.exp(-lambda_prime * T) * (lambda_prime * T)**n / np.math.factorial(n)
            
            # 调整后的参数
            r_n = r - self.jump_intensity * self.jump_mean + n * np.log(1 + self.jump_mean) / T
            sigma_n = np.sqrt(sigma**2 + n * self.jump_std**2 / T)
            
            # Black-Scholes with adjusted parameters
            bs_value = self.black_scholes_put(S, K, T, r_n, sigma_n, div_yield)
            option_value += prob_n * bs_value
            
        return option_value
    
    def implied_volatility_surface(self, market_prices, strikes, maturities, spot):
        """
        构建隐含波动率曲面
        反映市场对不同行权价和到期日的风险定价
        """
        iv_surface = pd.DataFrame(index=strikes, columns=maturities)
        
        for K in strikes:
            for T in maturities:
                # 从市场价格反推隐含波动率
                market_price = market_prices.get((K, T), None)
                if market_price:
                    iv = self.calculate_implied_volatility(
                        market_price, spot, K, T, 0.05  # 假设5%无风险利率
                    )
                    iv_surface.loc[K, T] = iv
                    
        return iv_surface
    
    def calculate_liquidation_premium(self, collateral_value, debt_value, 
                                    volatility, time_to_liquidation,
                                    gas_cost, mev_risk_premium):
        """
        计算考虑DeFi特性的清算溢价
        """
        # 基础期权价值
        base_option_value = self.merton_jump_diffusion(
            S=collateral_value,
            K=debt_value,
            T=time_to_liquidation,
            r=0.05,  # DeFi借贷利率
            sigma=volatility
        )
        
        # Gas成本调整（占抵押品价值的比例）
        gas_adjustment = gas_cost / collateral_value
        
        # MEV风险调整（清算者可能被抢先交易）
        mev_adjustment = mev_risk_premium
        
        # 流动性折扣（大额清算的市场冲击）
        liquidity_discount = self.calculate_liquidity_discount(
            collateral_value, 
            debt_value
        )
        
        # 总清算溢价
        total_premium = (base_option_value + gas_adjustment + 
                        mev_adjustment + liquidity_discount)
        
        # 建议的清算比率
        suggested_liquidation_ratio = 1 + total_premium
        
        return {
            'base_option_value': base_option_value,
            'gas_adjustment': gas_adjustment,
            'mev_adjustment': mev_adjustment,
            'liquidity_discount': liquidity_discount,
            'total_premium': total_premium,
            'suggested_liquidation_ratio': suggested_liquidation_ratio
        }
    
    def calculate_liquidity_discount(self, collateral_value, debt_value):
        """
        基于Amihud非流动性指标估算市场冲击
        """
        # 简化模型：假设市场深度与规模的平方根成反比
        market_depth_factor = 1e7  # 市场深度参数
        impact = np.sqrt(collateral_value / market_depth_factor)
        
        return min(impact, 0.1)  # 最大10%的流动性折扣

# 使用示例
pricing_model = DeFiOptionPricing()

# 计算CDP的清算参数
result = pricing_model.calculate_liquidation_premium(
    collateral_value=1000000,  # $1M抵押品
    debt_value=500000,         # $500K债务
    volatility=0.8,            # 80%年化波动率
    time_to_liquidation=1/365, # 1天
    gas_cost=500,              # $500 Gas成本
    mev_risk_premium=0.02      # 2% MEV风险
)

print(f"建议清算比率: {result['suggested_liquidation_ratio']:.2%}")
print(f"其中期权价值贡献: {result['base_option_value']:.2%}")
print(f"Gas成本贡献: {result['gas_adjustment']:.2%}")
print(f"MEV风险贡献: {result['mev_adjustment']:.2%}")
print(f"流动性折扣: {result['liquidity_discount']:.2%}")</code></pre>
        </div>
        
        <h3>5.5 市场压力测试与蒙特卡洛模拟</h3>
        
        <h4>5.5.1 压力测试框架</h4>
        <p>稳定币系统需要能够承受极端市场条件。通过蒙特卡洛模拟，我们可以评估系统在各种情景下的表现。</p>
        
        <div class="tip-box">
            <strong>📊 压力测试维度：</strong>
            <ul>
                <li><strong>价格冲击：</strong>抵押品价格瞬间下跌30%、50%、70%</li>
                <li><strong>流动性枯竭：</strong>DEX流动性降低90%</li>
                <li><strong>级联清算：</strong>大量CDP同时触发清算</li>
                <li><strong>预言机攻击：</strong>价格操纵或预言机失效</li>
                <li><strong>Gas价格激增：</strong>网络拥堵导致清算延迟</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">蒙特卡洛模拟引擎 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract MonteCarloSimulation {
    using ABDKMath64x64 for int128;
    
    struct SimulationParameters {
        uint256 numSimulations;      // 模拟次数
        uint256 timeHorizon;        // 时间范围（天）
        uint256 initialPrice;       // 初始价格
        uint256 annualVolatility;   // 年化波动率
        uint256 drift;              // 漂移率
        uint256 jumpProbability;    // 跳跃概率
        int256 jumpSize;            // 跳跃幅度
    }
    
    struct SimulationResults {
        uint256 avgFinalPrice;      // 平均最终价格
        uint256 minPrice;           // 最低价格
        uint256 maxPrice;           // 最高价格
        uint256 defaultProbability; // 违约概率
        uint256 avgLiquidations;    // 平均清算次数
        uint256 maxDrawdown;        // 最大回撤
        uint256 var95;             // 95% VaR
        uint256 var99;             // 99% VaR
    }
    
    // 随机数生成器（简化版，实际应使用Chainlink VRF）
    uint256 private seed;
    
    function runMonteCarloSimulation(
        SimulationParameters memory params,
        uint256 liquidationRatio,
        uint256 totalCDPs
    ) public returns (SimulationResults memory results) {
        uint256[] memory finalPrices = new uint256[](params.numSimulations);
        uint256[] memory liquidationCounts = new uint256[](params.numSimulations);
        uint256 defaultCount;
        
        results.minPrice = type(uint256).max;
        
        // 运行多次模拟
        for (uint256 sim = 0; sim < params.numSimulations; sim++) {
            (uint256 finalPrice, uint256 liquidations, uint256 minPriceInPath) = 
                simulatePricePath(params, liquidationRatio);
            
            finalPrices[sim] = finalPrice;
            liquidationCounts[sim] = liquidations;
            
            // 更新统计
            results.avgFinalPrice += finalPrice;
            results.avgLiquidations += liquidations;
            
            if (finalPrice < results.minPrice) {
                results.minPrice = finalPrice;
            }
            if (finalPrice > results.maxPrice) {
                results.maxPrice = finalPrice;
            }
            
            // 计算最大回撤
            uint256 drawdown = (params.initialPrice - minPriceInPath) * 1e18 / 
                              params.initialPrice;
            if (drawdown > results.maxDrawdown) {
                results.maxDrawdown = drawdown;
            }
            
            // 检查是否违约（价格跌破某个阈值）
            if (minPriceInPath < params.initialPrice * 100 / liquidationRatio) {
                defaultCount++;
            }
        }
        
        // 计算平均值
        results.avgFinalPrice /= params.numSimulations;
        results.avgLiquidations /= params.numSimulations;
        results.defaultProbability = defaultCount * 1e18 / params.numSimulations;
        
        // 计算VaR
        sortArray(finalPrices);
        uint256 var95Index = params.numSimulations * 5 / 100;
        uint256 var99Index = params.numSimulations * 1 / 100;
        results.var95 = params.initialPrice - finalPrices[var95Index];
        results.var99 = params.initialPrice - finalPrices[var99Index];
        
        return results;
    }
    
    // 模拟单条价格路径
    function simulatePricePath(
        SimulationParameters memory params,
        uint256 liquidationRatio
    ) private returns (
        uint256 finalPrice,
        uint256 liquidationCount,
        uint256 minPrice
    ) {
        uint256 currentPrice = params.initialPrice;
        minPrice = currentPrice;
        uint256 dt = 1; // 1天时间步长
        
        // 将参数转换为每日值
        uint256 dailyVolatility = params.annualVolatility / sqrt(365);
        int256 dailyDrift = int256(params.drift) / 365;
        
        for (uint256 day = 0; day < params.timeHorizon; day++) {
            // 生成随机数
            int256 randomNormal = generateNormalRandom();
            uint256 randomUniform = generateUniformRandom();
            
            // 几何布朗运动 + 跳跃过程
            int256 diffusion = int256(dailyVolatility) * randomNormal / 1e9;
            int256 priceChange = dailyDrift + diffusion;
            
            // 检查跳跃
            if (randomUniform < params.jumpProbability) {
                priceChange += params.jumpSize;
            }
            
            // 更新价格（确保不会变负）
            if (priceChange >= 0) {
                currentPrice = currentPrice * uint256(1e18 + priceChange) / 1e18;
            } else {
                uint256 decrease = uint256(-priceChange);
                if (decrease < 1e18) {
                    currentPrice = currentPrice * (1e18 - decrease) / 1e18;
                } else {
                    currentPrice = 1; // 最小价格
                }
            }
            
            // 更新最低价
            if (currentPrice < minPrice) {
                minPrice = currentPrice;
            }
            
            // 检查清算
            if (currentPrice < params.initialPrice * 100 / liquidationRatio) {
                liquidationCount++;
            }
        }
        
        finalPrice = currentPrice;
    }
    
    // 生成正态分布随机数（Box-Muller变换）
    function generateNormalRandom() private returns (int256) {
        uint256 u1 = generateUniformRandom();
        uint256 u2 = generateUniformRandom();
        
        // Box-Muller变换
        int256 z0 = int256(sqrt(uint256(-2) * ln(u1)) * 
                    cos(2 * 314159265 * u2 / 1e10));
        
        return z0;
    }
    
    // 生成均匀分布随机数
    function generateUniformRandom() private returns (uint256) {
        seed = uint256(keccak256(abi.encodePacked(seed, block.timestamp, msg.sender)));
        return seed % 1e18;
    }
    
    // 自然对数近似
    function ln(uint256 x) private pure returns (uint256) {
        require(x > 0, "ln of non-positive number");
        // 简化的泰勒级数近似
        // 实际应用中应使用更精确的实现
        if (x == 1e18) return 0;
        
        int256 result = 0;
        int256 term = int256(x - 1e18) * 1e18 / int256(x + 1e18);
        int256 termSquared = term * term / 1e18;
        
        result = 2 * term;
        term = term * termSquared / 1e18;
        result += 2 * term / 3;
        
        return uint256(result);
    }
    
    // 余弦近似
    function cos(uint256 x) private pure returns (int256) {
        // 简化的泰勒级数
        int256 x2 = int256(x) * int256(x) / 1e18;
        int256 result = 1e18 - x2 / 2;
        return result;
    }
    
    // 数组排序（用于VaR计算）
    function sortArray(uint256[] memory arr) private pure {
        uint256 n = arr.length;
        for (uint256 i = 0; i < n - 1; i++) {
            for (uint256 j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    uint256 temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    function sqrt(uint256 x) private pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
}</code></pre>
            </div>
        </div>
        
        <h4>5.4.2 系统性风险评估</h4>
        <p>基于模拟结果，我们可以评估系统的整体风险状况：</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">风险评估与预警系统 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract RiskAssessmentSystem {
    MonteCarloSimulation public simulator;
    
    struct RiskMetrics {
        uint256 systemCollateralRatio;   // 系统总抵押率
        uint256 concentrationRisk;       // 集中度风险
        uint256 liquidityRisk;          // 流动性风险
        uint256 correlationRisk;        // 相关性风险
        uint256 overallRiskScore;       // 综合风险评分
        RiskLevel riskLevel;            // 风险等级
    }
    
    enum RiskLevel { LOW, MEDIUM, HIGH, CRITICAL }
    
    // 风险阈值
    uint256 constant CRITICAL_COLLATERAL_RATIO = 120; // 120%
    uint256 constant HIGH_CONCENTRATION = 20;         // 20%单一头寸
    uint256 constant LOW_LIQUIDITY_DEPTH = 1e6 * 1e18; // 100万美元
    
    // 计算系统风险指标
    function assessSystemRisk(
        address[] memory cdps,
        address[] memory collateralTypes
    ) public returns (RiskMetrics memory metrics) {
        // 1. 计算系统总抵押率
        uint256 totalCollateralValue;
        uint256 totalDebtValue;
        
        for (uint256 i = 0; i < cdps.length; i++) {
            (uint256 collateral, uint256 debt) = getCDPValues(cdps[i]);
            totalCollateralValue += collateral;
            totalDebtValue += debt;
        }
        
        metrics.systemCollateralRatio = totalCollateralValue * 100 / totalDebtValue;
        
        // 2. 计算集中度风险（HHI指数）
        metrics.concentrationRisk = calculateHerfindahlIndex(cdps);
        
        // 3. 评估流动性风险
        metrics.liquidityRisk = assessLiquidityRisk(collateralTypes);
        
        // 4. 计算相关性风险
        metrics.correlationRisk = calculateCorrelationRisk(collateralTypes);
        
        // 5. 运行压力测试
        SimulationResults memory simResults = runStressTest();
        
        // 6. 综合评分（加权平均）
        metrics.overallRiskScore = calculateOverallRisk(
            metrics,
            simResults
        );
        
        // 7. 确定风险等级
        metrics.riskLevel = determineRiskLevel(metrics.overallRiskScore);
        
        // 8. 触发预警
        if (metrics.riskLevel >= RiskLevel.HIGH) {
            triggerRiskAlert(metrics);
        }
        
        return metrics;
    }
    
    // 计算赫芬达尔指数（市场集中度）
    function calculateHerfindahlIndex(
        address[] memory cdps
    ) private view returns (uint256) {
        uint256 totalDebt;
        uint256[] memory debts = new uint256[](cdps.length);
        
        // 获取总债务和各CDP债务
        for (uint256 i = 0; i < cdps.length; i++) {
            (, debts[i]) = getCDPValues(cdps[i]);
            totalDebt += debts[i];
        }
        
        // 计算HHI
        uint256 hhi;
        for (uint256 i = 0; i < cdps.length; i++) {
            uint256 marketShare = debts[i] * 10000 / totalDebt; // 基点
            hhi += marketShare * marketShare;
        }
        
        return hhi;
    }
    
    // 评估流动性风险
    function assessLiquidityRisk(
        address[] memory collateralTypes
    ) private view returns (uint256) {
        uint256 totalRisk;
        
        for (uint256 i = 0; i < collateralTypes.length; i++) {
            uint256 depth = getMarketDepth(collateralTypes[i]);
            
            if (depth < LOW_LIQUIDITY_DEPTH) {
                // 流动性不足，风险增加
                totalRisk += (LOW_LIQUIDITY_DEPTH - depth) * 1e18 / 
                            LOW_LIQUIDITY_DEPTH;
            }
        }
        
        return totalRisk / collateralTypes.length;
    }
    
    // 计算相关性风险
    function calculateCorrelationRisk(
        address[] memory collateralTypes
    ) private view returns (uint256) {
        // 简化版：计算价格相关系数
        // 实际应用中需要历史数据
        
        if (collateralTypes.length < 2) return 0;
        
        uint256 avgCorrelation;
        uint256 pairCount;
        
        for (uint256 i = 0; i < collateralTypes.length - 1; i++) {
            for (uint256 j = i + 1; j < collateralTypes.length; j++) {
                uint256 correlation = getPriceCorrelation(
                    collateralTypes[i],
                    collateralTypes[j]
                );
                avgCorrelation += correlation;
                pairCount++;
            }
        }
        
        return avgCorrelation / pairCount;
    }
    
    // 运行压力测试场景
    function runStressTest() private returns (SimulationResults memory) {
        SimulationParameters memory params = SimulationParameters({
            numSimulations: 1000,
            timeHorizon: 30,        // 30天
            initialPrice: 1e18,     // $1
            annualVolatility: 5000, // 50%波动率（压力场景）
            drift: -1000,          // -10%负漂移
            jumpProbability: 1e16,  // 1%跳跃概率
            jumpSize: -2e17        // -20%跳跃
        });
        
        return simulator.runMonteCarloSimulation(params, 150, 1000);
    }
    
    // 计算综合风险评分
    function calculateOverallRisk(
        RiskMetrics memory metrics,
        SimulationResults memory simResults
    ) private pure returns (uint256) {
        // 权重配置
        uint256 w1 = 30; // 抵押率权重
        uint256 w2 = 20; // 集中度权重
        uint256 w3 = 25; // 流动性权重
        uint256 w4 = 15; // 相关性权重
        uint256 w5 = 10; // 压力测试权重
        
        // 标准化各项指标（0-100）
        uint256 collateralScore = metrics.systemCollateralRatio > 200 ? 0 :
                                 (200 - metrics.systemCollateralRatio) / 2;
        
        uint256 concentrationScore = metrics.concentrationRisk / 100;
        
        uint256 liquidityScore = metrics.liquidityRisk * 100 / 1e18;
        
        uint256 correlationScore = metrics.correlationRisk * 100 / 1e18;
        
        uint256 stressScore = simResults.defaultProbability * 100 / 1e18;
        
        // 加权平均
        return (collateralScore * w1 + 
                concentrationScore * w2 + 
                liquidityScore * w3 + 
                correlationScore * w4 + 
                stressScore * w5) / 100;
    }
    
    // 确定风险等级
    function determineRiskLevel(uint256 riskScore) 
        private 
        pure 
        returns (RiskLevel) 
    {
        if (riskScore < 25) return RiskLevel.LOW;
        if (riskScore < 50) return RiskLevel.MEDIUM;
        if (riskScore < 75) return RiskLevel.HIGH;
        return RiskLevel.CRITICAL;
    }
    
    // 触发风险预警
    function triggerRiskAlert(RiskMetrics memory metrics) private {
        emit RiskAlert(
            metrics.riskLevel,
            metrics.overallRiskScore,
            block.timestamp
        );
        
        // 自动调整系统参数
        if (metrics.riskLevel == RiskLevel.CRITICAL) {
            // 提高清算线
            // 增加稳定费
            // 限制新借款
        }
    }
    
    // 辅助函数（简化版）
    function getCDPValues(address cdp) 
        private 
        view 
        returns (uint256 collateral, uint256 debt) 
    {
        // 实际实现中从CDP合约读取
        collateral = 150e18;
        debt = 100e18;
    }
    
    function getMarketDepth(address collateral) 
        private 
        view 
        returns (uint256) 
    {
        // 实际实现中从DEX获取流动性深度
        return 2e6 * 1e18;
    }
    
    function getPriceCorrelation(address token1, address token2) 
        private 
        view 
        returns (uint256) 
    {
        // 实际实现中计算历史价格相关性
        return 5e17; // 0.5相关系数
    }
    
    event RiskAlert(RiskLevel level, uint256 score, uint256 timestamp);
}</code></pre>
            </div>
        </div>
        
        <h3>练习题</h3>
        
        <div class="exercise">
            <h4>练习 5.1：实现自适应PID控制器</h4>
            <p>设计一个自适应PID控制器，能够根据市场条件（波动率、交易量、价格偏离程度）自动调整PID参数。要求：</p>
            <ul>
                <li>实现Ziegler-Nichols参数整定方法</li>
                <li>加入抗积分饱和机制</li>
                <li>实现参数平滑过渡（避免突变）</li>
                <li>记录参数调整历史用于分析</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-1')">查看参考答案</button>
            <div id="answer5-1" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract AdaptivePIDController {
    struct PIDParams {
        int256 Kp;
        int256 Ki;
        int256 Kd;
        uint256 timestamp;
    }
    
    PIDParams public currentParams;
    PIDParams[] public paramsHistory;
    
    // Ziegler-Nichols参数
    int256 public Ku;  // 终极增益
    uint256 public Tu; // 终极周期
    
    // 抗积分饱和
    int256 public integralMax = 1e18;
    int256 public integralMin = -1e18;
    
    // 参数平滑
    uint256 public smoothingFactor = 900; // 90%原值 + 10%新值
    
    function adaptParameters(
        uint256 volatility,
        uint256 volume,
        uint256 priceDeviation
    ) external {
        // 计算系统响应特性
        uint256 responseSpeed = calculateResponseSpeed(volatility, volume);
        
        // Ziegler-Nichols整定
        if (needsRetuning(priceDeviation, responseSpeed)) {
            (int256 newKp, int256 newKi, int256 newKd) = 
                zieglerNicholsTuning(responseSpeed);
            
            // 平滑过渡
            currentParams.Kp = (currentParams.Kp * int256(smoothingFactor) + 
                               newKp * int256(1000 - smoothingFactor)) / 1000;
            currentParams.Ki = (currentParams.Ki * int256(smoothingFactor) + 
                               newKi * int256(1000 - smoothingFactor)) / 1000;
            currentParams.Kd = (currentParams.Kd * int256(smoothingFactor) + 
                               newKd * int256(1000 - smoothingFactor)) / 1000;
            
            // 记录历史
            paramsHistory.push(PIDParams({
                Kp: currentParams.Kp,
                Ki: currentParams.Ki,
                Kd: currentParams.Kd,
                timestamp: block.timestamp
            }));
        }
    }
    
    function zieglerNicholsTuning(uint256 responseSpeed) 
        private 
        view 
        returns (int256 Kp, int256 Ki, int256 Kd) 
    {
        // PI控制器参数
        Kp = Ku * 45 / 100;
        Ki = Kp * 1e18 / (Tu * 83 / 100);
        Kd = 0;
        
        // 根据响应速度微调
        if (responseSpeed > 1e18) {
            // 快速响应，增加D项
            Kd = Kp * Tu * 125 / 1000;
        }
    }
    
    function computePIDWithAntiWindup(int256 error, uint256 dt) 
        external 
        returns (int256 output) 
    {
        // P项
        int256 pTerm = currentParams.Kp * error / 1e18;
        
        // I项（带抗饱和）
        int256 newIntegral = integral + error * int256(dt);
        
        // 检查积分限制
        if (newIntegral > integralMax) {
            integral = integralMax;
        } else if (newIntegral < integralMin) {
            integral = integralMin;
        } else {
            integral = newIntegral;
        }
        
        int256 iTerm = currentParams.Ki * integral / 1e18;
        
        // D项（带滤波）
        int256 dTerm = 0;
        if (dt > 0) {
            int256 derivativeRaw = (error - lastError) * 1e18 / int256(dt);
            // 低通滤波
            derivative = (derivative * 8 + derivativeRaw * 2) / 10;
            dTerm = currentParams.Kd * derivative / 1e18;
        }
        
        output = pTerm + iTerm + dTerm;
        
        // 反算积分项防止windup
        if (output > MAX_OUTPUT) {
            integral -= (output - MAX_OUTPUT) * 1e18 / currentParams.Ki;
            output = MAX_OUTPUT;
        } else if (output < MIN_OUTPUT) {
            integral -= (output - MIN_OUTPUT) * 1e18 / currentParams.Ki;
            output = MIN_OUTPUT;
        }
        
        lastError = error;
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习 5.2：构建博弈论清算模型</h4>
            <p>实现一个基于博弈论的清算激励系统，考虑：</p>
            <ul>
                <li>多个Keeper之间的竞争博弈</li>
                <li>CDP持有者的最优响应策略</li>
                <li>实现声誉系统影响Keeper行为</li>
                <li>设计防止恶意清算的机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-2')">查看参考答案</button>
            <div id="answer5-2" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract GameTheoreticLiquidation {
    struct KeeperInfo {
        uint256 reputation;      // 声誉分数
        uint256 successfulLiquidations;
        uint256 failedAttempts;
        uint256 avgResponseTime;
        uint256 totalProfit;
    }
    
    struct LiquidationGame {
        address cdp;
        uint256 startTime;
        uint256 optimalBid;      // 博弈论计算的最优出价
        address[] participants;
        mapping(address => uint256) bids;
        bool settled;
    }
    
    mapping(address => KeeperInfo) public keepers;
    mapping(uint256 => LiquidationGame) public games;
    
    // 计算纳什均衡出价
    function calculateNashEquilibrium(
        uint256 collateralValue,
        uint256 debtValue,
        uint256 numKeepers,
        uint256 gasPrice
    ) public pure returns (uint256 equilibriumBid) {
        // 简化的纳什均衡：
        // 出价 = (抵押品价值 - 债务 - Gas成本) / (参与者数量 + 1)
        
        uint256 profit = collateralValue - debtValue;
        uint256 gasCost = gasPrice * 300000; // 估计Gas消耗
        
        if (profit > gasCost) {
            equilibriumBid = (profit - gasCost) * 1e18 / (numKeepers + 1) / 1e18;
        } else {
            equilibriumBid = 0;
        }
    }
    
    // Keeper提交密封出价（commit-reveal模式）
    function commitBid(uint256 gameId, bytes32 commitment) external {
        require(!games[gameId].settled, "Game settled");
        require(block.timestamp < games[gameId].startTime + 5 minutes, "Commit phase ended");
        
        commitments[gameId][msg.sender] = commitment;
        games[gameId].participants.push(msg.sender);
    }
    
    // 揭示出价
    function revealBid(
        uint256 gameId, 
        uint256 bid, 
        uint256 nonce
    ) external {
        require(block.timestamp >= games[gameId].startTime + 5 minutes, "Still in commit phase");
        require(block.timestamp < games[gameId].startTime + 10 minutes, "Reveal phase ended");
        
        bytes32 commitment = keccak256(abi.encodePacked(bid, nonce, msg.sender));
        require(commitments[gameId][msg.sender] == commitment, "Invalid reveal");
        
        games[gameId].bids[msg.sender] = bid;
        
        // 更新Keeper响应时间
        uint256 responseTime = block.timestamp - games[gameId].startTime;
        updateKeeperStats(msg.sender, responseTime);
    }
    
    // 结算清算博弈
    function settleLiquidationGame(uint256 gameId) external {
        LiquidationGame storage game = games[gameId];
        require(!game.settled, "Already settled");
        require(block.timestamp >= game.startTime + 10 minutes, "Reveal phase not ended");
        
        address winner;
        uint256 highestBid;
        
        // 找出最高出价者（考虑声誉加成）
        for (uint256 i = 0; i < game.participants.length; i++) {
            address keeper = game.participants[i];
            uint256 bid = game.bids[keeper];
            
            // 声誉加成
            uint256 effectiveBid = bid * (1000 + keepers[keeper].reputation) / 1000;
            
            if (effectiveBid > highestBid) {
                highestBid = effectiveBid;
                winner = keeper;
            }
        }
        
        // 执行清算
        if (winner != address(0)) {
            executeLiquidation(game.cdp, winner, game.bids[winner]);
            
            // 更新统计
            keepers[winner].successfulLiquidations++;
            keepers[winner].totalProfit += calculateProfit(gameId, game.bids[winner]);
            
            // 更新声誉
            updateReputation(winner, true);
            
            // 惩罚出价过低的Keeper
            punishLowBidders(gameId, game.optimalBid);
        }
        
        game.settled = true;
    }
    
    // 声誉系统
    function updateReputation(address keeper, bool success) private {
        if (success) {
            keepers[keeper].reputation = min(
                keepers[keeper].reputation + 10,
                1000  // 最高1000分
            );
        } else {
            keepers[keeper].reputation = keepers[keeper].reputation > 10 ? 
                keepers[keeper].reputation - 10 : 0;
        }
    }
    
    // 防恶意清算机制
    function challengeLiquidation(uint256 gameId) external {
        // CDP持有者可以挑战清算
        LiquidationGame storage game = games[gameId];
        require(msg.sender == getCDPOwner(game.cdp), "Not CDP owner");
        require(!game.settled, "Already settled");
        
        // 检查是否真的需要清算
        if (isCDPSafe(game.cdp)) {
            // 清算无效，惩罚发起者
            address liquidator = game.participants[0];
            keepers[liquidator].failedAttempts++;
            updateReputation(liquidator, false);
            
            // 补偿CDP持有者
            compensateCDPOwner(msg.sender);
            
            // 取消清算
            game.settled = true;
        }
    }
    
    // CDP持有者最优响应
    function calculateOptimalResponse(
        uint256 currentCollateralRatio,
        uint256 liquidationRatio,
        uint256 gasPrice
    ) external view returns (
        bool shouldTopUp,
        uint256 topUpAmount,
        bool shouldRepay,
        uint256 repayAmount
    ) {
        uint256 buffer = (currentCollateralRatio - liquidationRatio) * 1e18 / 
                        liquidationRatio;
        
        if (buffer < 1e17) { // 少于10%缓冲
            // 计算补充抵押品vs偿还债务的成本
            uint256 topUpCost = calculateTopUpCost(gasPrice);
            uint256 repayCost = calculateRepayCost(gasPrice);
            
            if (topUpCost < repayCost) {
                shouldTopUp = true;
                topUpAmount = calculateRequiredCollateral(
                    liquidationRatio * 125 / 100  // 目标125%的清算线
                );
            } else {
                shouldRepay = true;
                repayAmount = calculateRequiredRepayment(
                    liquidationRatio * 125 / 100
                );
            }
        }
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习 5.3：期权定价与动态抵押率</h4>
            <p>基于Black-Scholes模型，实现一个动态抵押率调整系统：</p>
            <ul>
                <li>根据隐含波动率实时调整抵押要求</li>
                <li>实现波动率微笑修正</li>
                <li>加入流动性风险溢价</li>
                <li>设计平滑调整机制避免频繁变动</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-3')">查看参考答案</button>
            <div id="answer5-3" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract DynamicCollateralRatio {
    using ABDKMath64x64 for int128;
    
    struct VolatilitySmile {
        uint256 atmVol;          // 平值波动率
        int256 skew;            // 偏斜
        uint256 kurtosis;       // 峰度
    }
    
    struct CollateralAdjustment {
        uint256 baseRatio;
        uint256 volAdjustment;
        uint256 liquidityAdjustment;
        uint256 finalRatio;
        uint256 timestamp;
    }
    
    mapping(address => VolatilitySmile) public volSmiles;
    mapping(address => CollateralAdjustment[]) public adjustmentHistory;
    
    uint256 public smoothingWindow = 4 hours;
    uint256 public maxAdjustmentPerPeriod = 5; // 5%
    
    // 计算隐含波动率
    function calculateImpliedVolatility(
        address asset,
        uint256 optionPrice,
        uint256 strike,
        uint256 spot,
        uint256 timeToExpiry
    ) public pure returns (uint256 impliedVol) {
        // Newton-Raphson迭代求解隐含波动率
        uint256 vol = 3000; // 初始猜测30%
        
        for (uint256 i = 0; i < 10; i++) {
            uint256 theoreticalPrice = blackScholesPrice(
                spot, strike, timeToExpiry, vol, 0
            );
            
            uint256 vega = calculateVega(
                spot, strike, timeToExpiry, vol
            );
            
            if (theoreticalPrice > optionPrice) {
                vol = vol - (theoreticalPrice - optionPrice) * 1e18 / vega;
            } else {
                vol = vol + (optionPrice - theoreticalPrice) * 1e18 / vega;
            }
        }
        
        return vol;
    }
    
    // 波动率微笑修正
    function applyVolatilitySmile(
        uint256 baseVol,
        uint256 moneyness,  // spot/strike
        VolatilitySmile memory smile
    ) public pure returns (uint256 adjustedVol) {
        // 二次修正模型
        int256 lnMoneyness = ln(moneyness);
        
        // vol = ATM_vol + skew * ln(K/S) + kurtosis * ln(K/S)^2
        int256 adjustment = smile.skew * lnMoneyness / 1e18 +
                           int256(smile.kurtosis) * lnMoneyness * 
                           lnMoneyness / 1e36;
        
        if (adjustment > 0) {
            adjustedVol = baseVol + uint256(adjustment);
        } else {
            adjustedVol = baseVol - uint256(-adjustment);
        }
    }
    
    // 计算流动性风险溢价
    function calculateLiquidityPremium(
        address asset,
        uint256 positionSize
    ) public view returns (uint256 premium) {
        uint256 marketDepth = getMarketDepth(asset);
        uint256 impactRatio = positionSize * 1e18 / marketDepth;
        
        // 非线性影响模型
        if (impactRatio < 1e16) { // < 1%
            premium = 0;
        } else if (impactRatio < 5e16) { // 1-5%
            premium = impactRatio / 10; // 10%的影响比例
        } else if (impactRatio < 1e17) { // 5-10%
            premium = impactRatio / 5;  // 20%的影响比例
        } else {
            premium = impactRatio / 2;  // 50%的影响比例
        }
    }
    
    // 动态调整抵押率
    function adjustCollateralRatio(
        address asset,
        uint256 currentRatio
    ) external returns (uint256 newRatio) {
        // 1. 获取最新市场数据
        uint256 spot = getSpotPrice(asset);
        uint256 impliedVol = getImpliedVolatility(asset);
        
        // 2. 应用波动率微笑
        VolatilitySmile memory smile = volSmiles[asset];
        uint256 adjustedVol = applyVolatilitySmile(
            impliedVol,
            1e18, // 平值
            smile
        );
        
        // 3. 基于期权模型计算基础抵押率
        uint256 baseRatio = calculateOptimalRatio(
            spot,
            spot * currentRatio / 100,
            adjustedVol
        );
        
        // 4. 加入流动性风险调整
        uint256 avgPositionSize = getAveragePositionSize(asset);
        uint256 liquidityPremium = calculateLiquidityPremium(
            asset,
            avgPositionSize
        );
        
        uint256 liquidityAdjustedRatio = baseRatio * 
            (1e18 + liquidityPremium) / 1e18;
        
        // 5. 平滑调整
        CollateralAdjustment memory lastAdjustment = 
            getLastAdjustment(asset);
        
        if (block.timestamp < lastAdjustment.timestamp + smoothingWindow) {
            // 在平滑窗口内，限制调整幅度
            int256 change = int256(liquidityAdjustedRatio) - 
                           int256(lastAdjustment.finalRatio);
            
            int256 maxChange = int256(lastAdjustment.finalRatio * 
                                     maxAdjustmentPerPeriod / 100);
            
            if (abs(change) > maxChange) {
                change = change > 0 ? maxChange : -maxChange;
            }
            
            newRatio = uint256(int256(lastAdjustment.finalRatio) + change);
        } else {
            newRatio = liquidityAdjustedRatio;
        }
        
        // 6. 记录调整历史
        adjustmentHistory[asset].push(CollateralAdjustment({
            baseRatio: baseRatio,
            volAdjustment: adjustedVol - impliedVol,
            liquidityAdjustment: liquidityPremium,
            finalRatio: newRatio,
            timestamp: block.timestamp
        }));
        
        return newRatio;
    }
    
    // 计算Vega（期权价格对波动率的敏感度）
    function calculateVega(
        uint256 spot,
        uint256 strike,
        uint256 timeToExpiry,
        uint256 vol
    ) private pure returns (uint256) {
        // 简化的Vega计算
        uint256 d1 = calculateD1(spot, strike, timeToExpiry, vol, 0);
        uint256 sqrtT = sqrt(timeToExpiry * 1e18 / 365 days);
        
        // Vega = S * N'(d1) * sqrt(T)
        uint256 nPrimeD1 = normalPDF(d1);
        return spot * nPrimeD1 * sqrtT / 1e27;
    }
    
    // 正态分布概率密度函数
    function normalPDF(uint256 x) private pure returns (uint256) {
        // N'(x) = 1/√(2π) * e^(-x²/2)
        uint256 exponent = x * x / 2e18;
        uint256 expTerm = exp(-int256(exponent));
        return expTerm * 398942280 / 1e9; // 1/√(2π) ≈ 0.398942280
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习 5.4：综合风险管理系统</h4>
            <p>设计一个综合的风险管理系统，整合前面所有的数学模型：</p>
            <ul>
                <li>实时风险仪表板，显示各项风险指标</li>
                <li>自动触发风险缓解措施</li>
                <li>多场景压力测试引擎</li>
                <li>机器学习风险预测（链下计算，链上验证）</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-4')">查看参考答案</button>
            <div id="answer5-4" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract IntegratedRiskManagement {
    // 风险仪表板
    struct RiskDashboard {
        uint256 overallHealthScore;     // 0-100
        uint256 systemCollateralRatio;
        uint256 liquidityDepth;
        uint256 concentrationIndex;
        uint256 volatilityIndex;
        uint256 stressTestScore;
        PIDStatus pidStatus;
        OptionMetrics optionMetrics;
        MLPrediction mlPrediction;
    }
    
    struct PIDStatus {
        int256 currentError;
        int256 integralError;
        int256 output;
        uint256 lastAdjustment;
    }
    
    struct OptionMetrics {
        uint256 impliedVol;
        uint256 optimalCollateralRatio;
        uint256 expectedLoss;
    }
    
    struct MLPrediction {
        uint256 riskScore;
        uint256 confidence;
        bytes32 modelHash;
        uint256 timestamp;
    }
    
    // 风险缓解措施
    enum RiskMitigation {
        NONE,
        INCREASE_COLLATERAL_RATIO,
        PAUSE_NEW_CDPS,
        INCREASE_STABILITY_FEE,
        TRIGGER_EMERGENCY_SHUTDOWN
    }
    
    // 获取实时风险仪表板
    function getRiskDashboard() 
        external 
        view 
        returns (RiskDashboard memory dashboard) 
    {
        dashboard.systemCollateralRatio = calculateSystemCR();
        dashboard.liquidityDepth = assessLiquidity();
        dashboard.concentrationIndex = calculateConcentration();
        dashboard.volatilityIndex = getVolatilityIndex();
        dashboard.stressTestScore = getLatestStressTestScore();
        
        dashboard.pidStatus = getPIDStatus();
        dashboard.optionMetrics = getOptionMetrics();
        dashboard.mlPrediction = getMLPrediction();
        
        // 计算总体健康分数
        dashboard.overallHealthScore = calculateHealthScore(dashboard);
    }
    
    // 自动风险缓解
    function triggerRiskMitigation() external {
        RiskDashboard memory dashboard = getRiskDashboard();
        
        RiskMitigation action = determineAction(dashboard);
        
        if (action == RiskMitigation.INCREASE_COLLATERAL_RATIO) {
            adjustCollateralRequirements(5); // 增加5%
        } else if (action == RiskMitigation.PAUSE_NEW_CDPS) {
            pauseNewCDPCreation();
        } else if (action == RiskMitigation.INCREASE_STABILITY_FEE) {
            increaseStabilityFee(2); // 增加2%
        } else if (action == RiskMitigation.TRIGGER_EMERGENCY_SHUTDOWN) {
            triggerEmergencyShutdown();
        }
        
        emit RiskMitigationTriggered(action, dashboard.overallHealthScore);
    }
    
    // 多场景压力测试
    function runComprehensiveStressTest() external returns (
        StressTestResults memory results
    ) {
        // 场景1：黑天鹅事件
        results.blackSwanImpact = simulateBlackSwan(
            50, // 50%价格下跌
            1 hours // 1小时内
        );
        
        // 场景2：流动性危机
        results.liquidityCrisisImpact = simulateLiquidityCrisis(
            90 // 90%流动性枯竭
        );
        
        // 场景3：级联清算
        results.cascadeLiquidationImpact = simulateCascadeLiquidation(
            30 // 30%的CDP同时清算
        );
        
        // 场景4：预言机攻击
        results.oracleAttackImpact = simulateOracleAttack(
            20 // 20%价格操纵
        );
        
        // 场景5：网络拥堵
        results.networkCongestionImpact = simulateNetworkCongestion(
            1000 gwei // 极高Gas价格
        );
        
        // 综合评估
        results.worstCaseScenario = max(
            results.blackSwanImpact,
            results.liquidityCrisisImpact,
            results.cascadeLiquidationImpact,
            results.oracleAttackImpact,
            results.networkCongestionImpact
        );
        
        updateStressTestScore(results.worstCaseScenario);
    }
    
    // ML风险预测验证
    function verifyMLPrediction(
        uint256 predictedRisk,
        uint256 confidence,
        bytes32 modelHash,
        bytes memory proof
    ) external {
        // 验证链下ML模型的预测
        require(verifyZKProof(proof, modelHash), "Invalid ML proof");
        
        mlPredictions[block.timestamp] = MLPrediction({
            riskScore: predictedRisk,
            confidence: confidence,
            modelHash: modelHash,
            timestamp: block.timestamp
        });
        
        // 如果ML预测高风险，触发额外验证
        if (predictedRisk > 80 && confidence > 90) {
            requireManualReview = true;
            emit HighRiskMLPrediction(predictedRisk, confidence);
        }
    }
    
    // 综合健康评分计算
    function calculateHealthScore(RiskDashboard memory dashboard) 
        private 
        pure 
        returns (uint256) 
    {
        uint256 score = 100;
        
        // 抵押率评分
        if (dashboard.systemCollateralRatio < 150) {
            score -= (150 - dashboard.systemCollateralRatio) / 2;
        }
        
        // 流动性评分
        if (dashboard.liquidityDepth < 10e6 * 1e18) {
            score -= 20;
        }
        
        // 集中度评分
        if (dashboard.concentrationIndex > 1000) { // HHI > 1000
            score -= 15;
        }
        
        // 波动率评分
        if (dashboard.volatilityIndex > 50) {
            score -= (dashboard.volatilityIndex - 50) / 2;
        }
        
        // ML预测调整
        if (dashboard.mlPrediction.confidence > 80) {
            score = score * (100 - dashboard.mlPrediction.riskScore) / 100;
        }
        
        return score > 0 ? score : 0;
    }
}</code></pre>
            </div>
        </div>
        
        <h3>本章小结</h3>
        <div class="tip">
            <strong>关键要点：</strong>
            <ul>
                <li><strong>控制理论应用：</strong>PID控制器可以有效维持稳定币价格稳定，但需要根据市场条件动态调整参数</li>
                <li><strong>博弈论视角：</strong>清算机制设计需要平衡多方利益，确保系统激励相容</li>
                <li><strong>期权定价模型：</strong>Black-Scholes模型提供了科学的抵押率定价方法</li>
                <li><strong>风险管理：</strong>综合运用多种数学模型，构建全方位的风险管理体系</li>
                <li><strong>实践价值：</strong>这些理论模型不是纸上谈兵，而是可以直接应用于生产环境的实用工具</li>
            </ul>
        </div>
        
        <h3>术语速查表</h3>
        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
            <tr style="background: #f3f4f6;">
                <th style="border: 1px solid #ddd; padding: 12px;">术语</th>
                <th style="border: 1px solid #ddd; padding: 12px;">英文</th>
                <th style="border: 1px solid #ddd; padding: 12px;">含义</th>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">PID控制器</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Proportional-Integral-Derivative Controller</td>
                <td style="border: 1px solid #ddd; padding: 8px;">经典的反馈控制算法</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">纳什均衡</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Nash Equilibrium</td>
                <td style="border: 1px solid #ddd; padding: 8px;">博弈论中的稳定状态</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">隐含波动率</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Implied Volatility</td>
                <td style="border: 1px solid #ddd; padding: 8px;">从期权价格反推的波动率</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">VaR</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Value at Risk</td>
                <td style="border: 1px solid #ddd; padding: 8px;">风险价值，潜在损失的统计度量</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">蒙特卡洛模拟</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Monte Carlo Simulation</td>
                <td style="border: 1px solid #ddd; padding: 8px;">基于随机抽样的数值计算方法</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">积分饱和</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Integral Windup</td>
                <td style="border: 1px solid #ddd; padding: 8px;">PID控制器中积分项过度累积</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">波动率微笑</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Volatility Smile</td>
                <td style="border: 1px solid #ddd; padding: 8px;">不同行权价的隐含波动率曲线</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">HHI指数</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Herfindahl-Hirschman Index</td>
                <td style="border: 1px solid #ddd; padding: 8px;">市场集中度指标</td>
            </tr>
        </table>
    </div>
    
    <h3>5.6 2024年最新发展：LST/LRT与RWA</h3>
    
    <h4>5.6.1 流动性质押代币(LST)作为抵押品</h4>
    <p>随着以太坊转向PoS，流动性质押代币（Liquid Staking Tokens）如stETH、rETH成为重要的抵押品类型。这带来了新的风险管理挑战。</p>
    
    <div class="info-box">
        <h5>💡 LST特有风险</h5>
        <ul>
            <li><strong>脱锚风险</strong>：LST可能与底层ETH脱锚，特别是在市场压力下</li>
            <li><strong>Slashing风险</strong>：验证者被罚没可能影响LST价值</li>
            <li><strong>流动性风险</strong>：赎回延迟可能影响清算效率</li>
            <li><strong>技术风险</strong>：智能合约和节点运营商风险</li>
        </ul>
    </div>
    
    <pre><code class="language-solidity">// LST抵押品管理合约
contract LSTCollateralManager {
    // LST特定参数
    struct LSTConfig {
        uint256 maxDeviationFromETH;      // 最大允许脱锚幅度 (如2%)
        uint256 liquidationPenalty;       // 清算罚金（考虑赎回延迟）
        uint256 minLiquidityThreshold;    // 最小流动性要求
        address oracle;                   // 专用价格预言机
    }
    
    mapping(address => LSTConfig) public lstConfigs;
    
    // 评估LST抵押品价值
    function getLSTValue(
        address lstToken,
        uint256 amount
    ) public view returns (uint256) {
        LSTConfig memory config = lstConfigs[lstToken];
        
        // 获取LST/ETH汇率
        uint256 lstToEthRate = IOracle(config.oracle).getRate(lstToken);
        uint256 ethPrice = getETHPrice();
        
        // 检查脱锚程度
        uint256 deviation = lstToEthRate > 1e18 ? 
            lstToEthRate - 1e18 : 1e18 - lstToEthRate;
            
        require(
            deviation <= config.maxDeviationFromETH,
            "LST deviation too high"
        );
        
        // 应用折扣因子（考虑流动性和赎回风险）
        uint256 discountFactor = calculateDiscountFactor(
            lstToken,
            amount,
            config.minLiquidityThreshold
        );
        
        return amount * lstToEthRate * ethPrice * discountFactor / 1e36;
    }
    
    // 计算折扣因子
    function calculateDiscountFactor(
        address lstToken,
        uint256 amount,
        uint256 minLiquidity
    ) internal view returns (uint256) {
        // 检查链上流动性深度
        uint256 liquidity = getOnchainLiquidity(lstToken);
        
        if (liquidity < minLiquidity) {
            // 流动性不足，应用额外折扣
            return 9500; // 95%
        }
        
        // 检查可立即兑换的量
        uint256 instantRedeemable = getInstantRedeemableAmount(lstToken);
        
        if (amount > instantRedeemable) {
            // 需要等待期，应用折扣
            return 9700; // 97%
        }
        
        return 9900; // 99%基础折扣
    }
}</code></pre>
    
    <h4>5.6.2 真实世界资产(RWA)集成</h4>
    <p>RWA（Real World Assets）的引入为稳定币提供了更稳定的收益来源，但也带来了新的复杂性。</p>
    
    <pre><code class="language-python"># RWA风险评估框架
class RWACollateralManager:
    def __init__(self):
        self.rwa_types = {
            'US_TREASURY': {
                'risk_weight': 0.05,
                'liquidity_score': 0.95,
                'legal_complexity': 0.3
            },
            'CORPORATE_BOND': {
                'risk_weight': 0.20,
                'liquidity_score': 0.70,
                'legal_complexity': 0.6
            },
            'REAL_ESTATE': {
                'risk_weight': 0.35,
                'liquidity_score': 0.30,
                'legal_complexity': 0.9
            }
        }
    
    def assess_rwa_risk(self, asset_type, amount, credit_rating):
        """评估RWA风险"""
        base_risk = self.rwa_types[asset_type]
        
        # 信用风险调整
        credit_multiplier = self.get_credit_multiplier(credit_rating)
        
        # 集中度风险
        concentration_factor = self.calculate_concentration_risk(
            asset_type, amount
        )
        
        # 综合风险评分
        risk_score = (
            base_risk['risk_weight'] * credit_multiplier * 
            concentration_factor
        )
        
        # 计算所需抵押率
        required_collateral_ratio = 1.5 + risk_score * 2
        
        return {
            'risk_score': risk_score,
            'required_ratio': required_collateral_ratio,
            'liquidity_haircut': 1 - base_risk['liquidity_score'],
            'legal_reserve': base_risk['legal_complexity'] * 0.1
        }
    
    def monitor_rwa_portfolio(self, portfolio):
        """监控RWA组合风险"""
        alerts = []
        
        # 检查到期分布
        maturity_concentration = self.check_maturity_concentration(portfolio)
        if maturity_concentration > 0.3:
            alerts.append("High maturity concentration risk")
        
        # 检查发行人集中度
        issuer_concentration = self.check_issuer_concentration(portfolio)
        if issuer_concentration > 0.15:
            alerts.append("High issuer concentration")
        
        # 检查法律管辖区风险
        jurisdiction_risk = self.assess_jurisdiction_risk(portfolio)
        if jurisdiction_risk > 0.7:
            alerts.append("High jurisdictional risk")
        
        return alerts</code></pre>
    
    <h3>5.7 预言机安全与治理机制</h3>
    
    <h4>5.7.1 多层预言机防御体系</h4>
    <p>预言机是稳定币系统的关键攻击向量，需要多层防御机制。</p>
    
    <pre><code class="language-solidity">// 安全预言机聚合器
contract SecureOracleAggregator {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;
    }
    
    struct OracleConfig {
        address oracle;
        uint256 weight;
        uint256 maxDeviation;
        bool isActive;
    }
    
    mapping(address => OracleConfig[]) public assetOracles;
    mapping(address => PriceData) public cachedPrices;
    
    uint256 public constant PRICE_STALENESS_THRESHOLD = 3600; // 1小时
    uint256 public constant EMERGENCY_PAUSE_DURATION = 86400;  // 24小时
    
    // 获取安全价格（带TWAP和异常检测）
    function getSecurePrice(
        address asset
    ) external returns (uint256 price, uint256 confidence) {
        OracleConfig[] memory oracles = assetOracles[asset];
        require(oracles.length >= 3, "Insufficient oracles");
        
        uint256[] memory prices = new uint256[](oracles.length);
        uint256[] memory weights = new uint256[](oracles.length);
        uint256 validOracles = 0;
        
        // 收集所有预言机价格
        for (uint i = 0; i < oracles.length; i++) {
            if (!oracles[i].isActive) continue;
            
            try IOracle(oracles[i].oracle).getPrice(asset) 
            returns (uint256 oraclePrice) {
                // 异常检测：价格偏离检查
                if (isAnomalousPrice(asset, oraclePrice)) {
                    emit AnomalousPrice(oracles[i].oracle, oraclePrice);
                    continue;
                }
                
                prices[validOracles] = oraclePrice;
                weights[validOracles] = oracles[i].weight;
                validOracles++;
            } catch {
                emit OracleFailure(oracles[i].oracle);
            }
        }
        
        require(validOracles >= 2, "Insufficient valid prices");
        
        // 计算加权中位数
        price = calculateWeightedMedian(prices, weights, validOracles);
        
        // 计算置信度
        confidence = calculateConfidence(prices, validOracles);
        
        // 更新缓存
        cachedPrices[asset] = PriceData({
            price: price,
            timestamp: block.timestamp,
            confidence: confidence
        });
        
        // 如果置信度低，触发紧急模式
        if (confidence < 7000) { // 70%
            triggerEmergencyMode(asset);
        }
        
        return (price, confidence);
    }
    
    // 异常价格检测
    function isAnomalousPrice(
        address asset,
        uint256 newPrice
    ) internal view returns (bool) {
        PriceData memory cached = cachedPrices[asset];
        
        // 如果没有历史价格，接受
        if (cached.timestamp == 0) return false;
        
        // 检查价格变化幅度
        uint256 priceChange = newPrice > cached.price ?
            (newPrice - cached.price) * 10000 / cached.price :
            (cached.price - newPrice) * 10000 / cached.price;
        
        // 根据时间调整阈值
        uint256 timeDelta = block.timestamp - cached.timestamp;
        uint256 maxAllowedChange = calculateMaxPriceChange(timeDelta);
        
        return priceChange > maxAllowedChange;
    }
    
    // 计算加权中位数
    function calculateWeightedMedian(
        uint256[] memory prices,
        uint256[] memory weights,
        uint256 count
    ) internal pure returns (uint256) {
        // 排序
        for (uint i = 0; i < count - 1; i++) {
            for (uint j = i + 1; j < count; j++) {
                if (prices[i] > prices[j]) {
                    (prices[i], prices[j]) = (prices[j], prices[i]);
                    (weights[i], weights[j]) = (weights[j], weights[i]);
                }
            }
        }
        
        // 找到加权中位数
        uint256 totalWeight = 0;
        for (uint i = 0; i < count; i++) {
            totalWeight += weights[i];
        }
        
        uint256 targetWeight = totalWeight / 2;
        uint256 cumulativeWeight = 0;
        
        for (uint i = 0; i < count; i++) {
            cumulativeWeight += weights[i];
            if (cumulativeWeight >= targetWeight) {
                return prices[i];
            }
        }
        
        return prices[count - 1];
    }
}</code></pre>
    
    <h4>5.7.2 治理与紧急响应机制</h4>
    <p>有效的治理机制对于稳定币系统的长期可持续性至关重要。</p>
    
    <pre><code class="language-solidity">// 治理与紧急响应合约
contract GovernanceEmergencyResponse {
    enum ProposalType { PARAMETER, EMERGENCY, UPGRADE }
    enum EmergencyLevel { LOW, MEDIUM, HIGH, CRITICAL }
    
    struct Proposal {
        ProposalType proposalType;
        address target;
        bytes data;
        uint256 startTime;
        uint256 endTime;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        bool cancelled;
    }
    
    struct EmergencyAction {
        EmergencyLevel level;
        address[] affectedContracts;
        bytes[] actions;
        uint256 executionTime;
        bool executed;
    }
    
    // 时间锁配置
    mapping(ProposalType => uint256) public timelocks;
    mapping(EmergencyLevel => uint256) public emergencyDelays;
    
    // 多签安全委员会
    address[] public securityCouncil;
    uint256 public councilThreshold;
    
    constructor() {
        // 设置时间锁
        timelocks[ProposalType.PARAMETER] = 2 days;
        timelocks[ProposalType.EMERGENCY] = 6 hours;
        timelocks[ProposalType.UPGRADE] = 7 days;
        
        // 设置紧急延迟
        emergencyDelays[EmergencyLevel.LOW] = 24 hours;
        emergencyDelays[EmergencyLevel.MEDIUM] = 6 hours;
        emergencyDelays[EmergencyLevel.HIGH] = 1 hours;
        emergencyDelays[EmergencyLevel.CRITICAL] = 0; // 立即执行
    }
    
    // 创建提案（带自动分类）
    function createProposal(
        address target,
        bytes calldata data,
        string calldata description
    ) external returns (uint256 proposalId) {
        // 自动分类提案类型
        ProposalType pType = classifyProposal(target, data);
        
        // 检查提案者权限
        require(
            hasProposalRight(msg.sender, pType),
            "Insufficient rights"
        );
        
        // 创建提案
        uint256 votingPeriod = getVotingPeriod(pType);
        
        proposals[proposalId] = Proposal({
            proposalType: pType,
            target: target,
            data: data,
            startTime: block.timestamp,
            endTime: block.timestamp + votingPeriod,
            forVotes: 0,
            againstVotes: 0,
            executed: false,
            cancelled: false
        });
        
        emit ProposalCreated(proposalId, pType, description);
    }
    
    // 紧急暂停机制
    function emergencyPause(
        EmergencyLevel level,
        address[] calldata contracts,
        string calldata reason
    ) external onlySecurityCouncil {
        require(level >= EmergencyLevel.HIGH, "Not emergency");
        
        // 记录紧急行动
        uint256 actionId = nextEmergencyActionId++;
        emergencyActions[actionId] = EmergencyAction({
            level: level,
            affectedContracts: contracts,
            actions: new bytes[](contracts.length),
            executionTime: block.timestamp + emergencyDelays[level],
            executed: false
        });
        
        // 如果是CRITICAL级别，立即执行
        if (level == EmergencyLevel.CRITICAL) {
            executeEmergencyPause(actionId);
        }
        
        emit EmergencyActionInitiated(actionId, level, reason);
    }
    
    // 执行紧急暂停
    function executeEmergencyPause(uint256 actionId) internal {
        EmergencyAction storage action = emergencyActions[actionId];
        require(!action.executed, "Already executed");
        
        for (uint i = 0; i < action.affectedContracts.length; i++) {
            // 调用紧急暂停函数
            (bool success,) = action.affectedContracts[i].call(
                abi.encodeWithSignature("emergencyPause()")
            );
            require(success, "Pause failed");
        }
        
        action.executed = true;
        emit EmergencyActionExecuted(actionId);
    }
    
    // 恢复机制（需要更高级别的批准）
    function emergencyResume(
        address[] calldata contracts,
        uint256[] calldata councilSignatures
    ) external {
        require(
            councilSignatures.length >= councilThreshold * 2,
            "Need super majority for resume"
        );
        
        // 验证签名...
        
        for (uint i = 0; i < contracts.length; i++) {
            IEmergencyPausable(contracts[i]).emergencyResume();
        }
        
        emit EmergencyResumed(contracts);
    }
}</code></pre>
    
    <h3>5.8 高级控制模型</h3>
    
    <h4>5.8.1 模型预测控制(MPC)</h4>
    <p>MPC通过预测未来系统行为来优化控制决策，特别适合处理约束和多目标优化问题。</p>
    
    <pre><code class="language-python"># 稳定币MPC控制器
import numpy as np
from scipy.optimize import minimize
import cvxpy as cp

class StablecoinMPC:
    def __init__(self, prediction_horizon=10, control_horizon=5):
        self.N = prediction_horizon  # 预测时域
        self.M = control_horizon     # 控制时域
        
        # 系统模型参数
        self.dt = 1.0  # 时间步长（小时）
        
        # 状态：[价格偏差, 供应量, 抵押率]
        # 控制：[铸造/销毁率, 稳定费调整, 清算阈值调整]
        
    def predict_system_dynamics(self, x0, u_sequence):
        """预测系统未来状态"""
        x_pred = np.zeros((self.N + 1, 3))
        x_pred[0] = x0
        
        for k in range(self.N):
            # 获取控制输入
            u = u_sequence[min(k, self.M - 1)]
            
            # 非线性动态模型
            x_pred[k + 1] = self.system_dynamics(x_pred[k], u)
        
        return x_pred
    
    def system_dynamics(self, x, u):
        """系统动态方程"""
        price_dev, supply, coll_ratio = x
        mint_rate, fee_adj, threshold_adj = u
        
        # 价格动态（受供需和市场情绪影响）
        market_pressure = self.estimate_market_pressure()
        price_elasticity = 0.001  # 价格弹性
        
        new_price_dev = price_dev + self.dt * (
            -price_elasticity * mint_rate +  # 供应影响
            0.05 * market_pressure +          # 市场压力
            -0.02 * fee_adj                   # 费用调整影响
        )
        
        # 供应量动态
        new_supply = supply + self.dt * mint_rate
        
        # 抵押率动态
        volatility = self.estimate_volatility()
        new_coll_ratio = coll_ratio + self.dt * (
            threshold_adj - 0.1 * volatility * np.random.randn()
        )
        
        return np.array([new_price_dev, new_supply, new_coll_ratio])
    
    def compute_optimal_control(self, x0, reference):
        """计算最优控制序列"""
        # 定义优化变量
        u = cp.Variable((self.M, 3))
        
        # 预测状态轨迹
        x = cp.Variable((self.N + 1, 3))
        x[0] = x0
        
        # 构建优化问题
        cost = 0
        
        for k in range(self.N):
            # 状态误差成本
            Q = np.diag([100, 1, 10])  # 权重矩阵
            cost += cp.quad_form(x[k] - reference, Q)
            
            # 控制成本
            if k < self.M:
                R = np.diag([0.1, 1, 1])
                cost += cp.quad_form(u[k], R)
                
                # 控制变化率惩罚
                if k > 0:
                    cost += 10 * cp.norm(u[k] - u[k-1], 2)
        
        # 约束条件
        constraints = []
        
        # 系统动态约束（线性化）
        A, B = self.linearize_dynamics(x0)
        for k in range(self.N):
            u_idx = min(k, self.M - 1)
            constraints.append(
                x[k + 1] == A @ x[k] + B @ u[u_idx]
            )
        
        # 控制约束
        constraints.append(u[:, 0] >= -1000)  # 最大销毁率
        constraints.append(u[:, 0] <= 1000)   # 最大铸造率
        constraints.append(u[:, 1] >= -0.05)  # 费用调整限制
        constraints.append(u[:, 1] <= 0.05)
        constraints.append(u[:, 2] >= -0.1)   # 阈值调整限制
        constraints.append(u[:, 2] <= 0.1)
        
        # 状态约束
        constraints.append(x[:, 0] >= -0.05)  # 价格偏差限制
        constraints.append(x[:, 0] <= 0.05)
        constraints.append(x[:, 2] >= 1.2)    # 最小抵押率
        
        # 求解优化问题
        problem = cp.Problem(cp.Minimize(cost), constraints)
        problem.solve(solver=cp.OSQP)
        
        if problem.status == cp.OPTIMAL:
            return u.value[0]  # 返回第一个控制动作
        else:
            # 返回安全默认控制
            return np.array([0, 0, 0])
    
    def linearize_dynamics(self, x0):
        """在当前状态点线性化系统"""
        # 使用数值微分计算雅可比矩阵
        eps = 1e-6
        n_x, n_u = 3, 3
        
        A = np.zeros((n_x, n_x))
        B = np.zeros((n_x, n_u))
        
        # 计算A矩阵
        for i in range(n_x):
            x_plus = x0.copy()
            x_plus[i] += eps
            x_minus = x0.copy()
            x_minus[i] -= eps
            
            f_plus = self.system_dynamics(x_plus, np.zeros(n_u))
            f_minus = self.system_dynamics(x_minus, np.zeros(n_u))
            
            A[:, i] = (f_plus - f_minus) / (2 * eps)
        
        # 计算B矩阵
        for i in range(n_u):
            u_plus = np.zeros(n_u)
            u_plus[i] = eps
            u_minus = np.zeros(n_u)
            u_minus[i] = -eps
            
            f_plus = self.system_dynamics(x0, u_plus)
            f_minus = self.system_dynamics(x0, u_minus)
            
            B[:, i] = (f_plus - f_minus) / (2 * eps)
        
        return A, B</code></pre>
    
    <h4>5.8.2 强化学习控制器</h4>
    <p>使用深度强化学习自动学习最优控制策略。</p>
    
    <pre><code class="language-python"># 基于PPO的稳定币控制器
import torch
import torch.nn as nn
import torch.optim as optim
from torch.distributions import Normal

class StablecoinPPOAgent:
    def __init__(self, state_dim=10, action_dim=3, lr=3e-4):
        self.state_dim = state_dim
        self.action_dim = action_dim
        
        # Actor网络（策略）
        self.actor = nn.Sequential(
            nn.Linear(state_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, action_dim * 2)  # 均值和标准差
        )
        
        # Critic网络（价值函数）
        self.critic = nn.Sequential(
            nn.Linear(state_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, 1)
        )
        
        self.actor_optimizer = optim.Adam(self.actor.parameters(), lr=lr)
        self.critic_optimizer = optim.Adam(self.critic.parameters(), lr=lr)
        
    def get_action(self, state):
        """根据当前状态选择动作"""
        state_tensor = torch.FloatTensor(state).unsqueeze(0)
        
        # 获取动作分布参数
        output = self.actor(state_tensor)
        mean = output[:, :self.action_dim]
        log_std = output[:, self.action_dim:]
        std = torch.exp(log_std)
        
        # 采样动作
        dist = Normal(mean, std)
        action = dist.sample()
        log_prob = dist.log_prob(action).sum(-1)
        
        # 动作裁剪
        action = torch.tanh(action)  # [-1, 1]
        
        return action.numpy()[0], log_prob
    
    def compute_reward(self, state, action, next_state):
        """计算奖励函数"""
        price_dev = next_state[0]
        volatility = next_state[1]
        liquidity = next_state[2]
        gas_cost = self.estimate_gas_cost(action)
        
        # 多目标奖励设计
        reward = 0
        
        # 价格稳定奖励
        price_reward = -100 * abs(price_dev)
        reward += price_reward
        
        # 波动率惩罚
        volatility_penalty = -10 * volatility
        reward += volatility_penalty
        
        # 流动性奖励
        liquidity_reward = 5 * np.log1p(liquidity)
        reward += liquidity_reward
        
        # Gas成本惩罚
        gas_penalty = -0.01 * gas_cost
        reward += gas_penalty
        
        # 极端情况额外惩罚
        if abs(price_dev) > 0.05:  # 5%脱锚
            reward -= 1000
        
        return reward
    
    def train(self, trajectories, epochs=10, clip_epsilon=0.2):
        """PPO训练更新"""
        states = torch.FloatTensor(trajectories['states'])
        actions = torch.FloatTensor(trajectories['actions'])
        rewards = torch.FloatTensor(trajectories['rewards'])
        old_log_probs = torch.FloatTensor(trajectories['log_probs'])
        
        # 计算优势估计
        values = self.critic(states).squeeze()
        advantages = self.compute_advantages(rewards, values)
        
        for epoch in range(epochs):
            # 更新Actor
            output = self.actor(states)
            mean = output[:, :self.action_dim]
            log_std = output[:, self.action_dim:]
            std = torch.exp(log_std)
            
            dist = Normal(mean, std)
            new_log_probs = dist.log_prob(actions).sum(-1)
            
            # PPO裁剪
            ratio = torch.exp(new_log_probs - old_log_probs)
            clipped_ratio = torch.clamp(ratio, 1 - clip_epsilon, 1 + clip_epsilon)
            actor_loss = -torch.min(
                ratio * advantages,
                clipped_ratio * advantages
            ).mean()
            
            self.actor_optimizer.zero_grad()
            actor_loss.backward()
            self.actor_optimizer.step()
            
            # 更新Critic
            new_values = self.critic(states).squeeze()
            critic_loss = nn.MSELoss()(new_values, rewards)
            
            self.critic_optimizer.zero_grad()
            critic_loss.backward()
            self.critic_optimizer.step()
    
    def compute_advantages(self, rewards, values, gamma=0.99, lam=0.95):
        """计算广义优势估计(GAE)"""
        advantages = torch.zeros_like(rewards)
        last_advantage = 0
        
        for t in reversed(range(len(rewards) - 1)):
            delta = rewards[t] + gamma * values[t + 1] - values[t]
            advantages[t] = last_advantage = delta + gamma * lam * last_advantage
        
        return advantages</code></pre>
    
    <h3>5.9 死亡螺旋预防机制</h3>
    
    <p>死亡螺旋是算法稳定币最大的系统性风险，需要多重预防机制。</p>
    
    <div class="info-box">
        <h5>🚨 死亡螺旋触发条件</h5>
        <ul>
            <li>市场信心丧失导致大规模抛售</li>
            <li>抵押品价值急剧下跌</li>
            <li>清算级联效应</li>
            <li>流动性枯竭</li>
        </ul>
    </div>
    
    <pre><code class="language-solidity">// 死亡螺旋预防系统
contract DeathSpiralPrevention {
    struct SystemHealth {
        uint256 priceDeviation;
        uint256 supplyVelocity;
        uint256 collateralRatio;
        uint256 liquidityDepth;
        uint256 marketConfidence;
    }
    
    enum RiskLevel { NORMAL, ELEVATED, HIGH, CRITICAL }
    
    // 断路器参数
    uint256 public constant SUPPLY_VELOCITY_THRESHOLD = 1000; // 10%/小时
    uint256 public constant PRICE_DEVIATION_THRESHOLD = 500;  // 5%
    uint256 public constant LIQUIDITY_THRESHOLD = 1e6;        // $1M
    
    // 动态参数调整
    function assessSystemRisk() public view returns (RiskLevel) {
        SystemHealth memory health = getCurrentHealth();
        
        uint256 riskScore = 0;
        
        // 价格偏离评分
        if (health.priceDeviation > PRICE_DEVIATION_THRESHOLD) {
            riskScore += 30;
        }
        
        // 供应速度评分
        if (health.supplyVelocity > SUPPLY_VELOCITY_THRESHOLD) {
            riskScore += 25;
        }
        
        // 抵押率评分
        if (health.collateralRatio < 150) {
            riskScore += 25;
        }
        
        // 流动性评分
        if (health.liquidityDepth < LIQUIDITY_THRESHOLD) {
            riskScore += 20;
        }
        
        // 确定风险等级
        if (riskScore >= 70) return RiskLevel.CRITICAL;
        if (riskScore >= 50) return RiskLevel.HIGH;
        if (riskScore >= 30) return RiskLevel.ELEVATED;
        return RiskLevel.NORMAL;
    }
    
    // 自动触发保护机制
    function activateProtection(RiskLevel risk) external {
        if (risk == RiskLevel.CRITICAL) {
            // 1. 暂停所有铸造
            pauseMinting();
            
            // 2. 提高清算激励
            increaseLiquidationIncentive(150); // 15%
            
            // 3. 激活紧急流动性池
            activateEmergencyLiquidity();
            
            // 4. 降低借贷上限
            reduceBorrowingCaps(50); // 减少50%
        }
        else if (risk == RiskLevel.HIGH) {
            // 渐进式调整
            adjustStabilityFee(200); // +2%
            adjustLiquidationRatio(105); // 提高5%
            enableSupplyThrottling();
        }
    }
    
    // 紧急流动性注入
    function activateEmergencyLiquidity() internal {
        uint256 reserveAmount = emergencyReserve.balance();
        
        // 使用储备基金提供流动性
        if (reserveAmount > 0) {
            // 在主要DEX添加流动性
            addLiquidityToAMM(reserveAmount / 2);
            
            // 设置价格支撑订单
            createPriceSupportOrders(reserveAmount / 2);
        }
        
        emit EmergencyLiquidityActivated(reserveAmount);
    }
}</code></pre>
    
    <h3>第五章小结</h3>
    
    <p>本章深入探讨了稳定币系统的数学建模和控制理论应用：</p>
    
    <ul>
        <li><strong>控制理论基础</strong>：从PID控制器到高级MPC和强化学习方法</li>
        <li><strong>博弈论应用</strong>：清算机制设计和MEV防护</li>
        <li><strong>金融模型适配</strong>：Black-Scholes在DeFi环境下的调整</li>
        <li><strong>风险管理</strong>：压力测试和蒙特卡洛模拟</li>
        <li><strong>2024最新发展</strong>：LST/LRT集成和RWA风险管理</li>
        <li><strong>安全机制</strong>：预言机防护和治理响应</li>
        <li><strong>系统稳定性</strong>：死亡螺旋预防和紧急干预</li>
    </ul>
    
    <div class="key-concepts">
        <h4>🔑 关键要点</h4>
        <ol>
            <li>稳定币控制是一个多变量、非线性、有约束的复杂系统</li>
            <li>需要结合多种控制方法，没有单一最优解</li>
            <li>预言机安全和治理机制是系统稳定的基础</li>
            <li>必须为极端市场情况设计充分的预防机制</li>
            <li>新型抵押品（LST/RWA）带来新的风险维度</li>
        </ol>
    </div>
    
    <!-- 第六章：AMM集成 -->
    <div class="chapter" id="chapter6">
        <h2>第六章：AMM集成与流动性管理</h2>
        
        <div class="intro-box">
            <strong>本章概览：</strong>
            <ul>
                <li>自动做市商（AMM）基础原理与数学模型</li>
                <li>Uniswap V2/V3在稳定币交易中的应用</li>
                <li>Curve StableSwap算法深度解析</li>
                <li>集中流动性与稳定币对优化</li>
                <li>实战：构建专门的稳定币AMM</li>
            </ul>
        </div>
        
        <div class="tip-box">
            <strong>🎯 章节目标：</strong>
            <p>本章将深入探讨稳定币如何与各种AMM协议集成，理解不同AMM模型对稳定币交易的影响，并学习如何设计和优化稳定币专用的流动性池。对于资深开发者，我们将重点关注数学原理、Gas优化和MEV防护。</p>
        </div>

        <h3>6.1 AMM基础原理与稳定币特性</h3>
        
        <h4>6.1.1 从恒定乘积到恒定和：理论张力的建立</h4>
        <p>要理解稳定币AMM的设计哲学，我们需要从两个极端模型开始：</p>
        
        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <h5>1. 恒定乘积模型（Constant Product）</h5>
            <p style="text-align: center; font-size: 1.2em;">x · y = k</p>
            <ul>
                <li><strong>优点：</strong>永远有流动性，价格可以从0到∞</li>
                <li><strong>缺点：</strong>即使是稳定币之间的小额交易也有显著滑点</li>
                <li><strong>资本效率：</strong>极低 - 99%的流动性备用在0.9以下或1.1以上的价格区间</li>
            </ul>
            
            <h5>2. 恒定和模型（Constant Sum）</h5>
            <p style="text-align: center; font-size: 1.2em;">x + y = k</p>
            <ul>
                <li><strong>优点：</strong>零滑点，完美的1:1兑换</li>
                <li><strong>缺点：</strong>会完全耗尽其中一种资产，无法应对价格偏离</li>
                <li><strong>致命缺陷：</strong>一旦出现微小的价格差异，套利者会瞬间清空"好"资产</li>
            </ul>
        </div>
        
        <div class="info-box">
            <h5>🎯 核心设计挑战</h5>
            <p><strong>稳定币AMM的本质是在两个极端之间寻找平衡：</strong></p>
            <ul>
                <li>我们想要恒定和模型的<strong>低滑点</strong>（在锚定价格附近）</li>
                <li>我们需要恒定乘积模型的<strong>无限流动性</strong>（防止池子被抽干）</li>
            </ul>
            <p>这个理论张力推动了从Uniswap V3到Curve StableSwap的所有创新。</p>
        </div>
        
        <h4>6.1.2 稳定币AMM的特殊需求</h4>
        <div class="tip">
            💡 <strong>稳定币交易的三大核心需求：</strong>
            <ol>
                <li><strong>极低滑点区间：</strong>在0.999-1.001范围内，滑点应接近零</li>
                <li><strong>高资本效率：</strong>80%+的流动性应集中在±1%的价格范围内</li>
                <li><strong>脱锚韧性：</strong>当稳定币脱锚时，协议应平滑过渡而非突然崩溃</li>
            </ol>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">量化分析：不同AMM模型的效率对比 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># 稳定币AMM效率对比分析
import numpy as np
import matplotlib.pyplot as plt

class AMMComparison:
    def __init__(self):
        self.k = 1000000  # 初始流动性
        
    def constant_product_price(self, x):
        """恒定乘积: x*y = k"""
        return self.k / x
    
    def constant_sum_price(self, x):
        """恒定和: x+y = k (价格始终为1)"""
        return 1.0 if x < self.k else float('inf')
    
    def stableswap_price(self, x, A=100):
        """简化的StableSwap价格函数"""
        # 这是一个近似，实际计算更复杂
        n = 2  # 两种资产
        y = self.k - x  # 近似
        
        # 在平衡点附近表现像恒定和
        # 在极端情况下表现像恒定乘积
        balance_point = self.k / n
        deviation = abs(x - balance_point) / balance_point
        
        # 混合权重
        sum_weight = A / (A + deviation * 100)
        product_weight = 1 - sum_weight
        
        # 混合价格
        sum_price = 1.0
        product_price = self.constant_product_price(x)
        
        return sum_weight * sum_price + product_weight * product_price
    
    def calculate_slippage(self, model, trade_size, initial_x=500000):
        """计算不同交易规模的滑点"""
        if model == 'product':
            y_before = self.constant_product_price(initial_x)
            y_after = self.constant_product_price(initial_x + trade_size)
            # 实际获得的y
            y_received = initial_x * y_before - (initial_x + trade_size) * y_after
        elif model == 'sum':
            y_received = trade_size  # 1:1兑换
        else:  # stableswap
            # 简化计算
            price_impact = self.stableswap_price(initial_x + trade_size) - 1
            y_received = trade_size * (1 - abs(price_impact))
            
        ideal_output = trade_size  # 理想的1:1兑换
        slippage = (ideal_output - y_received) / ideal_output * 100
        
        return max(0, slippage)
    
    def visualize_comparison(self):
        """可视化不同模型的表现"""
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
        
        # 1. 价格曲线对比
        x_range = np.linspace(100000, 900000, 1000)
        
        # 恒定乘积价格
        cp_prices = [self.constant_product_price(x) for x in x_range]
        # StableSwap价格 (不同A值)
        ss_prices_low = [self.stableswap_price(x, A=10) for x in x_range]
        ss_prices_med = [self.stableswap_price(x, A=100) for x in x_range]
        ss_prices_high = [self.stableswap_price(x, A=1000) for x in x_range]
        
        ax1.plot(x_range/500000, cp_prices, label='Constant Product', linewidth=2)
        ax1.plot(x_range/500000, ss_prices_low, label='StableSwap (A=10)', linewidth=2)
        ax1.plot(x_range/500000, ss_prices_med, label='StableSwap (A=100)', linewidth=2)
        ax1.plot(x_range/500000, ss_prices_high, label='StableSwap (A=1000)', linewidth=2)
        ax1.axhline(y=1, color='black', linestyle='--', alpha=0.5, label='Constant Sum')
        
        ax1.set_xlabel('Pool Balance (x/balance_point)')
        ax1.set_ylabel('Price (y/x)')
        ax1.set_title('Price Curves Comparison')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.set_ylim(0, 3)
        
        # 2. 滑点分析
        trade_sizes = np.logspace(2, 5, 50)  # 100到100,000
        
        cp_slippages = [self.calculate_slippage('product', size) for size in trade_sizes]
        ss_slippages = [self.calculate_slippage('stableswap', size) for size in trade_sizes]
        
        ax2.loglog(trade_sizes, cp_slippages, label='Constant Product', linewidth=2)
        ax2.loglog(trade_sizes, ss_slippages, label='StableSwap (A=100)', linewidth=2)
        
        ax2.set_xlabel('Trade Size')
        ax2.set_ylabel('Slippage (%)')
        ax2.set_title('Slippage vs Trade Size')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

# 运行分析
analyzer = AMMComparison()
analyzer.visualize_comparison()

# 计算具体数值
print("$10,000 交易的滑点对比:")
print(f"Constant Product: {analyzer.calculate_slippage('product', 10000):.3f}%")
print(f"StableSwap: {analyzer.calculate_slippage('stableswap', 10000):.3f}%")
print(f"Constant Sum: {analyzer.calculate_slippage('sum', 10000):.3f}%")</code></pre>
            </div>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">基础AMM接口定义 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IAMM {
    // 获取报价
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);
    
    // 交换代币
    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;
    
    // 添加流动性
    function mint(address to) external returns (uint256 liquidity);
    
    // 移除流动性
    function burn(address to) external returns (uint256 amount0, uint256 amount1);
    
    // 获取储备量
    function getReserves() external view returns (
        uint112 reserve0,
        uint112 reserve1,
        uint32 blockTimestampLast
    );
}

// 稳定币AMM特有接口
interface IStableSwap {
    // 获取虚拟价格（衡量LP代币价值）
    function get_virtual_price() external view returns (uint256);
    
    // 计算一个代币换另一个代币
    function get_dy(
        int128 i,
        int128 j,
        uint256 dx
    ) external view returns (uint256);
    
    // 动态费用
    function dynamic_fee(
        int128 i,
        int128 j
    ) external view returns (uint256);
}</code></pre>
            </div>
        </div>

        <h3>6.2 Uniswap V2/V3集成策略</h3>
        
        <h4>6.2.1 Uniswap V2稳定币池分析</h4>
        <p>虽然Uniswap V2不是为稳定币优化的，但由于其简单性和广泛采用，许多稳定币对仍在V2上交易。让我们量化其低效性：</p>
        
        <div class="info-box">
            <h5>📊 V2资本效率的量化分析</h5>
            <p>以USDC/DAI池为例（假设均衡状态各有$50M）：</p>
            <ul>
                <li>价格在0.99-1.01之间的流动性：仅占总流动性的<strong>2%</strong></li>
                <li>价格在0.95-1.05之间的流动性：约占<strong>10%</strong></li>
                <li>剩余90%的流动性备用在几乎不可能触及的价格区间</li>
            </ul>
            <p><strong>结果：</strong>$100M的TVL中，只有$2M在日常交易中被有效利用</p>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Uniswap V2稳定币对实现 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract UniswapV2StablecoinPair {
    using SafeMath for uint256;
    
    uint256 private constant MINIMUM_LIQUIDITY = 10**3;
    uint256 private constant FEE_DENOMINATOR = 10000;
    uint256 private constant FEE_NUMERATOR = 30; // 0.3%费用
    
    uint112 private reserve0;
    uint112 private reserve1;
    uint32 private blockTimestampLast;
    
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast;
    
    // 获取报价（考虑费用）
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 amountOut) {
        require(amountIn > 0, "INSUFFICIENT_INPUT_AMOUNT");
        require(reserveIn > 0 && reserveOut > 0, "INSUFFICIENT_LIQUIDITY");
        
        uint256 amountInWithFee = amountIn.mul(FEE_DENOMINATOR - FEE_NUMERATOR);
        uint256 numerator = amountInWithFee.mul(reserveOut);
        uint256 denominator = reserveIn.mul(FEE_DENOMINATOR).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
    
    // 价格影响计算（对稳定币尤其重要）
    function calculatePriceImpact(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 priceImpact) {
        uint256 amountOut = getAmountOut(amountIn, reserveIn, reserveOut);
        
        // 理想情况下1:1兑换
        uint256 idealOut = amountIn;
        
        // 计算价格影响（基点）
        if (idealOut > amountOut) {
            priceImpact = (idealOut - amountOut).mul(10000) / idealOut;
        }
    }
    
    // 优化的交换函数（带滑点保护）
    function swapWithSlippageProtection(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        uint256 maxSlippage // 基点
    ) external {
        require(amount0Out > 0 || amount1Out > 0, "INSUFFICIENT_OUTPUT_AMOUNT");
        (uint112 _reserve0, uint112 _reserve1,) = getReserves();
        require(amount0Out < _reserve0 && amount1Out < _reserve1, "INSUFFICIENT_LIQUIDITY");
        
        uint256 balance0;
        uint256 balance1;
        {
            address _token0 = token0;
            address _token1 = token1;
            require(to != _token0 && to != _token1, "INVALID_TO");
            
            if (amount0Out > 0) IERC20(_token0).transfer(to, amount0Out);
            if (amount1Out > 0) IERC20(_token1).transfer(to, amount1Out);
            
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
        
        uint256 amount0In = balance0 > _reserve0 - amount0Out ? 
            balance0 - (_reserve0 - amount0Out) : 0;
        uint256 amount1In = balance1 > _reserve1 - amount1Out ? 
            balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, "INSUFFICIENT_INPUT_AMOUNT");
        
        // 滑点检查
        uint256 priceImpact = calculatePriceImpact(
            amount0In > 0 ? amount0In : amount1In,
            amount0In > 0 ? _reserve0 : _reserve1,
            amount0In > 0 ? _reserve1 : _reserve0
        );
        require(priceImpact <= maxSlippage, "SLIPPAGE_TOO_HIGH");
        
        // K值检查
        {
            uint256 balance0Adjusted = balance0.mul(FEE_DENOMINATOR).sub(
                amount0In.mul(FEE_NUMERATOR)
            );
            uint256 balance1Adjusted = balance1.mul(FEE_DENOMINATOR).sub(
                amount1In.mul(FEE_NUMERATOR)
            );
            require(
                balance0Adjusted.mul(balance1Adjusted) >= 
                uint256(_reserve0).mul(_reserve1).mul(FEE_DENOMINATOR**2),
                "K"
            );
        }
        
        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.2.2 Uniswap V3集中流动性优化</h4>
        <p>Uniswap V3的集中流动性是一把双刃剑 - 它极大提升了资本效率，但也引入了新的风险维度：</p>
        
        <div class="tip-box">
            <strong>📊 集中流动性的收益与风险：</strong>
            <table style="width: 100%; margin-top: 1rem;">
                <tr style="background: #f0f4f8;">
                    <th style="padding: 0.5rem; border: 1px solid #ddd;">维度</th>
                    <th style="padding: 0.5rem; border: 1px solid #ddd;">优势</th>
                    <th style="padding: 0.5rem; border: 1px solid #ddd;">风险</th>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">资本效率</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">提升10-100倍</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">需要主动管理</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">无常损失</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">范围内收益更高</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">脱锚时IL放大5-10倍</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">费用收益</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">集中获取90%+费用</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">价格离开范围收益为0</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">Gas成本</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">单次操作高效</td>
                    <td style="padding: 0.5rem; border: 1px solid #ddd;">频繁再平衡成本高</td>
                </tr>
            </table>
        </div>
        
        <div class="info-box">
            <h5>⚠️ 稳定币脱锚时的V3风险分析</h5>
            <p>假设USDC/DAI池，LP在[0.999, 1.001]范围提供流动性：</p>
            <ul>
                <li>正常情况：捕获95%+的交易费用，IL接近0</li>
                <li>DAI脱锚至0.998：整个仓位100%转换为DAI（贬值资产）</li>
                <li>损失计算：相比持有50/50，损失放大至原来的<strong>50倍</strong></li>
                <li>恢复困难：即使价格恢复，也需要主动再平衡才能恢复原始比例</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Uniswap V3稳定币流动性管理 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract UniswapV3StablecoinManager {
    using TickMath for int24;
    using FullMath for uint256;
    
    INonfungiblePositionManager public immutable positionManager;
    IUniswapV3Pool public immutable pool;
    
    struct StablecoinPosition {
        uint256 tokenId;
        int24 tickLower;
        int24 tickUpper;
        uint128 liquidity;
        uint256 token0Deposited;
        uint256 token1Deposited;
    }
    
    // 计算稳定币对的最优价格范围
    function calculateOptimalRange(
        uint256 currentPrice,
        uint256 rangeWidthBips // 基点，如100 = 1%
    ) public pure returns (int24 tickLower, int24 tickUpper) {
        require(rangeWidthBips > 0 && rangeWidthBips < 10000, "Invalid range width");
        
        // 计算价格边界
        uint256 priceLower = currentPrice * (10000 - rangeWidthBips / 2) / 10000;
        uint256 priceUpper = currentPrice * (10000 + rangeWidthBips / 2) / 10000;
        
        // 转换为tick
        tickLower = TickMath.getTickAtSqrtRatio(
            uint160(sqrt(priceLower << 96))
        );
        tickUpper = TickMath.getTickAtSqrtRatio(
            uint160(sqrt(priceUpper << 96))
        );
        
        // 确保tick符合间距要求
        int24 tickSpacing = pool.tickSpacing();
        tickLower = (tickLower / tickSpacing) * tickSpacing;
        tickUpper = ((tickUpper / tickSpacing) + 1) * tickSpacing;
    }
    
    // 创建集中流动性头寸
    function createConcentratedPosition(
        uint256 amount0Desired,
        uint256 amount1Desired,
        uint256 rangeWidthBips,
        uint256 deadline
    ) external returns (
        uint256 tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    ) {
        // 获取当前价格
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
        uint256 currentPrice = uint256(sqrtPriceX96) ** 2 >> 192;
        
        // 计算最优范围
        (int24 tickLower, int24 tickUpper) = calculateOptimalRange(
            currentPrice,
            rangeWidthBips
        );
        
        // 批准代币
        IERC20(pool.token0()).approve(address(positionManager), amount0Desired);
        IERC20(pool.token1()).approve(address(positionManager), amount1Desired);
        
        // 创建头寸
        INonfungiblePositionManager.MintParams memory params = 
            INonfungiblePositionManager.MintParams({
                token0: pool.token0(),
                token1: pool.token1(),
                fee: pool.fee(),
                tickLower: tickLower,
                tickUpper: tickUpper,
                amount0Desired: amount0Desired,
                amount1Desired: amount1Desired,
                amount0Min: amount0Desired * 995 / 1000, // 0.5%滑点
                amount1Min: amount1Desired * 995 / 1000,
                recipient: msg.sender,
                deadline: deadline
            });
        
        (tokenId, liquidity, amount0, amount1) = positionManager.mint(params);
        
        emit PositionCreated(tokenId, tickLower, tickUpper, liquidity);
    }
    
    // 自动再平衡策略
    function rebalancePosition(
        uint256 tokenId,
        uint256 targetRangeWidthBips
    ) external {
        // 获取当前头寸信息
        (,, address token0, address token1, uint24 fee, int24 tickLower, 
         int24 tickUpper, uint128 liquidity,,,,) = positionManager.positions(tokenId);
        
        require(liquidity > 0, "Position has no liquidity");
        
        // 检查是否需要再平衡
        (uint160 sqrtPriceX96, int24 currentTick,,,,,) = pool.slot0();
        
        if (currentTick < tickLower || currentTick > tickUpper) {
            // 收集所有费用和流动性
            INonfungiblePositionManager.CollectParams memory collectParams = 
                INonfungiblePositionManager.CollectParams({
                    tokenId: tokenId,
                    recipient: address(this),
                    amount0Max: type(uint128).max,
                    amount1Max: type(uint128).max
                });
            
            (uint256 amount0Collected, uint256 amount1Collected) = 
                positionManager.collect(collectParams);
            
            // 移除旧流动性
            INonfungiblePositionManager.DecreaseLiquidityParams memory decreaseParams = 
                INonfungiblePositionManager.DecreaseLiquidityParams({
                    tokenId: tokenId,
                    liquidity: liquidity,
                    amount0Min: 0,
                    amount1Min: 0,
                    deadline: block.timestamp
                });
            
            positionManager.decreaseLiquidity(decreaseParams);
            
            // 创建新头寸
            createConcentratedPosition(
                amount0Collected,
                amount1Collected,
                targetRangeWidthBips,
                block.timestamp
            );
            
            // 销毁旧NFT
            positionManager.burn(tokenId);
        }
    }
    
    // 计算无常损失（对稳定币很重要）
    function calculateImpermanentLoss(
        uint256 price0Start,
        uint256 price0End,
        uint256 amount0Start,
        uint256 amount1Start
    ) public pure returns (uint256 lossPercentage) {
        // IL = 2 * sqrt(price_ratio) / (1 + price_ratio) - 1
        uint256 priceRatio = price0End * 1e18 / price0Start;
        uint256 sqrtPriceRatio = sqrt(priceRatio * 1e18);
        
        uint256 poolValue = 2 * sqrtPriceRatio / (1e18 + priceRatio);
        
        if (poolValue < 1e18) {
            lossPercentage = (1e18 - poolValue) * 10000 / 1e18; // 基点
        }
    }
    
    function sqrt(uint256 x) private pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}</code></pre>
            </div>
        </div>

        <h3>6.3 Curve StableSwap深度解析</h3>
        
        <h4>6.3.1 StableSwap不变量的数学推导</h4>
        <p>Curve的天才之处在于创造了一个在恒定和与恒定积之间优雅过渡的混合不变量：</p>
        
        <div style="background: #e0e7ff; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <h5>从第一性原理推导StableSwap公式</h5>
            <p><strong>1. 起点：两个极端的混合</strong></p>
            <p>恒定和：Σx<sub>i</sub> = D（零滑点但会耗尽）</p>
            <p>恒定积：Π(x<sub>i</sub>/n) = (D/n)<sup>n</sup>（无限流动性但高滑点）</p>
            
            <p><strong>2. 混合不变量：</strong></p>
            <p style="text-align: center; font-size: 1.2em; margin: 1rem 0;">
                χ·Σx<sub>i</sub> + Π(x<sub>i</sub>) = χ·D + (D/n)<sup>n</sup>
            </p>
            <p>其中χ是混合参数，控制两种模型的权重</p>
            
            <p><strong>3. 引入放大系数A：</strong></p>
            <p>令χ = An<sup>n</sup>，得到最终的StableSwap不变量：</p>
            <p style="text-align: center; font-size: 1.2em; background: #fff; padding: 1rem; border-radius: 4px;">
                An<sup>n</sup>Σx<sub>i</sub> + D = ADn<sup>n</sup> + D<sup>n+1</sup>/(n<sup>n</sup>Πx<sub>i</sub>)
            </p>
        </div>
        
        <div class="tip">
            💡 <strong>放大系数A的直观理解：</strong>
            <ul>
                <li>A → 0：公式退化为恒定乘积（类似Uniswap）</li>
                <li>A → ∞：公式趋近恒定和（完美的稳定币交换）</li>
                <li>A = 100：实践中的平衡点，在±2%范围内提供极低滑点</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">StableSwap曲线可视化与参数影响分析 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># Curve StableSwap可视化分析
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import newton

class StableSwapVisualization:
    def __init__(self, n_coins=2):
        self.n = n_coins
        self.precision = 10**18
        
    def get_D(self, xp, amp):
        """计算D值 - StableSwap的核心"""
        S = sum(xp)
        if S == 0:
            return 0
            
        D = S
        Ann = amp * self.n
        
        for _ in range(255):
            D_P = D
            for x in xp:
                D_P = D_P * D // (x * self.n)
            Dprev = D
            D = (Ann * S // amp + D_P * self.n) * D // ((Ann - amp) * D // amp + (self.n + 1) * D_P)
            
            if abs(D - Dprev) <= 1:
                break
                
        return D
    
    def get_y(self, i, j, x, xp, amp):
        """给定x计算y - 交易的核心计算"""
        D = self.get_D(xp, amp)
        
        S_ = sum(xp) - xp[i] - xp[j] + x
        c = D
        Ann = amp * self.n
        
        for k in range(self.n):
            if k != i and k != j:
                c = c * D // (xp[k] * self.n)
        c = c * D * amp // (Ann * self.n)
        
        b = S_ + D * amp // Ann
        y_prev = 0
        y = D
        
        for _ in range(255):
            y_prev = y
            y = (y * y + c) // (2 * y + b - D)
            if abs(y - y_prev) <= 1:
                break
                
        return y
    
    def visualize_curves(self):
        """可视化不同A值下的价格曲线"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # 初始池子：平衡状态
        initial_balance = 1000000
        
        # 1. 价格曲线对比
        ax = axes[0, 0]
        x_range = np.linspace(0.1 * initial_balance, 1.9 * initial_balance, 1000)
        
        for A in [0.1, 1, 10, 100, 1000]:
            prices = []
            for x in x_range:
                xp = [int(x), initial_balance]
                y = self.get_y(0, 1, int(x), xp, int(A * 100))
                # 计算边际价格 dy/dx
                price = (initial_balance - y) / (x - initial_balance) if x != initial_balance else 1
                prices.append(price)
            
            ax.plot(x_range / initial_balance, prices, label=f'A={A}', linewidth=2)
        
        ax.axhline(y=1, color='black', linestyle='--', alpha=0.3)
        ax.set_xlabel('相对储备量 (x/x₀)')
        ax.set_ylabel('价格 (dy/dx)')
        ax.set_title('不同A值下的价格曲线')
        ax.legend()
        ax.grid(True, alpha=0.3)
        ax.set_ylim(0, 2)
        
        # 2. 资本效率分析
        ax = axes[0, 1]
        A_values = [1, 10, 50, 100, 500, 1000]
        effective_liquidity = []
        
        for A in A_values:
            # 计算±1%价格范围内的有效流动性比例
            total_liquidity = 2 * initial_balance
            x_1pct = initial_balance * 0.99
            x_2pct = initial_balance * 1.01
            
            # 在这个范围内可交易的量
            tradeable = (x_2pct - x_1pct) / total_liquidity * 100
            effective_liquidity.append(tradeable)
        
        ax.bar(range(len(A_values)), effective_liquidity, color='skyblue', edgecolor='navy')
        ax.set_xticks(range(len(A_values)))
        ax.set_xticklabels([f'A={A}' for A in A_values])
        ax.set_ylabel('有效流动性比例 (%)')
        ax.set_title('±1%价格范围内的资本效率')
        ax.grid(True, alpha=0.3, axis='y')
        
        # 3. 滑点分析
        ax = axes[1, 0]
        trade_sizes = np.logspace(2, 6, 50)  # $100 到 $1M
        
        for A in [10, 100, 1000]:
            slippages = []
            for size in trade_sizes:
                # 计算交易产生的滑点
                xp = [initial_balance, initial_balance]
                y_out = initial_balance - self.get_y(0, 1, initial_balance + int(size), xp, int(A * 100))
                slippage = (size - y_out) / size * 10000  # 基点
                slippages.append(slippage)
            
            ax.loglog(trade_sizes, slippages, label=f'A={A}', linewidth=2)
        
        ax.set_xlabel('交易规模 ($)')
        ax.set_ylabel('滑点 (基点)')
        ax.set_title('交易规模 vs 滑点')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # 4. A参数的风险收益权衡
        ax = axes[1, 1]
        A_range = np.logspace(0, 3, 100)
        
        # 计算不同指标
        capital_efficiency = []
        depeg_risk = []
        
        for A in A_range:
            # 资本效率：1%范围内的深度
            eff = min(100, A / 10)  # 简化模型
            capital_efficiency.append(eff)
            
            # 脱锚风险：池子耗尽速度
            risk = 100 / (1 + A / 100)  # 简化模型
            depeg_risk.append(risk)
        
        ax2 = ax.twinx()
        
        line1 = ax.plot(A_range, capital_efficiency, 'b-', label='资本效率', linewidth=2)
        line2 = ax2.plot(A_range, depeg_risk, 'r-', label='脱锚风险', linewidth=2)
        
        ax.set_xlabel('放大系数 A')
        ax.set_ylabel('资本效率 (%)', color='b')
        ax2.set_ylabel('脱锚风险指数', color='r')
        ax.set_xscale('log')
        ax.set_title('A参数的风险收益权衡')
        
        lines = line1 + line2
        labels = [l.get_label() for l in lines]
        ax.legend(lines, labels, loc='center right')
        
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig
    
    def simulate_depeg_scenario(self, A=100, depeg_percent=5):
        """模拟脱锚场景下的池子行为"""
        initial = 1000000
        results = {
            'price': [],
            'pool_ratio': [],
            'trade_size': []
        }
        
        # 模拟逐步脱锚
        current_x = initial
        current_y = initial
        
        for step in range(100):
            # 套利者卖出贬值资产
            trade_size = initial * 0.01  # 每次1%
            
            xp = [current_x, current_y]
            new_y = self.get_y(0, 1, current_x + trade_size, xp, int(A * 100))
            
            received = current_y - new_y
            current_x += trade_size
            current_y = new_y
            
            # 计算价格
            price = received / trade_size
            pool_ratio = current_x / (current_x + current_y)
            
            results['price'].append(price)
            results['pool_ratio'].append(pool_ratio)
            results['trade_size'].append(step * trade_size)
            
            if price < (1 - depeg_percent/100):
                break
                
        return results

# 运行可视化
visualizer = StableSwapVisualization()
visualizer.visualize_curves()

# 模拟脱锚场景
depeg_results = visualizer.simulate_depeg_scenario(A=100, depeg_percent=5)
print(f"5%脱锚时，池子中稳定资产比例：{(1-depeg_results['pool_ratio'][-1])*100:.1f}%")</code></pre>
            </div>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Curve StableSwap核心实现 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract StableSwap {
    uint256 private constant A_PRECISION = 100;
    uint256 private constant PRECISION = 1e18;
    uint256 private constant FEE_DENOMINATOR = 1e10;
    
    uint256 public immutable N_COINS;
    uint256 public A;  // 放大系数
    uint256 public fee = 4000000; // 0.04%
    uint256 public admin_fee = 5000000000; // 50%的费用归协议
    
    uint256[] public balances;
    uint256 public totalSupply;
    
    // 计算D值（牛顿法）
    function get_D(uint256[] memory xp, uint256 amp) private pure returns (uint256) {
        uint256 S = 0;
        uint256 Dprev = 0;
        
        for (uint256 i = 0; i < xp.length; i++) {
            S += xp[i];
        }
        if (S == 0) return 0;
        
        uint256 D = S;
        uint256 Ann = amp * xp.length;
        
        for (uint256 i = 0; i < 255; i++) {
            uint256 D_P = D;
            for (uint256 j = 0; j < xp.length; j++) {
                D_P = D_P * D / (xp[j] * xp.length);
            }
            Dprev = D;
            D = (Ann * S / A_PRECISION + D_P * xp.length) * D / 
                ((Ann - A_PRECISION) * D / A_PRECISION + (xp.length + 1) * D_P);
            
            if (D > Dprev) {
                if (D - Dprev <= 1) break;
            } else {
                if (Dprev - D <= 1) break;
            }
        }
        return D;
    }
    
    // 计算交换后的余额（牛顿法）
    function get_y(
        uint256 i,
        uint256 j,
        uint256 x,
        uint256[] memory xp_
    ) private view returns (uint256) {
        require(i != j, "Same coin");
        require(j < N_COINS, "j too large");
        require(i < N_COINS, "i too large");
        
        uint256 amp = A;
        uint256 D = get_D(xp_, amp);
        
        uint256 S_ = 0;
        uint256 _x = 0;
        uint256 y_prev = 0;
        uint256 c = D;
        uint256 Ann = amp * N_COINS;
        
        for (uint256 k = 0; k < N_COINS; k++) {
            if (k == i) {
                _x = x;
            } else if (k != j) {
                _x = xp_[k];
            } else {
                continue;
            }
            S_ += _x;
            c = c * D / (_x * N_COINS);
        }
        
        c = c * D * A_PRECISION / (Ann * N_COINS);
        uint256 b = S_ + D * A_PRECISION / Ann;
        uint256 y = D;
        
        for (uint256 k = 0; k < 255; k++) {
            y_prev = y;
            y = (y * y + c) / (2 * y + b - D);
            if (y > y_prev) {
                if (y - y_prev <= 1) break;
            } else {
                if (y_prev - y <= 1) break;
            }
        }
        return y;
    }
    
    // 计算输出金额（含动态费用）
    function get_dy(
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256) {
        uint256[] memory xp = _xp();
        
        uint256 x = xp[i] + dx;
        uint256 y = get_y(i, j, x, xp);
        uint256 dy = xp[j] - y - 1;
        
        // 动态费用计算
        uint256 _fee = fee * N_COINS / (4 * (N_COINS - 1));
        
        // 根据池子平衡度调整费用
        uint256 balanced_fee = _calculate_balanced_fee(xp, i, j);
        _fee = _fee * balanced_fee / FEE_DENOMINATOR;
        
        return dy - dy * _fee / FEE_DENOMINATOR;
    }
    
    // 动态费用：池子越不平衡，费用越高
    function _calculate_balanced_fee(
        uint256[] memory xp,
        uint256 i,
        uint256 j
    ) private pure returns (uint256) {
        uint256 sum = 0;
        for (uint256 k = 0; k < xp.length; k++) {
            sum += xp[k];
        }
        
        uint256 avg = sum / xp.length;
        uint256 imbalance = 0;
        
        // 计算不平衡度
        for (uint256 k = 0; k < xp.length; k++) {
            uint256 diff = xp[k] > avg ? xp[k] - avg : avg - xp[k];
            imbalance += diff * PRECISION / avg;
        }
        
        // 费用倍数：1x到4x
        return FEE_DENOMINATOR + imbalance * 3;
    }
    
    // 执行交换
    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy,
        address receiver
    ) external returns (uint256) {
        require(i != j, "Same coin");
        require(dx > 0, "dx = 0");
        
        uint256[] memory old_balances = balances;
        uint256[] memory xp = _xp_mem(old_balances);
        
        // 转入代币
        IERC20(coins[i]).transferFrom(msg.sender, address(this), dx);
        
        uint256 x = xp[i] + dx;
        uint256 y = get_y(i, j, x, xp);
        
        uint256 dy = xp[j] - y - 1; // -1以防舍入错误
        uint256 dy_fee = dy * fee / FEE_DENOMINATOR;
        
        // 动态费用
        uint256 balanced_fee = _calculate_balanced_fee(xp, i, j);
        dy_fee = dy_fee * balanced_fee / FEE_DENOMINATOR;
        
        dy = dy - dy_fee;
        require(dy >= min_dy, "Slippage");
        
        // 更新余额
        balances[i] = old_balances[i] + dx;
        balances[j] = old_balances[j] - dy;
        
        // 转出代币
        IERC20(coins[j]).transfer(receiver, dy);
        
        emit TokenExchange(msg.sender, i, dx, j, dy);
        
        return dy;
    }
    
    // 添加流动性（优化版）
    function add_liquidity(
        uint256[] memory amounts,
        uint256 min_mint_amount
    ) external returns (uint256) {
        require(amounts.length == N_COINS, "Invalid amounts");
        
        uint256[] memory fees = new uint256[](N_COINS);
        uint256 _fee = fee * N_COINS / (4 * (N_COINS - 1));
        uint256 amp = A;
        
        uint256 token_supply = totalSupply;
        uint256[] memory old_balances = balances;
        uint256 D0 = 0;
        
        if (token_supply > 0) {
            D0 = get_D(_xp_mem(old_balances), amp);
        }
        
        uint256[] memory new_balances = new uint256[](N_COINS);
        
        for (uint256 i = 0; i < N_COINS; i++) {
            if (token_supply == 0) {
                require(amounts[i] > 0, "Initial deposit requires all coins");
            }
            
            // 转入代币
            if (amounts[i] > 0) {
                IERC20(coins[i]).transferFrom(msg.sender, address(this), amounts[i]);
            }
            
            new_balances[i] = old_balances[i] + amounts[i];
        }
        
        uint256 D1 = get_D(_xp_mem(new_balances), amp);
        require(D1 > D0, "D1 <= D0");
        
        uint256 mint_amount = 0;
        
        if (token_supply == 0) {
            mint_amount = D1;
        } else {
            // 计算理想余额
            uint256[] memory ideal_balance = new uint256[](N_COINS);
            uint256 difference = 0;
            
            for (uint256 i = 0; i < N_COINS; i++) {
                ideal_balance[i] = D1 * old_balances[i] / D0;
                uint256 diff = ideal_balance[i] > new_balances[i] ? 
                    ideal_balance[i] - new_balances[i] : 
                    new_balances[i] - ideal_balance[i];
                difference += diff;
            }
            
            // 根据不平衡程度收费
            if (difference > 0) {
                _fee = _fee * N_COINS * difference / D1;
            }
            
            mint_amount = token_supply * (D1 - D0) / D0;
            
            // 扣除费用
            mint_amount = mint_amount - mint_amount * _fee / FEE_DENOMINATOR;
        }
        
        require(mint_amount >= min_mint_amount, "Slippage");
        
        // 更新状态
        for (uint256 i = 0; i < N_COINS; i++) {
            balances[i] = new_balances[i];
        }
        
        totalSupply += mint_amount;
        _mint(msg.sender, mint_amount);
        
        emit AddLiquidity(msg.sender, amounts, fees, D1, token_supply + mint_amount);
        
        return mint_amount;
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.3.2 Curve V2：动态调整的自适应AMM</h4>
        <p>Curve V2（也称为Tricrypto）是DeFi中最先进的AMM设计之一，它引入了自适应机制来处理波动资产：</p>
        
        <div class="info-box">
            <h5>🚀 Curve V2的革命性创新</h5>
            <ul>
                <li><strong>内部预言机：</strong>使用EMA（指数移动平均）追踪"真实"市场价格</li>
                <li><strong>动态放大系数：</strong>根据市场条件自动调整A值</li>
                <li><strong>动态费用：</strong>池子失衡时提高费用，平衡时降低费用</li>
                <li><strong>K值重定价：</strong>通过调整K值激励套利者恢复平衡</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Curve V2自适应机制实现 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract CurveV2Pool {
    // V2核心参数
    uint256 public A;           // 基础放大系数
    uint256 public gamma;       // 风险参数（控制曲率）
    uint256 public mid_fee;     // 基础费用
    uint256 public out_fee;     // 最大费用
    uint256 public fee_gamma;   // 费用调整速度
    
    // 内部预言机状态
    uint256 public price_oracle;    // EMA价格
    uint256 public price_scale;     // 当前池内价格
    uint256 public last_prices_timestamp;
    
    // 动态A和gamma
    uint256 public future_A;
    uint256 public future_gamma;
    uint256 public future_time;
    
    // 计算动态费用
    function dynamic_fee() public view returns (uint256) {
        // 获取当前价格偏离度
        uint256 xp0 = balances[0] * PRECISION / price_scale;
        uint256 xp1 = balances[1] * PRECISION;
        
        // 理想平衡点
        uint256 ideal_balance = (xp0 + xp1) / 2;
        
        // 计算不平衡度
        uint256 imbalance = xp0 > xp1 ? 
            (xp0 - ideal_balance) * PRECISION / ideal_balance :
            (ideal_balance - xp1) * PRECISION / ideal_balance;
            
        // 动态费用 = mid_fee + (out_fee - mid_fee) * imbalance^fee_gamma
        uint256 fee = mid_fee;
        if (imbalance > 0) {
            // 使用近似的幂函数计算
            uint256 fee_multiplier = pow_approx(imbalance, fee_gamma);
            fee = mid_fee + (out_fee - mid_fee) * fee_multiplier / PRECISION;
        }
        
        return fee;
    }
    
    // 更新内部预言机
    function tweak_price(
        uint256 A_gamma,
        uint256 new_price_scale,
        uint256 K0_prev
    ) internal {
        // 时间衰减因子
        uint256 time_since = block.timestamp - last_prices_timestamp;
        uint256 alpha = exp_decay(time_since);
        
        // 更新EMA价格
        price_oracle = (price_oracle * alpha + new_price_scale * (PRECISION - alpha)) / PRECISION;
        
        // 当价格偏离过大时，调整K值
        uint256 price_deviation = new_price_scale > price_oracle ?
            (new_price_scale - price_oracle) * PRECISION / price_oracle :
            (price_oracle - new_price_scale) * PRECISION / price_oracle;
            
        if (price_deviation > allowed_extra_profit) {
            // 重新定价K值，激励套利
            K0 = K0 * (PRECISION + adjustment_step) / PRECISION;
        }
        
        price_scale = new_price_scale;
        last_prices_timestamp = block.timestamp;
        
        emit PriceOracleUpdated(price_oracle, price_scale);
    }
    
    // 自适应参数调整
    function update_parameters(
        uint256 _future_A,
        uint256 _future_gamma,
        uint256 _future_time
    ) external onlyOwner {
        require(_future_time > block.timestamp + MIN_RAMP_TIME, "Too soon");
        
        // 限制参数变化幅度
        require(_future_A > A / 10 && _future_A < A * 10, "A change too large");
        require(_future_gamma > gamma / 10 && _future_gamma < gamma * 10, "gamma change too large");
        
        future_A = _future_A;
        future_gamma = _future_gamma;
        future_time = _future_time;
        
        emit ParametersUpdateScheduled(_future_A, _future_gamma, _future_time);
    }
    
    // 获取当前有效参数（线性插值）
    function get_A_gamma() public view returns (uint256 A_effective, uint256 gamma_effective) {
        uint256 t = block.timestamp;
        
        if (t < future_time) {
            // 线性过渡
            uint256 elapsed = t - initial_time;
            uint256 total_time = future_time - initial_time;
            
            A_effective = initial_A + (future_A - initial_A) * elapsed / total_time;
            gamma_effective = initial_gamma + (future_gamma - initial_gamma) * elapsed / total_time;
        } else {
            A_effective = future_A;
            gamma_effective = future_gamma;
        }
    }
    
    // 防止价格操纵的延迟机制
    function claim_admin_fees() external {
        require(block.timestamp > last_claim_time + MIN_CLAIM_INTERVAL, "Too frequent");
        
        // 只有当价格稳定时才能提取费用
        uint256 price_threshold = PRECISION * 2 / 100; // 2%
        require(
            abs_diff(price_scale, price_oracle) < price_threshold,
            "Price not stable"
        );
        
        // 计算并转移管理费
        uint256 admin_share = calculate_admin_fees();
        _transfer_fees(admin_share);
        
        last_claim_time = block.timestamp;
    }
}</code></pre>
            </div>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">V2参数优化的AI/ML方法 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># 使用强化学习优化Curve V2参数
import numpy as np
import torch
import torch.nn as nn
from collections import deque

class CurveV2Optimizer:
    """基于深度强化学习的Curve V2参数优化器"""
    
    def __init__(self):
        self.state_dim = 10  # 市场状态维度
        self.action_dim = 4   # A, gamma, mid_fee, out_fee
        
        # 策略网络
        self.policy_net = nn.Sequential(
            nn.Linear(self.state_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, self.action_dim),
            nn.Sigmoid()  # 输出0-1范围
        )
        
        # 经验回放
        self.memory = deque(maxlen=10000)
        
    def get_market_state(self, pool_data):
        """提取市场状态特征"""
        state = []
        
        # 1. 价格偏离度
        price_deviation = abs(pool_data['price_scale'] - pool_data['price_oracle']) / pool_data['price_oracle']
        state.append(price_deviation)
        
        # 2. 池子不平衡度
        total = sum(pool_data['balances'])
        imbalance = max(pool_data['balances']) / total - 0.5
        state.append(imbalance)
        
        # 3. 历史波动率（24h）
        volatility = np.std(pool_data['price_history'][-96:]) / np.mean(pool_data['price_history'][-96:])
        state.append(volatility)
        
        # 4. 交易量趋势
        volume_ma_short = np.mean(pool_data['volume_history'][-24:])
        volume_ma_long = np.mean(pool_data['volume_history'][-168:])
        volume_trend = volume_ma_short / (volume_ma_long + 1e-8) - 1
        state.append(volume_trend)
        
        # 5. 费用收益率
        fee_apr = pool_data['fees_24h'] * 365 / pool_data['tvl']
        state.append(fee_apr)
        
        # 6. 无常损失估计
        il_estimate = self.estimate_impermanent_loss(pool_data)
        state.append(il_estimate)
        
        # 7-10. 其他市场指标
        state.extend([
            pool_data['gas_price_gwei'] / 100,  # 标准化gas价格
            pool_data['market_fear_greed'] / 100,  # 市场情绪
            pool_data['competing_pools_tvl'] / pool_data['tvl'],  # 竞争态势
            pool_data['arbitrage_volume'] / pool_data['total_volume']  # 套利占比
        ])
        
        return np.array(state, dtype=np.float32)
    
    def predict_optimal_params(self, market_state):
        """预测最优参数"""
        with torch.no_grad():
            state_tensor = torch.FloatTensor(market_state).unsqueeze(0)
            raw_output = self.policy_net(state_tensor)
            
            # 将网络输出映射到实际参数范围
            params = {
                'A': int(10 + raw_output[0, 0].item() * 990),  # 10-1000
                'gamma': int(1e14 + raw_output[0, 1].item() * 9e14),  # 0.0001-0.001
                'mid_fee': int(1e6 + raw_output[0, 2].item() * 4e6),  # 0.01%-0.05%
                'out_fee': int(1e7 + raw_output[0, 3].item() * 9e7)   # 0.1%-1%
            }
            
        return params
    
    def simulate_parameter_impact(self, pool_state, new_params, horizon=24):
        """模拟参数变更的影响"""
        results = {
            'revenue': [],
            'il': [],
            'volume': [],
            'price_stability': []
        }
        
        # 蒙特卡洛模拟
        for _ in range(100):
            sim_pool = self.create_pool_copy(pool_state)
            sim_pool.update_parameters(new_params)
            
            for hour in range(horizon):
                # 模拟市场活动
                trades = self.generate_random_trades()
                
                for trade in trades:
                    revenue = sim_pool.execute_trade(trade)
                    results['revenue'].append(revenue)
                
                # 记录指标
                results['il'].append(sim_pool.calculate_il())
                results['volume'].append(sim_pool.get_volume())
                results['price_stability'].append(sim_pool.get_price_stability())
        
        # 计算预期收益
        expected_performance = {
            'revenue': np.mean(results['revenue']),
            'il': np.mean(results['il']),
            'volume': np.mean(results['volume']),
            'sharpe_ratio': self.calculate_sharpe_ratio(results)
        }
        
        return expected_performance
    
    def auto_tune_parameters(self, pool_address):
        """自动调参主循环"""
        pool = CurveV2Pool(pool_address)
        
        while True:
            # 获取当前市场状态
            pool_data = pool.get_current_data()
            market_state = self.get_market_state(pool_data)
            
            # 预测最优参数
            optimal_params = self.predict_optimal_params(market_state)
            
            # 模拟影响
            impact = self.simulate_parameter_impact(pool_data, optimal_params)
            
            # 决策：是否更新参数
            if impact['sharpe_ratio'] > pool_data['current_sharpe'] * 1.1:
                # 预期性能提升10%以上，执行更新
                print(f"Updating parameters: {optimal_params}")
                pool.schedule_parameter_update(optimal_params)
                
                # 记录结果用于学习
                self.memory.append({
                    'state': market_state,
                    'action': optimal_params,
                    'reward': None  # 将在未来填充实际结果
                })
            
            # 等待下一个周期
            time.sleep(3600)  # 每小时检查一次

# 使用示例
optimizer = CurveV2Optimizer()
optimizer.auto_tune_parameters("0x...")  # Curve V2池地址</code></pre>
            </div>
        </div>

        <h3>6.4 高级AMM优化策略</h3>
        
        <h4>6.4.1 混合AMM设计</h4>
        <p>结合不同AMM模型的优点，为稳定币创造更高效的交易环境：</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">混合AMM实现 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract HybridStableSwap {
    // 结合Curve和Uniswap V3的优点
    
    uint256 private constant CURVE_THRESHOLD = 100; // 基点，1%
    uint256 private constant A = 100; // Curve放大系数
    
    IUniswapV3Pool public immutable uniV3Pool;
    IStableSwap public immutable curvePool;
    
    struct RouteParams {
        bool useCurve;
        uint256 expectedOut;
        uint256 priceImpact;
        uint256 gasEstimate;
    }
    
    // 智能路由：选择最优AMM
    function findBestRoute(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) public view returns (RouteParams memory best) {
        // 获取Curve报价
        uint256 curveOut = _getCurveQuote(tokenIn, tokenOut, amountIn);
        uint256 curvePriceImpact = _calculatePriceImpact(amountIn, curveOut);
        
        // 获取UniV3报价
        uint256 uniV3Out = _getUniV3Quote(tokenIn, tokenOut, amountIn);
        uint256 uniV3PriceImpact = _calculatePriceImpact(amountIn, uniV3Out);
        
        // 考虑Gas成本
        uint256 curveGas = 150000; // 估计值
        uint256 uniV3Gas = 180000; // 估计值
        
        // 决策逻辑
        if (curvePriceImpact < CURVE_THRESHOLD && curveOut > uniV3Out) {
            best = RouteParams({
                useCurve: true,
                expectedOut: curveOut,
                priceImpact: curvePriceImpact,
                gasEstimate: curveGas
            });
        } else {
            best = RouteParams({
                useCurve: false,
                expectedOut: uniV3Out,
                priceImpact: uniV3PriceImpact,
                gasEstimate: uniV3Gas
            });
        }
    }
    
    // 执行最优路由交换
    function smartSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient
    ) external returns (uint256 amountOut) {
        RouteParams memory route = findBestRoute(tokenIn, tokenOut, amountIn);
        require(route.expectedOut >= minAmountOut, "Insufficient output");
        
        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        
        if (route.useCurve) {
            IERC20(tokenIn).approve(address(curvePool), amountIn);
            amountOut = curvePool.exchange(
                _getTokenIndex(tokenIn),
                _getTokenIndex(tokenOut),
                amountIn,
                minAmountOut,
                recipient
            );
        } else {
            amountOut = _swapOnUniV3(tokenIn, tokenOut, amountIn, minAmountOut, recipient);
        }
        
        emit SmartSwapExecuted(
            tokenIn,
            tokenOut,
            amountIn,
            amountOut,
            route.useCurve,
            route.priceImpact
        );
    }
    
    // 动态流动性分配
    function rebalanceLiquidity() external {
        // 获取两个池的TVL和交易量
        uint256 curveTVL = _getCurveTVL();
        uint256 uniV3TVL = _getUniV3TVL();
        uint256 curveVolume24h = _getCurveVolume24h();
        uint256 uniV3Volume24h = _getUniV3Volume24h();
        
        // 计算效率指标
        uint256 curveEfficiency = curveVolume24h * 1e18 / curveTVL;
        uint256 uniV3Efficiency = uniV3Volume24h * 1e18 / uniV3TVL;
        
        // 根据效率调整流动性分配
        if (curveEfficiency > uniV3Efficiency * 120 / 100) {
            // Curve效率高20%以上，增加Curve流动性
            _shiftLiquidityToCurve();
        } else if (uniV3Efficiency > curveEfficiency * 120 / 100) {
            // UniV3效率高20%以上，增加UniV3流动性
            _shiftLiquidityToUniV3();
        }
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.4.2 MEV防护机制</h4>
        <p>稳定币AMM特别容易受到MEV攻击，需要专门的防护机制：</p>
        
        <div class="tip-box">
            <strong>🛡️ MEV攻击类型：</strong>
            <ul>
                <li><strong>三明治攻击：</strong>在大额交易前后插入交易获利</li>
                <li><strong>套利攻击：</strong>利用不同池之间的价格差</li>
                <li><strong>JIT流动性：</strong>在交易前添加流动性，交易后立即移除</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">MEV防护AMM <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract MEVProtectedAMM {
    using SafeMath for uint256;
    
    uint256 private constant TWAP_WINDOW = 600; // 10分钟
    uint256 private constant MAX_PRICE_IMPACT = 50; // 0.5%
    uint256 private constant COMMIT_DELAY = 2; // 2个区块延迟
    
    struct PriceObservation {
        uint256 timestamp;
        uint256 price0Cumulative;
        uint256 price1Cumulative;
    }
    
    struct CommitData {
        address user;
        bytes32 commitment;
        uint256 blockNumber;
        bool revealed;
    }
    
    PriceObservation[] public observations;
    mapping(bytes32 => CommitData) public commitments;
    
    // TWAP价格计算
    function getTWAPPrice() public view returns (uint256) {
        require(observations.length >= 2, "Insufficient observations");
        
        uint256 length = observations.length;
        PriceObservation memory oldest = observations[length - 2];
        PriceObservation memory newest = observations[length - 1];
        
        uint256 timeElapsed = newest.timestamp - oldest.timestamp;
        require(timeElapsed >= TWAP_WINDOW, "TWAP window too small");
        
        uint256 price0Average = (newest.price0Cumulative - oldest.price0Cumulative) / timeElapsed;
        uint256 price1Average = (newest.price1Cumulative - oldest.price1Cumulative) / timeElapsed;
        
        return price0Average * 1e18 / price1Average;
    }
    
    // Commit-Reveal机制防止抢跑
    function commitSwap(
        bytes32 commitment
    ) external {
        bytes32 commitId = keccak256(abi.encodePacked(msg.sender, commitment));
        
        commitments[commitId] = CommitData({
            user: msg.sender,
            commitment: commitment,
            blockNumber: block.number,
            revealed: false
        });
        
        emit SwapCommitted(msg.sender, commitId, block.number);
    }
    
    function revealSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 nonce
    ) external returns (uint256 amountOut) {
        // 验证commitment
        bytes32 commitment = keccak256(abi.encodePacked(
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut,
            nonce
        ));
        
        bytes32 commitId = keccak256(abi.encodePacked(msg.sender, commitment));
        CommitData storage commit = commitments[commitId];
        
        require(commit.user == msg.sender, "Invalid commitment");
        require(!commit.revealed, "Already revealed");
        require(block.number >= commit.blockNumber + COMMIT_DELAY, "Too early");
        require(block.number <= commit.blockNumber + COMMIT_DELAY + 10, "Too late");
        
        commit.revealed = true;
        
        // 价格检查
        uint256 twapPrice = getTWAPPrice();
        uint256 spotPrice = getSpotPrice();
        uint256 priceDeviation = spotPrice > twapPrice ? 
            (spotPrice - twapPrice) * 10000 / twapPrice :
            (twapPrice - spotPrice) * 10000 / twapPrice;
        
        require(priceDeviation <= MAX_PRICE_IMPACT, "Price manipulation detected");
        
        // 执行交换
        amountOut = _executeSwap(tokenIn, tokenOut, amountIn, minAmountOut);
        
        emit SwapExecuted(msg.sender, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    // 批量交易以分摊Gas成本
    function batchSwap(
        SwapData[] calldata swaps
    ) external {
        uint256 totalGasSaved = 0;
        
        for (uint256 i = 0; i < swaps.length; i++) {
            SwapData memory swap = swaps[i];
            
            // 检查是否可以合并相同路径的交易
            uint256 combinedAmountIn = swap.amountIn;
            uint256 j = i + 1;
            
            while (j < swaps.length && 
                   swaps[j].tokenIn == swap.tokenIn && 
                   swaps[j].tokenOut == swap.tokenOut) {
                combinedAmountIn += swaps[j].amountIn;
                j++;
            }
            
            // 执行合并后的交换
            if (j > i + 1) {
                uint256 amountOut = _executeSwap(
                    swap.tokenIn,
                    swap.tokenOut,
                    combinedAmountIn,
                    0
                );
                
                // 按比例分配输出
                for (uint256 k = i; k < j; k++) {
                    uint256 userAmountOut = amountOut * swaps[k].amountIn / combinedAmountIn;
                    IERC20(swap.tokenOut).transfer(swaps[k].recipient, userAmountOut);
                }
                
                totalGasSaved += (j - i - 1) * 100000; // 估计节省的Gas
                i = j - 1; // 跳过已处理的交易
            } else {
                _executeSwap(
                    swap.tokenIn,
                    swap.tokenOut,
                    swap.amountIn,
                    swap.minAmountOut
                );
            }
        }
        
        emit BatchSwapExecuted(swaps.length, totalGasSaved);
    }
    
    // 延迟价格更新防止操纵
    function updatePriceOracle() external {
        uint256 timeElapsed = block.timestamp - observations[observations.length - 1].timestamp;
        require(timeElapsed >= 60, "Update too frequent"); // 最少1分钟间隔
        
        (uint112 reserve0, uint112 reserve1,) = getReserves();
        
        uint256 price0Cumulative = observations[observations.length - 1].price0Cumulative + 
            reserve1 * timeElapsed / reserve0;
        uint256 price1Cumulative = observations[observations.length - 1].price1Cumulative + 
            reserve0 * timeElapsed / reserve1;
        
        observations.push(PriceObservation({
            timestamp: block.timestamp,
            price0Cumulative: price0Cumulative,
            price1Cumulative: price1Cumulative
        }));
        
        // 限制数组大小
        if (observations.length > 24) {
            for (uint256 i = 0; i < observations.length - 24; i++) {
                observations[i] = observations[i + 1];
            }
            observations.pop();
        }
    }
}</code></pre>
            </div>
        </div>

        <h3>6.5 2024年最新发展趋势</h3>
        
        <h4>6.5.1 Uniswap V4 Hooks：可组合的AMM新范式</h4>
        <div class="info-box">
            <h5>🔗 Hooks带来的革命性变化</h5>
            <ul>
                <li><strong>自定义逻辑：</strong>在交易生命周期的任何点插入自定义代码</li>
                <li><strong>动态费用：</strong>基于任意逻辑实时调整费用</li>
                <li><strong>MEV内部化：</strong>将MEV收益返还给LP而非套利者</li>
                <li><strong>条件订单：</strong>实现限价单、止损单等复杂订单类型</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Uniswap V4 稳定币专用Hook示例 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract StablecoinOptimizedHook is BaseHook {
    using FixedPoint96 for uint256;
    
    // Hook配置
    struct HookConfig {
        uint24 baseFee;           // 基础费用
        uint24 maxFee;            // 最大费用
        uint256 targetRatio;      // 目标平衡比例
        uint256 priceThreshold;   // 价格偏离阈值
        bool enableMEVProtection; // MEV保护开关
    }
    
    mapping(PoolId => HookConfig) public poolConfigs;
    mapping(PoolId => uint256) public lastTradeTimestamp;
    
    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params
    ) external override returns (bytes4) {
        // 1. 动态费用调整
        uint24 dynamicFee = calculateDynamicFee(key.toId(), params);
        
        // 2. MEV保护：检测潜在的三明治攻击
        if (poolConfigs[key.toId()].enableMEVProtection) {
            require(
                block.timestamp > lastTradeTimestamp[key.toId()] + 1,
                "Too frequent trading"
            );
        }
        
        // 3. 大额交易警告
        if (params.amountSpecified > getPoolLiquidity(key.toId()) / 100) {
            emit LargeTradeWarning(sender, params.amountSpecified);
        }
        
        // 更新费用
        poolManager.updateDynamicFee(key, dynamicFee);
        
        return BaseHook.beforeSwap.selector;
    }
    
    function afterSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        BalanceDelta delta
    ) external override returns (bytes4) {
        // 1. 更新价格预言机
        updateInternalOracle(key.toId(), delta);
        
        // 2. 检查是否需要触发再平衡
        if (shouldRebalance(key.toId())) {
            triggerRebalance(key.toId());
        }
        
        // 3. 分配MEV收益给LP
        uint256 mevRevenue = calculateMEVRevenue(params, delta);
        if (mevRevenue > 0) {
            distributeMEVToLPs(key.toId(), mevRevenue);
        }
        
        lastTradeTimestamp[key.toId()] = block.timestamp;
        
        return BaseHook.afterSwap.selector;
    }
    
    function calculateDynamicFee(
        PoolId poolId,
        IPoolManager.SwapParams calldata params
    ) internal view returns (uint24) {
        HookConfig memory config = poolConfigs[poolId];
        
        // 获取池子状态
        (uint256 balance0, uint256 balance1) = getPoolBalances(poolId);
        uint256 totalBalance = balance0 + balance1;
        
        // 计算不平衡度
        uint256 imbalance = balance0 > balance1 ?
            (balance0 - balance1) * 1e6 / totalBalance :
            (balance1 - balance0) * 1e6 / totalBalance;
            
        // 根据交易方向调整费用
        bool isBalancing = (params.zeroForOne && balance0 > balance1) ||
                          (!params.zeroForOne && balance1 > balance0);
                          
        if (isBalancing) {
            // 有助于平衡的交易，降低费用
            return config.baseFee / 2;
        } else {
            // 加剧不平衡的交易，提高费用
            uint24 fee = config.baseFee + uint24(imbalance * (config.maxFee - config.baseFee) / 1e6);
            return fee > config.maxFee ? config.maxFee : fee;
        }
    }
}</code></pre>
            </div>
        </div>
        
        <h4>6.5.2 AI驱动的流动性管理</h4>
        <p>2024年见证了AI在DeFi中的实际应用，特别是在流动性管理和参数优化方面：</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">基于Transformer的流动性预测模型 <span class="toggle-icon">▼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># 使用Transformer预测最优流动性分配
import torch
import torch.nn as nn
import numpy as np
from transformers import TimeSeriesTransformerModel

class LiquidityOptimizer:
    def __init__(self):
        # 预训练的市场预测模型
        self.market_predictor = TimeSeriesTransformerModel.from_pretrained(
            "defi-market-predictor-v2"
        )
        
        # 流动性分配网络
        self.allocation_net = nn.Sequential(
            nn.Linear(256, 512),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(512, 256),
            nn.ReLU(),
            nn.Linear(256, 10),  # 最多10个池子
            nn.Softmax(dim=-1)
        )
        
    def predict_market_conditions(self, historical_data):
        """预测未来24小时的市场条件"""
        # 准备输入数据
        features = self.extract_features(historical_data)
        
        # Transformer预测
        with torch.no_grad():
            predictions = self.market_predictor(
                input_ids=features['price_series'],
                attention_mask=features['mask']
            )
        
        # 解析预测结果
        market_forecast = {
            'volatility': predictions.volatility_forecast,
            'volume': predictions.volume_forecast,
            'correlation_matrix': predictions.correlation_forecast,
            'black_swan_probability': predictions.tail_risk_estimate
        }
        
        return market_forecast
    
    def optimize_liquidity_allocation(self, 
                                    available_capital,
                                    pool_candidates,
                                    risk_tolerance):
        """优化跨多个池子的流动性分配"""
        
        # 1. 获取市场预测
        market_forecast = self.predict_market_conditions(self.get_market_data())
        
        # 2. 评估每个池子
        pool_scores = []
        for pool in pool_candidates:
            score = self.evaluate_pool(pool, market_forecast)
            pool_scores.append(score)
        
        # 3. 运行优化
        allocation = self.solve_markowitz_optimization(
            expected_returns=pool_scores['returns'],
            covariance_matrix=pool_scores['risks'],
            risk_tolerance=risk_tolerance
        )
        
        # 4. 考虑实际约束
        allocation = self.apply_practical_constraints(
            allocation,
            min_position_size=1000,  # $1000最小仓位
            max_concentration=0.3,    # 单池最大30%
            gas_budget=available_capital * 0.01  # 1% gas预算
        )
        
        return allocation
    
    def real_time_rebalancing(self, current_positions):
        """实时再平衡决策"""
        rebalance_actions = []
        
        for position in current_positions:
            # 计算当前表现
            performance = self.calculate_position_performance(position)
            
            # 预测未来表现
            future_performance = self.predict_position_performance(
                position,
                horizon=24  # 24小时
            )
            
            # 再平衡决策
            if self.should_rebalance(performance, future_performance):
                action = self.generate_rebalance_action(position)
                rebalance_actions.append(action)
        
        # 批量优化以节省gas
        optimized_actions = self.batch_optimize_actions(rebalance_actions)
        
        return optimized_actions

# 实际应用
optimizer = LiquidityOptimizer()
allocation = optimizer.optimize_liquidity_allocation(
    available_capital=1000000,  # $1M
    pool_candidates=['USDC/DAI', 'USDC/USDT', 'DAI/FRAX'],
    risk_tolerance=0.05  # 5%最大回撤
)</code></pre>
            </div>
        </div>
        
        <h4>6.5.3 跨链流动性聚合与原生稳定币</h4>
        <div class="tip-box">
            <strong>🌉 2024年跨链发展</strong>
            <ul>
                <li><strong>LayerZero OFT：</strong>原生跨链稳定币，无需桥接</li>
                <li><strong>Chainlink CCIP：</strong>安全的跨链流动性转移</li>
                <li><strong>统一流动性层：</strong>多链共享流动性池</li>
                <li><strong>Intent-based架构：</strong>用户表达意图，协议自动寻找最优路径</li>
            </ul>
        </div>
        
        <h4>6.5.4 流动性激励与veTokenomics</h4>
        <p>理解现代AMM不能忽视其经济激励层，特别是Curve开创的ve模型：</p>
        
        <div class="info-box">
            <h5>💰 veTokenomics核心机制</h5>
            <ul>
                <li><strong>投票托管（Vote Escrow）：</strong>锁定治理代币获得投票权</li>
                <li><strong>收益加速：</strong>veCRV持有者可将LP收益提升至2.5倍</li>
                <li><strong>贿赂市场：</strong>协议通过贿赂veCRV持有者引导流动性</li>
                <li><strong>Gauge权重：</strong>投票决定各池子的CRV释放量</li>
            </ul>
        </div>

        <h3>练习题</h3>
        
        <div class="exercise">
            <h4>练习 6.1：实现动态费用AMM</h4>
            <p>设计一个AMM，根据以下因素动态调整交易费用：</p>
            <ul>
                <li>池子的不平衡程度</li>
                <li>交易规模相对于池子大小</li>
                <li>市场波动率</li>
                <li>历史交易频率</li>
            </ul>
            <p>要求费用在0.01%到1%之间动态调整。</p>
            
            <button onclick="toggleAnswer('answer6-1')">查看参考答案</button>
            <div id="answer6-1" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract DynamicFeeAMM {
    uint256 private constant MIN_FEE = 1; // 0.01%
    uint256 private constant MAX_FEE = 100; // 1%
    uint256 private constant FEE_DENOMINATOR = 10000;
    
    uint256 public volatilityWindow = 1 hours;
    uint256 public volumeDecayFactor = 9900; // 99%衰减
    
    struct FeeParameters {
        uint256 imbalanceFee;
        uint256 sizeFee;
        uint256 volatilityFee;
        uint256 frequencyFee;
    }
    
    function calculateDynamicFee(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public view returns (uint256 fee) {
        FeeParameters memory params;
        
        // 1. 不平衡费用
        uint256 totalReserves = reserveIn + reserveOut;
        uint256 imbalanceRatio = reserveIn > reserveOut ?
            (reserveIn - reserveOut) * FEE_DENOMINATOR / totalReserves :
            (reserveOut - reserveIn) * FEE_DENOMINATOR / totalReserves;
        params.imbalanceFee = imbalanceRatio * MAX_FEE / FEE_DENOMINATOR;
        
        // 2. 交易规模费用
        uint256 sizeRatio = amountIn * FEE_DENOMINATOR / reserveIn;
        params.sizeFee = sizeRatio * MAX_FEE / (FEE_DENOMINATOR * 10); // 10%的reserve收最高费
        
        // 3. 波动率费用
        uint256 volatility = getHistoricalVolatility();
        params.volatilityFee = volatility > 100 ? // 1%日波动率
            (volatility - 100) * MAX_FEE / 1000 : 0;
        
        // 4. 交易频率费用
        uint256 recentVolume = getRecentVolume();
        uint256 volumeRatio = recentVolume * FEE_DENOMINATOR / totalReserves;
        params.frequencyFee = volumeRatio > FEE_DENOMINATOR ?
            MAX_FEE / 2 : volumeRatio * MAX_FEE / (FEE_DENOMINATOR * 2);
        
        // 综合计算（加权平均）
        fee = (params.imbalanceFee * 30 + 
               params.sizeFee * 30 + 
               params.volatilityFee * 20 + 
               params.frequencyFee * 20) / 100;
        
        // 限制在最小最大范围内
        if (fee < MIN_FEE) fee = MIN_FEE;
        if (fee > MAX_FEE) fee = MAX_FEE;
    }
    
    function getHistoricalVolatility() private view returns (uint256) {
        // 计算过去1小时的价格标准差
        uint256 priceSum = 0;
        uint256 priceSquareSum = 0;
        uint256 count = 0;
        
        for (uint256 i = priceHistory.length - 1; i > 0; i--) {
            if (block.timestamp - priceHistory[i].timestamp > volatilityWindow) break;
            
            priceSum += priceHistory[i].price;
            priceSquareSum += priceHistory[i].price ** 2;
            count++;
        }
        
        if (count < 2) return 0;
        
        uint256 mean = priceSum / count;
        uint256 variance = priceSquareSum / count - mean ** 2;
        
        return sqrt(variance) * 10000 / mean; // 基点表示
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习 6.2：优化稳定币对的流动性管理</h4>
            <p>创建一个自动流动性管理器，实现：</p>
            <ul>
                <li>自动识别最优价格范围</li>
                <li>根据费用收益和无常损失动态调整</li>
                <li>多池聚合以最大化收益</li>
                <li>风险管理和止损机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer6-2')">查看参考答案</button>
            <div id="answer6-2" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract StablecoinLiquidityOptimizer {
    struct Position {
        uint256 tokenId;
        address pool;
        int24 tickLower;
        int24 tickUpper;
        uint128 liquidity;
        uint256 feeEarned;
        uint256 impermanentLoss;
        uint256 lastRebalance;
    }
    
    mapping(uint256 => Position) public positions;
    uint256 public nextPositionId;
    
    uint256 public maxImpermanentLoss = 50; // 0.5%
    uint256 public minFeeAPY = 500; // 5% APY
    uint256 public rebalanceInterval = 1 days;
    
    function optimizePosition(
        address token0,
        address token1,
        uint256 amount0,
        uint256 amount1
    ) external returns (uint256 positionId) {
        // 1. 分析历史数据找出最优范围
        (int24 optimalLower, int24 optimalUpper) = findOptimalRange(token0, token1);
        
        // 2. 评估不同池的收益潜力
        PoolEvaluation[] memory evaluations = evaluatePools(token0, token1);
        
        // 3. 分配流动性到多个池
        for (uint256 i = 0; i < evaluations.length && i < 3; i++) {
            if (evaluations[i].expectedAPY > minFeeAPY) {
                uint256 allocation = calculateOptimalAllocation(
                    evaluations[i],
                    amount0,
                    amount1
                );
                
                if (allocation > 0) {
                    uint256 tokenId = deployLiquidity(
                        evaluations[i].pool,
                        amount0 * allocation / 100,
                        amount1 * allocation / 100,
                        optimalLower,
                        optimalUpper
                    );
                    
                    positions[nextPositionId++] = Position({
                        tokenId: tokenId,
                        pool: evaluations[i].pool,
                        tickLower: optimalLower,
                        tickUpper: optimalUpper,
                        liquidity: getLiquidityAmount(tokenId),
                        feeEarned: 0,
                        impermanentLoss: 0,
                        lastRebalance: block.timestamp
                    });
                }
            }
        }
        
        return nextPositionId - 1;
    }
    
    function autoRebalance(uint256 positionId) external {
        Position storage pos = positions[positionId];
        require(block.timestamp >= pos.lastRebalance + rebalanceInterval, "Too soon");
        
        // 计算当前表现
        (uint256 currentFees, uint256 currentIL) = calculatePerformance(pos);
        
        // 检查是否需要调整
        bool needsRebalance = false;
        
        if (currentIL > maxImpermanentLoss) {
            needsRebalance = true; // IL过高
        }
        
        uint256 feeAPY = currentFees * 365 days * 10000 / 
                         (pos.liquidity * (block.timestamp - pos.lastRebalance));
        
        if (feeAPY < minFeeAPY) {
            needsRebalance = true; // 收益过低
        }
        
        if (needsRebalance) {
            // 收集流动性和费用
            collectAndRemove(pos.tokenId);
            
            // 重新优化部署
            optimizePosition(
                getToken0(pos.pool),
                getToken1(pos.pool),
                getBalance0(),
                getBalance1()
            );
        }
        
        pos.lastRebalance = block.timestamp;
    }
    
    function findOptimalRange(
        address token0,
        address token1
    ) private view returns (int24 tickLower, int24 tickUpper) {
        // 分析历史价格分布
        uint256[] memory priceDistribution = getPriceDistribution(token0, token1, 30 days);
        
        // 找出包含95%交易的价格范围
        uint256 percentile25 = getPercentile(priceDistribution, 25);
        uint256 percentile75 = getPercentile(priceDistribution, 75);
        
        // 转换为tick
        tickLower = priceToTick(percentile25);
        tickUpper = priceToTick(percentile75);
        
        // 确保范围不太窄
        int24 minWidth = 10; // 最小10个tick
        if (tickUpper - tickLower < minWidth) {
            int24 mid = (tickLower + tickUpper) / 2;
            tickLower = mid - minWidth / 2;
            tickUpper = mid + minWidth / 2;
        }
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习 6.3：实现跨链AMM聚合器</h4>
            <p>构建一个跨链AMM聚合器，要求：</p>
            <ul>
                <li>聚合多条链上的流动性</li>
                <li>自动选择最优执行路径</li>
                <li>处理跨链延迟和失败</li>
                <li>优化Gas成本</li>
            </ul>
            
            <button onclick="toggleAnswer('answer6-3')">查看参考答案</button>
            <div id="answer6-3" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract CrossChainAMMAggregator {
    using LayerZeroEndpoint for address;
    
    struct ChainLiquidity {
        uint16 chainId;
        address[] amms;
        uint256[] reserves;
        uint256[] fees;
        uint256 gasPrice;
    }
    
    struct CrossChainRoute {
        uint16[] chains;
        address[] amms;
        uint256[] amounts;
        uint256 totalGas;
        uint256 estimatedOut;
    }
    
    mapping(uint16 => ChainLiquidity) public chainLiquidities;
    mapping(bytes32 => PendingSwap) public pendingSwaps;
    
    ILayerZeroEndpoint public immutable lzEndpoint;
    
    function findBestCrossChainRoute(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint16[] memory targetChains
    ) public view returns (CrossChainRoute memory bestRoute) {
        uint256 bestOutput = 0;
        
        // 单链执行
        for (uint256 i = 0; i < targetChains.length; i++) {
            (uint256 output, uint256 gas) = getChainQuote(
                targetChains[i],
                tokenIn,
                tokenOut,
                amountIn
            );
            
            if (output > bestOutput) {
                bestOutput = output;
                bestRoute = CrossChainRoute({
                    chains: new uint16[](1),
                    amms: new address[](1),
                    amounts: new uint256[](1),
                    totalGas: gas,
                    estimatedOut: output
                });
                bestRoute.chains[0] = targetChains[i];
            }
        }
        
        // 多链分割执行
        if (targetChains.length > 1) {
            CrossChainRoute memory splitRoute = optimizeSplitRoute(
                tokenIn,
                tokenOut,
                amountIn,
                targetChains
            );
            
            if (splitRoute.estimatedOut > bestOutput) {
                bestRoute = splitRoute;
            }
        }
    }
    
    function executeCrossChainSwap(
        CrossChainRoute memory route,
        uint256 minAmountOut,
        address recipient
    ) external payable {
        require(route.estimatedOut >= minAmountOut, "Slippage");
        
        bytes32 swapId = keccak256(abi.encodePacked(
            msg.sender,
            route.chains,
            block.timestamp
        ));
        
        pendingSwaps[swapId] = PendingSwap({
            user: msg.sender,
            recipient: recipient,
            expectedOut: route.estimatedOut,
            receivedOut: 0,
            completedChains: 0,
            totalChains: route.chains.length,
            deadline: block.timestamp + 30 minutes
        });
        
        // 执行每条链的交换
        for (uint256 i = 0; i < route.chains.length; i++) {
            if (route.chains[i] == getChainId()) {
                // 本链执行
                executeLocalSwap(
                    route.amms[i],
                    route.amounts[i],
                    swapId
                );
            } else {
                // 跨链执行
                bytes memory payload = abi.encode(
                    swapId,
                    route.amms[i],
                    route.amounts[i],
                    recipient
                );
                
                lzEndpoint.send{value: msg.value / route.chains.length}(
                    route.chains[i],
                    abi.encodePacked(address(this)),
                    payload,
                    payable(msg.sender),
                    address(0),
                    bytes("")
                );
            }
        }
    }
    
    function lzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) external {
        require(msg.sender == address(lzEndpoint), "Invalid endpoint");
        
        (bytes32 swapId, address amm, uint256 amount, address recipient) = 
            abi.decode(_payload, (bytes32, address, uint256, address));
        
        PendingSwap storage swap = pendingSwaps[swapId];
        require(swap.deadline > block.timestamp, "Expired");
        
        // 执行交换
        uint256 amountOut = IAMM(amm).swap(amount, recipient);
        
        swap.receivedOut += amountOut;
        swap.completedChains++;
        
        if (swap.completedChains == swap.totalChains) {
            // 检查滑点
            require(
                swap.receivedOut >= swap.expectedOut * 95 / 100,
                "Excessive slippage"
            );
            
            emit CrossChainSwapCompleted(swapId, swap.receivedOut);
            delete pendingSwaps[swapId];
        }
    }
    
    // 失败处理
    function handleFailedSwap(bytes32 swapId) external {
        PendingSwap storage swap = pendingSwaps[swapId];
        require(swap.user == msg.sender, "Not owner");
        require(swap.deadline < block.timestamp, "Not expired");
        require(swap.completedChains < swap.totalChains, "Already completed");
        
        // 返还已完成部分
        if (swap.receivedOut > 0) {
            IERC20(tokenOut).transfer(swap.recipient, swap.receivedOut);
        }
        
        // 触发未完成链的退款流程
        for (uint256 i = 0; i < swap.totalChains; i++) {
            if (!isChainCompleted(swapId, i)) {
                triggerRefund(swap.chains[i], swapId);
            }
        }
        
        emit CrossChainSwapFailed(swapId, swap.completedChains, swap.totalChains);
        delete pendingSwaps[swapId];
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>练习 6.4：设计专用稳定币AMM曲线</h4>
            <p>设计一个新的AMM曲线，专门优化稳定币交易：</p>
            <ul>
                <li>在0.99-1.01范围内提供极低滑点</li>
                <li>支持多资产池（3个以上稳定币）</li>
                <li>动态调整曲线参数</li>
                <li>内置脱锚保护机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer6-4')">查看参考答案</button>
            <div id="answer6-4" class="answer">
                <h4>参考答案：</h4>
                <pre><code class="language-solidity">contract AdvancedStableCurve {
    using FixedPoint for uint256;
    
    uint256 private constant PRECISION = 1e18;
    uint256 private constant A_MULTIPLIER = 10000;
    
    struct PoolParams {
        uint256 A;              // 放大系数
        uint256 gamma;          // 曲率参数
        uint256 beta;           // 价格影响参数
        uint256 delta;          // 脱锚惩罚参数
        uint256[] weights;      // 资产权重
        uint256 lastUpdateTime;
    }
    
    PoolParams public params;
    uint256[] public balances;
    uint256 public D; // 不变量
    
    // 新的不变量公式：混合几何平均和算术平均
    function computeD(uint256[] memory xp) private view returns (uint256) {
        uint256 n = xp.length;
        uint256 s = 0;
        uint256 p = PRECISION;
        
        for (uint256 i = 0; i < n; i++) {
            s += xp[i];
            p = p * xp[i] / PRECISION;
        }
        
        if (s == 0) return 0;
        
        uint256 nPow = PRECISION;
        for (uint256 i = 0; i < n - 1; i++) {
            nPow = nPow * n / PRECISION;
        }
        
        uint256 d = s;
        uint256 d_prev;
        uint256 ann = params.A * nPow;
        
        // 混合不变量：D^n + b*D = a*sum(x_i) + c*prod(x_i)
        for (uint256 i = 0; i < 255; i++) {
            uint256 dp = d;
            for (uint256 j = 0; j < n; j++) {
                dp = dp * d / (xp[j] * n);
            }
            
            d_prev = d;
            
            // 加入曲率调整
            uint256 gamma_adj = PRECISION + params.gamma * (s - d) / s;
            
            d = (ann * s * gamma_adj / PRECISION + dp * n) * d /
                ((ann - PRECISION) * d / PRECISION + (n + 1) * dp);
            
            if (d > d_prev) {
                if (d - d_prev <= 1) break;
            } else {
                if (d_prev - d <= 1) break;
            }
        }
        
        return d;
    }
    
    // 动态A值调整
    function updateAmplification() external {
        uint256 timePassed = block.timestamp - params.lastUpdateTime;
        if (timePassed < 1 hours) return;
        
        // 计算价格偏离度
        uint256 maxDeviation = 0;
        for (uint256 i = 0; i < balances.length; i++) {
            uint256 idealBalance = D * params.weights[i] / PRECISION;
            uint256 deviation = balances[i] > idealBalance ?
                (balances[i] - idealBalance) * PRECISION / idealBalance :
                (idealBalance - balances[i]) * PRECISION / idealBalance;
            
            if (deviation > maxDeviation) maxDeviation = deviation;
        }
        
        // 根据偏离度调整A值
        if (maxDeviation > 0.01e18) { // 1%以上偏离
            params.A = params.A * 95 / 100; // 降低A值
        } else if (maxDeviation < 0.001e18) { // 0.1%以下偏离
            params.A = params.A * 105 / 100; // 提高A值
        }
        
        // 限制A值范围
        if (params.A < 10) params.A = 10;
        if (params.A > 10000) params.A = 10000;
        
        params.lastUpdateTime = block.timestamp;
    }
    
    // 脱锚保护
    function applyDepegProtection(
        uint256[] memory amounts,
        uint256[] memory prices
    ) private view returns (uint256[] memory adjusted) {
        adjusted = new uint256[](amounts.length);
        
        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 priceDeviation = prices[i] > PRECISION ?
                (prices[i] - PRECISION) * PRECISION / PRECISION :
                (PRECISION - prices[i]) * PRECISION / PRECISION;
            
            if (priceDeviation > 0.02e18) { // 2%以上脱锚
                // 应用惩罚因子
                uint256 penalty = PRECISION + params.delta * priceDeviation / PRECISION;
                adjusted[i] = amounts[i] * PRECISION / penalty;
            } else {
                adjusted[i] = amounts[i];
            }
        }
    }
    
    // 多资产交换
    function swapExactInput(
        uint256 tokenIn,
        uint256 tokenOut,
        uint256 amountIn,
        uint256 minAmountOut
    ) external returns (uint256 amountOut) {
        require(tokenIn < balances.length && tokenOut < balances.length, "Invalid token");
        require(tokenIn != tokenOut, "Same token");
        
        // 获取外部价格
        uint256[] memory prices = getExternalPrices();
        
        // 应用脱锚保护
        uint256[] memory adjustedBalances = applyDepegProtection(balances, prices);
        
        // 计算输出
        uint256 y = computeY(tokenIn, tokenOut, adjustedBalances[tokenIn] + amountIn, adjustedBalances);
        amountOut = adjustedBalances[tokenOut] - y;
        
        // 动态费用
        uint256 fee = calculateDynamicFee(tokenIn, tokenOut, amountIn, prices);
        amountOut = amountOut - amountOut * fee / PRECISION;
        
        require(amountOut >= minAmountOut, "Slippage");
        
        // 更新余额
        balances[tokenIn] += amountIn;
        balances[tokenOut] -= amountOut;
        
        // 更新D值
        D = computeD(balances);
        
        emit Swap(msg.sender, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    function calculateDynamicFee(
        uint256 tokenIn,
        uint256 tokenOut,
        uint256 amount,
        uint256[] memory prices
    ) private view returns (uint256 fee) {
        // 基础费用
        fee = 0.0001e18; // 0.01%
        
        // 价格偏离费用
        uint256 priceDevIn = prices[tokenIn] > PRECISION ?
            prices[tokenIn] - PRECISION : PRECISION - prices[tokenIn];
        uint256 priceDevOut = prices[tokenOut] > PRECISION ?
            prices[tokenOut] - PRECISION : PRECISION - prices[tokenOut];
        
        fee += (priceDevIn + priceDevOut) * params.beta / PRECISION;
        
        // 不平衡费用
        uint256 imbalance = calculateImbalance();
        fee += imbalance * 0.001e18 / PRECISION;
        
        // 限制最大费用
        if (fee > 0.01e18) fee = 0.01e18; // 最大1%
    }
}</code></pre>
            </div>
        </div>
        
        <h3>本章小结</h3>
        <div class="tip">
            <strong>关键要点：</strong>
            <ul>
                <li><strong>AMM选择：</strong>不同的AMM模型适合不同的稳定币交易场景，需要根据具体需求选择</li>
                <li><strong>资本效率：</strong>集中流动性和专用曲线可以显著提高稳定币交易的资本效率</li>
                <li><strong>MEV防护：</strong>稳定币AMM特别容易受到MEV攻击，需要专门的防护机制</li>
                <li><strong>动态调整：</strong>费用、流动性范围和曲线参数都应该根据市场条件动态调整</li>
                <li><strong>跨链整合：</strong>未来的AMM需要考虑跨链流动性聚合以提供最优价格</li>
            </ul>
        </div>
        
        <h3>术语速查表</h3>
        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
            <tr style="background: #f3f4f6;">
                <th style="border: 1px solid #ddd; padding: 12px;">术语</th>
                <th style="border: 1px solid #ddd; padding: 12px;">英文</th>
                <th style="border: 1px solid #ddd; padding: 12px;">含义</th>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">自动做市商</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Automated Market Maker (AMM)</td>
                <td style="border: 1px solid #ddd; padding: 8px;">使用算法自动提供流动性的协议</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">恒定乘积</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Constant Product</td>
                <td style="border: 1px solid #ddd; padding: 8px;">x*y=k的AMM公式</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">集中流动性</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Concentrated Liquidity</td>
                <td style="border: 1px solid #ddd; padding: 8px;">将流动性集中在特定价格范围</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">无常损失</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Impermanent Loss</td>
                <td style="border: 1px solid #ddd; padding: 8px;">提供流动性vs持有代币的价值差异</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">滑点</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Slippage</td>
                <td style="border: 1px solid #ddd; padding: 8px;">预期价格与实际执行价格的差异</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">TWAP</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Time-Weighted Average Price</td>
                <td style="border: 1px solid #ddd; padding: 8px;">时间加权平均价格</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">放大系数</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Amplification Factor</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Curve中控制曲线平坦度的参数</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">JIT流动性</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Just-In-Time Liquidity</td>
                <td style="border: 1px solid #ddd; padding: 8px;">在交易前临时添加的流动性</td>
            </tr>
        </table>

        <h3>第六章小结</h3>
        <div class="info-box">
            <h4>核心要点</h4>
            <ul>
                <li><strong>理论基础：</strong>从恒定乘积到恒定和，理解AMM模型的数学本质</li>
                <li><strong>效率优化：</strong>从V2到V3，集中流动性提升100倍资本效率但增加风险</li>
                <li><strong>稳定币专用：</strong>Curve StableSwap通过混合不变量实现低滑点高效率</li>
                <li><strong>动态调整：</strong>Curve V2的自适应系统，根据市场状态调整参数</li>
                <li><strong>前沿发展：</strong>Uniswap V4 Hooks、AI驱动优化、跨链聚合</li>
            </ul>
        </div>

        <div class="example-box">
            <h4>实践建议</h4>
            <ol>
                <li><strong>风险评估：</strong>部署前必须进行无常损失和脱锚风险的定量分析</li>
                <li><strong>参数选择：</strong>根据资产特性和市场环境合理设置放大系数A</li>
                <li><strong>MEV防护：</strong>实施TWAP、批量交易等机制保护用户</li>
                <li><strong>监控系统：</strong>建立实时监控，及时响应市场异常</li>
                <li><strong>治理机制：</strong>通过veToken等模型建立可持续的激励体系</li>
            </ol>
        </div>

        <div class="warning-box">
            <h4>风险提醒</h4>
            <ul>
                <li><strong>流动性风险：</strong>极端市场条件下可能出现流动性枯竭</li>
                <li><strong>Oracle风险：</strong>价格预言机操纵可能导致协议损失</li>
                <li><strong>智能合约风险：</strong>代码漏洞可能被利用造成资金损失</li>
                <li><strong>治理攻击：</strong>恶意提案可能损害协议利益</li>
                <li><strong>监管风险：</strong>法规变化可能影响协议运营</li>
            </ul>
        </div>

        <h3>推荐阅读</h3>
        <ul>
            <li><a href="https://curve.fi/files/stableswap-paper.pdf" target="_blank">Curve StableSwap Whitepaper</a></li>
            <li><a href="https://uniswap.org/whitepaper-v3.pdf" target="_blank">Uniswap V3 Core</a></li>
            <li><a href="https://github.com/Uniswap/v4-core" target="_blank">Uniswap V4 Documentation</a></li>
            <li><a href="https://arxiv.org/abs/2103.12732" target="_blank">Automated Market Making: Theory and Practice</a></li>
            <li><a href="https://ethereum.org/en/developers/docs/mev/" target="_blank">MEV Research Resources</a></li>
        </ul>
    </div>
    
    <!-- 第七章：借贷协议 -->
    <div class="chapter" id="chapter7">
        <h2>第七章：借贷协议（Lending Protocols）</h2>
        
        <div class="overview">
            <h3>本章概览</h3>
            <p>本章深入探讨稳定币在去中心化借贷协议中的核心作用。我们将学习主流借贷协议的架构设计、利率模型的数学原理、稳定币特有的风险管理机制，以及闪电贷的实现和防御策略。通过实践，您将构建一个功能完整的稳定币借贷池。</p>
        </div>

        <h3>7.1 借贷协议基础架构</h3>
        
        <h4>7.1.1 核心概念</h4>
        <div class="concept">
            <p><strong>借贷协议三要素：</strong></p>
            <ul>
                <li><strong>流动性池（Liquidity Pool）</strong>：资金聚合的智能合约</li>
                <li><strong>利率模型（Interest Rate Model）</strong>：动态定价机制</li>
                <li><strong>风险管理（Risk Management）</strong>：清算和保险机制</li>
            </ul>
        </div>

        <h4>7.1.2 Compound协议架构</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// cToken接口 - Compound的核心抽象
interface ICToken {
    // 存款
    function mint(uint mintAmount) external returns (uint);
    
    // 取款
    function redeem(uint redeemTokens) external returns (uint);
    function redeemUnderlying(uint redeemAmount) external returns (uint);
    
    // 借款
    function borrow(uint borrowAmount) external returns (uint);
    
    // 还款
    function repayBorrow(uint repayAmount) external returns (uint);
    
    // 查询函数
    function balanceOf(address owner) external view returns (uint);
    function borrowBalanceStored(address account) external view returns (uint);
    function exchangeRateStored() external view returns (uint);
}

// 稳定币专用的cToken实现
contract CStablecoin is ICToken, ERC20 {
    IERC20 public underlying;  // 底层稳定币
    uint public reserveFactorMantissa;  // 准备金率
    uint public accrualBlockNumber;  // 上次计息区块
    uint public borrowIndex;  // 借款指数
    uint public totalBorrows;  // 总借款
    uint public totalReserves;  // 总准备金
    
    // 关键参数
    uint constant expScale = 1e18;
    uint constant blocksPerYear = 2102400;  // 约15秒一个块
    
    // 利率模型
    IInterestRateModel public interestRateModel;
    
    struct BorrowSnapshot {
        uint principal;  // 本金
        uint interestIndex;  // 借款时的指数
    }
    
    mapping(address => BorrowSnapshot) internal accountBorrows;
    
    // 计算并累积利息
    function accrueInterest() public returns (uint) {
        uint currentBlockNumber = block.number;
        uint accrualBlockNumberPrior = accrualBlockNumber;
        
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return 0;
        }
        
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;
        uint borrowIndexPrior = borrowIndex;
        
        // 计算借款利率
        uint borrowRateMantissa = interestRateModel.getBorrowRate(
            cashPrior,
            borrowsPrior,
            reservesPrior
        );
        
        // 计算区块数差
        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;
        
        // 计算利息因子
        uint simpleInterestFactor = borrowRateMantissa * blockDelta;
        uint interestAccumulated = simpleInterestFactor * borrowsPrior / expScale;
        
        // 更新状态
        totalBorrows = borrowsPrior + interestAccumulated;
        totalReserves = reservesPrior + (interestAccumulated * reserveFactorMantissa / expScale);
        borrowIndex = borrowIndexPrior + (simpleInterestFactor * borrowIndexPrior / expScale);
        accrualBlockNumber = currentBlockNumber;
        
        return interestAccumulated;
    }
    
    // 存款实现
    function mintInternal(uint mintAmount) internal returns (uint) {
        accrueInterest();
        
        // 转入底层代币
        underlying.transferFrom(msg.sender, address(this), mintAmount);
        
        // 计算兑换率
        uint exchangeRateMantissa = exchangeRateStoredInternal();
        uint mintTokens = mintAmount * expScale / exchangeRateMantissa;
        
        // 铸造cToken
        _mint(msg.sender, mintTokens);
        
        return mintTokens;
    }
}</code></pre>
        </div>

        <h4>7.1.3 Aave V3架构创新</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// Aave V3的高级功能
contract AaveV3Pool {
    using WadRayMath for uint256;
    
    // 核心数据结构
    struct ReserveData {
        ReserveConfigurationMap configuration;
        uint128 liquidityIndex;
        uint128 variableBorrowIndex;
        uint128 currentLiquidityRate;
        uint128 currentVariableBorrowRate;
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        address interestRateStrategyAddress;
        uint8 id;
    }
    
    // 效率模式（E-Mode）- 稳定币专用优化
    struct EModeCategory {
        uint16 ltv;  // 贷款价值比
        uint16 liquidationThreshold;  // 清算阈值
        uint16 liquidationBonus;  // 清算奖励
        address priceSource;  // 价格源
        string label;  // 类别标签
    }
    
    mapping(uint8 => EModeCategory) internal _eModeCategories;
    
    // 供应函数 - 支持多种模式
    function supply(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external {
        DataTypes.ReserveData storage reserve = _reserves[asset];
        
        // 验证
        ValidationLogic.validateSupply(reserve, amount);
        
        // 更新状态
        reserve.updateState();
        reserve.updateInterestRates(asset, amount, 0);
        
        // 转入资产
        IERC20(asset).safeTransferFrom(msg.sender, reserve.aTokenAddress, amount);
        
        // 铸造aToken
        IAToken(reserve.aTokenAddress).mint(onBehalfOf, amount, reserve.liquidityIndex);
        
        emit Supply(asset, msg.sender, onBehalfOf, amount, referralCode);
    }
    
    // 隔离模式借款 - 风险隔离
    function borrowInIsolation(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        address onBehalfOf
    ) external {
        require(_usersConfig[onBehalfOf].isolationModeActive, "Not in isolation mode");
        
        DataTypes.ReserveData storage reserve = _reserves[asset];
        
        // 隔离模式特殊验证
        ValidationLogic.validateBorrowInIsolation(
            _reserves,
            _usersConfig[onBehalfOf],
            asset,
            amount
        );
        
        _executeBorrow(ExecuteBorrowParams({
            asset: asset,
            user: msg.sender,
            onBehalfOf: onBehalfOf,
            amount: amount,
            interestRateMode: interestRateMode,
            referralCode: 0,
            releaseUnderlying: true
        }));
    }
}</code></pre>
        </div>

        <h3>7.2 利率模型设计</h3>
        
        <h4>7.2.1 基础利率模型</h4>
        <div class="formula">
            <p><strong>利用率（Utilization Rate）</strong>：</p>
            <p>U = Borrows / (Cash + Borrows - Reserves)</p>
            
            <p><strong>借款利率模型</strong>：</p>
            <p>当 U ≤ U_optimal：R = R_0 + (U/U_optimal) × R_slope1</p>
            <p>当 U > U_optimal：R = R_0 + R_slope1 + ((U-U_optimal)/(1-U_optimal)) × R_slope2</p>
        </div>

        <div class="code-block">
            <pre><code class="language-solidity">// 跳跃率模型实现
contract JumpRateModelV2 is IInterestRateModel {
    uint256 public constant blocksPerYear = 2102400;
    
    uint256 public baseRatePerBlock;
    uint256 public multiplierPerBlock;
    uint256 public jumpMultiplierPerBlock;
    uint256 public kink;  // 拐点
    
    constructor(
        uint256 baseRatePerYear,
        uint256 multiplierPerYear,
        uint256 jumpMultiplierPerYear,
        uint256 kink_
    ) {
        baseRatePerBlock = baseRatePerYear / blocksPerYear;
        multiplierPerBlock = multiplierPerYear / blocksPerYear;
        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;
        kink = kink_;
    }
    
    function utilizationRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) public pure returns (uint256) {
        if (borrows == 0) {
            return 0;
        }
        return borrows * 1e18 / (cash + borrows - reserves);
    }
    
    function getBorrowRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) public view override returns (uint256) {
        uint256 util = utilizationRate(cash, borrows, reserves);
        
        if (util <= kink) {
            return baseRatePerBlock + util * multiplierPerBlock / 1e18;
        } else {
            uint256 normalRate = baseRatePerBlock + kink * multiplierPerBlock / 1e18;
            uint256 excessUtil = util - kink;
            return normalRate + excessUtil * jumpMultiplierPerBlock / 1e18;
        }
    }
    
    function getSupplyRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves,
        uint256 reserveFactorMantissa
    ) public view override returns (uint256) {
        uint256 oneMinusReserveFactor = 1e18 - reserveFactorMantissa;
        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);
        uint256 rateToPool = borrowRate * oneMinusReserveFactor / 1e18;
        return utilizationRate(cash, borrows, reserves) * rateToPool / 1e18;
    }
}</code></pre>
        </div>

        <h4>7.2.2 稳定币特殊利率策略</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// 稳定币优化利率模型
contract StablecoinRateStrategy is IInterestRateStrategy {
    using WadRayMath for uint256;
    
    // 稳定币特有参数
    uint256 public immutable OPTIMAL_UTILIZATION_RATE = 0.9e27;  // 90%
    uint256 public immutable BASE_VARIABLE_BORROW_RATE = 0.01e27;  // 1%
    uint256 public immutable VARIABLE_RATE_SLOPE1 = 0.04e27;  // 4%
    uint256 public immutable VARIABLE_RATE_SLOPE2 = 0.6e27;  // 60%
    uint256 public immutable STABLE_RATE_SLOPE1 = 0.02e27;  // 2%
    uint256 public immutable STABLE_RATE_SLOPE2 = 0.6e27;  // 60%
    
    // 动态调整机制
    uint256 public immutable OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = 0.2e27;  // 20%
    
    function calculateInterestRates(
        DataTypes.CalculateInterestRatesParams memory params
    ) public view override returns (uint256, uint256, uint256) {
        uint256 utilizationRate = params.totalDebt.rayDiv(params.totalLiquidity);
        
        uint256 currentVariableBorrowRate;
        uint256 currentStableBorrowRate;
        
        if (utilizationRate <= OPTIMAL_UTILIZATION_RATE) {
            // 正常区间 - 线性增长
            currentVariableBorrowRate = BASE_VARIABLE_BORROW_RATE +
                utilizationRate.rayMul(VARIABLE_RATE_SLOPE1).rayDiv(OPTIMAL_UTILIZATION_RATE);
                
            currentStableBorrowRate = currentVariableBorrowRate +
                utilizationRate.rayMul(STABLE_RATE_SLOPE1).rayDiv(OPTIMAL_UTILIZATION_RATE);
        } else {
            // 高利用率区间 - 快速增长
            uint256 excessUtilizationRateRatio = 
                (utilizationRate - OPTIMAL_UTILIZATION_RATE).rayDiv(1e27 - OPTIMAL_UTILIZATION_RATE);
                
            currentVariableBorrowRate = BASE_VARIABLE_BORROW_RATE +
                VARIABLE_RATE_SLOPE1 +
                VARIABLE_RATE_SLOPE2.rayMul(excessUtilizationRateRatio);
                
            currentStableBorrowRate = currentVariableBorrowRate +
                STABLE_RATE_SLOPE1 +
                STABLE_RATE_SLOPE2.rayMul(excessUtilizationRateRatio);
        }
        
        // 稳定利率调整
        if (params.stableDebt > 0) {
            uint256 stableToTotalDebtRatio = params.stableDebt.rayDiv(params.totalDebt);
            
            if (stableToTotalDebtRatio > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO) {
                uint256 excessStableDebtRatio = 
                    (stableToTotalDebtRatio - OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO)
                    .rayDiv(1e27 - OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO);
                    
                currentStableBorrowRate = currentStableBorrowRate +
                    STABLE_RATE_SLOPE2.rayMul(excessStableDebtRatio);
            }
        }
        
        // 计算流动性利率
        uint256 currentLiquidityRate = _getOverallBorrowRate(
            params.totalStableDebt,
            params.totalVariableDebt,
            currentVariableBorrowRate,
            params.averageStableBorrowRate
        ).rayMul(utilizationRate).rayMul(1e27 - params.reserveFactor);
        
        return (currentLiquidityRate, currentStableBorrowRate, currentVariableBorrowRate);
    }
}</code></pre>
        </div>

        <h3>7.3 闪电贷机制与安全</h3>
        
        <h4>7.3.1 闪电贷实现</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// EIP-3156 闪电贷标准实现
contract FlashLoanProvider is IERC3156FlashLender {
    using SafeERC20 for IERC20;
    
    // 闪电贷费率（基点）
    uint256 public constant FLASH_LOAN_FEE = 9;  // 0.09%
    bytes32 public constant CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan");
    
    mapping(address => bool) public supportedTokens;
    
    // 闪电贷核心函数
    function flashLoan(
        IERC3156FlashBorrower receiver,
        address token,
        uint256 amount,
        bytes calldata data
    ) external override returns (bool) {
        require(supportedTokens[token], "Token not supported");
        
        uint256 fee = _flashFee(amount);
        uint256 balanceBefore = IERC20(token).balanceOf(address(this));
        
        // 发送代币给借款人
        IERC20(token).safeTransfer(address(receiver), amount);
        
        // 执行回调
        require(
            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,
            "Callback failed"
        );
        
        // 收回本金和费用
        uint256 balanceAfter = IERC20(token).balanceOf(address(this));
        require(
            balanceAfter >= balanceBefore + fee,
            "Flash loan not repaid"
        );
        
        emit FlashLoan(address(receiver), token, amount, fee);
        return true;
    }
    
    // 批量闪电贷 - Gas优化
    function flashLoanMultiple(
        IERC3156FlashBorrower receiver,
        address[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata data
    ) external returns (bool) {
        require(tokens.length == amounts.length, "Array length mismatch");
        
        uint256[] memory fees = new uint256[](tokens.length);
        uint256[] memory balancesBefore = new uint256[](tokens.length);
        
        // 批量转出
        for (uint256 i = 0; i < tokens.length; i++) {
            require(supportedTokens[tokens[i]], "Token not supported");
            fees[i] = _flashFee(amounts[i]);
            balancesBefore[i] = IERC20(tokens[i]).balanceOf(address(this));
            IERC20(tokens[i]).safeTransfer(address(receiver), amounts[i]);
        }
        
        // 执行回调
        require(
            IFlashLoanReceiverMultiple(receiver).onFlashLoanMultiple(
                msg.sender,
                tokens,
                amounts,
                fees,
                data
            ) == CALLBACK_SUCCESS,
            "Callback failed"
        );
        
        // 批量验证还款
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
            require(
                balanceAfter >= balancesBefore[i] + fees[i],
                "Flash loan not repaid"
            );
        }
        
        return true;
    }
    
    function _flashFee(uint256 amount) internal pure returns (uint256) {
        return amount * FLASH_LOAN_FEE / 10000;
    }
}</code></pre>
        </div>

        <h4>7.3.2 闪电贷攻击防御</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// 防御闪电贷攻击的措施
contract FlashLoanProtectedVault {
    using ReentrancyGuard for uint256;
    
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    uint256 private _status;
    
    // 闪电贷检测
    modifier noFlashLoan() {
        require(!_isFlashLoan(), "Flash loan detected");
        _;
    }
    
    // 延迟更新机制
    struct PriceSnapshot {
        uint256 price;
        uint256 timestamp;
        uint256 blockNumber;
    }
    
    mapping(address => PriceSnapshot) public priceSnapshots;
    uint256 public constant PRICE_DELAY = 1 hours;
    
    function _isFlashLoan() internal view returns (bool) {
        // 检查是否在同一区块内有大额借贷
        // 实际实现需要追踪借贷历史
        return false;
    }
    
    // 时间加权价格
    function getSecurePrice(address token) public view returns (uint256) {
        PriceSnapshot memory snapshot = priceSnapshots[token];
        require(
            block.timestamp >= snapshot.timestamp + PRICE_DELAY,
            "Price not yet valid"
        );
        return snapshot.price;
    }
    
    // 闪电贷保护的清算函数
    function liquidate(
        address borrower,
        address collateralAsset,
        address debtAsset,
        uint256 debtToCover
    ) external noFlashLoan nonReentrant {
        // 使用延迟价格
        uint256 collateralPrice = getSecurePrice(collateralAsset);
        uint256 debtPrice = getSecurePrice(debtAsset);
        
        // 计算清算
        uint256 collateralAmount = _calculateLiquidation(
            debtToCover,
            debtPrice,
            collateralPrice
        );
        
        // 执行清算
        _executeLiquidation(borrower, collateralAsset, debtAsset, collateralAmount);
    }
    
    // 多重签名延迟执行
    mapping(bytes32 => TimelockTransaction) public timelockTransactions;
    
    struct TimelockTransaction {
        address target;
        bytes data;
        uint256 executeTime;
        bool executed;
    }
    
    function scheduleTransaction(
        address target,
        bytes memory data,
        uint256 delay
    ) external onlyOwner returns (bytes32) {
        bytes32 txHash = keccak256(abi.encode(target, data, block.timestamp));
        
        timelockTransactions[txHash] = TimelockTransaction({
            target: target,
            data: data,
            executeTime: block.timestamp + delay,
            executed: false
        });
        
        emit TransactionScheduled(txHash, target, delay);
        return txHash;
    }
}</code></pre>
        </div>

        <h3>7.4 实践：构建稳定币借贷池</h3>
        
        <h4>7.4.1 完整的借贷池实现</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// 稳定币借贷池完整实现
contract StablecoinLendingPool is 
    ReentrancyGuard, 
    Pausable, 
    AccessControl,
    IERC3156FlashLender 
{
    using SafeERC20 for IERC20;
    using WadRayMath for uint256;
    
    // 角色定义
    bytes32 public constant CONFIGURATOR_ROLE = keccak256("CONFIGURATOR_ROLE");
    bytes32 public constant RISK_ADMIN_ROLE = keccak256("RISK_ADMIN_ROLE");
    
    // 核心状态变量
    struct Reserve {
        uint256 liquidityIndex;
        uint256 variableBorrowIndex;
        uint256 currentLiquidityRate;
        uint256 currentVariableBorrowRate;
        uint40 lastUpdateTimestamp;
        address aTokenAddress;
        address debtTokenAddress;
        address interestRateStrategyAddress;
        uint256 accruedToTreasury;
        ReserveConfiguration configuration;
    }
    
    struct ReserveConfiguration {
        uint256 ltv;  // 贷款价值比
        uint256 liquidationThreshold;  // 清算阈值
        uint256 liquidationBonus;  // 清算奖励
        uint256 reserveFactor;  // 准备金率
        bool borrowingEnabled;
        bool stableBorrowRateEnabled;
        bool isActive;
        bool isFrozen;
    }
    
    mapping(address => Reserve) public reserves;
    mapping(address => mapping(address => uint256)) public userCollateral;
    mapping(address => mapping(address => uint256)) public userDebt;
    
    // 事件
    event Deposit(address indexed user, address indexed asset, uint256 amount);
    event Withdraw(address indexed user, address indexed asset, uint256 amount);
    event Borrow(address indexed user, address indexed asset, uint256 amount);
    event Repay(address indexed user, address indexed asset, uint256 amount);
    event Liquidation(
        address indexed liquidator,
        address indexed borrower,
        address indexed asset,
        uint256 debtCovered,
        uint256 collateralLiquidated
    );
    
    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CONFIGURATOR_ROLE, msg.sender);
        _setupRole(RISK_ADMIN_ROLE, msg.sender);
    }
    
    // 初始化储备
    function initReserve(
        address asset,
        address aTokenAddress,
        address debtTokenAddress,
        address interestRateStrategy
    ) external onlyRole(CONFIGURATOR_ROLE) {
        reserves[asset] = Reserve({
            liquidityIndex: WadRayMath.ray(),
            variableBorrowIndex: WadRayMath.ray(),
            currentLiquidityRate: 0,
            currentVariableBorrowRate: 0,
            lastUpdateTimestamp: uint40(block.timestamp),
            aTokenAddress: aTokenAddress,
            debtTokenAddress: debtTokenAddress,
            interestRateStrategyAddress: interestRateStrategy,
            accruedToTreasury: 0,
            configuration: ReserveConfiguration({
                ltv: 8000,  // 80%
                liquidationThreshold: 8500,  // 85%
                liquidationBonus: 10500,  // 105%
                reserveFactor: 1000,  // 10%
                borrowingEnabled: true,
                stableBorrowRateEnabled: false,
                isActive: true,
                isFrozen: false
            })
        });
    }
    
    // 存款
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf
    ) external nonReentrant whenNotPaused {
        Reserve storage reserve = reserves[asset];
        require(reserve.configuration.isActive, "Reserve not active");
        require(!reserve.configuration.isFrozen, "Reserve frozen");
        
        // 更新储备状态
        _updateIndexes(reserve);
        
        // 转入资产
        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);
        
        // 更新用户余额
        userCollateral[onBehalfOf][asset] += amount;
        
        // 铸造aToken
        IAToken(reserve.aTokenAddress).mint(onBehalfOf, amount, reserve.liquidityIndex);
        
        // 更新利率
        _updateInterestRates(reserve, asset, amount, 0);
        
        emit Deposit(onBehalfOf, asset, amount);
    }
    
    // 借款
    function borrow(
        address asset,
        uint256 amount,
        address onBehalfOf
    ) external nonReentrant whenNotPaused {
        Reserve storage reserve = reserves[asset];
        require(reserve.configuration.isActive, "Reserve not active");
        require(reserve.configuration.borrowingEnabled, "Borrowing not enabled");
        
        // 更新储备状态
        _updateIndexes(reserve);
        
        // 检查健康因子
        (, , , , uint256 healthFactor) = _calculateUserAccountData(onBehalfOf);
        require(healthFactor > WadRayMath.ray(), "Health factor too low");
        
        // 更新债务
        userDebt[onBehalfOf][asset] += amount;
        
        // 铸造债务代币
        IDebtToken(reserve.debtTokenAddress).mint(
            onBehalfOf,
            amount,
            reserve.variableBorrowIndex
        );
        
        // 转出资产
        IERC20(asset).safeTransfer(onBehalfOf, amount);
        
        // 更新利率
        _updateInterestRates(reserve, asset, 0, amount);
        
        emit Borrow(onBehalfOf, asset, amount);
    }
    
    // 清算
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover
    ) external nonReentrant whenNotPaused {
        Reserve storage collateralReserve = reserves[collateralAsset];
        Reserve storage debtReserve = reserves[debtAsset];
        
        // 更新储备状态
        _updateIndexes(collateralReserve);
        _updateIndexes(debtReserve);
        
        // 检查健康因子
        (, , , , uint256 healthFactor) = _calculateUserAccountData(user);
        require(healthFactor < WadRayMath.ray(), "Health factor not below 1");
        
        // 计算清算金额
        uint256 collateralAmount = _calculateAvailableCollateralToLiquidate(
            collateralReserve,
            debtReserve,
            collateralAsset,
            debtAsset,
            debtToCover,
            userCollateral[user][collateralAsset]
        );
        
        // 执行清算
        userDebt[user][debtAsset] -= debtToCover;
        userCollateral[user][collateralAsset] -= collateralAmount;
        
        // 转移债务
        IERC20(debtAsset).safeTransferFrom(msg.sender, address(this), debtToCover);
        
        // 转移抵押品（包含奖励）
        uint256 liquidationBonus = collateralAmount
            .wadMul(collateralReserve.configuration.liquidationBonus)
            .wadDiv(10000);
        IERC20(collateralAsset).safeTransfer(msg.sender, collateralAmount + liquidationBonus);
        
        emit Liquidation(msg.sender, user, debtAsset, debtToCover, collateralAmount);
    }
    
    // 辅助函数：更新指数
    function _updateIndexes(Reserve storage reserve) internal {
        uint256 scaledTotalSupply = IAToken(reserve.aTokenAddress).scaledTotalSupply();
        uint256 scaledTotalDebt = IDebtToken(reserve.debtTokenAddress).scaledTotalSupply();
        
        if (scaledTotalSupply == 0 && scaledTotalDebt == 0) {
            return;
        }
        
        uint256 cumulatedLiquidityInterest = _calculateLinearInterest(
            reserve.currentLiquidityRate,
            reserve.lastUpdateTimestamp
        );
        
        uint256 cumulatedVariableBorrowInterest = _calculateCompoundedInterest(
            reserve.currentVariableBorrowRate,
            reserve.lastUpdateTimestamp
        );
        
        reserve.liquidityIndex = cumulatedLiquidityInterest.rayMul(reserve.liquidityIndex);
        reserve.variableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(
            reserve.variableBorrowIndex
        );
        
        reserve.lastUpdateTimestamp = uint40(block.timestamp);
    }
    
    // 计算用户账户数据
    function _calculateUserAccountData(address user)
        internal
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 healthFactor
        )
    {
        // 实现省略，需要遍历所有用户的抵押品和债务
        // 使用预言机价格转换为ETH计价
        // 计算加权平均清算阈值
        // 计算健康因子 = (totalCollateral * liquidationThreshold) / totalDebt
    }
}</code></pre>
        </div>

        <h3>7.5 高级主题</h3>
        
        <h4>7.5.1 跨链借贷</h4>
        <div class="info-box">
            <p><strong>跨链借贷架构：</strong></p>
            <ul>
                <li>Hub-Spoke模型：中心化流动性管理</li>
                <li>点对点模型：直接跨链交互</li>
                <li>流动性聚合：跨链收益优化</li>
            </ul>
        </div>

        <h4>7.5.2 信用借贷探索</h4>
        <div class="concept">
            <p><strong>无抵押借贷创新：</strong></p>
            <ul>
                <li>链上信用评分系统</li>
                <li>社交恢复机制</li>
                <li>收入代币化模型</li>
                <li>保险池风险分担</li>
            </ul>
        </div>

        <h3>练习题</h3>
        
        <div class="exercise">
            <h4>练习 7.1：实现动态利率调整</h4>
            <p>设计一个根据市场条件自动调整的利率模型，要求：</p>
            <ul>
                <li>集成外部市场数据（如联邦基金利率）</li>
                <li>实现PID控制器进行平滑调整</li>
                <li>设置利率变化速度限制</li>
                <li>考虑极端市场条件的断路器</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-1')">查看参考答案</button>
            <div id="answer7-1" class="answer">
                <pre><code class="language-solidity">contract DynamicRateModel {
    using SafeMath for uint256;
    
    // PID控制器参数
    uint256 public constant Kp = 1e16;  // 比例系数
    uint256 public constant Ki = 1e15;  // 积分系数
    uint256 public constant Kd = 5e15;  // 微分系数
    
    // 市场数据
    IPriceOracle public marketDataOracle;
    uint256 public targetUtilization = 0.85e18;
    
    // 状态变量
    uint256 public lastError;
    uint256 public integral;
    uint256 public lastUpdateTime;
    
    // 速率限制
    uint256 public constant MAX_RATE_CHANGE = 0.001e18;  // 每次最多0.1%
    uint256 public constant UPDATE_INTERVAL = 1 hours;
    
    function updateInterestRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) external returns (uint256) {
        require(
            block.timestamp >= lastUpdateTime + UPDATE_INTERVAL,
            "Too soon to update"
        );
        
        uint256 utilization = borrows.mul(1e18).div(
            cash.add(borrows).sub(reserves)
        );
        
        // PID计算
        int256 error = int256(targetUtilization) - int256(utilization);
        integral = integral.add(uint256(error > 0 ? error : -error));
        int256 derivative = error - int256(lastError);
        
        int256 output = int256(Kp).mul(error).div(1e18)
            .add(int256(Ki).mul(int256(integral)).div(1e18))
            .add(int256(Kd).mul(derivative).div(1e18));
        
        // 获取市场基准利率
        uint256 marketRate = marketDataOracle.getMarketRate();
        uint256 newRate = uint256(int256(marketRate) + output);
        
        // 应用速率限制
        uint256 currentRate = getCurrentRate();
        if (newRate > currentRate) {
            newRate = Math.min(
                newRate,
                currentRate.add(MAX_RATE_CHANGE)
            );
        } else {
            newRate = Math.max(
                newRate,
                currentRate.sub(MAX_RATE_CHANGE)
            );
        }
        
        // 更新状态
        lastError = uint256(error > 0 ? error : -error);
        lastUpdateTime = block.timestamp;
        
        return newRate;
    }
}</code></pre>
            </div>
        </div>

        <div class="exercise">
            <h4>练习 7.2：防御闪电贷攻击</h4>
            <p>实现一个能够抵御闪电贷价格操纵的借贷协议：</p>
            <ul>
                <li>使用TWAP（时间加权平均价格）</li>
                <li>实现延迟价格更新机制</li>
                <li>添加异常检测逻辑</li>
                <li>设计紧急暂停机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-2')">查看参考答案</button>
            <div id="answer7-2" class="answer">
                <pre><code class="language-solidity">contract FlashLoanResistantLending {
    using FixedPoint for *;
    
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 cumulativePrice;
        uint256 priceCount;
    }
    
    mapping(address => PriceData) public priceHistory;
    uint256 public constant TWAP_PERIOD = 30 minutes;
    uint256 public constant PRICE_DEVIATION_THRESHOLD = 0.1e18;  // 10%
    
    modifier checkPriceManipulation(address asset) {
        uint256 currentPrice = IPriceOracle(oracle).getPrice(asset);
        uint256 twapPrice = getTWAPPrice(asset);
        
        uint256 deviation = currentPrice > twapPrice
            ? currentPrice.sub(twapPrice).mul(1e18).div(twapPrice)
            : twapPrice.sub(currentPrice).mul(1e18).div(twapPrice);
            
        require(
            deviation < PRICE_DEVIATION_THRESHOLD,
            "Price manipulation detected"
        );
        _;
    }
    
    function getTWAPPrice(address asset) public view returns (uint256) {
        PriceData memory data = priceHistory[asset];
        require(data.priceCount > 0, "No price history");
        
        uint256 timeElapsed = block.timestamp - data.timestamp;
        if (timeElapsed < TWAP_PERIOD) {
            return data.price;  // Not enough time passed
        }
        
        return data.cumulativePrice.div(data.priceCount);
    }
    
    function updatePrice(address asset) external {
        uint256 currentPrice = IPriceOracle(oracle).getPrice(asset);
        PriceData storage data = priceHistory[asset];
        
        // 累积价格用于TWAP计算
        data.cumulativePrice = data.cumulativePrice.add(currentPrice);
        data.priceCount = data.priceCount.add(1);
        
        // 重置TWAP窗口
        if (block.timestamp - data.timestamp > TWAP_PERIOD) {
            data.price = data.cumulativePrice.div(data.priceCount);
            data.cumulativePrice = currentPrice;
            data.priceCount = 1;
            data.timestamp = block.timestamp;
        }
    }
    
    function liquidate(
        address borrower,
        address collateralAsset,
        address debtAsset
    ) external checkPriceManipulation(collateralAsset) {
        // 使用TWAP价格进行清算计算
        uint256 collateralPrice = getTWAPPrice(collateralAsset);
        uint256 debtPrice = getTWAPPrice(debtAsset);
        
        // 清算逻辑...
    }
}</code></pre>
            </div>
        </div>

        <div class="exercise">
            <h4>练习 7.3：实现隔离池机制</h4>
            <p>设计一个隔离池系统，将高风险资产与主池隔离：</p>
            <ul>
                <li>实现多池架构</li>
                <li>设计跨池借贷限制</li>
                <li>实现风险评级系统</li>
                <li>添加池间资金调配机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-3')">查看参考答案</button>
            <div id="answer7-3" class="answer">
                <pre><code class="language-solidity">contract IsolatedLendingPools {
    enum RiskTier { STABLE, MEDIUM, HIGH, ISOLATED }
    
    struct Pool {
        mapping(address => uint256) reserves;
        mapping(address => RiskTier) assetRiskTier;
        uint256 totalLiquidity;
        uint256 totalBorrowed;
        bool crossPoolBorrowingEnabled;
    }
    
    mapping(uint256 => Pool) public pools;
    mapping(address => uint256) public userPrimaryPool;
    mapping(address => mapping(uint256 => bool)) public userPoolAccess;
    
    // 风险参数
    mapping(RiskTier => uint256) public maxLTV;
    mapping(RiskTier => uint256) public liquidationThreshold;
    
    constructor() {
        maxLTV[RiskTier.STABLE] = 0.9e18;  // 90%
        maxLTV[RiskTier.MEDIUM] = 0.75e18;  // 75%
        maxLTV[RiskTier.HIGH] = 0.5e18;  // 50%
        maxLTV[RiskTier.ISOLATED] = 0.3e18;  // 30%
        
        liquidationThreshold[RiskTier.STABLE] = 0.95e18;
        liquidationThreshold[RiskTier.MEDIUM] = 0.85e18;
        liquidationThreshold[RiskTier.HIGH] = 0.7e18;
        liquidationThreshold[RiskTier.ISOLATED] = 0.5e18;
    }
    
    function createIsolatedPool(
        address asset,
        RiskTier riskTier
    ) external onlyOwner returns (uint256 poolId) {
        poolId = uint256(keccak256(abi.encodePacked(asset, block.timestamp)));
        Pool storage pool = pools[poolId];
        pool.assetRiskTier[asset] = riskTier;
        pool.crossPoolBorrowingEnabled = (riskTier != RiskTier.ISOLATED);
    }
    
    function depositToPool(
        uint256 poolId,
        address asset,
        uint256 amount
    ) external {
        Pool storage pool = pools[poolId];
        require(pool.assetRiskTier[asset] != RiskTier(0), "Asset not in pool");
        
        IERC20(asset).transferFrom(msg.sender, address(this), amount);
        pool.reserves[asset] += amount;
        pool.totalLiquidity += amount;
        
        userPoolAccess[msg.sender][poolId] = true;
    }
    
    function borrowFromPool(
        uint256 poolId,
        address asset,
        uint256 amount
    ) external {
        Pool storage pool = pools[poolId];
        require(userPoolAccess[msg.sender][poolId], "No pool access");
        
        // 检查隔离池限制
        if (pool.assetRiskTier[asset] == RiskTier.ISOLATED) {
            require(
                userPrimaryPool[msg.sender] == 0 || 
                userPrimaryPool[msg.sender] == poolId,
                "Cannot borrow from multiple isolated pools"
            );
            userPrimaryPool[msg.sender] = poolId;
        }
        
        // 计算允许借款额度
        uint256 collateralValue = getUserCollateralValue(msg.sender, poolId);
        uint256 maxBorrow = collateralValue.mul(
            maxLTV[pool.assetRiskTier[asset]]
        ).div(1e18);
        
        require(amount <= maxBorrow, "Exceeds borrow limit");
        
        pool.reserves[asset] -= amount;
        pool.totalBorrowed += amount;
        IERC20(asset).transfer(msg.sender, amount);
    }
    
    // 跨池资金调配
    function rebalancePools(
        uint256 fromPoolId,
        uint256 toPoolId,
        address asset,
        uint256 amount
    ) external onlyOwner {
        Pool storage fromPool = pools[fromPoolId];
        Pool storage toPool = pools[toPoolId];
        
        require(
            fromPool.assetRiskTier[asset] <= toPool.assetRiskTier[asset],
            "Cannot move to higher risk pool"
        );
        
        fromPool.reserves[asset] -= amount;
        toPool.reserves[asset] += amount;
    }
}</code></pre>
            </div>
        </div>

        <div class="exercise">
            <h4>练习 7.4：实现收益率优化器</h4>
            <p>创建一个自动优化稳定币收益的策略合约：</p>
            <ul>
                <li>比较多个借贷协议的利率</li>
                <li>自动迁移资金到最高收益协议</li>
                <li>考虑Gas成本和滑点</li>
                <li>实现紧急撤出机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-4')">查看参考答案</button>
            <div id="answer7-4" class="answer">
                <pre><code class="language-solidity">contract YieldOptimizer {
    using SafeERC20 for IERC20;
    
    struct Strategy {
        address protocol;
        uint256 allocation;
        uint256 lastAPY;
        bool active;
    }
    
    IERC20 public stablecoin;
    Strategy[] public strategies;
    uint256 public rebalanceThreshold = 0.005e18;  // 0.5%
    uint256 public minRebalanceInterval = 6 hours;
    uint256 public lastRebalanceTime;
    
    // Gas成本考虑
    uint256 public gasPrice = 20 gwei;
    uint256 public estimatedGasPerStrategy = 200000;
    
    function findOptimalAllocation() public view returns (
        uint256[] memory allocations,
        uint256 expectedAPY
    ) {
        uint256 strategyCount = strategies.length;
        allocations = new uint256[](strategyCount);
        
        // 获取当前APY
        uint256[] memory apys = new uint256[](strategyCount);
        for (uint256 i = 0; i < strategyCount; i++) {
            if (strategies[i].active) {
                apys[i] = ILendingProtocol(strategies[i].protocol).getAPY();
            }
        }
        
        // 简单策略：分配到最高APY
        uint256 maxAPY = 0;
        uint256 maxIndex = 0;
        for (uint256 i = 0; i < strategyCount; i++) {
            if (apys[i] > maxAPY) {
                maxAPY = apys[i];
                maxIndex = i;
            }
        }
        
        // 考虑Gas成本
        uint256 totalBalance = stablecoin.balanceOf(address(this));
        uint256 rebalanceCost = gasPrice.mul(estimatedGasPerStrategy).mul(2);
        uint256 minProfitableAmount = rebalanceCost.mul(365 days).div(maxAPY);
        
        if (totalBalance > minProfitableAmount) {
            allocations[maxIndex] = totalBalance;
            expectedAPY = maxAPY;
        }
        
        return (allocations, expectedAPY);
    }
    
    function rebalance() external {
        require(
            block.timestamp >= lastRebalanceTime + minRebalanceInterval,
            "Too soon to rebalance"
        );
        
        (uint256[] memory newAllocations, uint256 newAPY) = findOptimalAllocation();
        
        // 检查是否值得重新平衡
        uint256 currentAPY = calculateCurrentAPY();
        uint256 improvement = newAPY > currentAPY
            ? newAPY.sub(currentAPY).mul(1e18).div(currentAPY)
            : 0;
            
        require(improvement > rebalanceThreshold, "Not worth rebalancing");
        
        // 执行重新平衡
        _executeRebalance(newAllocations);
        lastRebalanceTime = block.timestamp;
    }
    
    function _executeRebalance(uint256[] memory newAllocations) internal {
        // 1. 撤出所有资金
        for (uint256 i = 0; i < strategies.length; i++) {
            if (strategies[i].allocation > 0) {
                ILendingProtocol(strategies[i].protocol).withdrawAll();
                strategies[i].allocation = 0;
            }
        }
        
        // 2. 重新分配
        uint256 balance = stablecoin.balanceOf(address(this));
        for (uint256 i = 0; i < strategies.length; i++) {
            if (newAllocations[i] > 0) {
                uint256 amount = balance.mul(newAllocations[i]).div(balance);
                stablecoin.safeApprove(strategies[i].protocol, amount);
                ILendingProtocol(strategies[i].protocol).deposit(amount);
                strategies[i].allocation = amount;
            }
        }
    }
    
    // 紧急撤出
    function emergencyWithdraw() external onlyOwner {
        for (uint256 i = 0; i < strategies.length; i++) {
            if (strategies[i].allocation > 0) {
                try ILendingProtocol(strategies[i].protocol).withdrawAll() {
                    strategies[i].allocation = 0;
                } catch {
                    // 记录失败但继续
                    emit WithdrawFailed(strategies[i].protocol);
                }
            }
        }
        
        uint256 balance = stablecoin.balanceOf(address(this));
        stablecoin.safeTransfer(owner(), balance);
    }
}</code></pre>
            </div>
        </div>

        <h3>术语表</h3>
        <table class="reference-table">
            <tr>
                <th>术语</th>
                <th>定义</th>
                <th>重要性</th>
            </tr>
            <tr>
                <td>cToken</td>
                <td>Compound协议的计息代币，代表在协议中的存款份额</td>
                <td>核心机制，实现利息自动累积</td>
            </tr>
            <tr>
                <td>利用率（Utilization Rate）</td>
                <td>借出资金占总资金池的比例</td>
                <td>决定利率的关键参数</td>
            </tr>
            <tr>
                <td>跳跃率模型（Jump Rate Model）</td>
                <td>在特定利用率阈值后利率急剧上升的模型</td>
                <td>防止流动性枯竭</td>
            </tr>
            <tr>
                <td>闪电贷（Flash Loan）</td>
                <td>在同一交易内借入和归还的无抵押贷款</td>
                <td>套利和清算的重要工具</td>
            </tr>
            <tr>
                <td>健康因子（Health Factor）</td>
                <td>抵押品价值与债务价值的加权比率</td>
                <td>触发清算的关键指标</td>
            </tr>
            <tr>
                <td>准备金率（Reserve Factor）</td>
                <td>利息收入中分配给协议金库的比例</td>
                <td>协议可持续性的保障</td>
            </tr>
            <tr>
                <td>E-Mode</td>
                <td>Aave的效率模式，为相关资产提供更高的资本效率</td>
                <td>稳定币对的优化机制</td>
            </tr>
            <tr>
                <td>隔离模式（Isolation Mode）</td>
                <td>将高风险资产隔离，限制其作为抵押品的使用</td>
                <td>风险管理创新</td>
            </tr>
            <tr>
                <td>TWAP</td>
                <td>时间加权平均价格，抵御价格操纵</td>
                <td>闪电贷攻击防御</td>
            </tr>
            <tr>
                <td>收益聚合器（Yield Aggregator）</td>
                <td>自动在不同协议间优化收益的智能合约</td>
                <td>DeFi组合性的体现</td>
            </tr>
        </table>
    </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script>
        function toggleAnswer(answerId) {
            const answerElement = document.getElementById(answerId);
            answerElement.classList.toggle('show');
        }
        
        function toggleCode(btn) {
            const codeContent = btn.parentElement.nextElementSibling;
            const isCollapsed = codeContent.classList.contains('collapsed');
            
            if (isCollapsed) {
                codeContent.classList.remove('collapsed');
                btn.textContent = '折叠';
            } else {
                codeContent.classList.add('collapsed');
                btn.textContent = '展开';
            }
        }
        
        // 导航栏切换
        function toggleNav() {
            const navMenu = document.getElementById('navMenu');
            const navToggle = document.querySelector('.nav-toggle');
            navMenu.classList.toggle('active');
            navToggle.classList.toggle('active');
        }
        
        // 监听滚动，更新活动导航项
        function updateActiveNav() {
            const sections = document.querySelectorAll('.chapter');
            const navLinks = document.querySelectorAll('.nav-link');
            const chapterLinks = document.querySelectorAll('.chapter-list a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
            
            chapterLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        }
        
        // Initialize all code blocks
        document.addEventListener('DOMContentLoaded', function() {
            // Convert existing code blocks to new structure
            const codeBlocks = document.querySelectorAll('.code-block');
            codeBlocks.forEach((block, index) => {
                // Skip if already has the new structure
                if (block.querySelector('.code-header')) return;
                
                // Get the code content
                const codeText = block.textContent || block.innerText;
                
                // Determine language from code content
                let language = 'javascript';
                if (codeText.includes('pragma solidity') || codeText.includes('contract ')) {
                    language = 'solidity';
                } else if (codeText.includes('npm ') || codeText.includes('npx ')) {
                    language = 'bash';
                } else if (codeText.includes('import pandas') || codeText.includes('def ')) {
                    language = 'python';
                }
                
                // Create new structure
                block.innerHTML = `
                    <div class="code-header">
                        <span class="code-language">${language}</span>
                        <button class="code-toggle" onclick="toggleCode(this)">展开</button>
                    </div>
                    <div class="code-content collapsed">
                        <pre><code class="language-${language}">${codeText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>
                    </div>
                `;
            });
            
            // Apply syntax highlighting
            Prism.highlightAll();
            
            // 添加滚动监听
            window.addEventListener('scroll', updateActiveNav);
            updateActiveNav();
            
            // 点击导航链接后关闭移动端菜单
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => {
                link.addEventListener('click', () => {
                    const navMenu = document.getElementById('navMenu');
                    const navToggle = document.querySelector('.nav-toggle');
                    navMenu.classList.remove('active');
                    navToggle.classList.remove('active');
                });
            });
        });
    </script>
</body>
</html>