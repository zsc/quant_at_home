<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第十三章：稳定币生态系统集成 - 区块链稳定币教程</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">稳定币教程</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">☰</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">首页</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">引言</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">章节</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">第1章：区块链基础</a>
                        <a href="chapter2.html" class="dropdown-item">第2章：稳定币分类</a>
                        <a href="chapter3.html" class="dropdown-item">第3章：ERC-20标准</a>
                        <a href="chapter4.html" class="dropdown-item">第4章：抵押型设计</a>
                        <a href="chapter5.html" class="dropdown-item">第5章：数学模型</a>
                        <a href="chapter6.html" class="dropdown-item">第6章：AMM集成</a>
                        <a href="chapter7.html" class="dropdown-item">第7章：借贷协议</a>
                        <a href="chapter8.html" class="dropdown-item">第8章：收益策略</a>
                        <a href="chapter9.html" class="dropdown-item">第9章：智能合约安全</a>
                        <a href="chapter10.html" class="dropdown-item">第10章：经济攻击</a>
                        <a href="chapter11.html" class="dropdown-item">第11章：未来方向</a>
                        <a href="chapter12.html" class="dropdown-item">第12章：生产部署</a>
                        <a href="chapter13.html" class="dropdown-item">第13章：生态集成</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="#resources" class="nav-link">资源</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- 头部 -->
    <header id="top">
        <div class="container">
            <h1>第十三章：稳定币生态系统集成</h1>
        </div>
    </header>
    
    <!-- 主要内容 -->
    <div class="container">
        <div class="chapter">
<h2>第十三章：稳定币生态系统集成</h2>
        
        <div class="chapter-intro">
            <p>稳定币的成功不仅取决于其自身设计，更依赖于与整个DeFi生态系统的深度集成。本章探讨稳定币如何与钱包、支付网关、跨链桥、聚合器等基础设施协同工作，构建完整的金融服务生态。</p>
        </div>

        <h3 id="wallet-integration">13.1 钱包与用户界面集成</h3>
        
        <div class="theory-section">
            <h4>13.1.1 钱包标准与集成协议</h4>
            
            <h5>EIP-3085：添加以太坊链</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">钱包链配置标准 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// 钱包集成SDK
class WalletIntegrationSDK {
    private provider: any;
    private chainConfigs: Map<number, ChainConfig> = new Map();
    
    constructor() {
        this.initializeChainConfigs();
    }
    
    // 检测并连接钱包
    async connectWallet(): Promise<WalletConnection> {
        // 检测注入的provider
        if (typeof window.ethereum !== 'undefined') {
            this.provider = window.ethereum;
            
            // 请求账户访问
            const accounts = await this.provider.request({ 
                method: 'eth_requestAccounts' 
            });
            
            // 获取链ID
            const chainId = await this.provider.request({ 
                method: 'eth_chainId' 
            });
            
            return {
                address: accounts[0],
                chainId: parseInt(chainId, 16),
                provider: this.provider
            };
        } else {
            throw new Error('No wallet detected');
        }
    }
    
    // 添加自定义链（用于新链上的稳定币）
    async addCustomChain(chainId: number): Promise<void> {
        const config = this.chainConfigs.get(chainId);
        if (!config) throw new Error(`Chain ${chainId} not configured`);
        
        try {
            await this.provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                    chainId: `0x${chainId.toString(16)}`,
                    chainName: config.name,
                    nativeCurrency: config.nativeCurrency,
                    rpcUrls: config.rpcUrls,
                    blockExplorerUrls: config.blockExplorerUrls
                }]
            });
        } catch (error) {
            if (error.code === 4902) {
                throw new Error('User rejected chain addition');
            }
            throw error;
        }
    }
    
    // 添加代币到钱包
    async addTokenToWallet(tokenConfig: TokenConfig): Promise<boolean> {
        try {
            const wasAdded = await this.provider.request({
                method: 'wallet_watchAsset',
                params: {
                    type: 'ERC20',
                    options: {
                        address: tokenConfig.address,
                        symbol: tokenConfig.symbol,
                        decimals: tokenConfig.decimals,
                        image: tokenConfig.logoURI
                    }
                }
            });
            return wasAdded;
        } catch (error) {
            console.error('Error adding token:', error);
            return false;
        }
    }
    
    // 高级签名功能（EIP-712）
    async signTypedData(domain: EIP712Domain, types: any, value: any): Promise<string> {
        const msgParams = {
            domain,
            message: value,
            primaryType: 'Permit',
            types: {
                EIP712Domain: [
                    { name: 'name', type: 'string' },
                    { name: 'version', type: 'string' },
                    { name: 'chainId', type: 'uint256' },
                    { name: 'verifyingContract', type: 'address' }
                ],
                ...types
            }
        };
        
        const accounts = await this.provider.request({ 
            method: 'eth_requestAccounts' 
        });
        
        const signature = await this.provider.request({
            method: 'eth_signTypedData_v4',
            params: [accounts[0], JSON.stringify(msgParams)]
        });
        
        return signature;
    }
}</code></pre>
                </div>
            </div>
            
            <h5>账户抽象（ERC-4337）集成</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">智能钱包集成 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 支持账户抽象的稳定币
contract AACompatibleStablecoin is ERC20, IAccount {
    using UserOperationLib for UserOperation;
    
    // 账户抽象入口点
    IEntryPoint private immutable entryPoint;
    
    // 支付主合约
    mapping(address => bool) public paymasters;
    
    constructor(IEntryPoint _entryPoint) ERC20("AA Stablecoin", "AAUSD") {
        entryPoint = _entryPoint;
    }
    
    // 验证用户操作
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external override returns (uint256 validationData) {
        require(msg.sender == address(entryPoint), "Only EntryPoint");
        
        // 验证签名
        bytes32 hash = userOpHash.toEthSignedMessageHash();
        address signer = hash.recover(userOp.signature);
        
        // 检查是否是授权的操作
        if (!isValidSigner(signer)) {
            return SIG_VALIDATION_FAILED;
        }
        
        // 如果需要，从账户转移资金到EntryPoint
        if (missingAccountFunds > 0) {
            _transfer(address(this), msg.sender, missingAccountFunds);
        }
        
        return 0; // 验证成功
    }
    
    // 执行用户操作
    function execute(
        address dest,
        uint256 value,
        bytes calldata func
    ) external {
        require(msg.sender == address(entryPoint), "Only EntryPoint");
        
        if (value > 0) {
            require(address(this).balance >= value, "Insufficient balance");
        }
        
        (bool success, bytes memory result) = dest.call{value: value}(func);
        if (!success) {
            assembly {
                revert(add(result, 32), mload(result))
            }
        }
    }
    
    // 支持ERC-4337支付主合约
    function addPaymaster(address paymaster) external onlyOwner {
        paymasters[paymaster] = true;
    }
    
    // 允许支付主合约代付gas费
    function sponsorUserOperation(
        UserOperation calldata userOp
    ) external view returns (bool) {
        return paymasters[userOp.paymaster];
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>13.1.2 用户体验优化</h4>
            
            <h5>批量交易与元交易</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">元交易实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 支持元交易的稳定币（用户无需持有ETH）
contract MetaTransactionStablecoin is ERC20, EIP712 {
    using ECDSA for bytes32;
    
    struct MetaTransaction {
        uint256 nonce;
        address from;
        address to;
        uint256 value;
        bytes data;
        uint256 gasLimit;
        uint256 gasPrice;
        uint256 deadline;
    }
    
    mapping(address => uint256) public nonces;
    mapping(address => bool) public trustedForwarders;
    
    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(
        "MetaTransaction(uint256 nonce,address from,address to,uint256 value,bytes data,uint256 gasLimit,uint256 gasPrice,uint256 deadline)"
    );
    
    event MetaTransactionExecuted(
        address indexed from,
        address indexed to,
        address indexed relayer,
        uint256 value
    );
    
    function executeMetaTransaction(
        MetaTransaction memory metaTx,
        bytes memory signature
    ) public returns (bytes memory) {
        require(block.timestamp <= metaTx.deadline, "Transaction expired");
        require(nonces[metaTx.from] == metaTx.nonce, "Invalid nonce");
        
        // 验证签名
        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
            META_TRANSACTION_TYPEHASH,
            metaTx.nonce,
            metaTx.from,
            metaTx.to,
            metaTx.value,
            keccak256(metaTx.data),
            metaTx.gasLimit,
            metaTx.gasPrice,
            metaTx.deadline
        )));
        
        address signer = digest.recover(signature);
        require(signer == metaTx.from, "Invalid signature");
        
        // 更新nonce
        nonces[metaTx.from]++;
        
        // 执行交易
        (bool success, bytes memory returnData) = address(this).call(
            abi.encodePacked(metaTx.data, metaTx.from)
        );
        require(success, "Meta transaction failed");
        
        // 支付中继费用（从用户的稳定币余额中扣除）
        uint256 relayerFee = calculateRelayerFee(metaTx.gasLimit, metaTx.gasPrice);
        _transfer(metaTx.from, msg.sender, relayerFee);
        
        emit MetaTransactionExecuted(metaTx.from, metaTx.to, msg.sender, metaTx.value);
        
        return returnData;
    }
    
    // 批量操作支持
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        require(recipients.length == amounts.length, "Length mismatch");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            _transfer(_msgSender(), recipients[i], amounts[i]);
        }
    }
    
    // 获取实际的消息发送者（支持元交易）
    function _msgSender() internal view override returns (address) {
        if (msg.sender == address(this)) {
            bytes memory array = msg.data;
            uint256 index = msg.data.length;
            assembly {
                return := and(
                    mload(add(array, index)),
                    0xffffffffffffffffffffffffffffffffffffffff
                )
            }
        } else {
            return super._msgSender();
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>移动端优化</h5>
            <div class="info-box">
                <p><strong>移动钱包集成最佳实践：</strong></p>
                <ul>
                    <li><strong>WalletConnect v2</strong>：支持多链连接</li>
                    <li><strong>深度链接</strong>：直接唤起钱包应用</li>
                    <li><strong>二维码支付</strong>：线下场景支持</li>
                    <li><strong>推送通知</strong>：交易状态实时更新</li>
                    <li><strong>离线签名</strong>：冷钱包支持</li>
                </ul>
            </div>
        </div>
        
        <h3 id="payment-gateway">13.2 支付网关与商户集成</h3>
        
        <div class="theory-section">
            <h4>13.2.1 支付处理系统</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">商户支付网关 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// 稳定币支付网关服务
class StablecoinPaymentGateway {
    private merchants: Map<string, MerchantConfig> = new Map();
    private payments: Map<string, Payment> = new Map();
    
    // 创建支付请求
    async createPaymentRequest(params: PaymentRequestParams): Promise<PaymentRequest> {
        const merchant = this.merchants.get(params.merchantId);
        if (!merchant) throw new Error('Invalid merchant');
        
        const paymentId = generatePaymentId();
        const paymentAddress = await this.generatePaymentAddress(paymentId);
        
        const request: PaymentRequest = {
            id: paymentId,
            merchantId: params.merchantId,
            amount: params.amount,
            currency: params.currency,
            stablecoin: params.acceptedStablecoins || ['USDC', 'USDT', 'DAI'],
            paymentAddress: paymentAddress,
            memo: params.memo,
            createdAt: Date.now(),
            expiresAt: Date.now() + (params.ttl || 3600000), // 1小时默认
            status: 'pending',
            callbackUrl: params.callbackUrl,
            metadata: params.metadata
        };
        
        // 生成支付链接和二维码
        request.paymentUrl = this.generatePaymentUrl(request);
        request.qrCode = await this.generateQRCode(request.paymentUrl);
        
        this.payments.set(paymentId, request);
        
        // 开始监控支付
        this.monitorPayment(paymentId);
        
        return request;
    }
    
    // 监控链上支付
    private async monitorPayment(paymentId: string) {
        const payment = this.payments.get(paymentId);
        if (!payment) return;
        
        const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
        
        // 监听转账事件
        const stablecoinContracts = this.getStablecoinContracts(payment.stablecoin);
        
        for (const contract of stablecoinContracts) {
            const filter = contract.filters.Transfer(null, payment.paymentAddress);
            
            contract.on(filter, async (from, to, amount, event) => {
                // 验证支付金额
                const expectedAmount = ethers.parseUnits(
                    payment.amount.toString(),
                    await contract.decimals()
                );
                
                if (amount >= expectedAmount) {
                    // 更新支付状态
                    payment.status = 'confirmed';
                    payment.txHash = event.transactionHash;
                    payment.paidAmount = amount;
                    payment.paidToken = await contract.symbol();
                    payment.payer = from;
                    payment.confirmedAt = Date.now();
                    
                    // 通知商户
                    await this.notifyMerchant(payment);
                    
                    // 自动转换和结算
                    if (payment.autoConvert) {
                        await this.convertAndSettle(payment);
                    }
                }
            });
        }
        
        // 超时处理
        setTimeout(() => {
            if (payment.status === 'pending') {
                payment.status = 'expired';
                this.notifyMerchant(payment);
            }
        }, payment.expiresAt - Date.now());
    }
    
    // 自动转换和结算
    private async convertAndSettle(payment: Payment) {
        const merchant = this.merchants.get(payment.merchantId);
        
        // 通过聚合器获取最佳兑换路径
        const swapRoute = await this.findBestSwapRoute(
            payment.paidToken,
            merchant.settlementCurrency,
            payment.paidAmount
        );
        
        // 执行兑换
        const swapResult = await this.executeSwap(swapRoute);
        
        // 结算到商户账户
        await this.settleMerchant(
            merchant,
            swapResult.outputAmount,
            payment
        );
    }
    
    // Webhook通知系统
    private async notifyMerchant(payment: Payment) {
        const merchant = this.merchants.get(payment.merchantId);
        
        const notification = {
            event: payment.status === 'confirmed' ? 'payment.confirmed' : 'payment.expired',
            paymentId: payment.id,
            merchantId: payment.merchantId,
            amount: payment.amount,
            currency: payment.currency,
            paidAmount: payment.paidAmount,
            paidToken: payment.paidToken,
            txHash: payment.txHash,
            timestamp: Date.now(),
            signature: this.signWebhook(payment)
        };
        
        // 重试机制
        let retries = 0;
        while (retries < 3) {
            try {
                const response = await fetch(payment.callbackUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Signature': notification.signature
                    },
                    body: JSON.stringify(notification)
                });
                
                if (response.ok) break;
            } catch (error) {
                retries++;
                await new Promise(resolve => setTimeout(resolve, 1000 * retries));
            }
        }
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>13.2.2 结算与清算系统</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">批量结算合约 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 商户结算合约
contract MerchantSettlement is Ownable, Pausable {
    using SafeERC20 for IERC20;
    
    struct Settlement {
        address merchant;
        address token;
        uint256 amount;
        uint256 fee;
        uint256 timestamp;
        bytes32 batchId;
        bool processed;
    }
    
    struct MerchantAccount {
        address settlementAddress;
        uint256 minSettlementAmount;
        uint256 settlementDelay;
        uint256 feeRate; // 基点
        mapping(address => uint256) balances;
        uint256 lastSettlement;
    }
    
    mapping(address => MerchantAccount) public merchants;
    mapping(bytes32 => Settlement[]) public settlementBatches;
    
    uint256 public constant FEE_DENOMINATOR = 10000;
    address public feeCollector;
    
    event SettlementQueued(address indexed merchant, address token, uint256 amount);
    event BatchSettlementExecuted(bytes32 indexed batchId, uint256 count);
    
    // 累积商户余额
    function creditMerchant(
        address merchant,
        address token,
        uint256 amount
    ) external onlyAuthorized {
        require(merchants[merchant].settlementAddress != address(0), "Merchant not registered");
        
        merchants[merchant].balances[token] += amount;
        
        // 检查是否达到自动结算阈值
        if (merchants[merchant].balances[token] >= merchants[merchant].minSettlementAmount) {
            _queueSettlement(merchant, token);
        }
    }
    
    // 批量结算执行
    function executeBatchSettlement(bytes32 batchId) external onlyOwner {
        Settlement[] storage settlements = settlementBatches[batchId];
        require(settlements.length > 0, "Empty batch");
        
        uint256 totalGas = gasleft();
        
        for (uint256 i = 0; i < settlements.length; i++) {
            if (settlements[i].processed) continue;
            
            // 检查延迟期
            MerchantAccount storage account = merchants[settlements[i].merchant];
            require(
                block.timestamp >= account.lastSettlement + account.settlementDelay,
                "Settlement delay not met"
            );
            
            // 计算费用
            uint256 fee = (settlements[i].amount * account.feeRate) / FEE_DENOMINATOR;
            uint256 netAmount = settlements[i].amount - fee;
            
            // 执行转账
            IERC20(settlements[i].token).safeTransfer(
                account.settlementAddress,
                netAmount
            );
            
            if (fee > 0) {
                IERC20(settlements[i].token).safeTransfer(feeCollector, fee);
            }
            
            // 更新状态
            settlements[i].processed = true;
            settlements[i].fee = fee;
            account.balances[settlements[i].token] = 0;
            account.lastSettlement = block.timestamp;
            
            // Gas优化：如果剩余gas不足，停止执行
            if (gasleft() < totalGas / 10) break;
        }
        
        emit BatchSettlementExecuted(batchId, settlements.length);
    }
    
    // 紧急提取（需要多签）
    function emergencyWithdraw(
        address merchant,
        address token
    ) external onlyRole(EMERGENCY_ROLE) {
        uint256 balance = merchants[merchant].balances[token];
        require(balance > 0, "No balance");
        
        merchants[merchant].balances[token] = 0;
        
        IERC20(token).safeTransfer(
            merchants[merchant].settlementAddress,
            balance
        );
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h3 id="cross-chain-integration">13.3 跨链桥接与互操作性</h3>
        
        <div class="theory-section">
            <h4>13.3.1 跨链桥接协议</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">通用跨链桥实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 跨链桥接合约（源链）
contract CrossChainBridge is Ownable, Pausable {
    using SafeERC20 for IERC20;
    
    struct BridgeRequest {
        address token;
        address sender;
        address recipient;
        uint256 amount;
        uint256 targetChainId;
        uint256 nonce;
        uint256 timestamp;
        bytes32 requestHash;
    }
    
    // 支持的链和代币映射
    mapping(uint256 => mapping(address => address)) public tokenMappings;
    mapping(bytes32 => bool) public processedRequests;
    mapping(address => uint256) public nonces;
    
    // 验证者集合
    mapping(address => bool) public validators;
    uint256 public requiredValidations;
    mapping(bytes32 => mapping(address => bool)) public validations;
    mapping(bytes32 => uint256) public validationCounts;
    
    // 流动性池
    mapping(address => uint256) public liquidity;
    
    event BridgeRequestCreated(
        bytes32 indexed requestHash,
        address indexed sender,
        uint256 targetChainId,
        uint256 amount
    );
    
    event BridgeRequestValidated(
        bytes32 indexed requestHash,
        address indexed validator
    );
    
    event BridgeRequestExecuted(
        bytes32 indexed requestHash,
        address indexed recipient,
        uint256 amount
    );
    
    // 发起跨链转账
    function bridge(
        address token,
        uint256 amount,
        uint256 targetChainId,
        address recipient
    ) external whenNotPaused {
        require(tokenMappings[targetChainId][token] != address(0), "Unsupported token/chain");
        require(amount > 0, "Invalid amount");
        
        // 锁定代币
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        
        // 创建桥接请求
        uint256 nonce = nonces[msg.sender]++;
        bytes32 requestHash = keccak256(abi.encodePacked(
            token,
            msg.sender,
            recipient,
            amount,
            targetChainId,
            nonce,
            block.timestamp
        ));
        
        BridgeRequest memory request = BridgeRequest({
            token: token,
            sender: msg.sender,
            recipient: recipient,
            amount: amount,
            targetChainId: targetChainId,
            nonce: nonce,
            timestamp: block.timestamp,
            requestHash: requestHash
        });
        
        emit BridgeRequestCreated(requestHash, msg.sender, targetChainId, amount);
    }
    
    // 验证者签名验证
    function validateBridgeRequest(
        BridgeRequest calldata request,
        bytes[] calldata signatures
    ) external {
        require(validators[msg.sender], "Not a validator");
        require(!validations[request.requestHash][msg.sender], "Already validated");
        
        // 验证请求哈希
        bytes32 calculatedHash = keccak256(abi.encodePacked(
            request.token,
            request.sender,
            request.recipient,
            request.amount,
            request.targetChainId,
            request.nonce,
            request.timestamp
        ));
        require(calculatedHash == request.requestHash, "Invalid request hash");
        
        // 记录验证
        validations[request.requestHash][msg.sender] = true;
        validationCounts[request.requestHash]++;
        
        emit BridgeRequestValidated(request.requestHash, msg.sender);
        
        // 如果达到所需验证数，执行桥接
        if (validationCounts[request.requestHash] >= requiredValidations) {
            _executeBridgeRequest(request);
        }
    }
    
    // 执行跨链释放（目标链）
    function _executeBridgeRequest(BridgeRequest memory request) private {
        require(!processedRequests[request.requestHash], "Already processed");
        processedRequests[request.requestHash] = true;
        
        // 从流动性池释放代币
        address targetToken = tokenMappings[block.chainid][request.token];
        require(liquidity[targetToken] >= request.amount, "Insufficient liquidity");
        
        liquidity[targetToken] -= request.amount;
        IERC20(targetToken).safeTransfer(request.recipient, request.amount);
        
        emit BridgeRequestExecuted(request.requestHash, request.recipient, request.amount);
    }
    
    // 流动性提供者功能
    function addLiquidity(address token, uint256 amount) external {
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        liquidity[token] += amount;
    }
    
    function removeLiquidity(address token, uint256 amount) external onlyOwner {
        require(liquidity[token] >= amount, "Insufficient liquidity");
        liquidity[token] -= amount;
        IERC20(token).safeTransfer(msg.sender, amount);
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>13.3.2 跨链消息传递</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">LayerZero集成示例 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 使用LayerZero的全链稳定币
contract OmniChainStablecoin is OFT {
    using BytesLib for bytes;
    
    // 链特定配置
    mapping(uint16 => ChainConfig) public chainConfigs;
    
    struct ChainConfig {
        uint256 maxTransferAmount;
        uint256 minTransferAmount;
        uint256 dailyLimit;
        mapping(address => uint256) userDailyTransferred;
        mapping(address => uint256) lastTransferTimestamp;
    }
    
    constructor(
        address _lzEndpoint
    ) OFT("OmniChain USD", "omniUSD", _lzEndpoint) {
        // 初始化链配置
    }
    
    // 覆盖发送函数以添加自定义逻辑
    function _send(
        address _from,
        uint16 _dstChainId,
        bytes memory _toAddress,
        uint256 _amount,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes memory _adapterParams
    ) internal override {
        // 检查链特定限制
        ChainConfig storage config = chainConfigs[_dstChainId];
        require(_amount >= config.minTransferAmount, "Below minimum");
        require(_amount <= config.maxTransferAmount, "Exceeds maximum");
        
        // 检查每日限额
        uint256 today = block.timestamp / 86400;
        if (config.lastTransferTimestamp[_from] / 86400 < today) {
            config.userDailyTransferred[_from] = 0;
            config.lastTransferTimestamp[_from] = block.timestamp;
        }
        
        require(
            config.userDailyTransferred[_from] + _amount <= config.dailyLimit,
            "Daily limit exceeded"
        );
        
        config.userDailyTransferred[_from] += _amount;
        
        // 调用父类发送
        super._send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);
    }
    
    // 接收跨链消息的自定义处理
    function _nonblockingLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal override {
        // 解码payload
        (address to, uint256 amount) = abi.decode(_payload, (address, uint256));
        
        // 执行自定义逻辑（例如：合规检查）
        if (!isCompliant(to)) {
            // 将代币发送到托管账户而不是直接给用户
            _mint(address(this), amount);
            emit ComplianceHold(to, amount, _srcChainId);
            return;
        }
        
        // 正常铸造
        _mint(to, amount);
    }
    
    // 估算跨链费用
    function estimateSendFee(
        uint16 _dstChainId,
        bytes calldata _toAddress,
        uint256 _amount,
        bool _useZro,
        bytes calldata _adapterParams
    ) public view override returns (uint256 nativeFee, uint256 zroFee) {
        bytes memory payload = abi.encode(_toAddress, _amount);
        return lzEndpoint.estimateFees(
            _dstChainId,
            address(this),
            payload,
            _useZro,
            _adapterParams
        );
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h3 id="defi-aggregation">13.4 DeFi聚合器集成</h3>
        
        <div class="theory-section">
            <h4>13.4.1 流动性聚合</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">1inch聚合器集成 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// DeFi聚合器集成服务
class DeFiAggregatorService {
    private providers: Map<string, AggregatorProvider> = new Map();
    
    constructor() {
        // 初始化主流聚合器
        this.providers.set('1inch', new OneInchProvider());
        this.providers.set('0x', new ZeroXProvider());
        this.providers.set('paraswap', new ParaSwapProvider());
    }
    
    // 获取最佳交换路径
    async getBestSwapRoute(params: SwapParams): Promise<SwapRoute> {
        const quotes = await Promise.all(
            Array.from(this.providers.values()).map(provider => 
                provider.getQuote(params).catch(() => null)
            )
        );
        
        // 过滤有效报价并排序
        const validQuotes = quotes
            .filter(q => q !== null)
            .sort((a, b) => b.outputAmount - a.outputAmount);
        
        if (validQuotes.length === 0) {
            throw new Error('No valid quotes found');
        }
        
        const bestQuote = validQuotes[0];
        
        // 构建优化的交换路径
        return {
            provider: bestQuote.provider,
            inputToken: params.inputToken,
            outputToken: params.outputToken,
            inputAmount: params.inputAmount,
            outputAmount: bestQuote.outputAmount,
            path: bestQuote.path,
            pools: bestQuote.pools,
            gasEstimate: bestQuote.gasEstimate,
            priceImpact: this.calculatePriceImpact(bestQuote),
            calldata: bestQuote.calldata
        };
    }
    
    // 执行聚合交换
    async executeAggregatedSwap(route: SwapRoute, userAddress: string): Promise<TransactionResult> {
        // 构建交易参数
        const txParams = {
            to: route.provider.routerAddress,
            data: route.calldata,
            value: route.inputToken === 'ETH' ? route.inputAmount : 0,
            gasLimit: route.gasEstimate * 1.2, // 20%缓冲
            from: userAddress
        };
        
        // 如果是ERC20，需要先授权
        if (route.inputToken !== 'ETH') {
            await this.ensureApproval(
                route.inputToken,
                userAddress,
                route.provider.routerAddress,
                route.inputAmount
            );
        }
        
        // 执行交易
        const tx = await this.sendTransaction(txParams);
        
        // 监控交易
        return this.monitorTransaction(tx.hash);
    }
    
    // 套利机会检测
    async findArbitrageOpportunities(
        baseToken: string,
        quoteTokens: string[],
        amount: bigint
    ): Promise<ArbitrageOpportunity[]> {
        const opportunities: ArbitrageOpportunity[] = [];
        
        for (const quoteToken of quoteTokens) {
            // 获取各个DEX的价格
            const prices = await this.getAllPrices(baseToken, quoteToken, amount);
            
            // 寻找价差
            for (let i = 0; i < prices.length; i++) {
                for (let j = i + 1; j < prices.length; j++) {
                    const priceDiff = Math.abs(prices[i].price - prices[j].price);
                    const profitRatio = priceDiff / Math.min(prices[i].price, prices[j].price);
                    
                    // 如果价差超过阈值（考虑gas成本）
                    if (profitRatio > 0.005) { // 0.5%
                        const buyFrom = prices[i].price < prices[j].price ? prices[i] : prices[j];
                        const sellTo = prices[i].price > prices[j].price ? prices[i] : prices[j];
                        
                        const estimatedProfit = this.calculateProfit(
                            amount,
                            buyFrom,
                            sellTo
                        );
                        
                        if (estimatedProfit > 0) {
                            opportunities.push({
                                buyDex: buyFrom.dex,
                                sellDex: sellTo.dex,
                                token: baseToken,
                                quoteToken: quoteToken,
                                profitRatio: profitRatio,
                                estimatedProfit: estimatedProfit,
                                requiredCapital: amount,
                                gasEstimate: buyFrom.gasEstimate + sellTo.gasEstimate
                            });
                        }
                    }
                }
            }
        }
        
        return opportunities.sort((a, b) => b.estimatedProfit - a.estimatedProfit);
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h3 id="api-sdk">13.5 开发者工具与SDK</h3>
        
        <div class="practice-section">
            <h4>13.5.1 JavaScript SDK</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">稳定币SDK实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// 稳定币JavaScript SDK
import { ethers } from 'ethers';
import { EventEmitter } from 'events';

export class StablecoinSDK extends EventEmitter {
    private provider: ethers.Provider;
    private signer?: ethers.Signer;
    private contracts: Map<string, ethers.Contract> = new Map();
    private config: SDKConfig;
    
    constructor(config: SDKConfig) {
        super();
        this.config = config;
        this.provider = new ethers.JsonRpcProvider(config.rpcUrl);
        
        if (config.privateKey) {
            this.signer = new ethers.Wallet(config.privateKey, this.provider);
        }
        
        this.initializeContracts();
    }
    
    // 连接钱包
    async connect(signer: ethers.Signer): Promise<void> {
        this.signer = signer;
        await this.initializeContracts();
        this.emit('connected', await signer.getAddress());
    }
    
    // 获取余额
    async getBalance(address?: string): Promise<StablecoinBalance> {
        const account = address || await this.signer?.getAddress();
        if (!account) throw new Error('No account connected');
        
        const stablecoin = this.contracts.get('stablecoin');
        const balance = await stablecoin.balanceOf(account);
        const decimals = await stablecoin.decimals();
        
        return {
            raw: balance,
            formatted: ethers.formatUnits(balance, decimals),
            decimals: decimals,
            symbol: await stablecoin.symbol()
        };
    }
    
    // 转账
    async transfer(to: string, amount: string): Promise<TransactionResult> {
        const stablecoin = this.contracts.get('stablecoin');
        const decimals = await stablecoin.decimals();
        const amountWei = ethers.parseUnits(amount, decimals);
        
        // 估算gas
        const gasEstimate = await stablecoin.estimateGas.transfer(to, amountWei);
        
        // 发送交易
        const tx = await stablecoin.transfer(to, amountWei, {
            gasLimit: gasEstimate * 120n / 100n // 20%缓冲
        });
        
        this.emit('transactionSent', tx.hash);
        
        // 等待确认
        const receipt = await tx.wait();
        
        this.emit('transactionConfirmed', receipt);
        
        return {
            hash: tx.hash,
            blockNumber: receipt.blockNumber,
            gasUsed: receipt.gasUsed,
            status: receipt.status === 1
        };
    }
    
    // 批准支出
    async approve(spender: string, amount: string): Promise<TransactionResult> {
        const stablecoin = this.contracts.get('stablecoin');
        const decimals = await stablecoin.decimals();
        const amountWei = ethers.parseUnits(amount, decimals);
        
        const tx = await stablecoin.approve(spender, amountWei);
        const receipt = await tx.wait();
        
        return {
            hash: tx.hash,
            blockNumber: receipt.blockNumber,
            gasUsed: receipt.gasUsed,
            status: receipt.status === 1
        };
    }
    
    // 高级功能：批量操作
    async batchTransfer(transfers: BatchTransfer[]): Promise<TransactionResult> {
        const batcher = this.contracts.get('batcher');
        const decimals = await this.contracts.get('stablecoin').decimals();
        
        const recipients = transfers.map(t => t.to);
        const amounts = transfers.map(t => ethers.parseUnits(t.amount, decimals));
        
        const tx = await batcher.batchTransfer(recipients, amounts);
        const receipt = await tx.wait();
        
        return {
            hash: tx.hash,
            blockNumber: receipt.blockNumber,
            gasUsed: receipt.gasUsed,
            status: receipt.status === 1
        };
    }
    
    // 监听事件
    watchTransfers(callback: (transfer: Transfer) => void): () => void {
        const stablecoin = this.contracts.get('stablecoin');
        
        const filter = stablecoin.filters.Transfer();
        const listener = (from: string, to: string, amount: bigint, event: any) => {
            callback({
                from,
                to,
                amount: ethers.formatUnits(amount, this.config.decimals),
                txHash: event.transactionHash,
                blockNumber: event.blockNumber
            });
        };
        
        stablecoin.on(filter, listener);
        
        // 返回取消监听函数
        return () => {
            stablecoin.off(filter, listener);
        };
    }
    
    // 获取历史交易
    async getTransactionHistory(
        address: string,
        options?: HistoryOptions
    ): Promise<Transaction[]> {
        const stablecoin = this.contracts.get('stablecoin');
        
        const fromBlock = options?.fromBlock || 0;
        const toBlock = options?.toBlock || 'latest';
        
        // 获取发送的交易
        const sentFilter = stablecoin.filters.Transfer(address);
        const sentEvents = await stablecoin.queryFilter(sentFilter, fromBlock, toBlock);
        
        // 获取接收的交易
        const receivedFilter = stablecoin.filters.Transfer(null, address);
        const receivedEvents = await stablecoin.queryFilter(receivedFilter, fromBlock, toBlock);
        
        // 合并并排序
        const allEvents = [...sentEvents, ...receivedEvents]
            .sort((a, b) => b.blockNumber - a.blockNumber);
        
        return this.formatTransactionEvents(allEvents, address);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>13.5.2 REST API设计</h4>
            
            <div class="info-box">
                <p><strong>RESTful API端点设计：</strong></p>
                <pre><code class="language-yaml">openapi: 3.0.0
info:
  title: Stablecoin API
  version: 1.0.0

paths:
  /v1/balance/{address}:
    get:
      summary: 获取账户余额
      parameters:
        - name: address
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: 成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Balance'
                
  /v1/transfer:
    post:
      summary: 发起转账
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                from:
                  type: string
                to:
                  type: string
                amount:
                  type: string
                signature:
                  type: string
                  
  /v1/transactions/{hash}:
    get:
      summary: 查询交易状态
      parameters:
        - name: hash
          in: path
          required: true
          schema:
            type: string
            
  /v1/webhook:
    post:
      summary: 注册webhook
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                url:
                  type: string
                events:
                  type: array
                  items:
                    type: string
                    enum: [transfer, approval, mint, burn]</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">💻</span>
                <h4>练习13.1：构建稳定币支付系统</h4>
            </div>
            <p>设计并实现一个完整的稳定币支付系统，包括：</p>
            <ol>
                <li>支持多种稳定币的支付网关</li>
                <li>自动汇率转换功能</li>
                <li>商户管理和结算系统</li>
                <li>支付状态实时通知</li>
                <li>退款处理机制</li>
            </ol>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案</button>
            <div class="answer-content">
                <div class="code-block">
                    <div class="code-header" onclick="toggleCode(this)">完整支付系统实现 <span class="toggle-icon">▼</span></div>
                    <div class="code-content" style="display: none;">
                        <pre><code class="language-solidity">// 稳定币支付系统主合约
contract StablecoinPaymentSystem is Ownable, Pausable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    
    // 支付状态
    enum PaymentStatus { Pending, Completed, Refunded, Expired }
    
    // 支付订单
    struct PaymentOrder {
        bytes32 orderId;
        address merchant;
        address customer;
        address paymentToken;
        uint256 amount;
        uint256 merchantAmount;
        string fiatCurrency;
        uint256 exchangeRate;
        PaymentStatus status;
        uint256 createdAt;
        uint256 expiresAt;
        string metadata;
    }
    
    // 商户信息
    struct Merchant {
        string name;
        address payoutAddress;
        address[] acceptedTokens;
        string settlementCurrency;
        uint256 feeRate; // 基点
        bool autoConvert;
        bool isActive;
    }
    
    // 存储
    mapping(bytes32 => PaymentOrder) public orders;
    mapping(address => Merchant) public merchants;
    mapping(address => bool) public supportedStablecoins;
    mapping(string => mapping(address => uint256)) public exchangeRates;
    
    // 费用和结算
    address public feeCollector;
    uint256 public baseFeeRate = 30; // 0.3%
    uint256 public constant FEE_DENOMINATOR = 10000;
    
    // 聚合器和预言机
    IAggregator public priceAggregator;
    IOracle public exchangeRateOracle;
    
    event PaymentCreated(bytes32 indexed orderId, address indexed merchant, uint256 amount);
    event PaymentCompleted(bytes32 indexed orderId, address indexed customer, address token);
    event PaymentRefunded(bytes32 indexed orderId, uint256 amount);
    event MerchantSettlement(address indexed merchant, address token, uint256 amount);
    
    // 创建支付订单
    function createPaymentOrder(
        address merchant,
        uint256 fiatAmount,
        string calldata fiatCurrency,
        uint256 validityPeriod,
        string calldata metadata
    ) external returns (bytes32 orderId) {
        require(merchants[merchant].isActive, "Merchant not active");
        require(validityPeriod >= 300, "Validity too short"); // 最少5分钟
        
        orderId = keccak256(abi.encodePacked(
            merchant,
            fiatAmount,
            block.timestamp,
            msg.sender
        ));
        
        // 获取汇率并计算稳定币金额
        uint256 rate = exchangeRateOracle.getRate(fiatCurrency, "USD");
        uint256 usdAmount = fiatAmount.mul(rate).div(10**exchangeRateOracle.decimals());
        
        orders[orderId] = PaymentOrder({
            orderId: orderId,
            merchant: merchant,
            customer: address(0), // 待支付
            paymentToken: address(0), // 待选择
            amount: usdAmount,
            merchantAmount: 0, // 待计算
            fiatCurrency: fiatCurrency,
            exchangeRate: rate,
            status: PaymentStatus.Pending,
            createdAt: block.timestamp,
            expiresAt: block.timestamp + validityPeriod,
            metadata: metadata
        });
        
        emit PaymentCreated(orderId, merchant, usdAmount);
    }
    
    // 执行支付
    function pay(
        bytes32 orderId,
        address paymentToken
    ) external nonReentrant {
        PaymentOrder storage order = orders[orderId];
        require(order.status == PaymentStatus.Pending, "Invalid status");
        require(block.timestamp < order.expiresAt, "Order expired");
        require(supportedStablecoins[paymentToken], "Token not supported");
        require(
            _isTokenAcceptedByMerchant(order.merchant, paymentToken),
            "Token not accepted by merchant"
        );
        
        // 计算费用
        uint256 platformFee = order.amount.mul(baseFeeRate).div(FEE_DENOMINATOR);
        uint256 merchantFee = order.amount.mul(merchants[order.merchant].feeRate).div(FEE_DENOMINATOR);
        uint256 totalFee = platformFee.add(merchantFee);
        uint256 merchantAmount = order.amount.sub(totalFee);
        
        // 更新订单
        order.customer = msg.sender;
        order.paymentToken = paymentToken;
        order.merchantAmount = merchantAmount;
        order.status = PaymentStatus.Completed;
        
        // 执行转账
        IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), order.amount);
        
        // 分配费用
        if (platformFee > 0) {
            IERC20(paymentToken).safeTransfer(feeCollector, platformFee);
        }
        
        // 处理商户结算
        if (merchants[order.merchant].autoConvert) {
            _processAutoConversion(order);
        } else {
            _settleMerchant(order.merchant, paymentToken, merchantAmount);
        }
        
        emit PaymentCompleted(orderId, msg.sender, paymentToken);
    }
    
    // 自动转换和结算
    function _processAutoConversion(PaymentOrder memory order) private {
        Merchant memory merchant = merchants[order.merchant];
        
        // 通过聚合器找到最佳兑换路径
        (address[] memory path, uint256 expectedOutput) = priceAggregator.getBestPath(
            order.paymentToken,
            merchant.settlementCurrency,
            order.merchantAmount
        );
        
        // 执行兑换
        IERC20(order.paymentToken).safeApprove(address(priceAggregator), order.merchantAmount);
        uint256 outputAmount = priceAggregator.swap(
            order.paymentToken,
            merchant.settlementCurrency,
            order.merchantAmount,
            expectedOutput.mul(98).div(100), // 2%滑点保护
            path
        );
        
        // 结算给商户
        _settleMerchant(order.merchant, merchant.settlementCurrency, outputAmount);
    }
    
    // 退款功能
    function refund(bytes32 orderId) external nonReentrant {
        PaymentOrder storage order = orders[orderId];
        require(order.status == PaymentStatus.Completed, "Cannot refund");
        require(msg.sender == order.merchant || msg.sender == owner(), "Unauthorized");
        require(block.timestamp < order.createdAt + 30 days, "Refund period expired");
        
        order.status = PaymentStatus.Refunded;
        
        // 从商户扣除退款金额（需要商户预先授权）
        IERC20(order.paymentToken).safeTransferFrom(
            order.merchant,
            order.customer,
            order.amount
        );
        
        emit PaymentRefunded(orderId, order.amount);
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="summary-box">
            <h3>本章小结</h3>
            <p>稳定币生态系统集成是实现广泛应用的关键。本章介绍了：</p>
            <ul>
                <li><strong>钱包集成</strong>：支持多种钱包标准，优化用户体验</li>
                <li><strong>支付网关</strong>：商户接入、自动结算、多币种支持</li>
                <li><strong>跨链桥接</strong>：实现资产在不同区块链间的流动</li>
                <li><strong>DeFi聚合</strong>：集成主流聚合器，优化交易路径</li>
                <li><strong>开发者工具</strong>：提供易用的SDK和API</li>
            </ul>
            
            <p>成功的稳定币项目需要构建完整的生态系统，不仅要有优秀的核心协议，还需要便捷的集成工具、丰富的应用场景和活跃的开发者社区。通过本章学习，你应该能够设计和实现稳定币与各种基础设施的集成方案。</p>
        
            
            <!-- 章节导航 -->
            <div class="chapter-nav">
                <a href="chapter12.html">← 第12章</a>
                <a href="index.html">返回首页 →</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>