<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬åä¸‰ç« ï¼šç¨³å®šå¸ç”Ÿæ€ç³»ç»Ÿé›†æˆ - åŒºå—é“¾ç¨³å®šå¸æ•™ç¨‹</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">ç¨³å®šå¸æ•™ç¨‹</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">â˜°</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">é¦–é¡µ</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">å¼•è¨€</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">ç« èŠ‚</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">ç¬¬1ç« ï¼šåŒºå—é“¾åŸºç¡€</a>
                        <a href="chapter2.html" class="dropdown-item">ç¬¬2ç« ï¼šç¨³å®šå¸åˆ†ç±»</a>
                        <a href="chapter3.html" class="dropdown-item">ç¬¬3ç« ï¼šERC-20æ ‡å‡†</a>
                        <a href="chapter4.html" class="dropdown-item">ç¬¬4ç« ï¼šæŠµæŠ¼å‹è®¾è®¡</a>
                        <a href="chapter5.html" class="dropdown-item">ç¬¬5ç« ï¼šæ•°å­¦æ¨¡å‹</a>
                        <a href="chapter6.html" class="dropdown-item">ç¬¬6ç« ï¼šAMMé›†æˆ</a>
                        <a href="chapter7.html" class="dropdown-item">ç¬¬7ç« ï¼šå€Ÿè´·åè®®</a>
                        <a href="chapter8.html" class="dropdown-item">ç¬¬8ç« ï¼šæ”¶ç›Šç­–ç•¥</a>
                        <a href="chapter9.html" class="dropdown-item">ç¬¬9ç« ï¼šæ™ºèƒ½åˆçº¦å®‰å…¨</a>
                        <a href="chapter10.html" class="dropdown-item">ç¬¬10ç« ï¼šç»æµæ”»å‡»</a>
                        <a href="chapter11.html" class="dropdown-item">ç¬¬11ç« ï¼šæœªæ¥æ–¹å‘</a>
                        <a href="chapter12.html" class="dropdown-item">ç¬¬12ç« ï¼šç”Ÿäº§éƒ¨ç½²</a>
                        <a href="chapter13.html" class="dropdown-item">ç¬¬13ç« ï¼šç”Ÿæ€é›†æˆ</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="#resources" class="nav-link">èµ„æº</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- å¤´éƒ¨ -->
    <header id="top">
        <div class="container">
            <h1>ç¬¬åä¸‰ç« ï¼šç¨³å®šå¸ç”Ÿæ€ç³»ç»Ÿé›†æˆ</h1>
        </div>
    </header>
    
    <!-- ä¸»è¦å†…å®¹ -->
    <div class="container">
        <div class="chapter">
<h2>ç¬¬åä¸‰ç« ï¼šç¨³å®šå¸ç”Ÿæ€ç³»ç»Ÿé›†æˆ</h2>
        
        <div class="chapter-intro">
            <p>ç¨³å®šå¸çš„æˆåŠŸä¸ä»…å–å†³äºå…¶è‡ªèº«è®¾è®¡ï¼Œæ›´ä¾èµ–äºä¸æ•´ä¸ªDeFiç”Ÿæ€ç³»ç»Ÿçš„æ·±åº¦é›†æˆã€‚æœ¬ç« æ¢è®¨ç¨³å®šå¸å¦‚ä½•ä¸é’±åŒ…ã€æ”¯ä»˜ç½‘å…³ã€è·¨é“¾æ¡¥ã€èšåˆå™¨ç­‰åŸºç¡€è®¾æ–½ååŒå·¥ä½œï¼Œæ„å»ºå®Œæ•´çš„é‡‘èæœåŠ¡ç”Ÿæ€ã€‚</p>
        </div>

        <h3 id="wallet-integration">13.1 é’±åŒ…ä¸ç”¨æˆ·ç•Œé¢é›†æˆ</h3>
        
        <div class="theory-section">
            <h4>13.1.1 é’±åŒ…æ ‡å‡†ä¸é›†æˆåè®®</h4>
            
            <h5>EIP-3085ï¼šæ·»åŠ ä»¥å¤ªåŠé“¾</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">é’±åŒ…é“¾é…ç½®æ ‡å‡† <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// é’±åŒ…é›†æˆSDK
class WalletIntegrationSDK {
    private provider: any;
    private chainConfigs: Map<number, ChainConfig> = new Map();
    
    constructor() {
        this.initializeChainConfigs();
    }
    
    // æ£€æµ‹å¹¶è¿æ¥é’±åŒ…
    async connectWallet(): Promise<WalletConnection> {
        // æ£€æµ‹æ³¨å…¥çš„provider
        if (typeof window.ethereum !== 'undefined') {
            this.provider = window.ethereum;
            
            // è¯·æ±‚è´¦æˆ·è®¿é—®
            const accounts = await this.provider.request({ 
                method: 'eth_requestAccounts' 
            });
            
            // è·å–é“¾ID
            const chainId = await this.provider.request({ 
                method: 'eth_chainId' 
            });
            
            return {
                address: accounts[0],
                chainId: parseInt(chainId, 16),
                provider: this.provider
            };
        } else {
            throw new Error('No wallet detected');
        }
    }
    
    // æ·»åŠ è‡ªå®šä¹‰é“¾ï¼ˆç”¨äºæ–°é“¾ä¸Šçš„ç¨³å®šå¸ï¼‰
    async addCustomChain(chainId: number): Promise<void> {
        const config = this.chainConfigs.get(chainId);
        if (!config) throw new Error(`Chain ${chainId} not configured`);
        
        try {
            await this.provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                    chainId: `0x${chainId.toString(16)}`,
                    chainName: config.name,
                    nativeCurrency: config.nativeCurrency,
                    rpcUrls: config.rpcUrls,
                    blockExplorerUrls: config.blockExplorerUrls
                }]
            });
        } catch (error) {
            if (error.code === 4902) {
                throw new Error('User rejected chain addition');
            }
            throw error;
        }
    }
    
    // æ·»åŠ ä»£å¸åˆ°é’±åŒ…
    async addTokenToWallet(tokenConfig: TokenConfig): Promise<boolean> {
        try {
            const wasAdded = await this.provider.request({
                method: 'wallet_watchAsset',
                params: {
                    type: 'ERC20',
                    options: {
                        address: tokenConfig.address,
                        symbol: tokenConfig.symbol,
                        decimals: tokenConfig.decimals,
                        image: tokenConfig.logoURI
                    }
                }
            });
            return wasAdded;
        } catch (error) {
            console.error('Error adding token:', error);
            return false;
        }
    }
    
    // é«˜çº§ç­¾ååŠŸèƒ½ï¼ˆEIP-712ï¼‰
    async signTypedData(domain: EIP712Domain, types: any, value: any): Promise<string> {
        const msgParams = {
            domain,
            message: value,
            primaryType: 'Permit',
            types: {
                EIP712Domain: [
                    { name: 'name', type: 'string' },
                    { name: 'version', type: 'string' },
                    { name: 'chainId', type: 'uint256' },
                    { name: 'verifyingContract', type: 'address' }
                ],
                ...types
            }
        };
        
        const accounts = await this.provider.request({ 
            method: 'eth_requestAccounts' 
        });
        
        const signature = await this.provider.request({
            method: 'eth_signTypedData_v4',
            params: [accounts[0], JSON.stringify(msgParams)]
        });
        
        return signature;
    }
}</code></pre>
                </div>
            </div>
            
            <h5>è´¦æˆ·æŠ½è±¡ï¼ˆERC-4337ï¼‰é›†æˆ</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">æ™ºèƒ½é’±åŒ…é›†æˆ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// æ”¯æŒè´¦æˆ·æŠ½è±¡çš„ç¨³å®šå¸
contract AACompatibleStablecoin is ERC20, IAccount {
    using UserOperationLib for UserOperation;
    
    // è´¦æˆ·æŠ½è±¡å…¥å£ç‚¹
    IEntryPoint private immutable entryPoint;
    
    // æ”¯ä»˜ä¸»åˆçº¦
    mapping(address => bool) public paymasters;
    
    constructor(IEntryPoint _entryPoint) ERC20("AA Stablecoin", "AAUSD") {
        entryPoint = _entryPoint;
    }
    
    // éªŒè¯ç”¨æˆ·æ“ä½œ
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external override returns (uint256 validationData) {
        require(msg.sender == address(entryPoint), "Only EntryPoint");
        
        // éªŒè¯ç­¾å
        bytes32 hash = userOpHash.toEthSignedMessageHash();
        address signer = hash.recover(userOp.signature);
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æˆæƒçš„æ“ä½œ
        if (!isValidSigner(signer)) {
            return SIG_VALIDATION_FAILED;
        }
        
        // å¦‚æœéœ€è¦ï¼Œä»è´¦æˆ·è½¬ç§»èµ„é‡‘åˆ°EntryPoint
        if (missingAccountFunds > 0) {
            _transfer(address(this), msg.sender, missingAccountFunds);
        }
        
        return 0; // éªŒè¯æˆåŠŸ
    }
    
    // æ‰§è¡Œç”¨æˆ·æ“ä½œ
    function execute(
        address dest,
        uint256 value,
        bytes calldata func
    ) external {
        require(msg.sender == address(entryPoint), "Only EntryPoint");
        
        if (value > 0) {
            require(address(this).balance >= value, "Insufficient balance");
        }
        
        (bool success, bytes memory result) = dest.call{value: value}(func);
        if (!success) {
            assembly {
                revert(add(result, 32), mload(result))
            }
        }
    }
    
    // æ”¯æŒERC-4337æ”¯ä»˜ä¸»åˆçº¦
    function addPaymaster(address paymaster) external onlyOwner {
        paymasters[paymaster] = true;
    }
    
    // å…è®¸æ”¯ä»˜ä¸»åˆçº¦ä»£ä»˜gasè´¹
    function sponsorUserOperation(
        UserOperation calldata userOp
    ) external view returns (bool) {
        return paymasters[userOp.paymaster];
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>13.1.2 ç”¨æˆ·ä½“éªŒä¼˜åŒ–</h4>
            
            <h5>æ‰¹é‡äº¤æ˜“ä¸å…ƒäº¤æ˜“</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">å…ƒäº¤æ˜“å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// æ”¯æŒå…ƒäº¤æ˜“çš„ç¨³å®šå¸ï¼ˆç”¨æˆ·æ— éœ€æŒæœ‰ETHï¼‰
contract MetaTransactionStablecoin is ERC20, EIP712 {
    using ECDSA for bytes32;
    
    struct MetaTransaction {
        uint256 nonce;
        address from;
        address to;
        uint256 value;
        bytes data;
        uint256 gasLimit;
        uint256 gasPrice;
        uint256 deadline;
    }
    
    mapping(address => uint256) public nonces;
    mapping(address => bool) public trustedForwarders;
    
    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(
        "MetaTransaction(uint256 nonce,address from,address to,uint256 value,bytes data,uint256 gasLimit,uint256 gasPrice,uint256 deadline)"
    );
    
    event MetaTransactionExecuted(
        address indexed from,
        address indexed to,
        address indexed relayer,
        uint256 value
    );
    
    function executeMetaTransaction(
        MetaTransaction memory metaTx,
        bytes memory signature
    ) public returns (bytes memory) {
        require(block.timestamp <= metaTx.deadline, "Transaction expired");
        require(nonces[metaTx.from] == metaTx.nonce, "Invalid nonce");
        
        // éªŒè¯ç­¾å
        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
            META_TRANSACTION_TYPEHASH,
            metaTx.nonce,
            metaTx.from,
            metaTx.to,
            metaTx.value,
            keccak256(metaTx.data),
            metaTx.gasLimit,
            metaTx.gasPrice,
            metaTx.deadline
        )));
        
        address signer = digest.recover(signature);
        require(signer == metaTx.from, "Invalid signature");
        
        // æ›´æ–°nonce
        nonces[metaTx.from]++;
        
        // æ‰§è¡Œäº¤æ˜“
        (bool success, bytes memory returnData) = address(this).call(
            abi.encodePacked(metaTx.data, metaTx.from)
        );
        require(success, "Meta transaction failed");
        
        // æ”¯ä»˜ä¸­ç»§è´¹ç”¨ï¼ˆä»ç”¨æˆ·çš„ç¨³å®šå¸ä½™é¢ä¸­æ‰£é™¤ï¼‰
        uint256 relayerFee = calculateRelayerFee(metaTx.gasLimit, metaTx.gasPrice);
        _transfer(metaTx.from, msg.sender, relayerFee);
        
        emit MetaTransactionExecuted(metaTx.from, metaTx.to, msg.sender, metaTx.value);
        
        return returnData;
    }
    
    // æ‰¹é‡æ“ä½œæ”¯æŒ
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        require(recipients.length == amounts.length, "Length mismatch");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            _transfer(_msgSender(), recipients[i], amounts[i]);
        }
    }
    
    // è·å–å®é™…çš„æ¶ˆæ¯å‘é€è€…ï¼ˆæ”¯æŒå…ƒäº¤æ˜“ï¼‰
    function _msgSender() internal view override returns (address) {
        if (msg.sender == address(this)) {
            bytes memory array = msg.data;
            uint256 index = msg.data.length;
            assembly {
                return := and(
                    mload(add(array, index)),
                    0xffffffffffffffffffffffffffffffffffffffff
                )
            }
        } else {
            return super._msgSender();
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>ç§»åŠ¨ç«¯ä¼˜åŒ–</h5>
            <div class="info-box">
                <p><strong>ç§»åŠ¨é’±åŒ…é›†æˆæœ€ä½³å®è·µï¼š</strong></p>
                <ul>
                    <li><strong>WalletConnect v2</strong>ï¼šæ”¯æŒå¤šé“¾è¿æ¥</li>
                    <li><strong>æ·±åº¦é“¾æ¥</strong>ï¼šç›´æ¥å”¤èµ·é’±åŒ…åº”ç”¨</li>
                    <li><strong>äºŒç»´ç æ”¯ä»˜</strong>ï¼šçº¿ä¸‹åœºæ™¯æ”¯æŒ</li>
                    <li><strong>æ¨é€é€šçŸ¥</strong>ï¼šäº¤æ˜“çŠ¶æ€å®æ—¶æ›´æ–°</li>
                    <li><strong>ç¦»çº¿ç­¾å</strong>ï¼šå†·é’±åŒ…æ”¯æŒ</li>
                </ul>
            </div>
        </div>
        
        <h3 id="payment-gateway">13.2 æ”¯ä»˜ç½‘å…³ä¸å•†æˆ·é›†æˆ</h3>
        
        <div class="theory-section">
            <h4>13.2.1 æ”¯ä»˜å¤„ç†ç³»ç»Ÿ</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">å•†æˆ·æ”¯ä»˜ç½‘å…³ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// ç¨³å®šå¸æ”¯ä»˜ç½‘å…³æœåŠ¡
class StablecoinPaymentGateway {
    private merchants: Map<string, MerchantConfig> = new Map();
    private payments: Map<string, Payment> = new Map();
    
    // åˆ›å»ºæ”¯ä»˜è¯·æ±‚
    async createPaymentRequest(params: PaymentRequestParams): Promise<PaymentRequest> {
        const merchant = this.merchants.get(params.merchantId);
        if (!merchant) throw new Error('Invalid merchant');
        
        const paymentId = generatePaymentId();
        const paymentAddress = await this.generatePaymentAddress(paymentId);
        
        const request: PaymentRequest = {
            id: paymentId,
            merchantId: params.merchantId,
            amount: params.amount,
            currency: params.currency,
            stablecoin: params.acceptedStablecoins || ['USDC', 'USDT', 'DAI'],
            paymentAddress: paymentAddress,
            memo: params.memo,
            createdAt: Date.now(),
            expiresAt: Date.now() + (params.ttl || 3600000), // 1å°æ—¶é»˜è®¤
            status: 'pending',
            callbackUrl: params.callbackUrl,
            metadata: params.metadata
        };
        
        // ç”Ÿæˆæ”¯ä»˜é“¾æ¥å’ŒäºŒç»´ç 
        request.paymentUrl = this.generatePaymentUrl(request);
        request.qrCode = await this.generateQRCode(request.paymentUrl);
        
        this.payments.set(paymentId, request);
        
        // å¼€å§‹ç›‘æ§æ”¯ä»˜
        this.monitorPayment(paymentId);
        
        return request;
    }
    
    // ç›‘æ§é“¾ä¸Šæ”¯ä»˜
    private async monitorPayment(paymentId: string) {
        const payment = this.payments.get(paymentId);
        if (!payment) return;
        
        const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
        
        // ç›‘å¬è½¬è´¦äº‹ä»¶
        const stablecoinContracts = this.getStablecoinContracts(payment.stablecoin);
        
        for (const contract of stablecoinContracts) {
            const filter = contract.filters.Transfer(null, payment.paymentAddress);
            
            contract.on(filter, async (from, to, amount, event) => {
                // éªŒè¯æ”¯ä»˜é‡‘é¢
                const expectedAmount = ethers.parseUnits(
                    payment.amount.toString(),
                    await contract.decimals()
                );
                
                if (amount >= expectedAmount) {
                    // æ›´æ–°æ”¯ä»˜çŠ¶æ€
                    payment.status = 'confirmed';
                    payment.txHash = event.transactionHash;
                    payment.paidAmount = amount;
                    payment.paidToken = await contract.symbol();
                    payment.payer = from;
                    payment.confirmedAt = Date.now();
                    
                    // é€šçŸ¥å•†æˆ·
                    await this.notifyMerchant(payment);
                    
                    // è‡ªåŠ¨è½¬æ¢å’Œç»“ç®—
                    if (payment.autoConvert) {
                        await this.convertAndSettle(payment);
                    }
                }
            });
        }
        
        // è¶…æ—¶å¤„ç†
        setTimeout(() => {
            if (payment.status === 'pending') {
                payment.status = 'expired';
                this.notifyMerchant(payment);
            }
        }, payment.expiresAt - Date.now());
    }
    
    // è‡ªåŠ¨è½¬æ¢å’Œç»“ç®—
    private async convertAndSettle(payment: Payment) {
        const merchant = this.merchants.get(payment.merchantId);
        
        // é€šè¿‡èšåˆå™¨è·å–æœ€ä½³å…‘æ¢è·¯å¾„
        const swapRoute = await this.findBestSwapRoute(
            payment.paidToken,
            merchant.settlementCurrency,
            payment.paidAmount
        );
        
        // æ‰§è¡Œå…‘æ¢
        const swapResult = await this.executeSwap(swapRoute);
        
        // ç»“ç®—åˆ°å•†æˆ·è´¦æˆ·
        await this.settleMerchant(
            merchant,
            swapResult.outputAmount,
            payment
        );
    }
    
    // Webhooké€šçŸ¥ç³»ç»Ÿ
    private async notifyMerchant(payment: Payment) {
        const merchant = this.merchants.get(payment.merchantId);
        
        const notification = {
            event: payment.status === 'confirmed' ? 'payment.confirmed' : 'payment.expired',
            paymentId: payment.id,
            merchantId: payment.merchantId,
            amount: payment.amount,
            currency: payment.currency,
            paidAmount: payment.paidAmount,
            paidToken: payment.paidToken,
            txHash: payment.txHash,
            timestamp: Date.now(),
            signature: this.signWebhook(payment)
        };
        
        // é‡è¯•æœºåˆ¶
        let retries = 0;
        while (retries < 3) {
            try {
                const response = await fetch(payment.callbackUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Signature': notification.signature
                    },
                    body: JSON.stringify(notification)
                });
                
                if (response.ok) break;
            } catch (error) {
                retries++;
                await new Promise(resolve => setTimeout(resolve, 1000 * retries));
            }
        }
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>13.2.2 ç»“ç®—ä¸æ¸…ç®—ç³»ç»Ÿ</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">æ‰¹é‡ç»“ç®—åˆçº¦ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// å•†æˆ·ç»“ç®—åˆçº¦
contract MerchantSettlement is Ownable, Pausable {
    using SafeERC20 for IERC20;
    
    struct Settlement {
        address merchant;
        address token;
        uint256 amount;
        uint256 fee;
        uint256 timestamp;
        bytes32 batchId;
        bool processed;
    }
    
    struct MerchantAccount {
        address settlementAddress;
        uint256 minSettlementAmount;
        uint256 settlementDelay;
        uint256 feeRate; // åŸºç‚¹
        mapping(address => uint256) balances;
        uint256 lastSettlement;
    }
    
    mapping(address => MerchantAccount) public merchants;
    mapping(bytes32 => Settlement[]) public settlementBatches;
    
    uint256 public constant FEE_DENOMINATOR = 10000;
    address public feeCollector;
    
    event SettlementQueued(address indexed merchant, address token, uint256 amount);
    event BatchSettlementExecuted(bytes32 indexed batchId, uint256 count);
    
    // ç´¯ç§¯å•†æˆ·ä½™é¢
    function creditMerchant(
        address merchant,
        address token,
        uint256 amount
    ) external onlyAuthorized {
        require(merchants[merchant].settlementAddress != address(0), "Merchant not registered");
        
        merchants[merchant].balances[token] += amount;
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°è‡ªåŠ¨ç»“ç®—é˜ˆå€¼
        if (merchants[merchant].balances[token] >= merchants[merchant].minSettlementAmount) {
            _queueSettlement(merchant, token);
        }
    }
    
    // æ‰¹é‡ç»“ç®—æ‰§è¡Œ
    function executeBatchSettlement(bytes32 batchId) external onlyOwner {
        Settlement[] storage settlements = settlementBatches[batchId];
        require(settlements.length > 0, "Empty batch");
        
        uint256 totalGas = gasleft();
        
        for (uint256 i = 0; i < settlements.length; i++) {
            if (settlements[i].processed) continue;
            
            // æ£€æŸ¥å»¶è¿ŸæœŸ
            MerchantAccount storage account = merchants[settlements[i].merchant];
            require(
                block.timestamp >= account.lastSettlement + account.settlementDelay,
                "Settlement delay not met"
            );
            
            // è®¡ç®—è´¹ç”¨
            uint256 fee = (settlements[i].amount * account.feeRate) / FEE_DENOMINATOR;
            uint256 netAmount = settlements[i].amount - fee;
            
            // æ‰§è¡Œè½¬è´¦
            IERC20(settlements[i].token).safeTransfer(
                account.settlementAddress,
                netAmount
            );
            
            if (fee > 0) {
                IERC20(settlements[i].token).safeTransfer(feeCollector, fee);
            }
            
            // æ›´æ–°çŠ¶æ€
            settlements[i].processed = true;
            settlements[i].fee = fee;
            account.balances[settlements[i].token] = 0;
            account.lastSettlement = block.timestamp;
            
            // Gasä¼˜åŒ–ï¼šå¦‚æœå‰©ä½™gasä¸è¶³ï¼Œåœæ­¢æ‰§è¡Œ
            if (gasleft() < totalGas / 10) break;
        }
        
        emit BatchSettlementExecuted(batchId, settlements.length);
    }
    
    // ç´§æ€¥æå–ï¼ˆéœ€è¦å¤šç­¾ï¼‰
    function emergencyWithdraw(
        address merchant,
        address token
    ) external onlyRole(EMERGENCY_ROLE) {
        uint256 balance = merchants[merchant].balances[token];
        require(balance > 0, "No balance");
        
        merchants[merchant].balances[token] = 0;
        
        IERC20(token).safeTransfer(
            merchants[merchant].settlementAddress,
            balance
        );
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h3 id="cross-chain-integration">13.3 è·¨é“¾æ¡¥æ¥ä¸äº’æ“ä½œæ€§</h3>
        
        <div class="theory-section">
            <h4>13.3.1 è·¨é“¾æ¡¥æ¥åè®®</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">é€šç”¨è·¨é“¾æ¡¥å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// è·¨é“¾æ¡¥æ¥åˆçº¦ï¼ˆæºé“¾ï¼‰
contract CrossChainBridge is Ownable, Pausable {
    using SafeERC20 for IERC20;
    
    struct BridgeRequest {
        address token;
        address sender;
        address recipient;
        uint256 amount;
        uint256 targetChainId;
        uint256 nonce;
        uint256 timestamp;
        bytes32 requestHash;
    }
    
    // æ”¯æŒçš„é“¾å’Œä»£å¸æ˜ å°„
    mapping(uint256 => mapping(address => address)) public tokenMappings;
    mapping(bytes32 => bool) public processedRequests;
    mapping(address => uint256) public nonces;
    
    // éªŒè¯è€…é›†åˆ
    mapping(address => bool) public validators;
    uint256 public requiredValidations;
    mapping(bytes32 => mapping(address => bool)) public validations;
    mapping(bytes32 => uint256) public validationCounts;
    
    // æµåŠ¨æ€§æ± 
    mapping(address => uint256) public liquidity;
    
    event BridgeRequestCreated(
        bytes32 indexed requestHash,
        address indexed sender,
        uint256 targetChainId,
        uint256 amount
    );
    
    event BridgeRequestValidated(
        bytes32 indexed requestHash,
        address indexed validator
    );
    
    event BridgeRequestExecuted(
        bytes32 indexed requestHash,
        address indexed recipient,
        uint256 amount
    );
    
    // å‘èµ·è·¨é“¾è½¬è´¦
    function bridge(
        address token,
        uint256 amount,
        uint256 targetChainId,
        address recipient
    ) external whenNotPaused {
        require(tokenMappings[targetChainId][token] != address(0), "Unsupported token/chain");
        require(amount > 0, "Invalid amount");
        
        // é”å®šä»£å¸
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        
        // åˆ›å»ºæ¡¥æ¥è¯·æ±‚
        uint256 nonce = nonces[msg.sender]++;
        bytes32 requestHash = keccak256(abi.encodePacked(
            token,
            msg.sender,
            recipient,
            amount,
            targetChainId,
            nonce,
            block.timestamp
        ));
        
        BridgeRequest memory request = BridgeRequest({
            token: token,
            sender: msg.sender,
            recipient: recipient,
            amount: amount,
            targetChainId: targetChainId,
            nonce: nonce,
            timestamp: block.timestamp,
            requestHash: requestHash
        });
        
        emit BridgeRequestCreated(requestHash, msg.sender, targetChainId, amount);
    }
    
    // éªŒè¯è€…ç­¾åéªŒè¯
    function validateBridgeRequest(
        BridgeRequest calldata request,
        bytes[] calldata signatures
    ) external {
        require(validators[msg.sender], "Not a validator");
        require(!validations[request.requestHash][msg.sender], "Already validated");
        
        // éªŒè¯è¯·æ±‚å“ˆå¸Œ
        bytes32 calculatedHash = keccak256(abi.encodePacked(
            request.token,
            request.sender,
            request.recipient,
            request.amount,
            request.targetChainId,
            request.nonce,
            request.timestamp
        ));
        require(calculatedHash == request.requestHash, "Invalid request hash");
        
        // è®°å½•éªŒè¯
        validations[request.requestHash][msg.sender] = true;
        validationCounts[request.requestHash]++;
        
        emit BridgeRequestValidated(request.requestHash, msg.sender);
        
        // å¦‚æœè¾¾åˆ°æ‰€éœ€éªŒè¯æ•°ï¼Œæ‰§è¡Œæ¡¥æ¥
        if (validationCounts[request.requestHash] >= requiredValidations) {
            _executeBridgeRequest(request);
        }
    }
    
    // æ‰§è¡Œè·¨é“¾é‡Šæ”¾ï¼ˆç›®æ ‡é“¾ï¼‰
    function _executeBridgeRequest(BridgeRequest memory request) private {
        require(!processedRequests[request.requestHash], "Already processed");
        processedRequests[request.requestHash] = true;
        
        // ä»æµåŠ¨æ€§æ± é‡Šæ”¾ä»£å¸
        address targetToken = tokenMappings[block.chainid][request.token];
        require(liquidity[targetToken] >= request.amount, "Insufficient liquidity");
        
        liquidity[targetToken] -= request.amount;
        IERC20(targetToken).safeTransfer(request.recipient, request.amount);
        
        emit BridgeRequestExecuted(request.requestHash, request.recipient, request.amount);
    }
    
    // æµåŠ¨æ€§æä¾›è€…åŠŸèƒ½
    function addLiquidity(address token, uint256 amount) external {
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        liquidity[token] += amount;
    }
    
    function removeLiquidity(address token, uint256 amount) external onlyOwner {
        require(liquidity[token] >= amount, "Insufficient liquidity");
        liquidity[token] -= amount;
        IERC20(token).safeTransfer(msg.sender, amount);
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>13.3.2 è·¨é“¾æ¶ˆæ¯ä¼ é€’</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">LayerZeroé›†æˆç¤ºä¾‹ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// ä½¿ç”¨LayerZeroçš„å…¨é“¾ç¨³å®šå¸
contract OmniChainStablecoin is OFT {
    using BytesLib for bytes;
    
    // é“¾ç‰¹å®šé…ç½®
    mapping(uint16 => ChainConfig) public chainConfigs;
    
    struct ChainConfig {
        uint256 maxTransferAmount;
        uint256 minTransferAmount;
        uint256 dailyLimit;
        mapping(address => uint256) userDailyTransferred;
        mapping(address => uint256) lastTransferTimestamp;
    }
    
    constructor(
        address _lzEndpoint
    ) OFT("OmniChain USD", "omniUSD", _lzEndpoint) {
        // åˆå§‹åŒ–é“¾é…ç½®
    }
    
    // è¦†ç›–å‘é€å‡½æ•°ä»¥æ·»åŠ è‡ªå®šä¹‰é€»è¾‘
    function _send(
        address _from,
        uint16 _dstChainId,
        bytes memory _toAddress,
        uint256 _amount,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes memory _adapterParams
    ) internal override {
        // æ£€æŸ¥é“¾ç‰¹å®šé™åˆ¶
        ChainConfig storage config = chainConfigs[_dstChainId];
        require(_amount >= config.minTransferAmount, "Below minimum");
        require(_amount <= config.maxTransferAmount, "Exceeds maximum");
        
        // æ£€æŸ¥æ¯æ—¥é™é¢
        uint256 today = block.timestamp / 86400;
        if (config.lastTransferTimestamp[_from] / 86400 < today) {
            config.userDailyTransferred[_from] = 0;
            config.lastTransferTimestamp[_from] = block.timestamp;
        }
        
        require(
            config.userDailyTransferred[_from] + _amount <= config.dailyLimit,
            "Daily limit exceeded"
        );
        
        config.userDailyTransferred[_from] += _amount;
        
        // è°ƒç”¨çˆ¶ç±»å‘é€
        super._send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);
    }
    
    // æ¥æ”¶è·¨é“¾æ¶ˆæ¯çš„è‡ªå®šä¹‰å¤„ç†
    function _nonblockingLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal override {
        // è§£ç payload
        (address to, uint256 amount) = abi.decode(_payload, (address, uint256));
        
        // æ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘ï¼ˆä¾‹å¦‚ï¼šåˆè§„æ£€æŸ¥ï¼‰
        if (!isCompliant(to)) {
            // å°†ä»£å¸å‘é€åˆ°æ‰˜ç®¡è´¦æˆ·è€Œä¸æ˜¯ç›´æ¥ç»™ç”¨æˆ·
            _mint(address(this), amount);
            emit ComplianceHold(to, amount, _srcChainId);
            return;
        }
        
        // æ­£å¸¸é“¸é€ 
        _mint(to, amount);
    }
    
    // ä¼°ç®—è·¨é“¾è´¹ç”¨
    function estimateSendFee(
        uint16 _dstChainId,
        bytes calldata _toAddress,
        uint256 _amount,
        bool _useZro,
        bytes calldata _adapterParams
    ) public view override returns (uint256 nativeFee, uint256 zroFee) {
        bytes memory payload = abi.encode(_toAddress, _amount);
        return lzEndpoint.estimateFees(
            _dstChainId,
            address(this),
            payload,
            _useZro,
            _adapterParams
        );
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h3 id="defi-aggregation">13.4 DeFièšåˆå™¨é›†æˆ</h3>
        
        <div class="theory-section">
            <h4>13.4.1 æµåŠ¨æ€§èšåˆ</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">1inchèšåˆå™¨é›†æˆ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// DeFièšåˆå™¨é›†æˆæœåŠ¡
class DeFiAggregatorService {
    private providers: Map<string, AggregatorProvider> = new Map();
    
    constructor() {
        // åˆå§‹åŒ–ä¸»æµèšåˆå™¨
        this.providers.set('1inch', new OneInchProvider());
        this.providers.set('0x', new ZeroXProvider());
        this.providers.set('paraswap', new ParaSwapProvider());
    }
    
    // è·å–æœ€ä½³äº¤æ¢è·¯å¾„
    async getBestSwapRoute(params: SwapParams): Promise<SwapRoute> {
        const quotes = await Promise.all(
            Array.from(this.providers.values()).map(provider => 
                provider.getQuote(params).catch(() => null)
            )
        );
        
        // è¿‡æ»¤æœ‰æ•ˆæŠ¥ä»·å¹¶æ’åº
        const validQuotes = quotes
            .filter(q => q !== null)
            .sort((a, b) => b.outputAmount - a.outputAmount);
        
        if (validQuotes.length === 0) {
            throw new Error('No valid quotes found');
        }
        
        const bestQuote = validQuotes[0];
        
        // æ„å»ºä¼˜åŒ–çš„äº¤æ¢è·¯å¾„
        return {
            provider: bestQuote.provider,
            inputToken: params.inputToken,
            outputToken: params.outputToken,
            inputAmount: params.inputAmount,
            outputAmount: bestQuote.outputAmount,
            path: bestQuote.path,
            pools: bestQuote.pools,
            gasEstimate: bestQuote.gasEstimate,
            priceImpact: this.calculatePriceImpact(bestQuote),
            calldata: bestQuote.calldata
        };
    }
    
    // æ‰§è¡Œèšåˆäº¤æ¢
    async executeAggregatedSwap(route: SwapRoute, userAddress: string): Promise<TransactionResult> {
        // æ„å»ºäº¤æ˜“å‚æ•°
        const txParams = {
            to: route.provider.routerAddress,
            data: route.calldata,
            value: route.inputToken === 'ETH' ? route.inputAmount : 0,
            gasLimit: route.gasEstimate * 1.2, // 20%ç¼“å†²
            from: userAddress
        };
        
        // å¦‚æœæ˜¯ERC20ï¼Œéœ€è¦å…ˆæˆæƒ
        if (route.inputToken !== 'ETH') {
            await this.ensureApproval(
                route.inputToken,
                userAddress,
                route.provider.routerAddress,
                route.inputAmount
            );
        }
        
        // æ‰§è¡Œäº¤æ˜“
        const tx = await this.sendTransaction(txParams);
        
        // ç›‘æ§äº¤æ˜“
        return this.monitorTransaction(tx.hash);
    }
    
    // å¥—åˆ©æœºä¼šæ£€æµ‹
    async findArbitrageOpportunities(
        baseToken: string,
        quoteTokens: string[],
        amount: bigint
    ): Promise<ArbitrageOpportunity[]> {
        const opportunities: ArbitrageOpportunity[] = [];
        
        for (const quoteToken of quoteTokens) {
            // è·å–å„ä¸ªDEXçš„ä»·æ ¼
            const prices = await this.getAllPrices(baseToken, quoteToken, amount);
            
            // å¯»æ‰¾ä»·å·®
            for (let i = 0; i < prices.length; i++) {
                for (let j = i + 1; j < prices.length; j++) {
                    const priceDiff = Math.abs(prices[i].price - prices[j].price);
                    const profitRatio = priceDiff / Math.min(prices[i].price, prices[j].price);
                    
                    // å¦‚æœä»·å·®è¶…è¿‡é˜ˆå€¼ï¼ˆè€ƒè™‘gasæˆæœ¬ï¼‰
                    if (profitRatio > 0.005) { // 0.5%
                        const buyFrom = prices[i].price < prices[j].price ? prices[i] : prices[j];
                        const sellTo = prices[i].price > prices[j].price ? prices[i] : prices[j];
                        
                        const estimatedProfit = this.calculateProfit(
                            amount,
                            buyFrom,
                            sellTo
                        );
                        
                        if (estimatedProfit > 0) {
                            opportunities.push({
                                buyDex: buyFrom.dex,
                                sellDex: sellTo.dex,
                                token: baseToken,
                                quoteToken: quoteToken,
                                profitRatio: profitRatio,
                                estimatedProfit: estimatedProfit,
                                requiredCapital: amount,
                                gasEstimate: buyFrom.gasEstimate + sellTo.gasEstimate
                            });
                        }
                    }
                }
            }
        }
        
        return opportunities.sort((a, b) => b.estimatedProfit - a.estimatedProfit);
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h3 id="api-sdk">13.5 å¼€å‘è€…å·¥å…·ä¸SDK</h3>
        
        <div class="practice-section">
            <h4>13.5.1 JavaScript SDK</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">ç¨³å®šå¸SDKå®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// ç¨³å®šå¸JavaScript SDK
import { ethers } from 'ethers';
import { EventEmitter } from 'events';

export class StablecoinSDK extends EventEmitter {
    private provider: ethers.Provider;
    private signer?: ethers.Signer;
    private contracts: Map<string, ethers.Contract> = new Map();
    private config: SDKConfig;
    
    constructor(config: SDKConfig) {
        super();
        this.config = config;
        this.provider = new ethers.JsonRpcProvider(config.rpcUrl);
        
        if (config.privateKey) {
            this.signer = new ethers.Wallet(config.privateKey, this.provider);
        }
        
        this.initializeContracts();
    }
    
    // è¿æ¥é’±åŒ…
    async connect(signer: ethers.Signer): Promise<void> {
        this.signer = signer;
        await this.initializeContracts();
        this.emit('connected', await signer.getAddress());
    }
    
    // è·å–ä½™é¢
    async getBalance(address?: string): Promise<StablecoinBalance> {
        const account = address || await this.signer?.getAddress();
        if (!account) throw new Error('No account connected');
        
        const stablecoin = this.contracts.get('stablecoin');
        const balance = await stablecoin.balanceOf(account);
        const decimals = await stablecoin.decimals();
        
        return {
            raw: balance,
            formatted: ethers.formatUnits(balance, decimals),
            decimals: decimals,
            symbol: await stablecoin.symbol()
        };
    }
    
    // è½¬è´¦
    async transfer(to: string, amount: string): Promise<TransactionResult> {
        const stablecoin = this.contracts.get('stablecoin');
        const decimals = await stablecoin.decimals();
        const amountWei = ethers.parseUnits(amount, decimals);
        
        // ä¼°ç®—gas
        const gasEstimate = await stablecoin.estimateGas.transfer(to, amountWei);
        
        // å‘é€äº¤æ˜“
        const tx = await stablecoin.transfer(to, amountWei, {
            gasLimit: gasEstimate * 120n / 100n // 20%ç¼“å†²
        });
        
        this.emit('transactionSent', tx.hash);
        
        // ç­‰å¾…ç¡®è®¤
        const receipt = await tx.wait();
        
        this.emit('transactionConfirmed', receipt);
        
        return {
            hash: tx.hash,
            blockNumber: receipt.blockNumber,
            gasUsed: receipt.gasUsed,
            status: receipt.status === 1
        };
    }
    
    // æ‰¹å‡†æ”¯å‡º
    async approve(spender: string, amount: string): Promise<TransactionResult> {
        const stablecoin = this.contracts.get('stablecoin');
        const decimals = await stablecoin.decimals();
        const amountWei = ethers.parseUnits(amount, decimals);
        
        const tx = await stablecoin.approve(spender, amountWei);
        const receipt = await tx.wait();
        
        return {
            hash: tx.hash,
            blockNumber: receipt.blockNumber,
            gasUsed: receipt.gasUsed,
            status: receipt.status === 1
        };
    }
    
    // é«˜çº§åŠŸèƒ½ï¼šæ‰¹é‡æ“ä½œ
    async batchTransfer(transfers: BatchTransfer[]): Promise<TransactionResult> {
        const batcher = this.contracts.get('batcher');
        const decimals = await this.contracts.get('stablecoin').decimals();
        
        const recipients = transfers.map(t => t.to);
        const amounts = transfers.map(t => ethers.parseUnits(t.amount, decimals));
        
        const tx = await batcher.batchTransfer(recipients, amounts);
        const receipt = await tx.wait();
        
        return {
            hash: tx.hash,
            blockNumber: receipt.blockNumber,
            gasUsed: receipt.gasUsed,
            status: receipt.status === 1
        };
    }
    
    // ç›‘å¬äº‹ä»¶
    watchTransfers(callback: (transfer: Transfer) => void): () => void {
        const stablecoin = this.contracts.get('stablecoin');
        
        const filter = stablecoin.filters.Transfer();
        const listener = (from: string, to: string, amount: bigint, event: any) => {
            callback({
                from,
                to,
                amount: ethers.formatUnits(amount, this.config.decimals),
                txHash: event.transactionHash,
                blockNumber: event.blockNumber
            });
        };
        
        stablecoin.on(filter, listener);
        
        // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
        return () => {
            stablecoin.off(filter, listener);
        };
    }
    
    // è·å–å†å²äº¤æ˜“
    async getTransactionHistory(
        address: string,
        options?: HistoryOptions
    ): Promise<Transaction[]> {
        const stablecoin = this.contracts.get('stablecoin');
        
        const fromBlock = options?.fromBlock || 0;
        const toBlock = options?.toBlock || 'latest';
        
        // è·å–å‘é€çš„äº¤æ˜“
        const sentFilter = stablecoin.filters.Transfer(address);
        const sentEvents = await stablecoin.queryFilter(sentFilter, fromBlock, toBlock);
        
        // è·å–æ¥æ”¶çš„äº¤æ˜“
        const receivedFilter = stablecoin.filters.Transfer(null, address);
        const receivedEvents = await stablecoin.queryFilter(receivedFilter, fromBlock, toBlock);
        
        // åˆå¹¶å¹¶æ’åº
        const allEvents = [...sentEvents, ...receivedEvents]
            .sort((a, b) => b.blockNumber - a.blockNumber);
        
        return this.formatTransactionEvents(allEvents, address);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>13.5.2 REST APIè®¾è®¡</h4>
            
            <div class="info-box">
                <p><strong>RESTful APIç«¯ç‚¹è®¾è®¡ï¼š</strong></p>
                <pre><code class="language-yaml">openapi: 3.0.0
info:
  title: Stablecoin API
  version: 1.0.0

paths:
  /v1/balance/{address}:
    get:
      summary: è·å–è´¦æˆ·ä½™é¢
      parameters:
        - name: address
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: æˆåŠŸ
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Balance'
                
  /v1/transfer:
    post:
      summary: å‘èµ·è½¬è´¦
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                from:
                  type: string
                to:
                  type: string
                amount:
                  type: string
                signature:
                  type: string
                  
  /v1/transactions/{hash}:
    get:
      summary: æŸ¥è¯¢äº¤æ˜“çŠ¶æ€
      parameters:
        - name: hash
          in: path
          required: true
          schema:
            type: string
            
  /v1/webhook:
    post:
      summary: æ³¨å†Œwebhook
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                url:
                  type: string
                events:
                  type: array
                  items:
                    type: string
                    enum: [transfer, approval, mint, burn]</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">ğŸ’»</span>
                <h4>ç»ƒä¹ 13.1ï¼šæ„å»ºç¨³å®šå¸æ”¯ä»˜ç³»ç»Ÿ</h4>
            </div>
            <p>è®¾è®¡å¹¶å®ç°ä¸€ä¸ªå®Œæ•´çš„ç¨³å®šå¸æ”¯ä»˜ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š</p>
            <ol>
                <li>æ”¯æŒå¤šç§ç¨³å®šå¸çš„æ”¯ä»˜ç½‘å…³</li>
                <li>è‡ªåŠ¨æ±‡ç‡è½¬æ¢åŠŸèƒ½</li>
                <li>å•†æˆ·ç®¡ç†å’Œç»“ç®—ç³»ç»Ÿ</li>
                <li>æ”¯ä»˜çŠ¶æ€å®æ—¶é€šçŸ¥</li>
                <li>é€€æ¬¾å¤„ç†æœºåˆ¶</li>
            </ol>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div class="answer-content">
                <div class="code-block">
                    <div class="code-header" onclick="toggleCode(this)">å®Œæ•´æ”¯ä»˜ç³»ç»Ÿå®ç° <span class="toggle-icon">â–¼</span></div>
                    <div class="code-content" style="display: none;">
                        <pre><code class="language-solidity">// ç¨³å®šå¸æ”¯ä»˜ç³»ç»Ÿä¸»åˆçº¦
contract StablecoinPaymentSystem is Ownable, Pausable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    
    // æ”¯ä»˜çŠ¶æ€
    enum PaymentStatus { Pending, Completed, Refunded, Expired }
    
    // æ”¯ä»˜è®¢å•
    struct PaymentOrder {
        bytes32 orderId;
        address merchant;
        address customer;
        address paymentToken;
        uint256 amount;
        uint256 merchantAmount;
        string fiatCurrency;
        uint256 exchangeRate;
        PaymentStatus status;
        uint256 createdAt;
        uint256 expiresAt;
        string metadata;
    }
    
    // å•†æˆ·ä¿¡æ¯
    struct Merchant {
        string name;
        address payoutAddress;
        address[] acceptedTokens;
        string settlementCurrency;
        uint256 feeRate; // åŸºç‚¹
        bool autoConvert;
        bool isActive;
    }
    
    // å­˜å‚¨
    mapping(bytes32 => PaymentOrder) public orders;
    mapping(address => Merchant) public merchants;
    mapping(address => bool) public supportedStablecoins;
    mapping(string => mapping(address => uint256)) public exchangeRates;
    
    // è´¹ç”¨å’Œç»“ç®—
    address public feeCollector;
    uint256 public baseFeeRate = 30; // 0.3%
    uint256 public constant FEE_DENOMINATOR = 10000;
    
    // èšåˆå™¨å’Œé¢„è¨€æœº
    IAggregator public priceAggregator;
    IOracle public exchangeRateOracle;
    
    event PaymentCreated(bytes32 indexed orderId, address indexed merchant, uint256 amount);
    event PaymentCompleted(bytes32 indexed orderId, address indexed customer, address token);
    event PaymentRefunded(bytes32 indexed orderId, uint256 amount);
    event MerchantSettlement(address indexed merchant, address token, uint256 amount);
    
    // åˆ›å»ºæ”¯ä»˜è®¢å•
    function createPaymentOrder(
        address merchant,
        uint256 fiatAmount,
        string calldata fiatCurrency,
        uint256 validityPeriod,
        string calldata metadata
    ) external returns (bytes32 orderId) {
        require(merchants[merchant].isActive, "Merchant not active");
        require(validityPeriod >= 300, "Validity too short"); // æœ€å°‘5åˆ†é’Ÿ
        
        orderId = keccak256(abi.encodePacked(
            merchant,
            fiatAmount,
            block.timestamp,
            msg.sender
        ));
        
        // è·å–æ±‡ç‡å¹¶è®¡ç®—ç¨³å®šå¸é‡‘é¢
        uint256 rate = exchangeRateOracle.getRate(fiatCurrency, "USD");
        uint256 usdAmount = fiatAmount.mul(rate).div(10**exchangeRateOracle.decimals());
        
        orders[orderId] = PaymentOrder({
            orderId: orderId,
            merchant: merchant,
            customer: address(0), // å¾…æ”¯ä»˜
            paymentToken: address(0), // å¾…é€‰æ‹©
            amount: usdAmount,
            merchantAmount: 0, // å¾…è®¡ç®—
            fiatCurrency: fiatCurrency,
            exchangeRate: rate,
            status: PaymentStatus.Pending,
            createdAt: block.timestamp,
            expiresAt: block.timestamp + validityPeriod,
            metadata: metadata
        });
        
        emit PaymentCreated(orderId, merchant, usdAmount);
    }
    
    // æ‰§è¡Œæ”¯ä»˜
    function pay(
        bytes32 orderId,
        address paymentToken
    ) external nonReentrant {
        PaymentOrder storage order = orders[orderId];
        require(order.status == PaymentStatus.Pending, "Invalid status");
        require(block.timestamp < order.expiresAt, "Order expired");
        require(supportedStablecoins[paymentToken], "Token not supported");
        require(
            _isTokenAcceptedByMerchant(order.merchant, paymentToken),
            "Token not accepted by merchant"
        );
        
        // è®¡ç®—è´¹ç”¨
        uint256 platformFee = order.amount.mul(baseFeeRate).div(FEE_DENOMINATOR);
        uint256 merchantFee = order.amount.mul(merchants[order.merchant].feeRate).div(FEE_DENOMINATOR);
        uint256 totalFee = platformFee.add(merchantFee);
        uint256 merchantAmount = order.amount.sub(totalFee);
        
        // æ›´æ–°è®¢å•
        order.customer = msg.sender;
        order.paymentToken = paymentToken;
        order.merchantAmount = merchantAmount;
        order.status = PaymentStatus.Completed;
        
        // æ‰§è¡Œè½¬è´¦
        IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), order.amount);
        
        // åˆ†é…è´¹ç”¨
        if (platformFee > 0) {
            IERC20(paymentToken).safeTransfer(feeCollector, platformFee);
        }
        
        // å¤„ç†å•†æˆ·ç»“ç®—
        if (merchants[order.merchant].autoConvert) {
            _processAutoConversion(order);
        } else {
            _settleMerchant(order.merchant, paymentToken, merchantAmount);
        }
        
        emit PaymentCompleted(orderId, msg.sender, paymentToken);
    }
    
    // è‡ªåŠ¨è½¬æ¢å’Œç»“ç®—
    function _processAutoConversion(PaymentOrder memory order) private {
        Merchant memory merchant = merchants[order.merchant];
        
        // é€šè¿‡èšåˆå™¨æ‰¾åˆ°æœ€ä½³å…‘æ¢è·¯å¾„
        (address[] memory path, uint256 expectedOutput) = priceAggregator.getBestPath(
            order.paymentToken,
            merchant.settlementCurrency,
            order.merchantAmount
        );
        
        // æ‰§è¡Œå…‘æ¢
        IERC20(order.paymentToken).safeApprove(address(priceAggregator), order.merchantAmount);
        uint256 outputAmount = priceAggregator.swap(
            order.paymentToken,
            merchant.settlementCurrency,
            order.merchantAmount,
            expectedOutput.mul(98).div(100), // 2%æ»‘ç‚¹ä¿æŠ¤
            path
        );
        
        // ç»“ç®—ç»™å•†æˆ·
        _settleMerchant(order.merchant, merchant.settlementCurrency, outputAmount);
    }
    
    // é€€æ¬¾åŠŸèƒ½
    function refund(bytes32 orderId) external nonReentrant {
        PaymentOrder storage order = orders[orderId];
        require(order.status == PaymentStatus.Completed, "Cannot refund");
        require(msg.sender == order.merchant || msg.sender == owner(), "Unauthorized");
        require(block.timestamp < order.createdAt + 30 days, "Refund period expired");
        
        order.status = PaymentStatus.Refunded;
        
        // ä»å•†æˆ·æ‰£é™¤é€€æ¬¾é‡‘é¢ï¼ˆéœ€è¦å•†æˆ·é¢„å…ˆæˆæƒï¼‰
        IERC20(order.paymentToken).safeTransferFrom(
            order.merchant,
            order.customer,
            order.amount
        );
        
        emit PaymentRefunded(orderId, order.amount);
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="summary-box">
            <h3>æœ¬ç« å°ç»“</h3>
            <p>ç¨³å®šå¸ç”Ÿæ€ç³»ç»Ÿé›†æˆæ˜¯å®ç°å¹¿æ³›åº”ç”¨çš„å…³é”®ã€‚æœ¬ç« ä»‹ç»äº†ï¼š</p>
            <ul>
                <li><strong>é’±åŒ…é›†æˆ</strong>ï¼šæ”¯æŒå¤šç§é’±åŒ…æ ‡å‡†ï¼Œä¼˜åŒ–ç”¨æˆ·ä½“éªŒ</li>
                <li><strong>æ”¯ä»˜ç½‘å…³</strong>ï¼šå•†æˆ·æ¥å…¥ã€è‡ªåŠ¨ç»“ç®—ã€å¤šå¸ç§æ”¯æŒ</li>
                <li><strong>è·¨é“¾æ¡¥æ¥</strong>ï¼šå®ç°èµ„äº§åœ¨ä¸åŒåŒºå—é“¾é—´çš„æµåŠ¨</li>
                <li><strong>DeFièšåˆ</strong>ï¼šé›†æˆä¸»æµèšåˆå™¨ï¼Œä¼˜åŒ–äº¤æ˜“è·¯å¾„</li>
                <li><strong>å¼€å‘è€…å·¥å…·</strong>ï¼šæä¾›æ˜“ç”¨çš„SDKå’ŒAPI</li>
            </ul>
            
            <p>æˆåŠŸçš„ç¨³å®šå¸é¡¹ç›®éœ€è¦æ„å»ºå®Œæ•´çš„ç”Ÿæ€ç³»ç»Ÿï¼Œä¸ä»…è¦æœ‰ä¼˜ç§€çš„æ ¸å¿ƒåè®®ï¼Œè¿˜éœ€è¦ä¾¿æ·çš„é›†æˆå·¥å…·ã€ä¸°å¯Œçš„åº”ç”¨åœºæ™¯å’Œæ´»è·ƒçš„å¼€å‘è€…ç¤¾åŒºã€‚é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ åº”è¯¥èƒ½å¤Ÿè®¾è®¡å’Œå®ç°ç¨³å®šå¸ä¸å„ç§åŸºç¡€è®¾æ–½çš„é›†æˆæ–¹æ¡ˆã€‚</p>
        
            
            <!-- ç« èŠ‚å¯¼èˆª -->
            <div class="chapter-nav">
                <a href="chapter12.html">â† ç¬¬12ç« </a>
                <a href="index.html">è¿”å›é¦–é¡µ â†’</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>