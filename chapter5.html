<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬äº”ç« ï¼šæ•°å­¦æ¨¡å‹ä¸æ§åˆ¶ç†è®º - åŒºå—é“¾ç¨³å®šå¸æ•™ç¨‹</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">ç¨³å®šå¸æ•™ç¨‹</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">â˜°</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">é¦–é¡µ</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">å¼•è¨€</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">ç« èŠ‚</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">ç¬¬1ç« ï¼šåŒºå—é“¾åŸºç¡€</a>
                        <a href="chapter2.html" class="dropdown-item">ç¬¬2ç« ï¼šç¨³å®šå¸åˆ†ç±»</a>
                        <a href="chapter3.html" class="dropdown-item">ç¬¬3ç« ï¼šERC-20æ ‡å‡†</a>
                        <a href="chapter4.html" class="dropdown-item">ç¬¬4ç« ï¼šæŠµæŠ¼å‹è®¾è®¡</a>
                        <a href="chapter5.html" class="dropdown-item">ç¬¬5ç« ï¼šæ•°å­¦æ¨¡å‹</a>
                        <a href="chapter6.html" class="dropdown-item">ç¬¬6ç« ï¼šAMMé›†æˆ</a>
                        <a href="chapter7.html" class="dropdown-item">ç¬¬7ç« ï¼šå€Ÿè´·åè®®</a>
                        <a href="chapter8.html" class="dropdown-item">ç¬¬8ç« ï¼šæ”¶ç›Šç­–ç•¥</a>
                        <a href="chapter9.html" class="dropdown-item">ç¬¬9ç« ï¼šæ™ºèƒ½åˆçº¦å®‰å…¨</a>
                        <a href="chapter10.html" class="dropdown-item">ç¬¬10ç« ï¼šç»æµæ”»å‡»</a>
                        <a href="chapter11.html" class="dropdown-item">ç¬¬11ç« ï¼šæœªæ¥æ–¹å‘</a>
                        <a href="chapter12.html" class="dropdown-item">ç¬¬12ç« ï¼šç”Ÿäº§éƒ¨ç½²</a>
                        <a href="chapter13.html" class="dropdown-item">ç¬¬13ç« ï¼šç”Ÿæ€é›†æˆ</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="#resources" class="nav-link">èµ„æº</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- å¤´éƒ¨ -->
    <header id="top">
        <div class="container">
            <h1>ç¬¬äº”ç« ï¼šæ•°å­¦æ¨¡å‹ä¸æ§åˆ¶ç†è®º</h1>
        </div>
    </header>
    
    <!-- ä¸»è¦å†…å®¹ -->
    <div class="container">
        <div class="chapter">
<h2>ç¬¬äº”ç« ï¼šæ•°å­¦æ¨¡å‹ä¸æ§åˆ¶ç†è®º</h2>
        
        <p>ç»è¿‡å‰å››ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å·²ç»æŒæ¡äº†ç¨³å®šå¸çš„åŸºç¡€çŸ¥è¯†ã€åˆ†ç±»æ–¹æ³•ã€æŠ€æœ¯æ ‡å‡†å’ŒæŠµæŠ¼æœºåˆ¶ã€‚ç„¶è€Œï¼Œè¦è®¾è®¡ä¸€ä¸ªçœŸæ­£ç¨³å¥çš„ç¨³å®šå¸ç³»ç»Ÿï¼Œä»…æœ‰è¿™äº›è¿˜ä¸å¤Ÿã€‚æœ¬ç« å°†å¼•å…¥æ¥è‡ªæ§åˆ¶ç†è®ºã€åšå¼ˆè®ºå’Œé‡‘èå·¥ç¨‹çš„æ•°å­¦æ¨¡å‹ï¼Œä¸ºç¨³å®šå¸è®¾è®¡æä¾›ä¸¥æ ¼çš„ç†è®ºåŸºç¡€ã€‚ä»PIDæ§åˆ¶å™¨åˆ°Black-Scholesæ¨¡å‹ï¼Œä»åšå¼ˆè®ºåˆ†æåˆ°è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿï¼Œè¿™äº›çœ‹ä¼¼æŠ½è±¡çš„æ•°å­¦å·¥å…·å°†å¸®åŠ©æˆ‘ä»¬ç†è§£å’Œä¼˜åŒ–ç¨³å®šå¸çš„åŠ¨æ€è¡Œä¸ºï¼Œé¢„æµ‹ç³»ç»Ÿåœ¨æç«¯æƒ…å†µä¸‹çš„è¡¨ç°ï¼Œå¹¶è®¾è®¡å‡ºæ›´åŠ ç¨³å¥çš„æœºåˆ¶ã€‚</p>
        
        <div class="intro-box">
            <strong>æœ¬ç« æ¦‚è§ˆï¼š</strong>
            <ul>
                <li>PIDæ§åˆ¶å™¨åœ¨ç®—æ³•ç¨³å®šå¸ä¸­çš„åº”ç”¨</li>
                <li>æ¸…ç®—åšå¼ˆè®ºä¸æœ€ä¼˜ç­–ç•¥åˆ†æ</li>
                <li>Black-ScholesæœŸæƒå®šä»·æ¨¡å‹åœ¨æŠµæŠ¼ç‡è®¾è®¡ä¸­çš„åº”ç”¨</li>
                <li>å¸‚åœºå‹åŠ›æµ‹è¯•ä¸è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ</li>
                <li>å®æˆ˜ï¼šæ„å»ºç¨³å®šå¸å‚æ•°ä¼˜åŒ–å¼•æ“</li>
            </ul>
        </div>
        
        <div class="tip-box">
            <strong>ğŸ¯ ç« èŠ‚ç›®æ ‡ï¼š</strong>
            <p>æœ¬ç« å°†æ·±å…¥æ¢è®¨ç¨³å®šå¸ç³»ç»ŸèƒŒåçš„æ•°å­¦åŸç†ã€‚å¯¹äºAIç§‘å­¦å®¶å’Œèµ„æ·±ç¨‹åºå‘˜ï¼Œè¿™äº›æ•°å­¦æ¨¡å‹ä¸ä»…æ˜¯ç†è®ºå·¥å…·ï¼Œæ›´æ˜¯è®¾è®¡å’Œä¼˜åŒ–ç¨³å®šå¸ç³»ç»Ÿçš„å®ç”¨æ–¹æ³•ã€‚æˆ‘ä»¬å°†é€šè¿‡å®é™…ä»£ç å’Œæ•°æ®åˆ†æï¼Œå±•ç¤ºå¦‚ä½•å°†è¿™äº›ç†è®ºåº”ç”¨äºå®è·µã€‚</p>
        </div>

        <div class="info-box">
            <h4>ğŸ“Š é“¾ä¸Šç¯å¢ƒä¸ç†è®ºæ¨¡å‹çš„å·®å¼‚</h4>
            <p>åœ¨å°†ç»å…¸æ§åˆ¶ç†è®ºå’Œé‡‘èæ¨¡å‹åº”ç”¨äºåŒºå—é“¾æ—¶ï¼Œéœ€è¦è€ƒè™‘ä»¥ä¸‹å…³é”®å·®å¼‚ï¼š</p>
            <ul>
                <li><strong>ç¦»æ•£æ—¶é—´ vs è¿ç»­æ—¶é—´ï¼š</strong>åŒºå—é“¾ä»¥åŒºå—ä¸ºå•ä½æ›´æ–°ï¼Œè€Œéè¿ç»­</li>
                <li><strong>å®šç‚¹æ•° vs æµ®ç‚¹æ•°ï¼š</strong>Solidityç¼ºä¹åŸç”Ÿæµ®ç‚¹æ”¯æŒï¼Œéœ€è¦ç²¾åº¦æƒè¡¡</li>
                <li><strong>Gasé™åˆ¶ï¼š</strong>å¤æ‚è®¡ç®—å¯èƒ½è¶…å‡ºå•ç¬”äº¤æ˜“çš„Gasä¸Šé™</li>
                <li><strong>é¢„è¨€æœºå»¶è¿Ÿï¼š</strong>ä»·æ ¼æ•°æ®å­˜åœ¨å»¶è¿Ÿå’Œæ½œåœ¨çš„æ“çºµé£é™©</li>
                <li><strong>MEVå½±å“ï¼š</strong>å‚æ•°æ›´æ–°å¯èƒ½è¢«æŠ¢å…ˆäº¤æ˜“åˆ©ç”¨</li>
            </ul>
        </div>

        <h3>5.1 PIDæ§åˆ¶å™¨åœ¨ç®—æ³•ç¨³å®šå¸ä¸­çš„åº”ç”¨</h3>
        
        <h4>5.1.1 æ§åˆ¶ç†è®ºåŸºç¡€</h4>
        <p>PIDï¼ˆæ¯”ä¾‹-ç§¯åˆ†-å¾®åˆ†ï¼‰æ§åˆ¶å™¨æ˜¯å·¥ä¸šæ§åˆ¶ä¸­æœ€å¸¸ç”¨çš„åé¦ˆæ§åˆ¶å™¨ã€‚åœ¨ç¨³å®šå¸ç³»ç»Ÿä¸­ï¼ŒPIDæ§åˆ¶å™¨å¯ä»¥ç”¨æ¥åŠ¨æ€è°ƒæ•´å‚æ•°ä»¥ç»´æŒä»·æ ¼ç¨³å®šã€‚</p>
        
        <div class="tip">
            ğŸ’¡ <strong>å…³é”®æ´å¯Ÿï¼š</strong>ç¨³å®šå¸ä»·æ ¼ç¨³å®šé—®é¢˜æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæ§åˆ¶ç³»ç»Ÿé—®é¢˜ï¼šæˆ‘ä»¬éœ€è¦é€šè¿‡è°ƒæ•´ç³»ç»Ÿå‚æ•°ï¼ˆå¦‚ç¨³å®šè´¹ç‡ã€æŠµæŠ¼ç‡ç­‰ï¼‰æ¥ä½¿è¾“å‡ºï¼ˆç¨³å®šå¸ä»·æ ¼ï¼‰è·Ÿè¸ªå‚è€ƒå€¼ï¼ˆ1ç¾å…ƒï¼‰ã€‚
        </div>
        
        <h4>5.1.2 PIDæ§åˆ¶å™¨æ•°å­¦æ¨¡å‹</h4>
        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <p><strong>è¿ç»­æ—¶é—´PIDæ§åˆ¶å™¨ï¼š</strong></p>
            <p style="text-align: center; font-size: 1.2em;">
                u(t) = K<sub>p</sub>e(t) + K<sub>i</sub>âˆ«<sub>0</sub><sup>t</sup>e(Ï„)dÏ„ + K<sub>d</sub>de(t)/dt
            </p>
            
            <p><strong>ç¦»æ•£æ—¶é—´PIDæ§åˆ¶å™¨ï¼ˆåŒºå—é“¾é€‚ç”¨ï¼‰ï¼š</strong></p>
            <p style="text-align: center; font-size: 1.2em;">
                u[k] = K<sub>p</sub>e[k] + K<sub>i</sub>T<sub>s</sub>Î£<sub>j=0</sub><sup>k</sup>e[j] + K<sub>d</sub>(e[k]-e[k-1])/T<sub>s</sub>
            </p>
            
            <p>å…¶ä¸­ï¼š</p>
            <ul>
                <li><strong>e(t) / e[k]</strong> = è¯¯å·®ä¿¡å· = å‚è€ƒå€¼(r) - å®é™…å€¼(y)</li>
                <li><strong>K<sub>p</sub></strong> = æ¯”ä¾‹å¢ç›Šï¼ˆå¿«é€Ÿå“åº”ï¼‰</li>
                <li><strong>K<sub>i</sub></strong> = ç§¯åˆ†å¢ç›Šï¼ˆæ¶ˆé™¤ç¨³æ€è¯¯å·®ï¼‰</li>
                <li><strong>K<sub>d</sub></strong> = å¾®åˆ†å¢ç›Šï¼ˆé¢„æµ‹æœªæ¥ï¼Œå‡å°‘è¶…è°ƒï¼‰</li>
                <li><strong>T<sub>s</sub></strong> = é‡‡æ ·æ—¶é—´ï¼ˆåŒºå—æ—¶é—´ï¼‰</li>
                <li><strong>u(t) / u[k]</strong> = æ§åˆ¶è¾“å‡º</li>
            </ul>
        </div>
        
        <h4>5.1.3 Pythonæ¨¡æ‹Ÿç¯å¢ƒ</h4>
        <p>åœ¨å®ç°é“¾ä¸Šç‰ˆæœ¬å‰ï¼Œæˆ‘ä»¬å…ˆç”¨Pythonå»ºç«‹ç›´è§‚ç†è§£ï¼š</p>
        
        <div class="code-block">
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import pandas as pd

class PIDController:
    """ç¨³å®šå¸ä»·æ ¼PIDæ§åˆ¶å™¨æ¨¡æ‹Ÿ"""
    
    def __init__(self, Kp=0.01, Ki=0.001, Kd=0.005, 
                 target=1.0, dt=15.0, deadband=0.001):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.target = target
        self.dt = dt  # åŒºå—æ—¶é—´ï¼ˆç§’ï¼‰
        self.deadband = deadband
        
        # çŠ¶æ€å˜é‡
        self.integral = 0
        self.last_error = 0
        self.output_limits = (-0.05, 0.05)  # Â±5%è°ƒæ•´é™åˆ¶
        
    def update(self, current_price):
        """è®¡ç®—PIDè¾“å‡º"""
        error = self.target - current_price
        
        # æ­»åŒºå¤„ç†
        if abs(error) < self.deadband:
            return 0
        
        # Pé¡¹
        P = self.Kp * error
        
        # Ié¡¹ï¼ˆå¸¦æŠ—ç§¯åˆ†é¥±å’Œï¼‰
        self.integral += error * self.dt
        # ç§¯åˆ†é™å¹…
        integral_limit = self.output_limits[1] / self.Ki
        self.integral = np.clip(self.integral, -integral_limit, integral_limit)
        I = self.Ki * self.integral
        
        # Dé¡¹ï¼ˆå¸¦æ»¤æ³¢ï¼‰
        if self.dt > 0:
            derivative = (error - self.last_error) / self.dt
            D = self.Kd * derivative
        else:
            D = 0
            
        # è®¡ç®—æ€»è¾“å‡º
        output = P + I + D
        
        # è¾“å‡ºé™å¹…
        output = np.clip(output, self.output_limits[0], self.output_limits[1])
        
        # æ›´æ–°çŠ¶æ€
        self.last_error = error
        
        return output
    
    def reset(self):
        """é‡ç½®æ§åˆ¶å™¨çŠ¶æ€"""
        self.integral = 0
        self.last_error = 0

# å‚æ•°è‡ªåŠ¨è°ƒä¼˜ - Ziegler-Nicholsæ–¹æ³•
def ziegler_nichols_tuning(system_response):
    """
    åŸºäºç³»ç»Ÿé˜¶è·ƒå“åº”çš„Ziegler-Nicholsè°ƒå‚
    è¿”å›æ¨èçš„PIDå‚æ•°
    """
    # æ‰¾åˆ°æœ€å¤§æ–œç‡ç‚¹
    max_slope_idx = np.argmax(np.gradient(system_response))
    max_slope = np.gradient(system_response)[max_slope_idx]
    
    # ä¼°è®¡å»¶è¿Ÿå’Œæ—¶é—´å¸¸æ•°
    L = max_slope_idx * 0.1  # å‡è®¾0.1ç§’é‡‡æ ·
    T = len(system_response) * 0.1 / 3  # ç²—ç•¥ä¼°è®¡
    
    # Ziegler-Nichols PIDå‚æ•°
    Kp = 1.2 * T / L
    Ki = Kp / (2 * L)
    Kd = Kp * L / 2
    
    return Kp, Ki, Kd

# æ¨¡æ‹Ÿç¨³å®šå¸ç³»ç»Ÿ
def simulate_stablecoin_system(controller, market_shocks, blocks=1000):
    """
    æ¨¡æ‹Ÿç¨³å®šå¸ä»·æ ¼æ§åˆ¶ç³»ç»Ÿ
    åŒ…å«å¸‚åœºå†²å‡»å’Œå™ªå£°
    """
    prices = [1.0]  # åˆå§‹ä»·æ ¼$1
    rates = [0.02]  # åˆå§‹ç¨³å®šè´¹ç‡2%
    
    for i in range(blocks):
        # å½“å‰ä»·æ ¼ = ä¸Šä¸€ä»·æ ¼ + å¸‚åœºåŠ›é‡ + å™ªå£°
        market_pressure = market_shocks[i] if i < len(market_shocks) else 0
        noise = np.random.normal(0, 0.001)  # 0.1%æ ‡å‡†å·®çš„å™ªå£°
        
        # ç¨³å®šè´¹ç‡å¯¹ä»·æ ¼çš„å½±å“ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
        rate_effect = -rates[-1] * 0.1  # è´¹ç‡è¶Šé«˜ï¼Œå–å‹è¶Šå¤§
        
        new_price = prices[-1] + market_pressure + noise + rate_effect
        
        # PIDæ§åˆ¶å™¨è¾“å‡º
        rate_adjustment = controller.update(new_price)
        new_rate = max(0, rates[-1] + rate_adjustment)  # è´¹ç‡ä¸èƒ½ä¸ºè´Ÿ
        
        prices.append(new_price)
        rates.append(new_rate)
    
    return np.array(prices), np.array(rates)

# è¿è¡Œæ¨¡æ‹Ÿ
if __name__ == "__main__":
    # åˆ›å»ºå¸‚åœºå†²å‡»åœºæ™¯
    market_shocks = np.zeros(1000)
    market_shocks[100:150] = -0.02  # 5%çš„æŒç»­å–å‹
    market_shocks[500] = -0.05      # 5%çš„ç¬é—´å†²å‡»
    market_shocks[700:750] = 0.01   # 1%çš„ä¹°å‹
    
    # åˆ›å»ºæ§åˆ¶å™¨
    pid = PIDController(Kp=0.02, Ki=0.002, Kd=0.01)
    
    # è¿è¡Œæ¨¡æ‹Ÿ
    prices, rates = simulate_stablecoin_system(pid, market_shocks)
    
    # å¯è§†åŒ–ç»“æœ
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
    
    # ä»·æ ¼å›¾
    ax1.plot(prices, label='ç¨³å®šå¸ä»·æ ¼')
    ax1.axhline(y=1.0, color='r', linestyle='--', label='ç›®æ ‡ä»·æ ¼ $1')
    ax1.fill_between(range(len(prices)), 0.99, 1.01, alpha=0.3, color='green')
    ax1.set_ylabel('ä»·æ ¼ (USD)')
    ax1.set_title('PIDæ§åˆ¶ä¸‹çš„ç¨³å®šå¸ä»·æ ¼')
    ax1.legend()
    ax1.grid(True)
    
    # è´¹ç‡å›¾
    ax2.plot(rates * 100, label='ç¨³å®šè´¹ç‡')
    ax2.set_xlabel('åŒºå—æ•°')
    ax2.set_ylabel('è´¹ç‡ (%)')
    ax2.set_title('åŠ¨æ€è°ƒæ•´çš„ç¨³å®šè´¹ç‡')
    ax2.legend()
    ax2.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    rmse = np.sqrt(np.mean((prices - 1.0)**2))
    max_deviation = np.max(np.abs(prices - 1.0))
    settling_time = np.argmax(np.abs(prices[100:] - 1.0) < 0.01) if any(np.abs(prices[100:] - 1.0) < 0.01) else len(prices)
    
    print(f"RMSE: {rmse:.4f}")
    print(f"æœ€å¤§åç¦»: {max_deviation:.4f}")
    print(f"ç¨³å®šæ—¶é—´: {settling_time} åŒºå—")</code></pre>
        </div>
        
        <h4>5.1.4 é«˜çº§æ§åˆ¶æ¨¡å‹å±•æœ›</h4>
        <div class="info-box">
            <h5>ğŸš€ è¶…è¶ŠPIDï¼šä¸‹ä¸€ä»£æ§åˆ¶ç­–ç•¥</h5>
            <p>è™½ç„¶PIDæ§åˆ¶å™¨ç®€å•æœ‰æ•ˆï¼Œä½†ç°ä»£æ§åˆ¶ç†è®ºæä¾›äº†æ›´å¼ºå¤§çš„å·¥å…·ï¼š</p>
            
            <ul>
                <li><strong>æ¨¡å‹é¢„æµ‹æ§åˆ¶ï¼ˆMPCï¼‰ï¼š</strong>è€ƒè™‘æœªæ¥å¤šæ­¥é¢„æµ‹ï¼Œä¼˜åŒ–æ§åˆ¶åºåˆ—
                    <pre><code class="language-python"># MPCä¼ªä»£ç 
def mpc_controller(current_state, prediction_horizon=10):
    # é¢„æµ‹æœªæ¥çŠ¶æ€
    future_states = predict_system_evolution(current_state, horizon)
    # ä¼˜åŒ–æ§åˆ¶åºåˆ—
    optimal_controls = optimize_control_sequence(future_states)
    # åªæ‰§è¡Œç¬¬ä¸€æ­¥
    return optimal_controls[0]</code></pre>
                </li>
                
                <li><strong>å¼ºåŒ–å­¦ä¹ ï¼ˆRLï¼‰æ§åˆ¶å™¨ï¼š</strong>é€šè¿‡ä¸ç¯å¢ƒäº¤äº’å­¦ä¹ æœ€ä¼˜ç­–ç•¥
                    <pre><code class="language-python"># RLæ§åˆ¶å™¨æ¦‚å¿µ
class RLStablecoinController:
    def __init__(self):
        self.q_network = build_neural_network()
        self.replay_buffer = []
    
    def get_action(self, state):
        # Îµ-è´ªå¿ƒç­–ç•¥
        if random.random() < self.epsilon:
            return random_action()
        return self.q_network.predict(state)</code></pre>
                </li>
                
                <li><strong>è‡ªé€‚åº”æ§åˆ¶ï¼š</strong>å®æ—¶è°ƒæ•´æ§åˆ¶å™¨å‚æ•°
                    <ul>
                        <li>é€’å½’æœ€å°äºŒä¹˜ï¼ˆRLSï¼‰å‚æ•°ä¼°è®¡</li>
                        <li>å¡å°”æ›¼æ»¤æ³¢çŠ¶æ€ä¼°è®¡</li>
                        <li>è´å¶æ–¯ä¼˜åŒ–å‚æ•°è°ƒä¼˜</li>
                    </ul>
                </li>
            </ul>
            
            <p><strong>æŒ‘æˆ˜ï¼š</strong>è¿™äº›é«˜çº§æ–¹æ³•åœ¨é“¾ä¸Šå®ç°é¢ä¸´Gasæˆæœ¬å’Œè®¡ç®—å¤æ‚åº¦é™åˆ¶ï¼Œé€šå¸¸éœ€è¦é“¾ä¸‹è®¡ç®—+é“¾ä¸ŠéªŒè¯çš„æ··åˆæ¶æ„ã€‚</p>
        </div>
        
        <h4>5.1.5 Solidityå®ç°</h4>
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">PIDæ§åˆ¶å™¨å®Œæ•´å®ç° <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PIDController {
    // PIDå‚æ•°
    int256 public Kp = 1e16;      // æ¯”ä¾‹ç³»æ•° (0.01)
    int256 public Ki = 1e15;      // ç§¯åˆ†ç³»æ•° (0.001)
    int256 public Kd = 5e15;      // å¾®åˆ†ç³»æ•° (0.005)
    
    // çŠ¶æ€å˜é‡
    int256 public integral;        // ç§¯åˆ†é¡¹
    int256 public lastError;       // ä¸Šæ¬¡è¯¯å·®
    uint256 public lastTime;       // ä¸Šæ¬¡æ›´æ–°æ—¶é—´
    
    // ç›®æ ‡ä»·æ ¼å’Œç•Œé™
    uint256 public constant TARGET_PRICE = 1e18;  // 1 USD
    int256 public constant MAX_OUTPUT = 5e16;     // æœ€å¤§è°ƒæ•´5%
    int256 public constant MIN_OUTPUT = -5e16;    // æœ€å°è°ƒæ•´-5%
    
    // æ­»åŒºè®¾ç½®ï¼ˆå‡å°‘é¢‘ç¹è°ƒæ•´ï¼‰
    uint256 public constant DEADBAND = 1e15;      // 0.1%æ­»åŒº
    
    // è®¡ç®—PIDè¾“å‡º
    function computePID(uint256 currentPrice) public returns (int256) {
        require(currentPrice > 0, "Invalid price");
        
        uint256 currentTime = block.timestamp;
        uint256 deltaTime = currentTime - lastTime;
        
        // è®¡ç®—è¯¯å·®ï¼ˆå¯ä»¥ä¸ºè´Ÿï¼‰
        int256 error = int256(TARGET_PRICE) - int256(currentPrice);
        
        // æ­»åŒºå¤„ç†
        if (abs(error) < int256(DEADBAND)) {
            return 0;
        }
        
        // è®¡ç®—PIDå„é¡¹
        int256 proportional = Kp * error / 1e18;
        
        // ç§¯åˆ†é¡¹ï¼ˆå¸¦æŠ—ç§¯åˆ†é¥±å’Œï¼‰
        integral += error * int256(deltaTime);
        // é™åˆ¶ç§¯åˆ†é¡¹é˜²æ­¢ç§¯åˆ†é¥±å’Œ
        if (integral > MAX_OUTPUT * 1e18 / Ki) {
            integral = MAX_OUTPUT * 1e18 / Ki;
        } else if (integral < MIN_OUTPUT * 1e18 / Ki) {
            integral = MIN_OUTPUT * 1e18 / Ki;
        }
        int256 integralTerm = Ki * integral / 1e18;
        
        // å¾®åˆ†é¡¹ï¼ˆå¸¦æ»¤æ³¢ï¼‰
        int256 derivative = 0;
        if (deltaTime > 0) {
            derivative = Kd * (error - lastError) * 1e18 / int256(deltaTime);
        }
        
        // è®¡ç®—æ€»è¾“å‡º
        int256 output = proportional + integralTerm + derivative;
        
        // è¾“å‡ºé™å¹…
        if (output > MAX_OUTPUT) {
            output = MAX_OUTPUT;
        } else if (output < MIN_OUTPUT) {
            output = MIN_OUTPUT;
        }
        
        // æ›´æ–°çŠ¶æ€
        lastError = error;
        lastTime = currentTime;
        
        emit PIDComputed(currentPrice, error, output);
        
        return output;
    }
    
    // å‚æ•°è‡ªé€‚åº”è°ƒæ•´
    function adaptiveParameterTuning(
        uint256 volatility,
        uint256 volume
    ) external {
        // é«˜æ³¢åŠ¨æ€§æ—¶å¢åŠ Kdï¼Œå‡å°‘Ki
        if (volatility > 2e16) { // 2%æ³¢åŠ¨ç‡
            Kd = Kd * 12 / 10;    // å¢åŠ 20%
            Ki = Ki * 8 / 10;     // å‡å°‘20%
        }
        
        // ä½äº¤æ˜“é‡æ—¶å‡å°‘æ‰€æœ‰å¢ç›Š
        if (volume < 1e6 * 1e18) { // å°‘äº100ä¸‡ç¾å…ƒ
            Kp = Kp * 9 / 10;
            Ki = Ki * 9 / 10;
            Kd = Kd * 9 / 10;
        }
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ç»å¯¹å€¼
    function abs(int256 x) private pure returns (int256) {
        return x >= 0 ? x : -x;
    }
    
    event PIDComputed(uint256 price, int256 error, int256 output);
}</code></pre>
            </div>
        </div>
        
        <h4>5.1.6 ç¨³å®šè´¹ç‡åŠ¨æ€è°ƒæ•´</h4>
        <p>å°†PIDæ§åˆ¶å™¨åº”ç”¨äºç¨³å®šè´¹ç‡è°ƒæ•´ï¼Œå®ç°ä»·æ ¼çš„è‡ªåŠ¨ç¨³å®šï¼š</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">ç¨³å®šè´¹ç‡æ§åˆ¶ç³»ç»Ÿ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract StabilityFeeController {
    PIDController public pidController;
    IPriceOracle public priceOracle;
    
    // è´¹ç‡å‚æ•°
    uint256 public baseRate = 2e16;        // åŸºç¡€è´¹ç‡2%
    uint256 public currentRate;            // å½“å‰è´¹ç‡
    uint256 public minRate = 0;            // æœ€ä½è´¹ç‡0%
    uint256 public maxRate = 20e16;        // æœ€é«˜è´¹ç‡20%
    
    // æ›´æ–°é¢‘ç‡æ§åˆ¶
    uint256 public lastUpdate;
    uint256 public constant UPDATE_INTERVAL = 1 hours;
    
    // å†å²æ•°æ®è®°å½•ï¼ˆç”¨äºåˆ†æï¼‰
    struct RateHistory {
        uint256 timestamp;
        uint256 price;
        uint256 rate;
        int256 adjustment;
    }
    
    RateHistory[] public rateHistory;
    
    function updateStabilityFee() external {
        require(block.timestamp >= lastUpdate + UPDATE_INTERVAL, "Too frequent");
        
        // è·å–å½“å‰ä»·æ ¼ï¼ˆå¯èƒ½æ˜¯TWAPï¼‰
        uint256 currentPrice = priceOracle.getPrice();
        
        // è®¡ç®—PIDè¾“å‡º
        int256 adjustment = pidController.computePID(currentPrice);
        
        // åº”ç”¨è°ƒæ•´
        if (adjustment > 0) {
            currentRate = currentRate + uint256(adjustment);
        } else {
            uint256 decrease = uint256(-adjustment);
            currentRate = currentRate > decrease ? currentRate - decrease : 0;
        }
        
        // é™åˆ¶èŒƒå›´
        if (currentRate > maxRate) {
            currentRate = maxRate;
        } else if (currentRate < minRate) {
            currentRate = minRate;
        }
        
        // è®°å½•å†å²
        rateHistory.push(RateHistory({
            timestamp: block.timestamp,
            price: currentPrice,
            rate: currentRate,
            adjustment: adjustment
        }));
        
        // æ›´æ–°CDPç³»ç»Ÿçš„è´¹ç‡
        cdpEngine.updateStabilityFee(currentRate);
        
        lastUpdate = block.timestamp;
        
        emit StabilityFeeUpdated(currentRate, adjustment, currentPrice);
    }
    
    // è·å–ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
    function getPerformanceMetrics(uint256 periods) 
        external 
        view 
        returns (
            uint256 avgPrice,
            uint256 priceStdDev,
            uint256 avgRate,
            uint256 adjustmentCount
        ) 
    {
        require(periods > 0 && periods <= rateHistory.length, "Invalid periods");
        
        uint256 startIdx = rateHistory.length - periods;
        uint256 sumPrice;
        uint256 sumRate;
        uint256 sumSquaredDev;
        
        // è®¡ç®—å¹³å‡å€¼
        for (uint256 i = startIdx; i < rateHistory.length; i++) {
            sumPrice += rateHistory[i].price;
            sumRate += rateHistory[i].rate;
            if (rateHistory[i].adjustment != 0) {
                adjustmentCount++;
            }
        }
        
        avgPrice = sumPrice / periods;
        avgRate = sumRate / periods;
        
        // è®¡ç®—æ ‡å‡†å·®
        for (uint256 i = startIdx; i < rateHistory.length; i++) {
            int256 deviation = int256(rateHistory[i].price) - int256(avgPrice);
            sumSquaredDev += uint256(deviation * deviation);
        }
        
        priceStdDev = sqrt(sumSquaredDev / periods);
    }
    
    // å¹³æ–¹æ ¹å‡½æ•°ï¼ˆç”¨äºæ ‡å‡†å·®è®¡ç®—ï¼‰
    function sqrt(uint256 x) private pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}</code></pre>
            </div>
        </div>
        
        <h3>5.2 é¢„è¨€æœºå®‰å…¨ä¸æ²»ç†</h3>
        
        <h4>5.2.1 é¢„è¨€æœºåœ¨ç¨³å®šå¸ç³»ç»Ÿä¸­çš„å…³é”®ä½œç”¨</h4>
        <p>é¢„è¨€æœºæ˜¯ç¨³å®šå¸ç³»ç»Ÿçš„"çœ¼ç›"ï¼Œæä¾›é“¾å¤–ä¸–ç•Œçš„ä»·æ ¼æ•°æ®ã€‚å…¶å®‰å…¨æ€§ç›´æ¥å½±å“æ•´ä¸ªç³»ç»Ÿçš„ç¨³å®šæ€§ã€‚</p>
        
        <div class="info-box">
            <h5>âš ï¸ é¢„è¨€æœºé£é™©åˆ†ç±»</h5>
            <ul>
                <li><strong>æŠ€æœ¯é£é™©ï¼š</strong>èŠ‚ç‚¹æ•…éšœã€ç½‘ç»œå»¶è¿Ÿã€æ•°æ®æºé”™è¯¯</li>
                <li><strong>ç»æµæ”»å‡»ï¼š</strong>ä»·æ ¼æ“çºµã€é—ªç”µè´·æ”»å‡»ã€MEVæŠ¢å…ˆäº¤æ˜“</li>
                <li><strong>æ²»ç†é£é™©ï¼š</strong>æ¶æ„ææ¡ˆã€å‚æ•°æ“çºµã€ç´§æ€¥å“åº”å»¶è¿Ÿ</li>
                <li><strong>ç³»ç»Ÿæ€§é£é™©ï¼š</strong>çº§è”æ•…éšœã€æµåŠ¨æ€§æ¯ç«­ã€é»‘å¤©é¹…äº‹ä»¶</li>
            </ul>
        </div>
        
        <h4>5.2.2 å¤šå±‚é˜²å¾¡æœºåˆ¶</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// å®‰å…¨é¢„è¨€æœºèšåˆå™¨
contract SecureOracleAggregator {
    using FixedPoint for uint256;
    
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;  // ç½®ä¿¡åº¦è¯„åˆ†
        address source;
    }
    
    struct OracleConfig {
        address oracle;
        uint256 weight;      // æƒé‡
        uint256 deviation;   // å…è®¸åå·®
        bool isActive;
    }
    
    // å¤šä¸ªé¢„è¨€æœºæº
    OracleConfig[] public oracles;
    mapping(address => PriceData) public latestPrices;
    
    // å®‰å…¨å‚æ•°
    uint256 public constant MIN_SOURCES = 3;
    uint256 public constant MAX_DEVIATION = 0.05e18;  // 5%
    uint256 public constant PRICE_STALENESS = 3600;   // 1å°æ—¶
    uint256 public constant EMERGENCY_PAUSE_THRESHOLD = 0.1e18;  // 10%
    
    // TWAPï¼ˆæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼‰
    mapping(address => uint256[]) public priceHistory;
    uint256 public constant TWAP_WINDOW = 24;  // 24ä¸ªæ•°æ®ç‚¹
    
    // æ–­è·¯å™¨çŠ¶æ€
    bool public emergencyPause;
    uint256 public lastValidPrice;
    
    function getSecurePrice(address asset) external returns (uint256) {
        require(!emergencyPause, "Oracle paused");
        
        uint256[] memory prices = new uint256[](oracles.length);
        uint256[] memory weights = new uint256[](oracles.length);
        uint256 validSources = 0;
        
        // æ”¶é›†æ‰€æœ‰æ´»è·ƒé¢„è¨€æœºçš„ä»·æ ¼
        for (uint i = 0; i < oracles.length; i++) {
            if (!oracles[i].isActive) continue;
            
            try IOracle(oracles[i].oracle).getPrice(asset) returns (uint256 price) {
                // æ£€æŸ¥ä»·æ ¼æ—¶æ•ˆæ€§
                if (block.timestamp - latestPrices[oracles[i].oracle].timestamp < PRICE_STALENESS) {
                    prices[validSources] = price;
                    weights[validSources] = oracles[i].weight;
                    validSources++;
                    
                    // æ›´æ–°ä»·æ ¼è®°å½•
                    latestPrices[oracles[i].oracle] = PriceData({
                        price: price,
                        timestamp: block.timestamp,
                        confidence: calculateConfidence(price, asset),
                        source: oracles[i].oracle
                    });
                }
            } catch {
                // è®°å½•å¤±è´¥ä½†ç»§ç»­
                emit OracleFailure(oracles[i].oracle, asset);
            }
        }
        
        require(validSources >= MIN_SOURCES, "Insufficient oracle sources");
        
        // è®¡ç®—åŠ æƒä¸­ä½æ•°
        uint256 finalPrice = calculateWeightedMedian(prices, weights, validSources);
        
        // å¼‚å¸¸æ£€æµ‹
        if (lastValidPrice > 0) {
            uint256 priceChange = finalPrice > lastValidPrice 
                ? (finalPrice - lastValidPrice).div(lastValidPrice)
                : (lastValidPrice - finalPrice).div(lastValidPrice);
                
            if (priceChange > EMERGENCY_PAUSE_THRESHOLD) {
                emergencyPause = true;
                emit EmergencyPause(asset, lastValidPrice, finalPrice);
                return lastValidPrice;  // è¿”å›æœ€åæœ‰æ•ˆä»·æ ¼
            }
        }
        
        // æ›´æ–°TWAP
        updateTWAP(asset, finalPrice);
        lastValidPrice = finalPrice;
        
        return finalPrice;
    }
    
    // è®¡ç®—åŠ æƒä¸­ä½æ•°ï¼ˆæŠ—æ“çºµï¼‰
    function calculateWeightedMedian(
        uint256[] memory prices,
        uint256[] memory weights,
        uint256 count
    ) private pure returns (uint256) {
        // æ’åºä»·æ ¼æ•°ç»„ï¼ˆå¸¦æƒé‡ï¼‰
        for (uint i = 0; i < count - 1; i++) {
            for (uint j = 0; j < count - i - 1; j++) {
                if (prices[j] > prices[j + 1]) {
                    // äº¤æ¢ä»·æ ¼å’Œæƒé‡
                    (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]);
                    (weights[j], weights[j + 1]) = (weights[j + 1], weights[j]);
                }
            }
        }
        
        // æ‰¾åˆ°åŠ æƒä¸­ä½æ•°
        uint256 totalWeight;
        for (uint i = 0; i < count; i++) {
            totalWeight += weights[i];
        }
        
        uint256 targetWeight = totalWeight / 2;
        uint256 cumulativeWeight;
        
        for (uint i = 0; i < count; i++) {
            cumulativeWeight += weights[i];
            if (cumulativeWeight >= targetWeight) {
                return prices[i];
            }
        }
        
        return prices[count - 1];
    }
    
    // MEVä¿æŠ¤ï¼šå»¶è¿Ÿä»·æ ¼æ›´æ–°
    mapping(bytes32 => PriceCommitment) public priceCommitments;
    
    struct PriceCommitment {
        bytes32 commitment;
        uint256 revealDeadline;
        bool revealed;
    }
    
    function commitPrice(bytes32 commitment) external onlyOracle {
        priceCommitments[commitment] = PriceCommitment({
            commitment: commitment,
            revealDeadline: block.timestamp + 15 minutes,
            revealed: false
        });
    }
    
    function revealPrice(
        address asset,
        uint256 price,
        uint256 nonce
    ) external onlyOracle {
        bytes32 commitment = keccak256(abi.encodePacked(asset, price, nonce, msg.sender));
        PriceCommitment storage pc = priceCommitments[commitment];
        
        require(pc.commitment == commitment, "Invalid commitment");
        require(block.timestamp <= pc.revealDeadline, "Reveal deadline passed");
        require(!pc.revealed, "Already revealed");
        
        pc.revealed = true;
        // å¤„ç†æ­ç¤ºçš„ä»·æ ¼...
    }
}</code></pre>
        </div>
        
        <h4>5.2.3 æ²»ç†ä¸ç´§æ€¥å“åº”</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// æ²»ç†æ¨¡å—
contract OracleGovernance {
    using SafeMath for uint256;
    
    // æ—¶é—´é”å‚æ•°
    uint256 public constant MINIMUM_DELAY = 2 days;
    uint256 public constant MAXIMUM_DELAY = 30 days;
    uint256 public constant GRACE_PERIOD = 14 days;
    
    // ææ¡ˆç±»å‹
    enum ProposalType {
        ADD_ORACLE,
        REMOVE_ORACLE,
        UPDATE_WEIGHT,
        UPDATE_PARAMETERS,
        EMERGENCY_ACTION
    }
    
    struct Proposal {
        ProposalType proposalType;
        address target;
        uint256 value;
        bytes data;
        uint256 eta;  // æ‰§è¡Œæ—¶é—´
        bool executed;
        bool cancelled;
    }
    
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;
    
    // ç´§æ€¥å¤šç­¾
    mapping(address => bool) public guardians;
    uint256 public constant GUARDIAN_THRESHOLD = 3;
    
    // ç´§æ€¥æš‚åœï¼ˆéœ€è¦å¤šä¸ªå®ˆæŠ¤è€…ç­¾åï¼‰
    function emergencyPause() external {
        require(guardians[msg.sender], "Not a guardian");
        
        bytes32 actionHash = keccak256(abi.encodePacked("EMERGENCY_PAUSE", block.timestamp));
        
        if (confirmations[actionHash].length >= GUARDIAN_THRESHOLD) {
            IOracle(oracleAggregator).pause();
            emit EmergencyActionExecuted("PAUSE", block.timestamp);
        } else {
            confirmations[actionHash].push(msg.sender);
            emit GuardianConfirmation(msg.sender, actionHash);
        }
    }
    
    // å‚æ•°æ›´æ–°çš„æ¸è¿›å¼å®æ–½
    function executeParameterUpdate(
        uint256 proposalId
    ) external {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.executed, "Already executed");
        require(block.timestamp >= proposal.eta, "Too early");
        require(block.timestamp <= proposal.eta.add(GRACE_PERIOD), "Stale");
        
        // æ¸è¿›å¼æ›´æ–°ï¼Œé¿å…çªå˜
        if (proposal.proposalType == ProposalType.UPDATE_PARAMETERS) {
            uint256 currentValue = IOracle(proposal.target).getParameter(proposal.data);
            uint256 targetValue = proposal.value;
            
            // æ¯æ¬¡æœ€å¤šæ”¹å˜10%
            uint256 maxChange = currentValue.mul(10).div(100);
            uint256 actualChange = targetValue > currentValue
                ? Math.min(targetValue - currentValue, maxChange)
                : Math.min(currentValue - targetValue, maxChange);
                
            uint256 newValue = targetValue > currentValue
                ? currentValue.add(actualChange)
                : currentValue.sub(actualChange);
                
            IOracle(proposal.target).setParameter(proposal.data, newValue);
            
            // å¦‚æœè¿˜æœªè¾¾åˆ°ç›®æ ‡ï¼Œåˆ›å»ºæ–°ææ¡ˆ
            if (newValue != targetValue) {
                _createFollowUpProposal(proposal, newValue, targetValue);
            }
        }
        
        proposal.executed = true;
    }
}</code></pre>
        </div>
        
        <h4>5.2.4 2024å¹´é¢„è¨€æœºåˆ›æ–°</h4>
        <div class="info-box">
            <h5>ğŸ”® æœ€æ–°å‘å±•è¶‹åŠ¿</h5>
            <ul>
                <li><strong>é›¶çŸ¥è¯†é¢„è¨€æœºï¼š</strong>ä½¿ç”¨ZKè¯æ˜éªŒè¯é“¾ä¸‹è®¡ç®—ï¼Œå¦‚zkOracles</li>
                <li><strong>TEEé¢„è¨€æœºï¼š</strong>åˆ©ç”¨å¯ä¿¡æ‰§è¡Œç¯å¢ƒï¼ˆå¦‚Intel SGXï¼‰ä¿è¯æ•°æ®å®Œæ•´æ€§</li>
                <li><strong>AIå¢å¼ºé¢„è¨€æœºï¼š</strong>ä½¿ç”¨æœºå™¨å­¦ä¹ æ£€æµ‹å¼‚å¸¸å’Œé¢„æµ‹ä»·æ ¼</li>
                <li><strong>è·¨é“¾é¢„è¨€æœºæ ‡å‡†ï¼š</strong>ç»Ÿä¸€çš„é¢„è¨€æœºæ¥å£æ”¯æŒå¤šé“¾éƒ¨ç½²</li>
            </ul>
        </div>
        
        <h3>5.3 æ¸…ç®—åšå¼ˆè®ºä¸æ¿€åŠ±æœºåˆ¶</h3>
        
        <h4>5.3.1 æ¸…ç®—åšå¼ˆæ¨¡å‹</h4>
        <p>æ¸…ç®—è¿‡ç¨‹å¯ä»¥å»ºæ¨¡ä¸ºä¸€ä¸ªå¤šæ–¹åšå¼ˆï¼Œå‚ä¸è€…åŒ…æ‹¬ï¼šCDPæŒæœ‰è€…ã€Keeperï¼ˆæ¸…ç®—è€…ï¼‰å’Œåè®®æœ¬èº«ã€‚</p>
        
        <div class="tip-box">
            <strong>ğŸ® åšå¼ˆè®ºè§†è§’ï¼š</strong>
            <ul>
                <li><strong>CDPæŒæœ‰è€…ï¼š</strong>å¸Œæœ›é¿å…æ¸…ç®—ï¼Œä½†ä¹Ÿå¸Œæœ›æœ€å¤§åŒ–èµ„æœ¬æ•ˆç‡</li>
                <li><strong>Keeperï¼š</strong>å¯»æ±‚æ¸…ç®—åˆ©æ¶¦ï¼Œä½†éœ€è¦æ‰¿æ‹…Gasæˆæœ¬å’Œä»·æ ¼é£é™©</li>
                <li><strong>åè®®ï¼š</strong>éœ€è¦å¹³è¡¡ç³»ç»Ÿå®‰å…¨æ€§å’Œç”¨æˆ·ä½“éªŒ</li>
            </ul>
        </div>
        
        <h4>5.3.2 çº³ä»€å‡è¡¡åˆ†æ</h4>
        <div style="background: #fef3c7; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <p><strong>æ¸…ç®—åšå¼ˆçš„çº³ä»€å‡è¡¡æ¡ä»¶ï¼š</strong></p>
            <ol>
                <li><strong>Keeperå‚ä¸æ¡ä»¶ï¼š</strong>
                    <p>E[æ¸…ç®—åˆ©æ¶¦] > Gasæˆæœ¬ + æœºä¼šæˆæœ¬ + é£é™©æº¢ä»·</p>
                </li>
                <li><strong>CDPæŒæœ‰è€…æœ€ä¼˜æŠµæŠ¼ç‡ï¼š</strong>
                    <p>è¾¹é™…æ”¶ç›Šç‡ = æ¸…ç®—æ¦‚ç‡ Ã— æ¸…ç®—æŸå¤±ç‡</p>
                </li>
                <li><strong>åè®®æœ€ä¼˜å‚æ•°ï¼š</strong>
                    <p>æœ€å°åŒ–ï¼ˆç³»ç»Ÿé£é™© + ç”¨æˆ·æˆæœ¬ï¼‰</p>
                </li>
            </ol>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">æ¸…ç®—åšå¼ˆå»ºæ¨¡ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract LiquidationGameTheory {
    using ABDKMath64x64 for int128;
    
    struct GameParameters {
        uint256 liquidationPenalty;    // æ¸…ç®—ç½šé‡‘
        uint256 gasPrice;             // å½“å‰Gasä»·æ ¼
        uint256 volatility;           // å¸‚åœºæ³¢åŠ¨ç‡
        uint256 keeperCount;          // æ´»è·ƒKeeperæ•°é‡
    }
    
    // è®¡ç®—Keeperçš„æœŸæœ›æ”¶ç›Š
    function calculateKeeperExpectedProfit(
        uint256 collateralValue,
        uint256 debtValue,
        GameParameters memory params
    ) public pure returns (int256 expectedProfit) {
        // æ¸…ç®—æŠ˜æ‰£æ”¶ç›Š
        uint256 discount = collateralValue * params.liquidationPenalty / 1e18;
        
        // é¢„æœŸGasæˆæœ¬ï¼ˆè€ƒè™‘ç«äº‰ï¼‰
        uint256 gasCost = estimateGasCost(params.gasPrice, params.keeperCount);
        
        // ä»·æ ¼æ»‘ç‚¹é£é™©ï¼ˆåŸºäºæ³¢åŠ¨ç‡ï¼‰
        uint256 slippageRisk = collateralValue * params.volatility / 1e18;
        
        // ç«äº‰é£é™©ï¼ˆå…¶ä»–KeeperæŠ¢å…ˆï¼‰
        uint256 competitionRisk = discount * min(params.keeperCount, 10) / 20;
        
        // æœŸæœ›åˆ©æ¶¦ = æŠ˜æ‰£ - Gasæˆæœ¬ - æ»‘ç‚¹é£é™© - ç«äº‰é£é™©
        expectedProfit = int256(discount) - int256(gasCost) - 
                        int256(slippageRisk) - int256(competitionRisk);
    }
    
    // è®¡ç®—æœ€ä¼˜æŠµæŠ¼ç‡ï¼ˆCDPæŒæœ‰è€…è§†è§’ï¼‰
    function calculateOptimalCollateralRatio(
        uint256 stabilityFee,      // å¹´åŒ–ç¨³å®šè´¹
        uint256 collateralReturn,  // æŠµæŠ¼å“é¢„æœŸæ”¶ç›Šç‡
        uint256 volatility,        // æ³¢åŠ¨ç‡
        uint256 liquidationRatio   // æ¸…ç®—çº¿
    ) public pure returns (uint256 optimalRatio) {
        // ä½¿ç”¨Kellyå‡†åˆ™çš„å˜ä½“
        // f* = (p*b - q) / b
        // å…¶ä¸­ï¼špæ˜¯ç›ˆåˆ©æ¦‚ç‡ï¼Œbæ˜¯ç›ˆäºæ¯”ï¼Œqæ˜¯äºæŸæ¦‚ç‡
        
        // è®¡ç®—æŒæœ‰æ”¶ç›Š
        int256 holdingReturn = int256(collateralReturn) - int256(stabilityFee);
        
        // è®¡ç®—æ¸…ç®—æ¦‚ç‡ï¼ˆåŸºäºæ³¢åŠ¨ç‡å’Œè·ç¦»æ¸…ç®—çº¿çš„è·ç¦»ï¼‰
        uint256 liquidationProb = calculateLiquidationProbability(
            liquidationRatio,
            volatility
        );
        
        // Kellyå‡†åˆ™è®¡ç®—
        if (holdingReturn > 0) {
            // æœ‰æ­£æ”¶ç›Šæ—¶çš„æœ€ä¼˜æŠµæŠ¼ç‡
            optimalRatio = liquidationRatio * (1e18 + volatility) / 1e18;
            
            // åŠ å…¥å®‰å…¨è¾¹é™…
            optimalRatio = optimalRatio * 115 / 100; // 15%å®‰å…¨è¾¹é™…
        } else {
            // è´Ÿæ”¶ç›Šæ—¶ä¿å®ˆç­–ç•¥
            optimalRatio = liquidationRatio * 150 / 100;
        }
    }
    
    // è®¡ç®—æ¸…ç®—æ¦‚ç‡ï¼ˆä½¿ç”¨æ­£æ€åˆ†å¸ƒè¿‘ä¼¼ï¼‰
    function calculateLiquidationProbability(
        uint256 liquidationRatio,
        uint256 annualVolatility
    ) private pure returns (uint256) {
        // å°†å¹´åŒ–æ³¢åŠ¨ç‡è½¬æ¢ä¸ºæ¯æ—¥æ³¢åŠ¨ç‡
        uint256 dailyVol = annualVolatility * 1e18 / sqrt(365 * 1e18);
        
        // è®¡ç®—åˆ°è¾¾æ¸…ç®—çº¿çš„æ¦‚ç‡ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
        // P(æ¸…ç®—) â‰ˆ Î¦(-d), å…¶ä¸­d = ln(å½“å‰æ¯”ç‡/æ¸…ç®—æ¯”ç‡) / Ïƒ
        
        // è¿™é‡Œä½¿ç”¨è¿‘ä¼¼å…¬å¼
        uint256 distance = 1e18 - (1e36 / liquidationRatio);
        uint256 probability = distance * 1e18 / (dailyVol * 3); // ç®€åŒ–çš„æ¦‚ç‡ä¼°è®¡
        
        return probability > 1e18 ? 1e18 : probability;
    }
    
    // åè®®å‚æ•°ä¼˜åŒ–ï¼ˆå¤šç›®æ ‡ä¼˜åŒ–ï¼‰
    function optimizeProtocolParameters(
        uint256 systemRisk,
        uint256 userCost,
        uint256 keeperProfit
    ) public pure returns (
        uint256 optimalPenalty,
        uint256 optimalLiquidationRatio
    ) {
        // ç›®æ ‡å‡½æ•°ï¼šminimize(Î±*systemRisk + Î²*userCost - Î³*keeperProfit)
        // å…¶ä¸­Î±ã€Î²ã€Î³æ˜¯æƒé‡å‚æ•°
        
        uint256 alpha = 5;  // ç³»ç»Ÿé£é™©æƒé‡
        uint256 beta = 3;   // ç”¨æˆ·æˆæœ¬æƒé‡
        uint256 gamma = 2;  // Keeperåˆ©æ¶¦æƒé‡
        
        // ä½¿ç”¨æ¢¯åº¦ä¸‹é™æˆ–å…¶ä»–ä¼˜åŒ–ç®—æ³•
        // è¿™é‡Œç®€åŒ–ä¸ºè§„åˆ™åŸºç¡€çš„è°ƒæ•´
        
        if (systemRisk > 1e16) { // ç³»ç»Ÿé£é™©é«˜äº1%
            optimalLiquidationRatio = 150; // æé«˜åˆ°150%
            optimalPenalty = 15e16;        // 15%ç½šé‡‘
        } else if (userCost > 5e16) { // ç”¨æˆ·æˆæœ¬è¿‡é«˜
            optimalLiquidationRatio = 130; // é™ä½åˆ°130%
            optimalPenalty = 10e16;        // 10%ç½šé‡‘
        } else {
            optimalLiquidationRatio = 140; // æ ‡å‡†140%
            optimalPenalty = 13e16;        // 13%ç½šé‡‘
        }
    }
    
    // è¾…åŠ©å‡½æ•°
    function min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function sqrt(uint256 x) private pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
    
    function estimateGasCost(uint256 gasPrice, uint256 keeperCount) 
        private 
        pure 
        returns (uint256) 
    {
        // åŸºç¡€Gasæ¶ˆè€—
        uint256 baseGas = 200000;
        
        // ç«äº‰å¯¼è‡´çš„Gasæº¢ä»·
        uint256 premiumMultiplier = 100 + keeperCount * 10;
        
        return baseGas * gasPrice * premiumMultiplier / 100;
    }
}</code></pre>
            </div>
        </div>
        
        <h3>5.4 Black-Scholesæ¨¡å‹åœ¨æŠµæŠ¼ç‡è®¾è®¡ä¸­çš„åº”ç”¨</h3>
        
        <h4>5.4.1 æœŸæƒç†è®ºè§†è§’</h4>
        <p>CDPå¯ä»¥è¢«è§†ä¸ºä¸€ä¸ªæœŸæƒç»“æ„ï¼š</p>
        <ul>
            <li>å€Ÿæ¬¾äººæŒæœ‰ä¸€ä¸ª<strong>çœ‹è·ŒæœŸæƒ</strong>ï¼šæœ‰æƒä»¥å€ºåŠ¡é‡‘é¢"å–å‡º"æŠµæŠ¼å“ç»™åè®®</li>
            <li>åè®®éšå«åœ°<strong>å–å‡ºäº†çœ‹è·ŒæœŸæƒ</strong>ï¼šæ‰¿æ‹…äº†æŠµæŠ¼å“ä»·å€¼ä¸‹è·Œçš„é£é™©</li>
        </ul>
        
        <div class="tip">
            ğŸ’¡ <strong>å…³é”®æ´å¯Ÿï¼š</strong>æ¸…ç®—çº¿çš„è®¾å®šæœ¬è´¨ä¸Šæ˜¯åœ¨ä¸ºè¿™ä¸ªéšå«æœŸæƒå®šä»·ã€‚è¿‡é«˜çš„æ¸…ç®—çº¿ç›¸å½“äºæœŸæƒè´¹è¿‡é«˜ï¼Œé™ä½äº†èµ„æœ¬æ•ˆç‡ï¼›è¿‡ä½åˆ™å¢åŠ äº†åè®®çš„é£é™©æ•å£ã€‚
        </div>
        
        <h4>5.4.2 Black-Scholeså…¬å¼åº”ç”¨</h4>
        <div style="background: #e0e7ff; padding: 1.5rem; border-radius: 8px; margin: 1rem 0;">
            <p><strong>é€‚é…åçš„Black-Scholeså…¬å¼ï¼š</strong></p>
            <p>çœ‹è·ŒæœŸæƒä»·å€¼ P = Ke<sup>-rt</sup>N(-dâ‚‚) - Sâ‚€N(-dâ‚)</p>
            <p>å…¶ä¸­ï¼š</p>
            <ul>
                <li>Sâ‚€ = æŠµæŠ¼å“å½“å‰ä»·å€¼</li>
                <li>K = å€ºåŠ¡ä»·å€¼ï¼ˆè¡Œæƒä»·ï¼‰</li>
                <li>r = æ— é£é™©åˆ©ç‡</li>
                <li>t = æœŸé™</li>
                <li>Ïƒ = æŠµæŠ¼å“æ³¢åŠ¨ç‡</li>
                <li>dâ‚ = [ln(Sâ‚€/K) + (r + ÏƒÂ²/2)t] / (Ïƒâˆšt)</li>
                <li>dâ‚‚ = dâ‚ - Ïƒâˆšt</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">Black-ScholesæŠµæŠ¼ç‡è®¡ç®— <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// ä½¿ç”¨ABDKMath64x64åº“è¿›è¡Œé«˜ç²¾åº¦æ•°å­¦è®¡ç®—
import "./ABDKMath64x64.sol";

contract BlackScholesCollateral {
    using ABDKMath64x64 for int128;
    
    // å¸¸æ•°
    int128 private constant ONE = 0x10000000000000000; // 1.0 in 64.64
    int128 private constant HALF = 0x8000000000000000; // 0.5 in 64.64
    
    struct OptionParameters {
        uint256 spotPrice;      // æŠµæŠ¼å“ç°ä»·
        uint256 strikePrice;    // å€ºåŠ¡ä»·å€¼ï¼ˆè¡Œæƒä»·ï¼‰
        uint256 timeToMaturity; // åˆ°æœŸæ—¶é—´ï¼ˆç§’ï¼‰
        uint256 volatility;     // å¹´åŒ–æ³¢åŠ¨ç‡ï¼ˆåŸºç‚¹ï¼‰
        uint256 riskFreeRate;   // æ— é£é™©åˆ©ç‡ï¼ˆåŸºç‚¹ï¼‰
    }
    
    // è®¡ç®—ç†è®ºæ¸…ç®—æ¯”ç‡
    function calculateOptimalLiquidationRatio(
        OptionParameters memory params
    ) public pure returns (uint256 liquidationRatio) {
        // è½¬æ¢å‚æ•°ä¸º64.64å®šç‚¹æ•°
        int128 S = ABDKMath64x64.divu(params.spotPrice, 1e18);
        int128 K = ABDKMath64x64.divu(params.strikePrice, 1e18);
        int128 t = ABDKMath64x64.divu(params.timeToMaturity, 365 days);
        int128 sigma = ABDKMath64x64.divu(params.volatility, 10000);
        int128 r = ABDKMath64x64.divu(params.riskFreeRate, 10000);
        
        // è®¡ç®—d1å’Œd2
        (int128 d1, int128 d2) = calculateD1D2(S, K, r, sigma, t);
        
        // è®¡ç®—æœŸæƒä»·å€¼
        int128 putValue = calculatePutValue(S, K, r, t, d1, d2);
        
        // æ¸…ç®—æ¯”ç‡ = (å€ºåŠ¡ + æœŸæƒä»·å€¼) / å€ºåŠ¡
        // è¿™ç¡®ä¿äº†åè®®å¾—åˆ°å……åˆ†è¡¥å¿
        int128 ratio = ONE.add(putValue.div(K));
        
        // è½¬æ¢å›uint256ï¼ˆåŸºç‚¹ï¼‰
        liquidationRatio = uint256(int256(ratio.mul(ABDKMath64x64.fromUInt(10000))));
        
        // åŠ å…¥å®‰å…¨è¾¹é™…ï¼ˆæ ¹æ®æ³¢åŠ¨ç‡è°ƒæ•´ï¼‰
        uint256 safetyMargin = 10000 + params.volatility / 2; // åŸºç¡€100% + æ³¢åŠ¨ç‡çš„ä¸€åŠ
        liquidationRatio = liquidationRatio * safetyMargin / 10000;
    }
    
    // è®¡ç®—d1å’Œd2
    function calculateD1D2(
        int128 S,
        int128 K,
        int128 r,
        int128 sigma,
        int128 t
    ) private pure returns (int128 d1, int128 d2) {
        // ln(S/K)
        int128 lnSK = S.div(K).ln();
        
        // (r + ÏƒÂ²/2)t
        int128 sigma2 = sigma.mul(sigma);
        int128 drift = r.add(sigma2.div(ABDKMath64x64.fromUInt(2))).mul(t);
        
        // Ïƒâˆšt
        int128 sigmaRootT = sigma.mul(t.sqrt());
        
        // d1 = [ln(S/K) + (r + ÏƒÂ²/2)t] / (Ïƒâˆšt)
        d1 = lnSK.add(drift).div(sigmaRootT);
        
        // d2 = d1 - Ïƒâˆšt
        d2 = d1.sub(sigmaRootT);
    }
    
    // è®¡ç®—çœ‹è·ŒæœŸæƒä»·å€¼
    function calculatePutValue(
        int128 S,
        int128 K,
        int128 r,
        int128 t,
        int128 d1,
        int128 d2
    ) private pure returns (int128) {
        // e^(-rt)
        int128 discountFactor = (r.neg()).mul(t).exp();
        
        // N(-d1) å’Œ N(-d2)
        int128 Nd1 = normalCDF(d1.neg());
        int128 Nd2 = normalCDF(d2.neg());
        
        // P = Ke^(-rt)N(-d2) - S*N(-d1)
        int128 putValue = K.mul(discountFactor).mul(Nd2).sub(S.mul(Nd1));
        
        return putValue;
    }
    
    // æ­£æ€åˆ†å¸ƒç´¯ç§¯åˆ†å¸ƒå‡½æ•°ï¼ˆè¿‘ä¼¼ï¼‰
    function normalCDF(int128 x) private pure returns (int128) {
        // ä½¿ç”¨Abramowitzå’ŒStegunè¿‘ä¼¼
        int128 L = x.abs();
        int128 K = ONE.div(ONE.add(L.mul(ABDKMath64x64.divu(2316419, 10000000))));
        
        int128 a1 = ABDKMath64x64.divu(319381530, 1000000000);
        int128 a2 = ABDKMath64x64.divu(356563782, 1000000000).neg();
        int128 a3 = ABDKMath64x64.divu(1781477937, 1000000000);
        int128 a4 = ABDKMath64x64.divu(1821255978, 1000000000).neg();
        int128 a5 = ABDKMath64x64.divu(1330274429, 1000000000);
        
        int128 K2 = K.mul(K);
        int128 K3 = K2.mul(K);
        int128 K4 = K3.mul(K);
        int128 K5 = K4.mul(K);
        
        int128 sum = a1.mul(K).add(a2.mul(K2)).add(a3.mul(K3))
                    .add(a4.mul(K4)).add(a5.mul(K5));
        
        // 1.0 - 1.0/âˆš(2Ï€) * e^(-LÂ²/2) * sum
        int128 sqrtTwoPi = ABDKMath64x64.divu(2506628274, 1000000000);
        int128 expTerm = L.mul(L).div(ABDKMath64x64.fromUInt(2)).neg().exp();
        int128 result = ONE.sub(expTerm.div(sqrtTwoPi).mul(sum));
        
        return x >= 0 ? result : ONE.sub(result);
    }
    
    // åŠ¨æ€è°ƒæ•´æŠµæŠ¼ç‡ï¼ˆåŸºäºå¸‚åœºæ¡ä»¶ï¼‰
    function dynamicCollateralAdjustment(
        uint256 currentVolatility,
        uint256 historicalVolatility,
        uint256 marketDepth,
        uint256 currentLiquidationRatio
    ) public pure returns (uint256 newLiquidationRatio) {
        // æ³¢åŠ¨ç‡æ¯”ç‡
        uint256 volRatio = currentVolatility * 1e18 / historicalVolatility;
        
        // å¸‚åœºæ·±åº¦å› å­ï¼ˆæµåŠ¨æ€§è¶Šå·®ï¼Œéœ€è¦è¶Šé«˜çš„æŠµæŠ¼ç‡ï¼‰
        uint256 depthFactor = 1e18 * 1e18 / (marketDepth + 1e18);
        
        // è°ƒæ•´å› å­ = âˆš(æ³¢åŠ¨ç‡æ¯”ç‡ * æ·±åº¦å› å­)
        uint256 adjustmentFactor = sqrt(volRatio * depthFactor / 1e18);
        
        // æ–°æŠµæŠ¼ç‡ = å½“å‰æŠµæŠ¼ç‡ * è°ƒæ•´å› å­
        newLiquidationRatio = currentLiquidationRatio * adjustmentFactor / 1e18;
        
        // é™åˆ¶è°ƒæ•´å¹…åº¦ï¼ˆå•æ¬¡æœ€å¤šè°ƒæ•´10%ï¼‰
        uint256 maxChange = currentLiquidationRatio / 10;
        if (newLiquidationRatio > currentLiquidationRatio + maxChange) {
            newLiquidationRatio = currentLiquidationRatio + maxChange;
        } else if (newLiquidationRatio < currentLiquidationRatio - maxChange) {
            newLiquidationRatio = currentLiquidationRatio - maxChange;
        }
    }
    
    function sqrt(uint256 x) private pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
}</code></pre>
            </div>
        </div>
        
        <h4>5.4.3 Black-Scholesæ¨¡å‹çš„å±€é™æ€§ä¸DeFié€‚é…</h4>
        <div class="info-box">
            <h5>âš ï¸ ä¼ ç»Ÿæ¨¡å‹å‡è®¾ vs DeFiç°å®</h5>
            <table style="width: 100%; border-collapse: collapse;">
                <tr style="background: #f3f4f6;">
                    <th style="border: 1px solid #ddd; padding: 8px;">Black-Scholeså‡è®¾</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">DeFiå¸‚åœºç°å®</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">é€‚é…æ–¹æ¡ˆ</th>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">å¯¹æ•°æ­£æ€åˆ†å¸ƒ</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">è‚¥å°¾åˆ†å¸ƒã€é»‘å¤©é¹…äº‹ä»¶é¢‘å‘</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">ä½¿ç”¨è·³è·ƒæ‰©æ•£æ¨¡å‹</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">æ’å®šæ³¢åŠ¨ç‡</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">æ³¢åŠ¨ç‡å¾®ç¬‘ã€æ—¶å˜æ³¢åŠ¨ç‡</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">éšå«æ³¢åŠ¨ç‡æ›²é¢</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">æ— æ‘©æ“¦å¸‚åœº</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">é«˜Gasè´¹ã€æ»‘ç‚¹ã€MEV</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">äº¤æ˜“æˆæœ¬è°ƒæ•´</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">è¿ç»­äº¤æ˜“</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">åŒºå—æ—¶é—´ç¦»æ•£æ€§</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">ç¦»æ•£æ—¶é—´æ¨¡å‹</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">æ— é£é™©åˆ©ç‡</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">DeFiåˆ©ç‡æ³¢åŠ¨å‰§çƒˆ</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">åŠ¨æ€åˆ©ç‡æ¨¡å‹</td>
                </tr>
            </table>
        </div>
        
        <div class="code-block">
            <pre><code class="language-python"># DeFié€‚é…çš„æœŸæƒå®šä»·æ¨¡å‹
import numpy as np
from scipy.stats import norm
import pandas as pd

class DeFiOptionPricing:
    """è€ƒè™‘DeFiç‰¹æ€§çš„æœŸæƒå®šä»·æ¨¡å‹"""
    
    def __init__(self, jump_intensity=0.1, jump_mean=-0.05, jump_std=0.1):
        self.jump_intensity = jump_intensity  # è·³è·ƒå¼ºåº¦ï¼ˆLambdaï¼‰
        self.jump_mean = jump_mean          # å¹³å‡è·³è·ƒå¹…åº¦
        self.jump_std = jump_std            # è·³è·ƒæ ‡å‡†å·®
        
    def merton_jump_diffusion(self, S, K, T, r, sigma, div_yield=0):
        """
        Mertonè·³è·ƒæ‰©æ•£æ¨¡å‹
        é€‚ç”¨äºåŠ å¯†èµ„äº§çš„è‚¥å°¾åˆ†å¸ƒ
        """
        # è°ƒæ•´å‚æ•°ä»¥è€ƒè™‘è·³è·ƒ
        lambda_prime = self.jump_intensity * (1 + self.jump_mean)
        sigma_s = np.sqrt(sigma**2 + self.jump_intensity * self.jump_std**2)
        
        # è®¡ç®—æœŸæƒä»·å€¼çš„çº§æ•°å±•å¼€
        option_value = 0
        for n in range(50):  # é€šå¸¸50é¡¹è¶³å¤Ÿæ”¶æ•›
            # æ³Šæ¾æ¦‚ç‡
            prob_n = np.exp(-lambda_prime * T) * (lambda_prime * T)**n / np.math.factorial(n)
            
            # è°ƒæ•´åçš„å‚æ•°
            r_n = r - self.jump_intensity * self.jump_mean + n * np.log(1 + self.jump_mean) / T
            sigma_n = np.sqrt(sigma**2 + n * self.jump_std**2 / T)
            
            # Black-Scholes with adjusted parameters
            bs_value = self.black_scholes_put(S, K, T, r_n, sigma_n, div_yield)
            option_value += prob_n * bs_value
            
        return option_value
    
    def implied_volatility_surface(self, market_prices, strikes, maturities, spot):
        """
        æ„å»ºéšå«æ³¢åŠ¨ç‡æ›²é¢
        åæ˜ å¸‚åœºå¯¹ä¸åŒè¡Œæƒä»·å’Œåˆ°æœŸæ—¥çš„é£é™©å®šä»·
        """
        iv_surface = pd.DataFrame(index=strikes, columns=maturities)
        
        for K in strikes:
            for T in maturities:
                # ä»å¸‚åœºä»·æ ¼åæ¨éšå«æ³¢åŠ¨ç‡
                market_price = market_prices.get((K, T), None)
                if market_price:
                    iv = self.calculate_implied_volatility(
                        market_price, spot, K, T, 0.05  # å‡è®¾5%æ— é£é™©åˆ©ç‡
                    )
                    iv_surface.loc[K, T] = iv
                    
        return iv_surface
    
    def calculate_liquidation_premium(self, collateral_value, debt_value, 
                                    volatility, time_to_liquidation,
                                    gas_cost, mev_risk_premium):
        """
        è®¡ç®—è€ƒè™‘DeFiç‰¹æ€§çš„æ¸…ç®—æº¢ä»·
        """
        # åŸºç¡€æœŸæƒä»·å€¼
        base_option_value = self.merton_jump_diffusion(
            S=collateral_value,
            K=debt_value,
            T=time_to_liquidation,
            r=0.05,  # DeFiå€Ÿè´·åˆ©ç‡
            sigma=volatility
        )
        
        # Gasæˆæœ¬è°ƒæ•´ï¼ˆå æŠµæŠ¼å“ä»·å€¼çš„æ¯”ä¾‹ï¼‰
        gas_adjustment = gas_cost / collateral_value
        
        # MEVé£é™©è°ƒæ•´ï¼ˆæ¸…ç®—è€…å¯èƒ½è¢«æŠ¢å…ˆäº¤æ˜“ï¼‰
        mev_adjustment = mev_risk_premium
        
        # æµåŠ¨æ€§æŠ˜æ‰£ï¼ˆå¤§é¢æ¸…ç®—çš„å¸‚åœºå†²å‡»ï¼‰
        liquidity_discount = self.calculate_liquidity_discount(
            collateral_value, 
            debt_value
        )
        
        # æ€»æ¸…ç®—æº¢ä»·
        total_premium = (base_option_value + gas_adjustment + 
                        mev_adjustment + liquidity_discount)
        
        # å»ºè®®çš„æ¸…ç®—æ¯”ç‡
        suggested_liquidation_ratio = 1 + total_premium
        
        return {
            'base_option_value': base_option_value,
            'gas_adjustment': gas_adjustment,
            'mev_adjustment': mev_adjustment,
            'liquidity_discount': liquidity_discount,
            'total_premium': total_premium,
            'suggested_liquidation_ratio': suggested_liquidation_ratio
        }
    
    def calculate_liquidity_discount(self, collateral_value, debt_value):
        """
        åŸºäºAmihudéæµåŠ¨æ€§æŒ‡æ ‡ä¼°ç®—å¸‚åœºå†²å‡»
        """
        # ç®€åŒ–æ¨¡å‹ï¼šå‡è®¾å¸‚åœºæ·±åº¦ä¸è§„æ¨¡çš„å¹³æ–¹æ ¹æˆåæ¯”
        market_depth_factor = 1e7  # å¸‚åœºæ·±åº¦å‚æ•°
        impact = np.sqrt(collateral_value / market_depth_factor)
        
        return min(impact, 0.1)  # æœ€å¤§10%çš„æµåŠ¨æ€§æŠ˜æ‰£

# ä½¿ç”¨ç¤ºä¾‹
pricing_model = DeFiOptionPricing()

# è®¡ç®—CDPçš„æ¸…ç®—å‚æ•°
result = pricing_model.calculate_liquidation_premium(
    collateral_value=1000000,  # $1MæŠµæŠ¼å“
    debt_value=500000,         # $500Kå€ºåŠ¡
    volatility=0.8,            # 80%å¹´åŒ–æ³¢åŠ¨ç‡
    time_to_liquidation=1/365, # 1å¤©
    gas_cost=500,              # $500 Gasæˆæœ¬
    mev_risk_premium=0.02      # 2% MEVé£é™©
)

print(f"å»ºè®®æ¸…ç®—æ¯”ç‡: {result['suggested_liquidation_ratio']:.2%}")
print(f"å…¶ä¸­æœŸæƒä»·å€¼è´¡çŒ®: {result['base_option_value']:.2%}")
print(f"Gasæˆæœ¬è´¡çŒ®: {result['gas_adjustment']:.2%}")
print(f"MEVé£é™©è´¡çŒ®: {result['mev_adjustment']:.2%}")
print(f"æµåŠ¨æ€§æŠ˜æ‰£: {result['liquidity_discount']:.2%}")</code></pre>
        </div>
        
        <h3>5.5 å¸‚åœºå‹åŠ›æµ‹è¯•ä¸è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ</h3>
        
        <h4>5.5.1 å‹åŠ›æµ‹è¯•æ¡†æ¶</h4>
        <p>ç¨³å®šå¸ç³»ç»Ÿéœ€è¦èƒ½å¤Ÿæ‰¿å—æç«¯å¸‚åœºæ¡ä»¶ã€‚é€šè¿‡è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿï¼Œæˆ‘ä»¬å¯ä»¥è¯„ä¼°ç³»ç»Ÿåœ¨å„ç§æƒ…æ™¯ä¸‹çš„è¡¨ç°ã€‚</p>
        
        <div class="tip-box">
            <strong>ğŸ“Š å‹åŠ›æµ‹è¯•ç»´åº¦ï¼š</strong>
            <ul>
                <li><strong>ä»·æ ¼å†²å‡»ï¼š</strong>æŠµæŠ¼å“ä»·æ ¼ç¬é—´ä¸‹è·Œ30%ã€50%ã€70%</li>
                <li><strong>æµåŠ¨æ€§æ¯ç«­ï¼š</strong>DEXæµåŠ¨æ€§é™ä½90%</li>
                <li><strong>çº§è”æ¸…ç®—ï¼š</strong>å¤§é‡CDPåŒæ—¶è§¦å‘æ¸…ç®—</li>
                <li><strong>é¢„è¨€æœºæ”»å‡»ï¼š</strong>ä»·æ ¼æ“çºµæˆ–é¢„è¨€æœºå¤±æ•ˆ</li>
                <li><strong>Gasä»·æ ¼æ¿€å¢ï¼š</strong>ç½‘ç»œæ‹¥å µå¯¼è‡´æ¸…ç®—å»¶è¿Ÿ</li>
            </ul>
        </div>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿå¼•æ“ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract MonteCarloSimulation {
    using ABDKMath64x64 for int128;
    
    struct SimulationParameters {
        uint256 numSimulations;      // æ¨¡æ‹Ÿæ¬¡æ•°
        uint256 timeHorizon;        // æ—¶é—´èŒƒå›´ï¼ˆå¤©ï¼‰
        uint256 initialPrice;       // åˆå§‹ä»·æ ¼
        uint256 annualVolatility;   // å¹´åŒ–æ³¢åŠ¨ç‡
        uint256 drift;              // æ¼‚ç§»ç‡
        uint256 jumpProbability;    // è·³è·ƒæ¦‚ç‡
        int256 jumpSize;            // è·³è·ƒå¹…åº¦
    }
    
    struct SimulationResults {
        uint256 avgFinalPrice;      // å¹³å‡æœ€ç»ˆä»·æ ¼
        uint256 minPrice;           // æœ€ä½ä»·æ ¼
        uint256 maxPrice;           // æœ€é«˜ä»·æ ¼
        uint256 defaultProbability; // è¿çº¦æ¦‚ç‡
        uint256 avgLiquidations;    // å¹³å‡æ¸…ç®—æ¬¡æ•°
        uint256 maxDrawdown;        // æœ€å¤§å›æ’¤
        uint256 var95;             // 95% VaR
        uint256 var99;             // 99% VaR
    }
    
    // éšæœºæ•°ç”Ÿæˆå™¨ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”ä½¿ç”¨Chainlink VRFï¼‰
    uint256 private seed;
    
    function runMonteCarloSimulation(
        SimulationParameters memory params,
        uint256 liquidationRatio,
        uint256 totalCDPs
    ) public returns (SimulationResults memory results) {
        uint256[] memory finalPrices = new uint256[](params.numSimulations);
        uint256[] memory liquidationCounts = new uint256[](params.numSimulations);
        uint256 defaultCount;
        
        results.minPrice = type(uint256).max;
        
        // è¿è¡Œå¤šæ¬¡æ¨¡æ‹Ÿ
        for (uint256 sim = 0; sim < params.numSimulations; sim++) {
            (uint256 finalPrice, uint256 liquidations, uint256 minPriceInPath) = 
                simulatePricePath(params, liquidationRatio);
            
            finalPrices[sim] = finalPrice;
            liquidationCounts[sim] = liquidations;
            
            // æ›´æ–°ç»Ÿè®¡
            results.avgFinalPrice += finalPrice;
            results.avgLiquidations += liquidations;
            
            if (finalPrice < results.minPrice) {
                results.minPrice = finalPrice;
            }
            if (finalPrice > results.maxPrice) {
                results.maxPrice = finalPrice;
            }
            
            // è®¡ç®—æœ€å¤§å›æ’¤
            uint256 drawdown = (params.initialPrice - minPriceInPath) * 1e18 / 
                              params.initialPrice;
            if (drawdown > results.maxDrawdown) {
                results.maxDrawdown = drawdown;
            }
            
            // æ£€æŸ¥æ˜¯å¦è¿çº¦ï¼ˆä»·æ ¼è·Œç ´æŸä¸ªé˜ˆå€¼ï¼‰
            if (minPriceInPath < params.initialPrice * 100 / liquidationRatio) {
                defaultCount++;
            }
        }
        
        // è®¡ç®—å¹³å‡å€¼
        results.avgFinalPrice /= params.numSimulations;
        results.avgLiquidations /= params.numSimulations;
        results.defaultProbability = defaultCount * 1e18 / params.numSimulations;
        
        // è®¡ç®—VaR
        sortArray(finalPrices);
        uint256 var95Index = params.numSimulations * 5 / 100;
        uint256 var99Index = params.numSimulations * 1 / 100;
        results.var95 = params.initialPrice - finalPrices[var95Index];
        results.var99 = params.initialPrice - finalPrices[var99Index];
        
        return results;
    }
    
    // æ¨¡æ‹Ÿå•æ¡ä»·æ ¼è·¯å¾„
    function simulatePricePath(
        SimulationParameters memory params,
        uint256 liquidationRatio
    ) private returns (
        uint256 finalPrice,
        uint256 liquidationCount,
        uint256 minPrice
    ) {
        uint256 currentPrice = params.initialPrice;
        minPrice = currentPrice;
        uint256 dt = 1; // 1å¤©æ—¶é—´æ­¥é•¿
        
        // å°†å‚æ•°è½¬æ¢ä¸ºæ¯æ—¥å€¼
        uint256 dailyVolatility = params.annualVolatility / sqrt(365);
        int256 dailyDrift = int256(params.drift) / 365;
        
        for (uint256 day = 0; day < params.timeHorizon; day++) {
            // ç”Ÿæˆéšæœºæ•°
            int256 randomNormal = generateNormalRandom();
            uint256 randomUniform = generateUniformRandom();
            
            // å‡ ä½•å¸ƒæœ—è¿åŠ¨ + è·³è·ƒè¿‡ç¨‹
            int256 diffusion = int256(dailyVolatility) * randomNormal / 1e9;
            int256 priceChange = dailyDrift + diffusion;
            
            // æ£€æŸ¥è·³è·ƒ
            if (randomUniform < params.jumpProbability) {
                priceChange += params.jumpSize;
            }
            
            // æ›´æ–°ä»·æ ¼ï¼ˆç¡®ä¿ä¸ä¼šå˜è´Ÿï¼‰
            if (priceChange >= 0) {
                currentPrice = currentPrice * uint256(1e18 + priceChange) / 1e18;
            } else {
                uint256 decrease = uint256(-priceChange);
                if (decrease < 1e18) {
                    currentPrice = currentPrice * (1e18 - decrease) / 1e18;
                } else {
                    currentPrice = 1; // æœ€å°ä»·æ ¼
                }
            }
            
            // æ›´æ–°æœ€ä½ä»·
            if (currentPrice < minPrice) {
                minPrice = currentPrice;
            }
            
            // æ£€æŸ¥æ¸…ç®—
            if (currentPrice < params.initialPrice * 100 / liquidationRatio) {
                liquidationCount++;
            }
        }
        
        finalPrice = currentPrice;
    }
    
    // ç”Ÿæˆæ­£æ€åˆ†å¸ƒéšæœºæ•°ï¼ˆBox-Mullerå˜æ¢ï¼‰
    function generateNormalRandom() private returns (int256) {
        uint256 u1 = generateUniformRandom();
        uint256 u2 = generateUniformRandom();
        
        // Box-Mullerå˜æ¢
        int256 z0 = int256(sqrt(uint256(-2) * ln(u1)) * 
                    cos(2 * 314159265 * u2 / 1e10));
        
        return z0;
    }
    
    // ç”Ÿæˆå‡åŒ€åˆ†å¸ƒéšæœºæ•°
    function generateUniformRandom() private returns (uint256) {
        seed = uint256(keccak256(abi.encodePacked(seed, block.timestamp, msg.sender)));
        return seed % 1e18;
    }
    
    // è‡ªç„¶å¯¹æ•°è¿‘ä¼¼
    function ln(uint256 x) private pure returns (uint256) {
        require(x > 0, "ln of non-positive number");
        // ç®€åŒ–çš„æ³°å‹’çº§æ•°è¿‘ä¼¼
        // å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ›´ç²¾ç¡®çš„å®ç°
        if (x == 1e18) return 0;
        
        int256 result = 0;
        int256 term = int256(x - 1e18) * 1e18 / int256(x + 1e18);
        int256 termSquared = term * term / 1e18;
        
        result = 2 * term;
        term = term * termSquared / 1e18;
        result += 2 * term / 3;
        
        return uint256(result);
    }
    
    // ä½™å¼¦è¿‘ä¼¼
    function cos(uint256 x) private pure returns (int256) {
        // ç®€åŒ–çš„æ³°å‹’çº§æ•°
        int256 x2 = int256(x) * int256(x) / 1e18;
        int256 result = 1e18 - x2 / 2;
        return result;
    }
    
    // æ•°ç»„æ’åºï¼ˆç”¨äºVaRè®¡ç®—ï¼‰
    function sortArray(uint256[] memory arr) private pure {
        uint256 n = arr.length;
        for (uint256 i = 0; i < n - 1; i++) {
            for (uint256 j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    uint256 temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    function sqrt(uint256 x) private pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
}</code></pre>
            </div>
        </div>
        
        <h4>5.4.2 ç³»ç»Ÿæ€§é£é™©è¯„ä¼°</h4>
        <p>åŸºäºæ¨¡æ‹Ÿç»“æœï¼Œæˆ‘ä»¬å¯ä»¥è¯„ä¼°ç³»ç»Ÿçš„æ•´ä½“é£é™©çŠ¶å†µï¼š</p>
        
        <div class="code-block">
            <div class="code-header" onclick="toggleCode(this)">é£é™©è¯„ä¼°ä¸é¢„è­¦ç³»ç»Ÿ <span class="toggle-icon">â–¼</span></div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">contract RiskAssessmentSystem {
    MonteCarloSimulation public simulator;
    
    struct RiskMetrics {
        uint256 systemCollateralRatio;   // ç³»ç»Ÿæ€»æŠµæŠ¼ç‡
        uint256 concentrationRisk;       // é›†ä¸­åº¦é£é™©
        uint256 liquidityRisk;          // æµåŠ¨æ€§é£é™©
        uint256 correlationRisk;        // ç›¸å…³æ€§é£é™©
        uint256 overallRiskScore;       // ç»¼åˆé£é™©è¯„åˆ†
        RiskLevel riskLevel;            // é£é™©ç­‰çº§
    }
    
    enum RiskLevel { LOW, MEDIUM, HIGH, CRITICAL }
    
    // é£é™©é˜ˆå€¼
    uint256 constant CRITICAL_COLLATERAL_RATIO = 120; // 120%
    uint256 constant HIGH_CONCENTRATION = 20;         // 20%å•ä¸€å¤´å¯¸
    uint256 constant LOW_LIQUIDITY_DEPTH = 1e6 * 1e18; // 100ä¸‡ç¾å…ƒ
    
    // è®¡ç®—ç³»ç»Ÿé£é™©æŒ‡æ ‡
    function assessSystemRisk(
        address[] memory cdps,
        address[] memory collateralTypes
    ) public returns (RiskMetrics memory metrics) {
        // 1. è®¡ç®—ç³»ç»Ÿæ€»æŠµæŠ¼ç‡
        uint256 totalCollateralValue;
        uint256 totalDebtValue;
        
        for (uint256 i = 0; i < cdps.length; i++) {
            (uint256 collateral, uint256 debt) = getCDPValues(cdps[i]);
            totalCollateralValue += collateral;
            totalDebtValue += debt;
        }
        
        metrics.systemCollateralRatio = totalCollateralValue * 100 / totalDebtValue;
        
        // 2. è®¡ç®—é›†ä¸­åº¦é£é™©ï¼ˆHHIæŒ‡æ•°ï¼‰
        metrics.concentrationRisk = calculateHerfindahlIndex(cdps);
        
        // 3. è¯„ä¼°æµåŠ¨æ€§é£é™©
        metrics.liquidityRisk = assessLiquidityRisk(collateralTypes);
        
        // 4. è®¡ç®—ç›¸å…³æ€§é£é™©
        metrics.correlationRisk = calculateCorrelationRisk(collateralTypes);
        
        // 5. è¿è¡Œå‹åŠ›æµ‹è¯•
        SimulationResults memory simResults = runStressTest();
        
        // 6. ç»¼åˆè¯„åˆ†ï¼ˆåŠ æƒå¹³å‡ï¼‰
        metrics.overallRiskScore = calculateOverallRisk(
            metrics,
            simResults
        );
        
        // 7. ç¡®å®šé£é™©ç­‰çº§
        metrics.riskLevel = determineRiskLevel(metrics.overallRiskScore);
        
        // 8. è§¦å‘é¢„è­¦
        if (metrics.riskLevel >= RiskLevel.HIGH) {
            triggerRiskAlert(metrics);
        }
        
        return metrics;
    }
    
    // è®¡ç®—èµ«èŠ¬è¾¾å°”æŒ‡æ•°ï¼ˆå¸‚åœºé›†ä¸­åº¦ï¼‰
    function calculateHerfindahlIndex(
        address[] memory cdps
    ) private view returns (uint256) {
        uint256 totalDebt;
        uint256[] memory debts = new uint256[](cdps.length);
        
        // è·å–æ€»å€ºåŠ¡å’Œå„CDPå€ºåŠ¡
        for (uint256 i = 0; i < cdps.length; i++) {
            (, debts[i]) = getCDPValues(cdps[i]);
            totalDebt += debts[i];
        }
        
        // è®¡ç®—HHI
        uint256 hhi;
        for (uint256 i = 0; i < cdps.length; i++) {
            uint256 marketShare = debts[i] * 10000 / totalDebt; // åŸºç‚¹
            hhi += marketShare * marketShare;
        }
        
        return hhi;
    }
    
    // è¯„ä¼°æµåŠ¨æ€§é£é™©
    function assessLiquidityRisk(
        address[] memory collateralTypes
    ) private view returns (uint256) {
        uint256 totalRisk;
        
        for (uint256 i = 0; i < collateralTypes.length; i++) {
            uint256 depth = getMarketDepth(collateralTypes[i]);
            
            if (depth < LOW_LIQUIDITY_DEPTH) {
                // æµåŠ¨æ€§ä¸è¶³ï¼Œé£é™©å¢åŠ 
                totalRisk += (LOW_LIQUIDITY_DEPTH - depth) * 1e18 / 
                            LOW_LIQUIDITY_DEPTH;
            }
        }
        
        return totalRisk / collateralTypes.length;
    }
    
    // è®¡ç®—ç›¸å…³æ€§é£é™©
    function calculateCorrelationRisk(
        address[] memory collateralTypes
    ) private view returns (uint256) {
        // ç®€åŒ–ç‰ˆï¼šè®¡ç®—ä»·æ ¼ç›¸å…³ç³»æ•°
        // å®é™…åº”ç”¨ä¸­éœ€è¦å†å²æ•°æ®
        
        if (collateralTypes.length < 2) return 0;
        
        uint256 avgCorrelation;
        uint256 pairCount;
        
        for (uint256 i = 0; i < collateralTypes.length - 1; i++) {
            for (uint256 j = i + 1; j < collateralTypes.length; j++) {
                uint256 correlation = getPriceCorrelation(
                    collateralTypes[i],
                    collateralTypes[j]
                );
                avgCorrelation += correlation;
                pairCount++;
            }
        }
        
        return avgCorrelation / pairCount;
    }
    
    // è¿è¡Œå‹åŠ›æµ‹è¯•åœºæ™¯
    function runStressTest() private returns (SimulationResults memory) {
        SimulationParameters memory params = SimulationParameters({
            numSimulations: 1000,
            timeHorizon: 30,        // 30å¤©
            initialPrice: 1e18,     // $1
            annualVolatility: 5000, // 50%æ³¢åŠ¨ç‡ï¼ˆå‹åŠ›åœºæ™¯ï¼‰
            drift: -1000,          // -10%è´Ÿæ¼‚ç§»
            jumpProbability: 1e16,  // 1%è·³è·ƒæ¦‚ç‡
            jumpSize: -2e17        // -20%è·³è·ƒ
        });
        
        return simulator.runMonteCarloSimulation(params, 150, 1000);
    }
    
    // è®¡ç®—ç»¼åˆé£é™©è¯„åˆ†
    function calculateOverallRisk(
        RiskMetrics memory metrics,
        SimulationResults memory simResults
    ) private pure returns (uint256) {
        // æƒé‡é…ç½®
        uint256 w1 = 30; // æŠµæŠ¼ç‡æƒé‡
        uint256 w2 = 20; // é›†ä¸­åº¦æƒé‡
        uint256 w3 = 25; // æµåŠ¨æ€§æƒé‡
        uint256 w4 = 15; // ç›¸å…³æ€§æƒé‡
        uint256 w5 = 10; // å‹åŠ›æµ‹è¯•æƒé‡
        
        // æ ‡å‡†åŒ–å„é¡¹æŒ‡æ ‡ï¼ˆ0-100ï¼‰
        uint256 collateralScore = metrics.systemCollateralRatio > 200 ? 0 :
                                 (200 - metrics.systemCollateralRatio) / 2;
        
        uint256 concentrationScore = metrics.concentrationRisk / 100;
        
        uint256 liquidityScore = metrics.liquidityRisk * 100 / 1e18;
        
        uint256 correlationScore = metrics.correlationRisk * 100 / 1e18;
        
        uint256 stressScore = simResults.defaultProbability * 100 / 1e18;
        
        // åŠ æƒå¹³å‡
        return (collateralScore * w1 + 
                concentrationScore * w2 + 
                liquidityScore * w3 + 
                correlationScore * w4 + 
                stressScore * w5) / 100;
    }
    
    // ç¡®å®šé£é™©ç­‰çº§
    function determineRiskLevel(uint256 riskScore) 
        private 
        pure 
        returns (RiskLevel) 
    {
        if (riskScore < 25) return RiskLevel.LOW;
        if (riskScore < 50) return RiskLevel.MEDIUM;
        if (riskScore < 75) return RiskLevel.HIGH;
        return RiskLevel.CRITICAL;
    }
    
    // è§¦å‘é£é™©é¢„è­¦
    function triggerRiskAlert(RiskMetrics memory metrics) private {
        emit RiskAlert(
            metrics.riskLevel,
            metrics.overallRiskScore,
            block.timestamp
        );
        
        // è‡ªåŠ¨è°ƒæ•´ç³»ç»Ÿå‚æ•°
        if (metrics.riskLevel == RiskLevel.CRITICAL) {
            // æé«˜æ¸…ç®—çº¿
            // å¢åŠ ç¨³å®šè´¹
            // é™åˆ¶æ–°å€Ÿæ¬¾
        }
    }
    
    // è¾…åŠ©å‡½æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
    function getCDPValues(address cdp) 
        private 
        view 
        returns (uint256 collateral, uint256 debt) 
    {
        // å®é™…å®ç°ä¸­ä»CDPåˆçº¦è¯»å–
        collateral = 150e18;
        debt = 100e18;
    }
    
    function getMarketDepth(address collateral) 
        private 
        view 
        returns (uint256) 
    {
        // å®é™…å®ç°ä¸­ä»DEXè·å–æµåŠ¨æ€§æ·±åº¦
        return 2e6 * 1e18;
    }
    
    function getPriceCorrelation(address token1, address token2) 
        private 
        view 
        returns (uint256) 
    {
        // å®é™…å®ç°ä¸­è®¡ç®—å†å²ä»·æ ¼ç›¸å…³æ€§
        return 5e17; // 0.5ç›¸å…³ç³»æ•°
    }
    
    event RiskAlert(RiskLevel level, uint256 score, uint256 timestamp);
}</code></pre>
            </div>
        </div>
        
        <h3>ç»ƒä¹ é¢˜</h3>
        
        <div class="exercise">
            <h4>ç»ƒä¹  5.1ï¼šå®ç°è‡ªé€‚åº”PIDæ§åˆ¶å™¨</h4>
            <p>è®¾è®¡ä¸€ä¸ªè‡ªé€‚åº”PIDæ§åˆ¶å™¨ï¼Œèƒ½å¤Ÿæ ¹æ®å¸‚åœºæ¡ä»¶ï¼ˆæ³¢åŠ¨ç‡ã€äº¤æ˜“é‡ã€ä»·æ ¼åç¦»ç¨‹åº¦ï¼‰è‡ªåŠ¨è°ƒæ•´PIDå‚æ•°ã€‚è¦æ±‚ï¼š</p>
            <ul>
                <li>å®ç°Ziegler-Nicholså‚æ•°æ•´å®šæ–¹æ³•</li>
                <li>åŠ å…¥æŠ—ç§¯åˆ†é¥±å’Œæœºåˆ¶</li>
                <li>å®ç°å‚æ•°å¹³æ»‘è¿‡æ¸¡ï¼ˆé¿å…çªå˜ï¼‰</li>
                <li>è®°å½•å‚æ•°è°ƒæ•´å†å²ç”¨äºåˆ†æ</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-1')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer5-1" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract AdaptivePIDController {
    struct PIDParams {
        int256 Kp;
        int256 Ki;
        int256 Kd;
        uint256 timestamp;
    }
    
    PIDParams public currentParams;
    PIDParams[] public paramsHistory;
    
    // Ziegler-Nicholså‚æ•°
    int256 public Ku;  // ç»ˆæå¢ç›Š
    uint256 public Tu; // ç»ˆæå‘¨æœŸ
    
    // æŠ—ç§¯åˆ†é¥±å’Œ
    int256 public integralMax = 1e18;
    int256 public integralMin = -1e18;
    
    // å‚æ•°å¹³æ»‘
    uint256 public smoothingFactor = 900; // 90%åŸå€¼ + 10%æ–°å€¼
    
    function adaptParameters(
        uint256 volatility,
        uint256 volume,
        uint256 priceDeviation
    ) external {
        // è®¡ç®—ç³»ç»Ÿå“åº”ç‰¹æ€§
        uint256 responseSpeed = calculateResponseSpeed(volatility, volume);
        
        // Ziegler-Nicholsæ•´å®š
        if (needsRetuning(priceDeviation, responseSpeed)) {
            (int256 newKp, int256 newKi, int256 newKd) = 
                zieglerNicholsTuning(responseSpeed);
            
            // å¹³æ»‘è¿‡æ¸¡
            currentParams.Kp = (currentParams.Kp * int256(smoothingFactor) + 
                               newKp * int256(1000 - smoothingFactor)) / 1000;
            currentParams.Ki = (currentParams.Ki * int256(smoothingFactor) + 
                               newKi * int256(1000 - smoothingFactor)) / 1000;
            currentParams.Kd = (currentParams.Kd * int256(smoothingFactor) + 
                               newKd * int256(1000 - smoothingFactor)) / 1000;
            
            // è®°å½•å†å²
            paramsHistory.push(PIDParams({
                Kp: currentParams.Kp,
                Ki: currentParams.Ki,
                Kd: currentParams.Kd,
                timestamp: block.timestamp
            }));
        }
    }
    
    function zieglerNicholsTuning(uint256 responseSpeed) 
        private 
        view 
        returns (int256 Kp, int256 Ki, int256 Kd) 
    {
        // PIæ§åˆ¶å™¨å‚æ•°
        Kp = Ku * 45 / 100;
        Ki = Kp * 1e18 / (Tu * 83 / 100);
        Kd = 0;
        
        // æ ¹æ®å“åº”é€Ÿåº¦å¾®è°ƒ
        if (responseSpeed > 1e18) {
            // å¿«é€Ÿå“åº”ï¼Œå¢åŠ Dé¡¹
            Kd = Kp * Tu * 125 / 1000;
        }
    }
    
    function computePIDWithAntiWindup(int256 error, uint256 dt) 
        external 
        returns (int256 output) 
    {
        // Pé¡¹
        int256 pTerm = currentParams.Kp * error / 1e18;
        
        // Ié¡¹ï¼ˆå¸¦æŠ—é¥±å’Œï¼‰
        int256 newIntegral = integral + error * int256(dt);
        
        // æ£€æŸ¥ç§¯åˆ†é™åˆ¶
        if (newIntegral > integralMax) {
            integral = integralMax;
        } else if (newIntegral < integralMin) {
            integral = integralMin;
        } else {
            integral = newIntegral;
        }
        
        int256 iTerm = currentParams.Ki * integral / 1e18;
        
        // Dé¡¹ï¼ˆå¸¦æ»¤æ³¢ï¼‰
        int256 dTerm = 0;
        if (dt > 0) {
            int256 derivativeRaw = (error - lastError) * 1e18 / int256(dt);
            // ä½é€šæ»¤æ³¢
            derivative = (derivative * 8 + derivativeRaw * 2) / 10;
            dTerm = currentParams.Kd * derivative / 1e18;
        }
        
        output = pTerm + iTerm + dTerm;
        
        // åç®—ç§¯åˆ†é¡¹é˜²æ­¢windup
        if (output > MAX_OUTPUT) {
            integral -= (output - MAX_OUTPUT) * 1e18 / currentParams.Ki;
            output = MAX_OUTPUT;
        } else if (output < MIN_OUTPUT) {
            integral -= (output - MIN_OUTPUT) * 1e18 / currentParams.Ki;
            output = MIN_OUTPUT;
        }
        
        lastError = error;
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>ç»ƒä¹  5.2ï¼šæ„å»ºåšå¼ˆè®ºæ¸…ç®—æ¨¡å‹</h4>
            <p>å®ç°ä¸€ä¸ªåŸºäºåšå¼ˆè®ºçš„æ¸…ç®—æ¿€åŠ±ç³»ç»Ÿï¼Œè€ƒè™‘ï¼š</p>
            <ul>
                <li>å¤šä¸ªKeeperä¹‹é—´çš„ç«äº‰åšå¼ˆ</li>
                <li>CDPæŒæœ‰è€…çš„æœ€ä¼˜å“åº”ç­–ç•¥</li>
                <li>å®ç°å£°èª‰ç³»ç»Ÿå½±å“Keeperè¡Œä¸º</li>
                <li>è®¾è®¡é˜²æ­¢æ¶æ„æ¸…ç®—çš„æœºåˆ¶</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-2')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer5-2" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract GameTheoreticLiquidation {
    struct KeeperInfo {
        uint256 reputation;      // å£°èª‰åˆ†æ•°
        uint256 successfulLiquidations;
        uint256 failedAttempts;
        uint256 avgResponseTime;
        uint256 totalProfit;
    }
    
    struct LiquidationGame {
        address cdp;
        uint256 startTime;
        uint256 optimalBid;      // åšå¼ˆè®ºè®¡ç®—çš„æœ€ä¼˜å‡ºä»·
        address[] participants;
        mapping(address => uint256) bids;
        bool settled;
    }
    
    mapping(address => KeeperInfo) public keepers;
    mapping(uint256 => LiquidationGame) public games;
    
    // è®¡ç®—çº³ä»€å‡è¡¡å‡ºä»·
    function calculateNashEquilibrium(
        uint256 collateralValue,
        uint256 debtValue,
        uint256 numKeepers,
        uint256 gasPrice
    ) public pure returns (uint256 equilibriumBid) {
        // ç®€åŒ–çš„çº³ä»€å‡è¡¡ï¼š
        // å‡ºä»· = (æŠµæŠ¼å“ä»·å€¼ - å€ºåŠ¡ - Gasæˆæœ¬) / (å‚ä¸è€…æ•°é‡ + 1)
        
        uint256 profit = collateralValue - debtValue;
        uint256 gasCost = gasPrice * 300000; // ä¼°è®¡Gasæ¶ˆè€—
        
        if (profit > gasCost) {
            equilibriumBid = (profit - gasCost) * 1e18 / (numKeepers + 1) / 1e18;
        } else {
            equilibriumBid = 0;
        }
    }
    
    // Keeperæäº¤å¯†å°å‡ºä»·ï¼ˆcommit-revealæ¨¡å¼ï¼‰
    function commitBid(uint256 gameId, bytes32 commitment) external {
        require(!games[gameId].settled, "Game settled");
        require(block.timestamp < games[gameId].startTime + 5 minutes, "Commit phase ended");
        
        commitments[gameId][msg.sender] = commitment;
        games[gameId].participants.push(msg.sender);
    }
    
    // æ­ç¤ºå‡ºä»·
    function revealBid(
        uint256 gameId, 
        uint256 bid, 
        uint256 nonce
    ) external {
        require(block.timestamp >= games[gameId].startTime + 5 minutes, "Still in commit phase");
        require(block.timestamp < games[gameId].startTime + 10 minutes, "Reveal phase ended");
        
        bytes32 commitment = keccak256(abi.encodePacked(bid, nonce, msg.sender));
        require(commitments[gameId][msg.sender] == commitment, "Invalid reveal");
        
        games[gameId].bids[msg.sender] = bid;
        
        // æ›´æ–°Keeperå“åº”æ—¶é—´
        uint256 responseTime = block.timestamp - games[gameId].startTime;
        updateKeeperStats(msg.sender, responseTime);
    }
    
    // ç»“ç®—æ¸…ç®—åšå¼ˆ
    function settleLiquidationGame(uint256 gameId) external {
        LiquidationGame storage game = games[gameId];
        require(!game.settled, "Already settled");
        require(block.timestamp >= game.startTime + 10 minutes, "Reveal phase not ended");
        
        address winner;
        uint256 highestBid;
        
        // æ‰¾å‡ºæœ€é«˜å‡ºä»·è€…ï¼ˆè€ƒè™‘å£°èª‰åŠ æˆï¼‰
        for (uint256 i = 0; i < game.participants.length; i++) {
            address keeper = game.participants[i];
            uint256 bid = game.bids[keeper];
            
            // å£°èª‰åŠ æˆ
            uint256 effectiveBid = bid * (1000 + keepers[keeper].reputation) / 1000;
            
            if (effectiveBid > highestBid) {
                highestBid = effectiveBid;
                winner = keeper;
            }
        }
        
        // æ‰§è¡Œæ¸…ç®—
        if (winner != address(0)) {
            executeLiquidation(game.cdp, winner, game.bids[winner]);
            
            // æ›´æ–°ç»Ÿè®¡
            keepers[winner].successfulLiquidations++;
            keepers[winner].totalProfit += calculateProfit(gameId, game.bids[winner]);
            
            // æ›´æ–°å£°èª‰
            updateReputation(winner, true);
            
            // æƒ©ç½šå‡ºä»·è¿‡ä½çš„Keeper
            punishLowBidders(gameId, game.optimalBid);
        }
        
        game.settled = true;
    }
    
    // å£°èª‰ç³»ç»Ÿ
    function updateReputation(address keeper, bool success) private {
        if (success) {
            keepers[keeper].reputation = min(
                keepers[keeper].reputation + 10,
                1000  // æœ€é«˜1000åˆ†
            );
        } else {
            keepers[keeper].reputation = keepers[keeper].reputation > 10 ? 
                keepers[keeper].reputation - 10 : 0;
        }
    }
    
    // é˜²æ¶æ„æ¸…ç®—æœºåˆ¶
    function challengeLiquidation(uint256 gameId) external {
        // CDPæŒæœ‰è€…å¯ä»¥æŒ‘æˆ˜æ¸…ç®—
        LiquidationGame storage game = games[gameId];
        require(msg.sender == getCDPOwner(game.cdp), "Not CDP owner");
        require(!game.settled, "Already settled");
        
        // æ£€æŸ¥æ˜¯å¦çœŸçš„éœ€è¦æ¸…ç®—
        if (isCDPSafe(game.cdp)) {
            // æ¸…ç®—æ— æ•ˆï¼Œæƒ©ç½šå‘èµ·è€…
            address liquidator = game.participants[0];
            keepers[liquidator].failedAttempts++;
            updateReputation(liquidator, false);
            
            // è¡¥å¿CDPæŒæœ‰è€…
            compensateCDPOwner(msg.sender);
            
            // å–æ¶ˆæ¸…ç®—
            game.settled = true;
        }
    }
    
    // CDPæŒæœ‰è€…æœ€ä¼˜å“åº”
    function calculateOptimalResponse(
        uint256 currentCollateralRatio,
        uint256 liquidationRatio,
        uint256 gasPrice
    ) external view returns (
        bool shouldTopUp,
        uint256 topUpAmount,
        bool shouldRepay,
        uint256 repayAmount
    ) {
        uint256 buffer = (currentCollateralRatio - liquidationRatio) * 1e18 / 
                        liquidationRatio;
        
        if (buffer < 1e17) { // å°‘äº10%ç¼“å†²
            // è®¡ç®—è¡¥å……æŠµæŠ¼å“vså¿è¿˜å€ºåŠ¡çš„æˆæœ¬
            uint256 topUpCost = calculateTopUpCost(gasPrice);
            uint256 repayCost = calculateRepayCost(gasPrice);
            
            if (topUpCost < repayCost) {
                shouldTopUp = true;
                topUpAmount = calculateRequiredCollateral(
                    liquidationRatio * 125 / 100  // ç›®æ ‡125%çš„æ¸…ç®—çº¿
                );
            } else {
                shouldRepay = true;
                repayAmount = calculateRequiredRepayment(
                    liquidationRatio * 125 / 100
                );
            }
        }
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>ç»ƒä¹  5.3ï¼šæœŸæƒå®šä»·ä¸åŠ¨æ€æŠµæŠ¼ç‡</h4>
            <p>åŸºäºBlack-Scholesæ¨¡å‹ï¼Œå®ç°ä¸€ä¸ªåŠ¨æ€æŠµæŠ¼ç‡è°ƒæ•´ç³»ç»Ÿï¼š</p>
            <ul>
                <li>æ ¹æ®éšå«æ³¢åŠ¨ç‡å®æ—¶è°ƒæ•´æŠµæŠ¼è¦æ±‚</li>
                <li>å®ç°æ³¢åŠ¨ç‡å¾®ç¬‘ä¿®æ­£</li>
                <li>åŠ å…¥æµåŠ¨æ€§é£é™©æº¢ä»·</li>
                <li>è®¾è®¡å¹³æ»‘è°ƒæ•´æœºåˆ¶é¿å…é¢‘ç¹å˜åŠ¨</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-3')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer5-3" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract DynamicCollateralRatio {
    using ABDKMath64x64 for int128;
    
    struct VolatilitySmile {
        uint256 atmVol;          // å¹³å€¼æ³¢åŠ¨ç‡
        int256 skew;            // åæ–œ
        uint256 kurtosis;       // å³°åº¦
    }
    
    struct CollateralAdjustment {
        uint256 baseRatio;
        uint256 volAdjustment;
        uint256 liquidityAdjustment;
        uint256 finalRatio;
        uint256 timestamp;
    }
    
    mapping(address => VolatilitySmile) public volSmiles;
    mapping(address => CollateralAdjustment[]) public adjustmentHistory;
    
    uint256 public smoothingWindow = 4 hours;
    uint256 public maxAdjustmentPerPeriod = 5; // 5%
    
    // è®¡ç®—éšå«æ³¢åŠ¨ç‡
    function calculateImpliedVolatility(
        address asset,
        uint256 optionPrice,
        uint256 strike,
        uint256 spot,
        uint256 timeToExpiry
    ) public pure returns (uint256 impliedVol) {
        // Newton-Raphsonè¿­ä»£æ±‚è§£éšå«æ³¢åŠ¨ç‡
        uint256 vol = 3000; // åˆå§‹çŒœæµ‹30%
        
        for (uint256 i = 0; i < 10; i++) {
            uint256 theoreticalPrice = blackScholesPrice(
                spot, strike, timeToExpiry, vol, 0
            );
            
            uint256 vega = calculateVega(
                spot, strike, timeToExpiry, vol
            );
            
            if (theoreticalPrice > optionPrice) {
                vol = vol - (theoreticalPrice - optionPrice) * 1e18 / vega;
            } else {
                vol = vol + (optionPrice - theoreticalPrice) * 1e18 / vega;
            }
        }
        
        return vol;
    }
    
    // æ³¢åŠ¨ç‡å¾®ç¬‘ä¿®æ­£
    function applyVolatilitySmile(
        uint256 baseVol,
        uint256 moneyness,  // spot/strike
        VolatilitySmile memory smile
    ) public pure returns (uint256 adjustedVol) {
        // äºŒæ¬¡ä¿®æ­£æ¨¡å‹
        int256 lnMoneyness = ln(moneyness);
        
        // vol = ATM_vol + skew * ln(K/S) + kurtosis * ln(K/S)^2
        int256 adjustment = smile.skew * lnMoneyness / 1e18 +
                           int256(smile.kurtosis) * lnMoneyness * 
                           lnMoneyness / 1e36;
        
        if (adjustment > 0) {
            adjustedVol = baseVol + uint256(adjustment);
        } else {
            adjustedVol = baseVol - uint256(-adjustment);
        }
    }
    
    // è®¡ç®—æµåŠ¨æ€§é£é™©æº¢ä»·
    function calculateLiquidityPremium(
        address asset,
        uint256 positionSize
    ) public view returns (uint256 premium) {
        uint256 marketDepth = getMarketDepth(asset);
        uint256 impactRatio = positionSize * 1e18 / marketDepth;
        
        // éçº¿æ€§å½±å“æ¨¡å‹
        if (impactRatio < 1e16) { // < 1%
            premium = 0;
        } else if (impactRatio < 5e16) { // 1-5%
            premium = impactRatio / 10; // 10%çš„å½±å“æ¯”ä¾‹
        } else if (impactRatio < 1e17) { // 5-10%
            premium = impactRatio / 5;  // 20%çš„å½±å“æ¯”ä¾‹
        } else {
            premium = impactRatio / 2;  // 50%çš„å½±å“æ¯”ä¾‹
        }
    }
    
    // åŠ¨æ€è°ƒæ•´æŠµæŠ¼ç‡
    function adjustCollateralRatio(
        address asset,
        uint256 currentRatio
    ) external returns (uint256 newRatio) {
        // 1. è·å–æœ€æ–°å¸‚åœºæ•°æ®
        uint256 spot = getSpotPrice(asset);
        uint256 impliedVol = getImpliedVolatility(asset);
        
        // 2. åº”ç”¨æ³¢åŠ¨ç‡å¾®ç¬‘
        VolatilitySmile memory smile = volSmiles[asset];
        uint256 adjustedVol = applyVolatilitySmile(
            impliedVol,
            1e18, // å¹³å€¼
            smile
        );
        
        // 3. åŸºäºæœŸæƒæ¨¡å‹è®¡ç®—åŸºç¡€æŠµæŠ¼ç‡
        uint256 baseRatio = calculateOptimalRatio(
            spot,
            spot * currentRatio / 100,
            adjustedVol
        );
        
        // 4. åŠ å…¥æµåŠ¨æ€§é£é™©è°ƒæ•´
        uint256 avgPositionSize = getAveragePositionSize(asset);
        uint256 liquidityPremium = calculateLiquidityPremium(
            asset,
            avgPositionSize
        );
        
        uint256 liquidityAdjustedRatio = baseRatio * 
            (1e18 + liquidityPremium) / 1e18;
        
        // 5. å¹³æ»‘è°ƒæ•´
        CollateralAdjustment memory lastAdjustment = 
            getLastAdjustment(asset);
        
        if (block.timestamp < lastAdjustment.timestamp + smoothingWindow) {
            // åœ¨å¹³æ»‘çª—å£å†…ï¼Œé™åˆ¶è°ƒæ•´å¹…åº¦
            int256 change = int256(liquidityAdjustedRatio) - 
                           int256(lastAdjustment.finalRatio);
            
            int256 maxChange = int256(lastAdjustment.finalRatio * 
                                     maxAdjustmentPerPeriod / 100);
            
            if (abs(change) > maxChange) {
                change = change > 0 ? maxChange : -maxChange;
            }
            
            newRatio = uint256(int256(lastAdjustment.finalRatio) + change);
        } else {
            newRatio = liquidityAdjustedRatio;
        }
        
        // 6. è®°å½•è°ƒæ•´å†å²
        adjustmentHistory[asset].push(CollateralAdjustment({
            baseRatio: baseRatio,
            volAdjustment: adjustedVol - impliedVol,
            liquidityAdjustment: liquidityPremium,
            finalRatio: newRatio,
            timestamp: block.timestamp
        }));
        
        return newRatio;
    }
    
    // è®¡ç®—Vegaï¼ˆæœŸæƒä»·æ ¼å¯¹æ³¢åŠ¨ç‡çš„æ•æ„Ÿåº¦ï¼‰
    function calculateVega(
        uint256 spot,
        uint256 strike,
        uint256 timeToExpiry,
        uint256 vol
    ) private pure returns (uint256) {
        // ç®€åŒ–çš„Vegaè®¡ç®—
        uint256 d1 = calculateD1(spot, strike, timeToExpiry, vol, 0);
        uint256 sqrtT = sqrt(timeToExpiry * 1e18 / 365 days);
        
        // Vega = S * N'(d1) * sqrt(T)
        uint256 nPrimeD1 = normalPDF(d1);
        return spot * nPrimeD1 * sqrtT / 1e27;
    }
    
    // æ­£æ€åˆ†å¸ƒæ¦‚ç‡å¯†åº¦å‡½æ•°
    function normalPDF(uint256 x) private pure returns (uint256) {
        // N'(x) = 1/âˆš(2Ï€) * e^(-xÂ²/2)
        uint256 exponent = x * x / 2e18;
        uint256 expTerm = exp(-int256(exponent));
        return expTerm * 398942280 / 1e9; // 1/âˆš(2Ï€) â‰ˆ 0.398942280
    }
}</code></pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>ç»ƒä¹  5.4ï¼šç»¼åˆé£é™©ç®¡ç†ç³»ç»Ÿ</h4>
            <p>è®¾è®¡ä¸€ä¸ªç»¼åˆçš„é£é™©ç®¡ç†ç³»ç»Ÿï¼Œæ•´åˆå‰é¢æ‰€æœ‰çš„æ•°å­¦æ¨¡å‹ï¼š</p>
            <ul>
                <li>å®æ—¶é£é™©ä»ªè¡¨æ¿ï¼Œæ˜¾ç¤ºå„é¡¹é£é™©æŒ‡æ ‡</li>
                <li>è‡ªåŠ¨è§¦å‘é£é™©ç¼“è§£æªæ–½</li>
                <li>å¤šåœºæ™¯å‹åŠ›æµ‹è¯•å¼•æ“</li>
                <li>æœºå™¨å­¦ä¹ é£é™©é¢„æµ‹ï¼ˆé“¾ä¸‹è®¡ç®—ï¼Œé“¾ä¸ŠéªŒè¯ï¼‰</li>
            </ul>
            
            <button onclick="toggleAnswer('answer5-4')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div id="answer5-4" class="answer">
                <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                <pre><code class="language-solidity">contract IntegratedRiskManagement {
    // é£é™©ä»ªè¡¨æ¿
    struct RiskDashboard {
        uint256 overallHealthScore;     // 0-100
        uint256 systemCollateralRatio;
        uint256 liquidityDepth;
        uint256 concentrationIndex;
        uint256 volatilityIndex;
        uint256 stressTestScore;
        PIDStatus pidStatus;
        OptionMetrics optionMetrics;
        MLPrediction mlPrediction;
    }
    
    struct PIDStatus {
        int256 currentError;
        int256 integralError;
        int256 output;
        uint256 lastAdjustment;
    }
    
    struct OptionMetrics {
        uint256 impliedVol;
        uint256 optimalCollateralRatio;
        uint256 expectedLoss;
    }
    
    struct MLPrediction {
        uint256 riskScore;
        uint256 confidence;
        bytes32 modelHash;
        uint256 timestamp;
    }
    
    // é£é™©ç¼“è§£æªæ–½
    enum RiskMitigation {
        NONE,
        INCREASE_COLLATERAL_RATIO,
        PAUSE_NEW_CDPS,
        INCREASE_STABILITY_FEE,
        TRIGGER_EMERGENCY_SHUTDOWN
    }
    
    // è·å–å®æ—¶é£é™©ä»ªè¡¨æ¿
    function getRiskDashboard() 
        external 
        view 
        returns (RiskDashboard memory dashboard) 
    {
        dashboard.systemCollateralRatio = calculateSystemCR();
        dashboard.liquidityDepth = assessLiquidity();
        dashboard.concentrationIndex = calculateConcentration();
        dashboard.volatilityIndex = getVolatilityIndex();
        dashboard.stressTestScore = getLatestStressTestScore();
        
        dashboard.pidStatus = getPIDStatus();
        dashboard.optionMetrics = getOptionMetrics();
        dashboard.mlPrediction = getMLPrediction();
        
        // è®¡ç®—æ€»ä½“å¥åº·åˆ†æ•°
        dashboard.overallHealthScore = calculateHealthScore(dashboard);
    }
    
    // è‡ªåŠ¨é£é™©ç¼“è§£
    function triggerRiskMitigation() external {
        RiskDashboard memory dashboard = getRiskDashboard();
        
        RiskMitigation action = determineAction(dashboard);
        
        if (action == RiskMitigation.INCREASE_COLLATERAL_RATIO) {
            adjustCollateralRequirements(5); // å¢åŠ 5%
        } else if (action == RiskMitigation.PAUSE_NEW_CDPS) {
            pauseNewCDPCreation();
        } else if (action == RiskMitigation.INCREASE_STABILITY_FEE) {
            increaseStabilityFee(2); // å¢åŠ 2%
        } else if (action == RiskMitigation.TRIGGER_EMERGENCY_SHUTDOWN) {
            triggerEmergencyShutdown();
        }
        
        emit RiskMitigationTriggered(action, dashboard.overallHealthScore);
    }
    
    // å¤šåœºæ™¯å‹åŠ›æµ‹è¯•
    function runComprehensiveStressTest() external returns (
        StressTestResults memory results
    ) {
        // åœºæ™¯1ï¼šé»‘å¤©é¹…äº‹ä»¶
        results.blackSwanImpact = simulateBlackSwan(
            50, // 50%ä»·æ ¼ä¸‹è·Œ
            1 hours // 1å°æ—¶å†…
        );
        
        // åœºæ™¯2ï¼šæµåŠ¨æ€§å±æœº
        results.liquidityCrisisImpact = simulateLiquidityCrisis(
            90 // 90%æµåŠ¨æ€§æ¯ç«­
        );
        
        // åœºæ™¯3ï¼šçº§è”æ¸…ç®—
        results.cascadeLiquidationImpact = simulateCascadeLiquidation(
            30 // 30%çš„CDPåŒæ—¶æ¸…ç®—
        );
        
        // åœºæ™¯4ï¼šé¢„è¨€æœºæ”»å‡»
        results.oracleAttackImpact = simulateOracleAttack(
            20 // 20%ä»·æ ¼æ“çºµ
        );
        
        // åœºæ™¯5ï¼šç½‘ç»œæ‹¥å µ
        results.networkCongestionImpact = simulateNetworkCongestion(
            1000 gwei // æé«˜Gasä»·æ ¼
        );
        
        // ç»¼åˆè¯„ä¼°
        results.worstCaseScenario = max(
            results.blackSwanImpact,
            results.liquidityCrisisImpact,
            results.cascadeLiquidationImpact,
            results.oracleAttackImpact,
            results.networkCongestionImpact
        );
        
        updateStressTestScore(results.worstCaseScenario);
    }
    
    // MLé£é™©é¢„æµ‹éªŒè¯
    function verifyMLPrediction(
        uint256 predictedRisk,
        uint256 confidence,
        bytes32 modelHash,
        bytes memory proof
    ) external {
        // éªŒè¯é“¾ä¸‹MLæ¨¡å‹çš„é¢„æµ‹
        require(verifyZKProof(proof, modelHash), "Invalid ML proof");
        
        mlPredictions[block.timestamp] = MLPrediction({
            riskScore: predictedRisk,
            confidence: confidence,
            modelHash: modelHash,
            timestamp: block.timestamp
        });
        
        // å¦‚æœMLé¢„æµ‹é«˜é£é™©ï¼Œè§¦å‘é¢å¤–éªŒè¯
        if (predictedRisk > 80 && confidence > 90) {
            requireManualReview = true;
            emit HighRiskMLPrediction(predictedRisk, confidence);
        }
    }
    
    // ç»¼åˆå¥åº·è¯„åˆ†è®¡ç®—
    function calculateHealthScore(RiskDashboard memory dashboard) 
        private 
        pure 
        returns (uint256) 
    {
        uint256 score = 100;
        
        // æŠµæŠ¼ç‡è¯„åˆ†
        if (dashboard.systemCollateralRatio < 150) {
            score -= (150 - dashboard.systemCollateralRatio) / 2;
        }
        
        // æµåŠ¨æ€§è¯„åˆ†
        if (dashboard.liquidityDepth < 10e6 * 1e18) {
            score -= 20;
        }
        
        // é›†ä¸­åº¦è¯„åˆ†
        if (dashboard.concentrationIndex > 1000) { // HHI > 1000
            score -= 15;
        }
        
        // æ³¢åŠ¨ç‡è¯„åˆ†
        if (dashboard.volatilityIndex > 50) {
            score -= (dashboard.volatilityIndex - 50) / 2;
        }
        
        // MLé¢„æµ‹è°ƒæ•´
        if (dashboard.mlPrediction.confidence > 80) {
            score = score * (100 - dashboard.mlPrediction.riskScore) / 100;
        }
        
        return score > 0 ? score : 0;
    }
}</code></pre>
            </div>
        </div>
        
        <h3>æœ¬ç« å°ç»“</h3>
        <div class="tip">
            <strong>å…³é”®è¦ç‚¹ï¼š</strong>
            <ul>
                <li><strong>æ§åˆ¶ç†è®ºåº”ç”¨ï¼š</strong>PIDæ§åˆ¶å™¨å¯ä»¥æœ‰æ•ˆç»´æŒç¨³å®šå¸ä»·æ ¼ç¨³å®šï¼Œä½†éœ€è¦æ ¹æ®å¸‚åœºæ¡ä»¶åŠ¨æ€è°ƒæ•´å‚æ•°</li>
                <li><strong>åšå¼ˆè®ºè§†è§’ï¼š</strong>æ¸…ç®—æœºåˆ¶è®¾è®¡éœ€è¦å¹³è¡¡å¤šæ–¹åˆ©ç›Šï¼Œç¡®ä¿ç³»ç»Ÿæ¿€åŠ±ç›¸å®¹</li>
                <li><strong>æœŸæƒå®šä»·æ¨¡å‹ï¼š</strong>Black-Scholesæ¨¡å‹æä¾›äº†ç§‘å­¦çš„æŠµæŠ¼ç‡å®šä»·æ–¹æ³•</li>
                <li><strong>é£é™©ç®¡ç†ï¼š</strong>ç»¼åˆè¿ç”¨å¤šç§æ•°å­¦æ¨¡å‹ï¼Œæ„å»ºå…¨æ–¹ä½çš„é£é™©ç®¡ç†ä½“ç³»</li>
                <li><strong>å®è·µä»·å€¼ï¼š</strong>è¿™äº›ç†è®ºæ¨¡å‹ä¸æ˜¯çº¸ä¸Šè°ˆå…µï¼Œè€Œæ˜¯å¯ä»¥ç›´æ¥åº”ç”¨äºç”Ÿäº§ç¯å¢ƒçš„å®ç”¨å·¥å…·</li>
            </ul>
        </div>
        
        <h3>æœ¯è¯­é€ŸæŸ¥è¡¨</h3>
        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
            <tr style="background: #f3f4f6;">
                <th style="border: 1px solid #ddd; padding: 12px;">æœ¯è¯­</th>
                <th style="border: 1px solid #ddd; padding: 12px;">è‹±æ–‡</th>
                <th style="border: 1px solid #ddd; padding: 12px;">å«ä¹‰</th>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">PIDæ§åˆ¶å™¨</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Proportional-Integral-Derivative Controller</td>
                <td style="border: 1px solid #ddd; padding: 8px;">ç»å…¸çš„åé¦ˆæ§åˆ¶ç®—æ³•</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">çº³ä»€å‡è¡¡</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Nash Equilibrium</td>
                <td style="border: 1px solid #ddd; padding: 8px;">åšå¼ˆè®ºä¸­çš„ç¨³å®šçŠ¶æ€</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">éšå«æ³¢åŠ¨ç‡</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Implied Volatility</td>
                <td style="border: 1px solid #ddd; padding: 8px;">ä»æœŸæƒä»·æ ¼åæ¨çš„æ³¢åŠ¨ç‡</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">VaR</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Value at Risk</td>
                <td style="border: 1px solid #ddd; padding: 8px;">é£é™©ä»·å€¼ï¼Œæ½œåœ¨æŸå¤±çš„ç»Ÿè®¡åº¦é‡</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Monte Carlo Simulation</td>
                <td style="border: 1px solid #ddd; padding: 8px;">åŸºäºéšæœºæŠ½æ ·çš„æ•°å€¼è®¡ç®—æ–¹æ³•</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">ç§¯åˆ†é¥±å’Œ</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Integral Windup</td>
                <td style="border: 1px solid #ddd; padding: 8px;">PIDæ§åˆ¶å™¨ä¸­ç§¯åˆ†é¡¹è¿‡åº¦ç´¯ç§¯</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">æ³¢åŠ¨ç‡å¾®ç¬‘</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Volatility Smile</td>
                <td style="border: 1px solid #ddd; padding: 8px;">ä¸åŒè¡Œæƒä»·çš„éšå«æ³¢åŠ¨ç‡æ›²çº¿</td>
            </tr>
            <tr>
                <td style="border: 1px solid #ddd; padding: 8px;">HHIæŒ‡æ•°</td>
                <td style="border: 1px solid #ddd; padding: 8px;">Herfindahl-Hirschman Index</td>
                <td style="border: 1px solid #ddd; padding: 8px;">å¸‚åœºé›†ä¸­åº¦æŒ‡æ ‡</td>
            </tr>
        </table>
    </div>
    
    <h3>5.6 2024å¹´æœ€æ–°å‘å±•ï¼šLST/LRTä¸RWA</h3>
    
    <h4>5.6.1 æµåŠ¨æ€§è´¨æŠ¼ä»£å¸(LST)ä½œä¸ºæŠµæŠ¼å“</h4>
    <p>éšç€ä»¥å¤ªåŠè½¬å‘PoSï¼ŒæµåŠ¨æ€§è´¨æŠ¼ä»£å¸ï¼ˆLiquid Staking Tokensï¼‰å¦‚stETHã€rETHæˆä¸ºé‡è¦çš„æŠµæŠ¼å“ç±»å‹ã€‚è¿™å¸¦æ¥äº†æ–°çš„é£é™©ç®¡ç†æŒ‘æˆ˜ã€‚</p>
    
    <div class="info-box">
        <h5>ğŸ’¡ LSTç‰¹æœ‰é£é™©</h5>
        <ul>
            <li><strong>è„±é”šé£é™©</strong>ï¼šLSTå¯èƒ½ä¸åº•å±‚ETHè„±é”šï¼Œç‰¹åˆ«æ˜¯åœ¨å¸‚åœºå‹åŠ›ä¸‹</li>
            <li><strong>Slashingé£é™©</strong>ï¼šéªŒè¯è€…è¢«ç½šæ²¡å¯èƒ½å½±å“LSTä»·å€¼</li>
            <li><strong>æµåŠ¨æ€§é£é™©</strong>ï¼šèµå›å»¶è¿Ÿå¯èƒ½å½±å“æ¸…ç®—æ•ˆç‡</li>
            <li><strong>æŠ€æœ¯é£é™©</strong>ï¼šæ™ºèƒ½åˆçº¦å’ŒèŠ‚ç‚¹è¿è¥å•†é£é™©</li>
        </ul>
    </div>
    
    <pre><code class="language-solidity">// LSTæŠµæŠ¼å“ç®¡ç†åˆçº¦
contract LSTCollateralManager {
    // LSTç‰¹å®šå‚æ•°
    struct LSTConfig {
        uint256 maxDeviationFromETH;      // æœ€å¤§å…è®¸è„±é”šå¹…åº¦ (å¦‚2%)
        uint256 liquidationPenalty;       // æ¸…ç®—ç½šé‡‘ï¼ˆè€ƒè™‘èµå›å»¶è¿Ÿï¼‰
        uint256 minLiquidityThreshold;    // æœ€å°æµåŠ¨æ€§è¦æ±‚
        address oracle;                   // ä¸“ç”¨ä»·æ ¼é¢„è¨€æœº
    }
    
    mapping(address => LSTConfig) public lstConfigs;
    
    // è¯„ä¼°LSTæŠµæŠ¼å“ä»·å€¼
    function getLSTValue(
        address lstToken,
        uint256 amount
    ) public view returns (uint256) {
        LSTConfig memory config = lstConfigs[lstToken];
        
        // è·å–LST/ETHæ±‡ç‡
        uint256 lstToEthRate = IOracle(config.oracle).getRate(lstToken);
        uint256 ethPrice = getETHPrice();
        
        // æ£€æŸ¥è„±é”šç¨‹åº¦
        uint256 deviation = lstToEthRate > 1e18 ? 
            lstToEthRate - 1e18 : 1e18 - lstToEthRate;
            
        require(
            deviation <= config.maxDeviationFromETH,
            "LST deviation too high"
        );
        
        // åº”ç”¨æŠ˜æ‰£å› å­ï¼ˆè€ƒè™‘æµåŠ¨æ€§å’Œèµå›é£é™©ï¼‰
        uint256 discountFactor = calculateDiscountFactor(
            lstToken,
            amount,
            config.minLiquidityThreshold
        );
        
        return amount * lstToEthRate * ethPrice * discountFactor / 1e36;
    }
    
    // è®¡ç®—æŠ˜æ‰£å› å­
    function calculateDiscountFactor(
        address lstToken,
        uint256 amount,
        uint256 minLiquidity
    ) internal view returns (uint256) {
        // æ£€æŸ¥é“¾ä¸ŠæµåŠ¨æ€§æ·±åº¦
        uint256 liquidity = getOnchainLiquidity(lstToken);
        
        if (liquidity < minLiquidity) {
            // æµåŠ¨æ€§ä¸è¶³ï¼Œåº”ç”¨é¢å¤–æŠ˜æ‰£
            return 9500; // 95%
        }
        
        // æ£€æŸ¥å¯ç«‹å³å…‘æ¢çš„é‡
        uint256 instantRedeemable = getInstantRedeemableAmount(lstToken);
        
        if (amount > instantRedeemable) {
            // éœ€è¦ç­‰å¾…æœŸï¼Œåº”ç”¨æŠ˜æ‰£
            return 9700; // 97%
        }
        
        return 9900; // 99%åŸºç¡€æŠ˜æ‰£
    }
}</code></pre>
    
    <h4>5.6.2 çœŸå®ä¸–ç•Œèµ„äº§(RWA)é›†æˆ</h4>
    <p>RWAï¼ˆReal World Assetsï¼‰çš„å¼•å…¥ä¸ºç¨³å®šå¸æä¾›äº†æ›´ç¨³å®šçš„æ”¶ç›Šæ¥æºï¼Œä½†ä¹Ÿå¸¦æ¥äº†æ–°çš„å¤æ‚æ€§ã€‚</p>
    
    <pre><code class="language-python"># RWAé£é™©è¯„ä¼°æ¡†æ¶
class RWACollateralManager:
    def __init__(self):
        self.rwa_types = {
            'US_TREASURY': {
                'risk_weight': 0.05,
                'liquidity_score': 0.95,
                'legal_complexity': 0.3
            },
            'CORPORATE_BOND': {
                'risk_weight': 0.20,
                'liquidity_score': 0.70,
                'legal_complexity': 0.6
            },
            'REAL_ESTATE': {
                'risk_weight': 0.35,
                'liquidity_score': 0.30,
                'legal_complexity': 0.9
            }
        }
    
    def assess_rwa_risk(self, asset_type, amount, credit_rating):
        """è¯„ä¼°RWAé£é™©"""
        base_risk = self.rwa_types[asset_type]
        
        # ä¿¡ç”¨é£é™©è°ƒæ•´
        credit_multiplier = self.get_credit_multiplier(credit_rating)
        
        # é›†ä¸­åº¦é£é™©
        concentration_factor = self.calculate_concentration_risk(
            asset_type, amount
        )
        
        # ç»¼åˆé£é™©è¯„åˆ†
        risk_score = (
            base_risk['risk_weight'] * credit_multiplier * 
            concentration_factor
        )
        
        # è®¡ç®—æ‰€éœ€æŠµæŠ¼ç‡
        required_collateral_ratio = 1.5 + risk_score * 2
        
        return {
            'risk_score': risk_score,
            'required_ratio': required_collateral_ratio,
            'liquidity_haircut': 1 - base_risk['liquidity_score'],
            'legal_reserve': base_risk['legal_complexity'] * 0.1
        }
    
    def monitor_rwa_portfolio(self, portfolio):
        """ç›‘æ§RWAç»„åˆé£é™©"""
        alerts = []
        
        # æ£€æŸ¥åˆ°æœŸåˆ†å¸ƒ
        maturity_concentration = self.check_maturity_concentration(portfolio)
        if maturity_concentration > 0.3:
            alerts.append("High maturity concentration risk")
        
        # æ£€æŸ¥å‘è¡Œäººé›†ä¸­åº¦
        issuer_concentration = self.check_issuer_concentration(portfolio)
        if issuer_concentration > 0.15:
            alerts.append("High issuer concentration")
        
        # æ£€æŸ¥æ³•å¾‹ç®¡è¾–åŒºé£é™©
        jurisdiction_risk = self.assess_jurisdiction_risk(portfolio)
        if jurisdiction_risk > 0.7:
            alerts.append("High jurisdictional risk")
        
        return alerts</code></pre>
    
    <h3>5.7 é¢„è¨€æœºå®‰å…¨ä¸æ²»ç†æœºåˆ¶</h3>
    
    <h4>5.7.1 å¤šå±‚é¢„è¨€æœºé˜²å¾¡ä½“ç³»</h4>
    <p>é¢„è¨€æœºæ˜¯ç¨³å®šå¸ç³»ç»Ÿçš„å…³é”®æ”»å‡»å‘é‡ï¼Œéœ€è¦å¤šå±‚é˜²å¾¡æœºåˆ¶ã€‚</p>
    
    <pre><code class="language-solidity">// å®‰å…¨é¢„è¨€æœºèšåˆå™¨
contract SecureOracleAggregator {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;
    }
    
    struct OracleConfig {
        address oracle;
        uint256 weight;
        uint256 maxDeviation;
        bool isActive;
    }
    
    mapping(address => OracleConfig[]) public assetOracles;
    mapping(address => PriceData) public cachedPrices;
    
    uint256 public constant PRICE_STALENESS_THRESHOLD = 3600; // 1å°æ—¶
    uint256 public constant EMERGENCY_PAUSE_DURATION = 86400;  // 24å°æ—¶
    
    // è·å–å®‰å…¨ä»·æ ¼ï¼ˆå¸¦TWAPå’Œå¼‚å¸¸æ£€æµ‹ï¼‰
    function getSecurePrice(
        address asset
    ) external returns (uint256 price, uint256 confidence) {
        OracleConfig[] memory oracles = assetOracles[asset];
        require(oracles.length >= 3, "Insufficient oracles");
        
        uint256[] memory prices = new uint256[](oracles.length);
        uint256[] memory weights = new uint256[](oracles.length);
        uint256 validOracles = 0;
        
        // æ”¶é›†æ‰€æœ‰é¢„è¨€æœºä»·æ ¼
        for (uint i = 0; i < oracles.length; i++) {
            if (!oracles[i].isActive) continue;
            
            try IOracle(oracles[i].oracle).getPrice(asset) 
            returns (uint256 oraclePrice) {
                // å¼‚å¸¸æ£€æµ‹ï¼šä»·æ ¼åç¦»æ£€æŸ¥
                if (isAnomalousPrice(asset, oraclePrice)) {
                    emit AnomalousPrice(oracles[i].oracle, oraclePrice);
                    continue;
                }
                
                prices[validOracles] = oraclePrice;
                weights[validOracles] = oracles[i].weight;
                validOracles++;
            } catch {
                emit OracleFailure(oracles[i].oracle);
            }
        }
        
        require(validOracles >= 2, "Insufficient valid prices");
        
        // è®¡ç®—åŠ æƒä¸­ä½æ•°
        price = calculateWeightedMedian(prices, weights, validOracles);
        
        // è®¡ç®—ç½®ä¿¡åº¦
        confidence = calculateConfidence(prices, validOracles);
        
        // æ›´æ–°ç¼“å­˜
        cachedPrices[asset] = PriceData({
            price: price,
            timestamp: block.timestamp,
            confidence: confidence
        });
        
        // å¦‚æœç½®ä¿¡åº¦ä½ï¼Œè§¦å‘ç´§æ€¥æ¨¡å¼
        if (confidence < 7000) { // 70%
            triggerEmergencyMode(asset);
        }
        
        return (price, confidence);
    }
    
    // å¼‚å¸¸ä»·æ ¼æ£€æµ‹
    function isAnomalousPrice(
        address asset,
        uint256 newPrice
    ) internal view returns (bool) {
        PriceData memory cached = cachedPrices[asset];
        
        // å¦‚æœæ²¡æœ‰å†å²ä»·æ ¼ï¼Œæ¥å—
        if (cached.timestamp == 0) return false;
        
        // æ£€æŸ¥ä»·æ ¼å˜åŒ–å¹…åº¦
        uint256 priceChange = newPrice > cached.price ?
            (newPrice - cached.price) * 10000 / cached.price :
            (cached.price - newPrice) * 10000 / cached.price;
        
        // æ ¹æ®æ—¶é—´è°ƒæ•´é˜ˆå€¼
        uint256 timeDelta = block.timestamp - cached.timestamp;
        uint256 maxAllowedChange = calculateMaxPriceChange(timeDelta);
        
        return priceChange > maxAllowedChange;
    }
    
    // è®¡ç®—åŠ æƒä¸­ä½æ•°
    function calculateWeightedMedian(
        uint256[] memory prices,
        uint256[] memory weights,
        uint256 count
    ) internal pure returns (uint256) {
        // æ’åº
        for (uint i = 0; i < count - 1; i++) {
            for (uint j = i + 1; j < count; j++) {
                if (prices[i] > prices[j]) {
                    (prices[i], prices[j]) = (prices[j], prices[i]);
                    (weights[i], weights[j]) = (weights[j], weights[i]);
                }
            }
        }
        
        // æ‰¾åˆ°åŠ æƒä¸­ä½æ•°
        uint256 totalWeight = 0;
        for (uint i = 0; i < count; i++) {
            totalWeight += weights[i];
        }
        
        uint256 targetWeight = totalWeight / 2;
        uint256 cumulativeWeight = 0;
        
        for (uint i = 0; i < count; i++) {
            cumulativeWeight += weights[i];
            if (cumulativeWeight >= targetWeight) {
                return prices[i];
            }
        }
        
        return prices[count - 1];
    }
}</code></pre>
    
    <h4>5.7.2 æ²»ç†ä¸ç´§æ€¥å“åº”æœºåˆ¶</h4>
    <p>æœ‰æ•ˆçš„æ²»ç†æœºåˆ¶å¯¹äºç¨³å®šå¸ç³»ç»Ÿçš„é•¿æœŸå¯æŒç»­æ€§è‡³å…³é‡è¦ã€‚</p>
    
    <pre><code class="language-solidity">// æ²»ç†ä¸ç´§æ€¥å“åº”åˆçº¦
contract GovernanceEmergencyResponse {
    enum ProposalType { PARAMETER, EMERGENCY, UPGRADE }
    enum EmergencyLevel { LOW, MEDIUM, HIGH, CRITICAL }
    
    struct Proposal {
        ProposalType proposalType;
        address target;
        bytes data;
        uint256 startTime;
        uint256 endTime;
        uint256 forVotes;
        uint256 againstVotes;
        bool executed;
        bool cancelled;
    }
    
    struct EmergencyAction {
        EmergencyLevel level;
        address[] affectedContracts;
        bytes[] actions;
        uint256 executionTime;
        bool executed;
    }
    
    // æ—¶é—´é”é…ç½®
    mapping(ProposalType => uint256) public timelocks;
    mapping(EmergencyLevel => uint256) public emergencyDelays;
    
    // å¤šç­¾å®‰å…¨å§”å‘˜ä¼š
    address[] public securityCouncil;
    uint256 public councilThreshold;
    
    constructor() {
        // è®¾ç½®æ—¶é—´é”
        timelocks[ProposalType.PARAMETER] = 2 days;
        timelocks[ProposalType.EMERGENCY] = 6 hours;
        timelocks[ProposalType.UPGRADE] = 7 days;
        
        // è®¾ç½®ç´§æ€¥å»¶è¿Ÿ
        emergencyDelays[EmergencyLevel.LOW] = 24 hours;
        emergencyDelays[EmergencyLevel.MEDIUM] = 6 hours;
        emergencyDelays[EmergencyLevel.HIGH] = 1 hours;
        emergencyDelays[EmergencyLevel.CRITICAL] = 0; // ç«‹å³æ‰§è¡Œ
    }
    
    // åˆ›å»ºææ¡ˆï¼ˆå¸¦è‡ªåŠ¨åˆ†ç±»ï¼‰
    function createProposal(
        address target,
        bytes calldata data,
        string calldata description
    ) external returns (uint256 proposalId) {
        // è‡ªåŠ¨åˆ†ç±»ææ¡ˆç±»å‹
        ProposalType pType = classifyProposal(target, data);
        
        // æ£€æŸ¥ææ¡ˆè€…æƒé™
        require(
            hasProposalRight(msg.sender, pType),
            "Insufficient rights"
        );
        
        // åˆ›å»ºææ¡ˆ
        uint256 votingPeriod = getVotingPeriod(pType);
        
        proposals[proposalId] = Proposal({
            proposalType: pType,
            target: target,
            data: data,
            startTime: block.timestamp,
            endTime: block.timestamp + votingPeriod,
            forVotes: 0,
            againstVotes: 0,
            executed: false,
            cancelled: false
        });
        
        emit ProposalCreated(proposalId, pType, description);
    }
    
    // ç´§æ€¥æš‚åœæœºåˆ¶
    function emergencyPause(
        EmergencyLevel level,
        address[] calldata contracts,
        string calldata reason
    ) external onlySecurityCouncil {
        require(level >= EmergencyLevel.HIGH, "Not emergency");
        
        // è®°å½•ç´§æ€¥è¡ŒåŠ¨
        uint256 actionId = nextEmergencyActionId++;
        emergencyActions[actionId] = EmergencyAction({
            level: level,
            affectedContracts: contracts,
            actions: new bytes[](contracts.length),
            executionTime: block.timestamp + emergencyDelays[level],
            executed: false
        });
        
        // å¦‚æœæ˜¯CRITICALçº§åˆ«ï¼Œç«‹å³æ‰§è¡Œ
        if (level == EmergencyLevel.CRITICAL) {
            executeEmergencyPause(actionId);
        }
        
        emit EmergencyActionInitiated(actionId, level, reason);
    }
    
    // æ‰§è¡Œç´§æ€¥æš‚åœ
    function executeEmergencyPause(uint256 actionId) internal {
        EmergencyAction storage action = emergencyActions[actionId];
        require(!action.executed, "Already executed");
        
        for (uint i = 0; i < action.affectedContracts.length; i++) {
            // è°ƒç”¨ç´§æ€¥æš‚åœå‡½æ•°
            (bool success,) = action.affectedContracts[i].call(
                abi.encodeWithSignature("emergencyPause()")
            );
            require(success, "Pause failed");
        }
        
        action.executed = true;
        emit EmergencyActionExecuted(actionId);
    }
    
    // æ¢å¤æœºåˆ¶ï¼ˆéœ€è¦æ›´é«˜çº§åˆ«çš„æ‰¹å‡†ï¼‰
    function emergencyResume(
        address[] calldata contracts,
        uint256[] calldata councilSignatures
    ) external {
        require(
            councilSignatures.length >= councilThreshold * 2,
            "Need super majority for resume"
        );
        
        // éªŒè¯ç­¾å...
        
        for (uint i = 0; i < contracts.length; i++) {
            IEmergencyPausable(contracts[i]).emergencyResume();
        }
        
        emit EmergencyResumed(contracts);
    }
}</code></pre>
    
    <h3>5.8 é«˜çº§æ§åˆ¶æ¨¡å‹</h3>
    
    <h4>5.8.1 æ¨¡å‹é¢„æµ‹æ§åˆ¶(MPC)</h4>
    <p>MPCé€šè¿‡é¢„æµ‹æœªæ¥ç³»ç»Ÿè¡Œä¸ºæ¥ä¼˜åŒ–æ§åˆ¶å†³ç­–ï¼Œç‰¹åˆ«é€‚åˆå¤„ç†çº¦æŸå’Œå¤šç›®æ ‡ä¼˜åŒ–é—®é¢˜ã€‚</p>
    
    <pre><code class="language-python"># ç¨³å®šå¸MPCæ§åˆ¶å™¨
import numpy as np
from scipy.optimize import minimize
import cvxpy as cp

class StablecoinMPC:
    def __init__(self, prediction_horizon=10, control_horizon=5):
        self.N = prediction_horizon  # é¢„æµ‹æ—¶åŸŸ
        self.M = control_horizon     # æ§åˆ¶æ—¶åŸŸ
        
        # ç³»ç»Ÿæ¨¡å‹å‚æ•°
        self.dt = 1.0  # æ—¶é—´æ­¥é•¿ï¼ˆå°æ—¶ï¼‰
        
        # çŠ¶æ€ï¼š[ä»·æ ¼åå·®, ä¾›åº”é‡, æŠµæŠ¼ç‡]
        # æ§åˆ¶ï¼š[é“¸é€ /é”€æ¯ç‡, ç¨³å®šè´¹è°ƒæ•´, æ¸…ç®—é˜ˆå€¼è°ƒæ•´]
        
    def predict_system_dynamics(self, x0, u_sequence):
        """é¢„æµ‹ç³»ç»Ÿæœªæ¥çŠ¶æ€"""
        x_pred = np.zeros((self.N + 1, 3))
        x_pred[0] = x0
        
        for k in range(self.N):
            # è·å–æ§åˆ¶è¾“å…¥
            u = u_sequence[min(k, self.M - 1)]
            
            # éçº¿æ€§åŠ¨æ€æ¨¡å‹
            x_pred[k + 1] = self.system_dynamics(x_pred[k], u)
        
        return x_pred
    
    def system_dynamics(self, x, u):
        """ç³»ç»ŸåŠ¨æ€æ–¹ç¨‹"""
        price_dev, supply, coll_ratio = x
        mint_rate, fee_adj, threshold_adj = u
        
        # ä»·æ ¼åŠ¨æ€ï¼ˆå—ä¾›éœ€å’Œå¸‚åœºæƒ…ç»ªå½±å“ï¼‰
        market_pressure = self.estimate_market_pressure()
        price_elasticity = 0.001  # ä»·æ ¼å¼¹æ€§
        
        new_price_dev = price_dev + self.dt * (
            -price_elasticity * mint_rate +  # ä¾›åº”å½±å“
            0.05 * market_pressure +          # å¸‚åœºå‹åŠ›
            -0.02 * fee_adj                   # è´¹ç”¨è°ƒæ•´å½±å“
        )
        
        # ä¾›åº”é‡åŠ¨æ€
        new_supply = supply + self.dt * mint_rate
        
        # æŠµæŠ¼ç‡åŠ¨æ€
        volatility = self.estimate_volatility()
        new_coll_ratio = coll_ratio + self.dt * (
            threshold_adj - 0.1 * volatility * np.random.randn()
        )
        
        return np.array([new_price_dev, new_supply, new_coll_ratio])
    
    def compute_optimal_control(self, x0, reference):
        """è®¡ç®—æœ€ä¼˜æ§åˆ¶åºåˆ—"""
        # å®šä¹‰ä¼˜åŒ–å˜é‡
        u = cp.Variable((self.M, 3))
        
        # é¢„æµ‹çŠ¶æ€è½¨è¿¹
        x = cp.Variable((self.N + 1, 3))
        x[0] = x0
        
        # æ„å»ºä¼˜åŒ–é—®é¢˜
        cost = 0
        
        for k in range(self.N):
            # çŠ¶æ€è¯¯å·®æˆæœ¬
            Q = np.diag([100, 1, 10])  # æƒé‡çŸ©é˜µ
            cost += cp.quad_form(x[k] - reference, Q)
            
            # æ§åˆ¶æˆæœ¬
            if k < self.M:
                R = np.diag([0.1, 1, 1])
                cost += cp.quad_form(u[k], R)
                
                # æ§åˆ¶å˜åŒ–ç‡æƒ©ç½š
                if k > 0:
                    cost += 10 * cp.norm(u[k] - u[k-1], 2)
        
        # çº¦æŸæ¡ä»¶
        constraints = []
        
        # ç³»ç»ŸåŠ¨æ€çº¦æŸï¼ˆçº¿æ€§åŒ–ï¼‰
        A, B = self.linearize_dynamics(x0)
        for k in range(self.N):
            u_idx = min(k, self.M - 1)
            constraints.append(
                x[k + 1] == A @ x[k] + B @ u[u_idx]
            )
        
        # æ§åˆ¶çº¦æŸ
        constraints.append(u[:, 0] >= -1000)  # æœ€å¤§é”€æ¯ç‡
        constraints.append(u[:, 0] <= 1000)   # æœ€å¤§é“¸é€ ç‡
        constraints.append(u[:, 1] >= -0.05)  # è´¹ç”¨è°ƒæ•´é™åˆ¶
        constraints.append(u[:, 1] <= 0.05)
        constraints.append(u[:, 2] >= -0.1)   # é˜ˆå€¼è°ƒæ•´é™åˆ¶
        constraints.append(u[:, 2] <= 0.1)
        
        # çŠ¶æ€çº¦æŸ
        constraints.append(x[:, 0] >= -0.05)  # ä»·æ ¼åå·®é™åˆ¶
        constraints.append(x[:, 0] <= 0.05)
        constraints.append(x[:, 2] >= 1.2)    # æœ€å°æŠµæŠ¼ç‡
        
        # æ±‚è§£ä¼˜åŒ–é—®é¢˜
        problem = cp.Problem(cp.Minimize(cost), constraints)
        problem.solve(solver=cp.OSQP)
        
        if problem.status == cp.OPTIMAL:
            return u.value[0]  # è¿”å›ç¬¬ä¸€ä¸ªæ§åˆ¶åŠ¨ä½œ
        else:
            # è¿”å›å®‰å…¨é»˜è®¤æ§åˆ¶
            return np.array([0, 0, 0])
    
    def linearize_dynamics(self, x0):
        """åœ¨å½“å‰çŠ¶æ€ç‚¹çº¿æ€§åŒ–ç³»ç»Ÿ"""
        # ä½¿ç”¨æ•°å€¼å¾®åˆ†è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
        eps = 1e-6
        n_x, n_u = 3, 3
        
        A = np.zeros((n_x, n_x))
        B = np.zeros((n_x, n_u))
        
        # è®¡ç®—AçŸ©é˜µ
        for i in range(n_x):
            x_plus = x0.copy()
            x_plus[i] += eps
            x_minus = x0.copy()
            x_minus[i] -= eps
            
            f_plus = self.system_dynamics(x_plus, np.zeros(n_u))
            f_minus = self.system_dynamics(x_minus, np.zeros(n_u))
            
            A[:, i] = (f_plus - f_minus) / (2 * eps)
        
        # è®¡ç®—BçŸ©é˜µ
        for i in range(n_u):
            u_plus = np.zeros(n_u)
            u_plus[i] = eps
            u_minus = np.zeros(n_u)
            u_minus[i] = -eps
            
            f_plus = self.system_dynamics(x0, u_plus)
            f_minus = self.system_dynamics(x0, u_minus)
            
            B[:, i] = (f_plus - f_minus) / (2 * eps)
        
        return A, B</code></pre>
    
    <h4>5.8.2 å¼ºåŒ–å­¦ä¹ æ§åˆ¶å™¨</h4>
    <p>ä½¿ç”¨æ·±åº¦å¼ºåŒ–å­¦ä¹ è‡ªåŠ¨å­¦ä¹ æœ€ä¼˜æ§åˆ¶ç­–ç•¥ã€‚</p>
    
    <pre><code class="language-python"># åŸºäºPPOçš„ç¨³å®šå¸æ§åˆ¶å™¨
import torch
import torch.nn as nn
import torch.optim as optim
from torch.distributions import Normal

class StablecoinPPOAgent:
    def __init__(self, state_dim=10, action_dim=3, lr=3e-4):
        self.state_dim = state_dim
        self.action_dim = action_dim
        
        # Actorç½‘ç»œï¼ˆç­–ç•¥ï¼‰
        self.actor = nn.Sequential(
            nn.Linear(state_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, action_dim * 2)  # å‡å€¼å’Œæ ‡å‡†å·®
        )
        
        # Criticç½‘ç»œï¼ˆä»·å€¼å‡½æ•°ï¼‰
        self.critic = nn.Sequential(
            nn.Linear(state_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, 1)
        )
        
        self.actor_optimizer = optim.Adam(self.actor.parameters(), lr=lr)
        self.critic_optimizer = optim.Adam(self.critic.parameters(), lr=lr)
        
    def get_action(self, state):
        """æ ¹æ®å½“å‰çŠ¶æ€é€‰æ‹©åŠ¨ä½œ"""
        state_tensor = torch.FloatTensor(state).unsqueeze(0)
        
        # è·å–åŠ¨ä½œåˆ†å¸ƒå‚æ•°
        output = self.actor(state_tensor)
        mean = output[:, :self.action_dim]
        log_std = output[:, self.action_dim:]
        std = torch.exp(log_std)
        
        # é‡‡æ ·åŠ¨ä½œ
        dist = Normal(mean, std)
        action = dist.sample()
        log_prob = dist.log_prob(action).sum(-1)
        
        # åŠ¨ä½œè£å‰ª
        action = torch.tanh(action)  # [-1, 1]
        
        return action.numpy()[0], log_prob
    
    def compute_reward(self, state, action, next_state):
        """è®¡ç®—å¥–åŠ±å‡½æ•°"""
        price_dev = next_state[0]
        volatility = next_state[1]
        liquidity = next_state[2]
        gas_cost = self.estimate_gas_cost(action)
        
        # å¤šç›®æ ‡å¥–åŠ±è®¾è®¡
        reward = 0
        
        # ä»·æ ¼ç¨³å®šå¥–åŠ±
        price_reward = -100 * abs(price_dev)
        reward += price_reward
        
        # æ³¢åŠ¨ç‡æƒ©ç½š
        volatility_penalty = -10 * volatility
        reward += volatility_penalty
        
        # æµåŠ¨æ€§å¥–åŠ±
        liquidity_reward = 5 * np.log1p(liquidity)
        reward += liquidity_reward
        
        # Gasæˆæœ¬æƒ©ç½š
        gas_penalty = -0.01 * gas_cost
        reward += gas_penalty
        
        # æç«¯æƒ…å†µé¢å¤–æƒ©ç½š
        if abs(price_dev) > 0.05:  # 5%è„±é”š
            reward -= 1000
        
        return reward
    
    def train(self, trajectories, epochs=10, clip_epsilon=0.2):
        """PPOè®­ç»ƒæ›´æ–°"""
        states = torch.FloatTensor(trajectories['states'])
        actions = torch.FloatTensor(trajectories['actions'])
        rewards = torch.FloatTensor(trajectories['rewards'])
        old_log_probs = torch.FloatTensor(trajectories['log_probs'])
        
        # è®¡ç®—ä¼˜åŠ¿ä¼°è®¡
        values = self.critic(states).squeeze()
        advantages = self.compute_advantages(rewards, values)
        
        for epoch in range(epochs):
            # æ›´æ–°Actor
            output = self.actor(states)
            mean = output[:, :self.action_dim]
            log_std = output[:, self.action_dim:]
            std = torch.exp(log_std)
            
            dist = Normal(mean, std)
            new_log_probs = dist.log_prob(actions).sum(-1)
            
            # PPOè£å‰ª
            ratio = torch.exp(new_log_probs - old_log_probs)
            clipped_ratio = torch.clamp(ratio, 1 - clip_epsilon, 1 + clip_epsilon)
            actor_loss = -torch.min(
                ratio * advantages,
                clipped_ratio * advantages
            ).mean()
            
            self.actor_optimizer.zero_grad()
            actor_loss.backward()
            self.actor_optimizer.step()
            
            # æ›´æ–°Critic
            new_values = self.critic(states).squeeze()
            critic_loss = nn.MSELoss()(new_values, rewards)
            
            self.critic_optimizer.zero_grad()
            critic_loss.backward()
            self.critic_optimizer.step()
    
    def compute_advantages(self, rewards, values, gamma=0.99, lam=0.95):
        """è®¡ç®—å¹¿ä¹‰ä¼˜åŠ¿ä¼°è®¡(GAE)"""
        advantages = torch.zeros_like(rewards)
        last_advantage = 0
        
        for t in reversed(range(len(rewards) - 1)):
            delta = rewards[t] + gamma * values[t + 1] - values[t]
            advantages[t] = last_advantage = delta + gamma * lam * last_advantage
        
        return advantages</code></pre>
    
    <h3>5.9 æ­»äº¡èºæ—‹é¢„é˜²æœºåˆ¶</h3>
    
    <p>æ­»äº¡èºæ—‹æ˜¯ç®—æ³•ç¨³å®šå¸æœ€å¤§çš„ç³»ç»Ÿæ€§é£é™©ï¼Œéœ€è¦å¤šé‡é¢„é˜²æœºåˆ¶ã€‚</p>
    
    <div class="info-box">
        <h5>ğŸš¨ æ­»äº¡èºæ—‹è§¦å‘æ¡ä»¶</h5>
        <ul>
            <li>å¸‚åœºä¿¡å¿ƒä¸§å¤±å¯¼è‡´å¤§è§„æ¨¡æŠ›å”®</li>
            <li>æŠµæŠ¼å“ä»·å€¼æ€¥å‰§ä¸‹è·Œ</li>
            <li>æ¸…ç®—çº§è”æ•ˆåº”</li>
            <li>æµåŠ¨æ€§æ¯ç«­</li>
        </ul>
    </div>
    
    <pre><code class="language-solidity">// æ­»äº¡èºæ—‹é¢„é˜²ç³»ç»Ÿ
contract DeathSpiralPrevention {
    struct SystemHealth {
        uint256 priceDeviation;
        uint256 supplyVelocity;
        uint256 collateralRatio;
        uint256 liquidityDepth;
        uint256 marketConfidence;
    }
    
    enum RiskLevel { NORMAL, ELEVATED, HIGH, CRITICAL }
    
    // æ–­è·¯å™¨å‚æ•°
    uint256 public constant SUPPLY_VELOCITY_THRESHOLD = 1000; // 10%/å°æ—¶
    uint256 public constant PRICE_DEVIATION_THRESHOLD = 500;  // 5%
    uint256 public constant LIQUIDITY_THRESHOLD = 1e6;        // $1M
    
    // åŠ¨æ€å‚æ•°è°ƒæ•´
    function assessSystemRisk() public view returns (RiskLevel) {
        SystemHealth memory health = getCurrentHealth();
        
        uint256 riskScore = 0;
        
        // ä»·æ ¼åç¦»è¯„åˆ†
        if (health.priceDeviation > PRICE_DEVIATION_THRESHOLD) {
            riskScore += 30;
        }
        
        // ä¾›åº”é€Ÿåº¦è¯„åˆ†
        if (health.supplyVelocity > SUPPLY_VELOCITY_THRESHOLD) {
            riskScore += 25;
        }
        
        // æŠµæŠ¼ç‡è¯„åˆ†
        if (health.collateralRatio < 150) {
            riskScore += 25;
        }
        
        // æµåŠ¨æ€§è¯„åˆ†
        if (health.liquidityDepth < LIQUIDITY_THRESHOLD) {
            riskScore += 20;
        }
        
        // ç¡®å®šé£é™©ç­‰çº§
        if (riskScore >= 70) return RiskLevel.CRITICAL;
        if (riskScore >= 50) return RiskLevel.HIGH;
        if (riskScore >= 30) return RiskLevel.ELEVATED;
        return RiskLevel.NORMAL;
    }
    
    // è‡ªåŠ¨è§¦å‘ä¿æŠ¤æœºåˆ¶
    function activateProtection(RiskLevel risk) external {
        if (risk == RiskLevel.CRITICAL) {
            // 1. æš‚åœæ‰€æœ‰é“¸é€ 
            pauseMinting();
            
            // 2. æé«˜æ¸…ç®—æ¿€åŠ±
            increaseLiquidationIncentive(150); // 15%
            
            // 3. æ¿€æ´»ç´§æ€¥æµåŠ¨æ€§æ± 
            activateEmergencyLiquidity();
            
            // 4. é™ä½å€Ÿè´·ä¸Šé™
            reduceBorrowingCaps(50); // å‡å°‘50%
        }
        else if (risk == RiskLevel.HIGH) {
            // æ¸è¿›å¼è°ƒæ•´
            adjustStabilityFee(200); // +2%
            adjustLiquidationRatio(105); // æé«˜5%
            enableSupplyThrottling();
        }
    }
    
    // ç´§æ€¥æµåŠ¨æ€§æ³¨å…¥
    function activateEmergencyLiquidity() internal {
        uint256 reserveAmount = emergencyReserve.balance();
        
        // ä½¿ç”¨å‚¨å¤‡åŸºé‡‘æä¾›æµåŠ¨æ€§
        if (reserveAmount > 0) {
            // åœ¨ä¸»è¦DEXæ·»åŠ æµåŠ¨æ€§
            addLiquidityToAMM(reserveAmount / 2);
            
            // è®¾ç½®ä»·æ ¼æ”¯æ’‘è®¢å•
            createPriceSupportOrders(reserveAmount / 2);
        }
        
        emit EmergencyLiquidityActivated(reserveAmount);
    }
}</code></pre>
    
    <h3>ç¬¬äº”ç« å°ç»“</h3>
    
    <p>æœ¬ç« æ·±å…¥æ¢è®¨äº†ç¨³å®šå¸ç³»ç»Ÿçš„æ•°å­¦å»ºæ¨¡å’Œæ§åˆ¶ç†è®ºåº”ç”¨ï¼š</p>
    
    <ul>
        <li><strong>æ§åˆ¶ç†è®ºåŸºç¡€</strong>ï¼šä»PIDæ§åˆ¶å™¨åˆ°é«˜çº§MPCå’Œå¼ºåŒ–å­¦ä¹ æ–¹æ³•</li>
        <li><strong>åšå¼ˆè®ºåº”ç”¨</strong>ï¼šæ¸…ç®—æœºåˆ¶è®¾è®¡å’ŒMEVé˜²æŠ¤</li>
        <li><strong>é‡‘èæ¨¡å‹é€‚é…</strong>ï¼šBlack-Scholesåœ¨DeFiç¯å¢ƒä¸‹çš„è°ƒæ•´</li>
        <li><strong>é£é™©ç®¡ç†</strong>ï¼šå‹åŠ›æµ‹è¯•å’Œè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ</li>
        <li><strong>2024æœ€æ–°å‘å±•</strong>ï¼šLST/LRTé›†æˆå’ŒRWAé£é™©ç®¡ç†</li>
        <li><strong>å®‰å…¨æœºåˆ¶</strong>ï¼šé¢„è¨€æœºé˜²æŠ¤å’Œæ²»ç†å“åº”</li>
        <li><strong>ç³»ç»Ÿç¨³å®šæ€§</strong>ï¼šæ­»äº¡èºæ—‹é¢„é˜²å’Œç´§æ€¥å¹²é¢„</li>
    </ul>
    
    <div class="key-concepts">
        <h4>ğŸ”‘ å…³é”®è¦ç‚¹</h4>
        <ol>
            <li>ç¨³å®šå¸æ§åˆ¶æ˜¯ä¸€ä¸ªå¤šå˜é‡ã€éçº¿æ€§ã€æœ‰çº¦æŸçš„å¤æ‚ç³»ç»Ÿ</li>
            <li>éœ€è¦ç»“åˆå¤šç§æ§åˆ¶æ–¹æ³•ï¼Œæ²¡æœ‰å•ä¸€æœ€ä¼˜è§£</li>
            <li>é¢„è¨€æœºå®‰å…¨å’Œæ²»ç†æœºåˆ¶æ˜¯ç³»ç»Ÿç¨³å®šçš„åŸºç¡€</li>
            <li>å¿…é¡»ä¸ºæç«¯å¸‚åœºæƒ…å†µè®¾è®¡å……åˆ†çš„é¢„é˜²æœºåˆ¶</li>
            <li>æ–°å‹æŠµæŠ¼å“ï¼ˆLST/RWAï¼‰å¸¦æ¥æ–°çš„é£é™©ç»´åº¦</li>
        </ol>
    
            
            <!-- ç« èŠ‚å¯¼èˆª -->
            <div class="chapter-nav">
                <a href="chapter4.html">â† ç¬¬4ç« </a>
                <a href="chapter6.html">ç¬¬6ç«  â†’</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>