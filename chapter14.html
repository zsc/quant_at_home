<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬åå››ç« ï¼šä¼ä¸šçº§ç¨³å®šå¸åº”ç”¨ä¸B2Båœºæ™¯ - åŒºå—é“¾ç¨³å®šå¸æ•™ç¨‹</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">ç¨³å®šå¸æ•™ç¨‹</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">â˜°</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">é¦–é¡µ</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">å¼•è¨€</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">ç« èŠ‚</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">ç¬¬1ç« ï¼šåŒºå—é“¾åŸºç¡€</a>
                        <a href="chapter2.html" class="dropdown-item">ç¬¬2ç« ï¼šç¨³å®šå¸åˆ†ç±»</a>
                        <a href="chapter3.html" class="dropdown-item">ç¬¬3ç« ï¼šERC-20æ ‡å‡†</a>
                        <a href="chapter4.html" class="dropdown-item">ç¬¬4ç« ï¼šæŠµæŠ¼å‹è®¾è®¡</a>
                        <a href="chapter5.html" class="dropdown-item">ç¬¬5ç« ï¼šæ•°å­¦æ¨¡å‹</a>
                        <a href="chapter6.html" class="dropdown-item">ç¬¬6ç« ï¼šAMMé›†æˆ</a>
                        <a href="chapter7.html" class="dropdown-item">ç¬¬7ç« ï¼šå€Ÿè´·åè®®</a>
                        <a href="chapter8.html" class="dropdown-item">ç¬¬8ç« ï¼šæ”¶ç›Šç­–ç•¥</a>
                        <a href="chapter9.html" class="dropdown-item">ç¬¬9ç« ï¼šæ™ºèƒ½åˆçº¦å®‰å…¨</a>
                        <a href="chapter10.html" class="dropdown-item">ç¬¬10ç« ï¼šç»æµæ”»å‡»</a>
                        <a href="chapter11.html" class="dropdown-item">ç¬¬11ç« ï¼šæœªæ¥æ–¹å‘</a>
                        <a href="chapter12.html" class="dropdown-item">ç¬¬12ç« ï¼šç”Ÿäº§éƒ¨ç½²</a>
                        <a href="chapter13.html" class="dropdown-item">ç¬¬13ç« ï¼šç”Ÿæ€é›†æˆ</a>
                        <a href="chapter14.html" class="dropdown-item">ç¬¬14ç« ï¼šä¼ä¸šåº”ç”¨</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="index.html#resources" class="nav-link">èµ„æº</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- å¤´éƒ¨ -->
    <header id="top">
        <div class="container">
            <h1>ç¬¬åå››ç« ï¼šä¼ä¸šçº§ç¨³å®šå¸åº”ç”¨ä¸B2Båœºæ™¯</h1>
        </div>
    </header>
    
    <!-- ä¸»è¦å†…å®¹ -->
    <div class="container">
        <div class="chapter">
<h2>ç¬¬åå››ç« ï¼šä¼ä¸šçº§ç¨³å®šå¸åº”ç”¨ä¸B2Båœºæ™¯</h2>
        
        <p>ç»è¿‡å‰é¢ç« èŠ‚çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å·²ç»æŒæ¡äº†ç¨³å®šå¸çš„æŠ€æœ¯å®ç°å’Œç”Ÿæ€é›†æˆã€‚ç„¶è€Œï¼Œç¨³å®šå¸çš„çœŸæ­£ä»·å€¼åœ¨äºè§£å†³å®é™…å•†ä¸šé—®é¢˜ã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨ç¨³å®šå¸åœ¨ä¼ä¸šçº§åº”ç”¨ä¸­çš„å·¨å¤§æ½œåŠ›ï¼Œä»ä¾›åº”é“¾é‡‘èåˆ°è·¨å¢ƒè´¸æ˜“ç»“ç®—ï¼Œä»ä¼ä¸šèµ„é‡‘ç®¡ç†åˆ°è‡ªåŠ¨åŒ–è´¢åŠ¡ç³»ç»Ÿã€‚æˆ‘ä»¬å°†é€šè¿‡çœŸå®æ¡ˆä¾‹å’Œå®è·µä»£ç ï¼Œå±•ç¤ºå¦‚ä½•æ„å»ºæ»¡è¶³ä¼ä¸šéœ€æ±‚çš„ç¨³å®šå¸è§£å†³æ–¹æ¡ˆã€‚</p>
        
        <div class="intro-box">
            <strong>æœ¬ç« æ¦‚è§ˆï¼š</strong>
            <ul>
                <li>ä¾›åº”é“¾é‡‘èä¸­çš„ç¨³å®šå¸åº”ç”¨</li>
                <li>è·¨å¢ƒè´¸æ˜“ç»“ç®—ä¸ä¿¡ç”¨è¯ç³»ç»Ÿ</li>
                <li>ä¼ä¸šèµ„é‡‘ç®¡ç†ä¸æµåŠ¨æ€§ä¼˜åŒ–</li>
                <li>è‡ªåŠ¨åŒ–è´¢åŠ¡ä¸æ™ºèƒ½å‘ç¥¨ç³»ç»Ÿ</li>
                <li>B2Bæ”¯ä»˜åŸºç¡€è®¾æ–½å»ºè®¾</li>
            </ul>
        </div>

        <h3 id="supply-chain-finance">14.1 ä¾›åº”é“¾é‡‘èä¸­çš„ç¨³å®šå¸åº”ç”¨</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>ğŸ­ é‡å¡‘ä¾›åº”é“¾é‡‘èï¼šä»ä¼ ç»Ÿåˆ°åŒºå—é“¾çš„é©å‘½</h4>
            <p>ä¾›åº”é“¾é‡‘èé•¿æœŸå­˜åœ¨ç€ä¿¡æ¯ä¸å¯¹ç§°ã€èèµ„æˆæœ¬é«˜ã€ç»“ç®—å‘¨æœŸé•¿ç­‰ç—›ç‚¹ã€‚ç¨³å®šå¸ç»“åˆæ™ºèƒ½åˆçº¦ï¼Œæ­£åœ¨åˆ›é€ ä¸€ä¸ªæ›´åŠ é«˜æ•ˆã€é€æ˜ã€æ™®æƒ çš„ä¾›åº”é“¾é‡‘èç”Ÿæ€ç³»ç»Ÿã€‚</p>
            
            <div style="background-color: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 15px;">
                <h5>ğŸ¯ ç¨³å®šå¸è§£å†³çš„æ ¸å¿ƒé—®é¢˜</h5>
                <ol>
                    <li><strong>ä¿¡ä»»é—®é¢˜</strong>ï¼šåŒºå—é“¾æä¾›ä¸å¯ç¯¡æ”¹çš„äº¤æ˜“è®°å½•</li>
                    <li><strong>æ•ˆç‡é—®é¢˜</strong>ï¼šå®æ—¶ç»“ç®—æ›¿ä»£T+Nå¤©çš„ä¼ ç»Ÿæµç¨‹</li>
                    <li><strong>æˆæœ¬é—®é¢˜</strong>ï¼šå»ä¸­ä»‹åŒ–é™ä½èèµ„æˆæœ¬</li>
                    <li><strong>é€æ˜é—®é¢˜</strong>ï¼šå…¨é“¾æ¡å¯è¿½æº¯ï¼Œé™ä½é£é™©</li>
                </ol>
            </div>
        </div>

        <div class="info-box">
            <h4>ğŸ“Š ä¼ ç»Ÿä¾›åº”é“¾é‡‘è vs ç¨³å®šå¸ä¾›åº”é“¾é‡‘è</h4>
            <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                <thead style="background-color: #f3f4f6;">
                    <tr>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">å¯¹æ¯”ç»´åº¦</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">ä¼ ç»Ÿæ¨¡å¼</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">ç¨³å®šå¸æ¨¡å¼</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">æ”¹è¿›å¹…åº¦</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>ç»“ç®—æ—¶é—´</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">3-7å¤©</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å®æ—¶-1å°æ—¶</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db; background-color: #dcfce7;">â†“ 95%</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>èèµ„æˆæœ¬</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">8-15% å¹´åŒ–</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">4-8% å¹´åŒ–</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db; background-color: #dcfce7;">â†“ 50%</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>æ“ä½œæˆæœ¬</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">äº¤æ˜“é¢çš„2-3%</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">0.1-0.5%</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db; background-color: #dcfce7;">â†“ 85%</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>é€æ˜åº¦</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">æœ‰é™ï¼Œä¾èµ–ä¸­å¿ƒåŒ–ç³»ç»Ÿ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å…¨ç¨‹å¯è¿½æº¯</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db; background-color: #dcfce7;">â†‘ 100%</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="theory-section">
            <h4>14.1.1 åº”æ”¶è´¦æ¬¾èèµ„æ™ºèƒ½åˆçº¦</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">
                    Solidity ä»£ç  - åº”æ”¶è´¦æ¬¾ä»£å¸åŒ–å¹³å° <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * @title ReceivableFinancing
 * @dev åº”æ”¶è´¦æ¬¾èèµ„å¹³å° - å°†åº”æ”¶è´¦æ¬¾ä»£å¸åŒ–å¹¶æä¾›èèµ„
 */
contract ReceivableFinancing is ERC721, ReentrancyGuard, AccessControl {
    bytes32 public constant VERIFIER_ROLE = keccak256("VERIFIER_ROLE");
    bytes32 public constant FINANCER_ROLE = keccak256("FINANCER_ROLE");
    
    IERC20 public immutable stablecoin;
    uint256 private _tokenIdCounter;
    
    // åº”æ”¶è´¦æ¬¾ç»“æ„
    struct Receivable {
        address supplier;        // ä¾›åº”å•†
        address buyer;          // é‡‡è´­æ–¹
        uint256 amount;         // åº”æ”¶é‡‘é¢
        uint256 dueDate;        // åˆ°æœŸæ—¥
        uint256 invoiceHash;    // å‘ç¥¨å“ˆå¸Œ
        bool isVerified;        // æ˜¯å¦å·²éªŒè¯
        bool isFinanced;        // æ˜¯å¦å·²èèµ„
        uint256 financedAmount; // èèµ„é‡‘é¢
        address financer;       // èµ„é‡‘æ–¹
    }
    
    // tokenId => åº”æ”¶è´¦æ¬¾
    mapping(uint256 => Receivable) public receivables;
    
    // ä¹°æ–¹ä¿¡ç”¨è¯„çº§ (0-1000)
    mapping(address => uint256) public creditScores;
    
    // èèµ„æ± 
    uint256 public totalPoolBalance;
    mapping(address => uint256) public financerBalances;
    
    event ReceivableCreated(uint256 indexed tokenId, address indexed supplier, address indexed buyer, uint256 amount);
    event ReceivableVerified(uint256 indexed tokenId, address verifier);
    event ReceivableFinanced(uint256 indexed tokenId, address financer, uint256 financedAmount);
    event ReceivableSettled(uint256 indexed tokenId, uint256 settlementAmount);
    
    constructor(address _stablecoin) ERC721("ReceivableToken", "RCT") {
        stablecoin = IERC20(_stablecoin);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }
    
    /**
     * @dev åˆ›å»ºåº”æ”¶è´¦æ¬¾NFT
     */
    function createReceivable(
        address buyer,
        uint256 amount,
        uint256 dueDate,
        uint256 invoiceHash
    ) external returns (uint256) {
        require(buyer != address(0), "Invalid buyer");
        require(amount > 0, "Invalid amount");
        require(dueDate > block.timestamp, "Invalid due date");
        
        uint256 tokenId = _tokenIdCounter++;
        _safeMint(msg.sender, tokenId);
        
        receivables[tokenId] = Receivable({
            supplier: msg.sender,
            buyer: buyer,
            amount: amount,
            dueDate: dueDate,
            invoiceHash: invoiceHash,
            isVerified: false,
            isFinanced: false,
            financedAmount: 0,
            financer: address(0)
        });
        
        emit ReceivableCreated(tokenId, msg.sender, buyer, amount);
        return tokenId;
    }
    
    /**
     * @dev éªŒè¯åº”æ”¶è´¦æ¬¾çœŸå®æ€§
     */
    function verifyReceivable(uint256 tokenId) external onlyRole(VERIFIER_ROLE) {
        Receivable storage rcv = receivables[tokenId];
        require(!rcv.isVerified, "Already verified");
        
        // å®é™…åº”ç”¨ä¸­è¿™é‡Œä¼šè°ƒç”¨å¤–éƒ¨é¢„è¨€æœºéªŒè¯å‘ç¥¨çœŸå®æ€§
        rcv.isVerified = true;
        
        emit ReceivableVerified(tokenId, msg.sender);
    }
    
    /**
     * @dev è®¡ç®—èèµ„é¢åº¦å’Œåˆ©ç‡
     */
    function calculateFinancing(uint256 tokenId) public view returns (uint256 maxAmount, uint256 interestRate) {
        Receivable memory rcv = receivables[tokenId];
        require(rcv.isVerified, "Not verified");
        
        uint256 creditScore = creditScores[rcv.buyer];
        uint256 daysUntilDue = (rcv.dueDate - block.timestamp) / 1 days;
        
        // æ ¹æ®ä¿¡ç”¨è¯„åˆ†ç¡®å®šèèµ„æ¯”ä¾‹ (50%-90%)
        uint256 financingRatio = 500 + (creditScore * 400 / 1000); // 500-900 (50%-90%)
        maxAmount = rcv.amount * financingRatio / 1000;
        
        // æ ¹æ®æœŸé™å’Œä¿¡ç”¨ç¡®å®šåˆ©ç‡ (å¹´åŒ– 4%-12%)
        uint256 baseRate = 40; // 4%
        uint256 riskPremium = (1000 - creditScore) * 80 / 1000; // 0-8%
        interestRate = baseRate + riskPremium;
        
        // æ ¹æ®æœŸé™è°ƒæ•´
        if (daysUntilDue < 30) {
            interestRate = interestRate * 80 / 100; // çŸ­æœŸæŠ˜æ‰£
        }
        
        return (maxAmount, interestRate);
    }
    
    /**
     * @dev ä¸ºåº”æ”¶è´¦æ¬¾æä¾›èèµ„
     */
    function financeReceivable(uint256 tokenId, uint256 amount) external nonReentrant onlyRole(FINANCER_ROLE) {
        Receivable storage rcv = receivables[tokenId];
        require(rcv.isVerified, "Not verified");
        require(!rcv.isFinanced, "Already financed");
        require(ownerOf(tokenId) == rcv.supplier, "Supplier must own token");
        
        (uint256 maxAmount,) = calculateFinancing(tokenId);
        require(amount <= maxAmount, "Exceeds max financing");
        require(financerBalances[msg.sender] >= amount, "Insufficient balance");
        
        // è½¬ç§»èµ„é‡‘ç»™ä¾›åº”å•†
        financerBalances[msg.sender] -= amount;
        totalPoolBalance -= amount;
        stablecoin.safeTransfer(rcv.supplier, amount);
        
        // æ›´æ–°èèµ„ä¿¡æ¯
        rcv.isFinanced = true;
        rcv.financedAmount = amount;
        rcv.financer = msg.sender;
        
        emit ReceivableFinanced(tokenId, msg.sender, amount);
    }
    
    /**
     * @dev ä¹°æ–¹ç»“ç®—åº”æ”¶è´¦æ¬¾
     */
    function settleReceivable(uint256 tokenId) external nonReentrant {
        Receivable storage rcv = receivables[tokenId];
        require(msg.sender == rcv.buyer, "Only buyer can settle");
        require(rcv.isFinanced, "Not financed");
        
        uint256 settlementAmount = rcv.amount;
        
        // ä¹°æ–¹æ”¯ä»˜å…¨é¢
        stablecoin.safeTransferFrom(msg.sender, address(this), settlementAmount);
        
        // è®¡ç®—åˆ©æ¯
        uint256 daysFinanced = (block.timestamp - rcv.dueDate) / 1 days;
        (, uint256 interestRate) = calculateFinancing(tokenId);
        uint256 interest = rcv.financedAmount * interestRate * daysFinanced / 365 / 1000;
        
        // æ”¯ä»˜ç»™èµ„é‡‘æ–¹æœ¬é‡‘+åˆ©æ¯
        uint256 payToFinancer = rcv.financedAmount + interest;
        stablecoin.safeTransfer(rcv.financer, payToFinancer);
        
        // å‰©ä½™éƒ¨åˆ†æ”¯ä»˜ç»™ä¾›åº”å•†
        uint256 remaining = settlementAmount - rcv.financedAmount;
        if (remaining > 0) {
            stablecoin.safeTransfer(rcv.supplier, remaining);
        }
        
        // é”€æ¯NFT
        _burn(tokenId);
        
        emit ReceivableSettled(tokenId, settlementAmount);
    }
    
    /**
     * @dev èµ„é‡‘æ–¹å­˜å…¥èµ„é‡‘åˆ°èèµ„æ± 
     */
    function depositToPool(uint256 amount) external {
        stablecoin.safeTransferFrom(msg.sender, address(this), amount);
        financerBalances[msg.sender] += amount;
        totalPoolBalance += amount;
    }
    
    /**
     * @dev èµ„é‡‘æ–¹æå–èµ„é‡‘
     */
    function withdrawFromPool(uint256 amount) external {
        require(financerBalances[msg.sender] >= amount, "Insufficient balance");
        financerBalances[msg.sender] -= amount;
        totalPoolBalance -= amount;
        stablecoin.safeTransfer(msg.sender, amount);
    }
}</code></pre>
                </div>
            </div>
        </div>

        <div class="example-box" style="background-color: #dcfce7; margin: 20px 0;">
            <h4>ğŸ’¼ å®é™…æ¡ˆä¾‹ï¼šåŠ¨æ€æŠ˜æ‰£ç®¡ç†ç³»ç»Ÿ</h4>
            <p>ä¾›åº”é“¾ä¸­çš„åŠ¨æ€æŠ˜æ‰£ï¼ˆDynamic Discountingï¼‰å…è®¸ä¾›åº”å•†ä»¥æŠ˜æ‰£ä»·æå‰æ”¶åˆ°è´§æ¬¾ï¼Œè€Œä¹°æ–¹å¯ä»¥è·å¾—æŠ˜æ‰£æ”¶ç›Šã€‚ç¨³å®šå¸è®©è¿™ä¸ªè¿‡ç¨‹å®Œå…¨è‡ªåŠ¨åŒ–ã€‚</p>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">
                    JavaScript ä»£ç  - åŠ¨æ€æŠ˜æ‰£è®¡ç®—å¼•æ“ <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content">
                    <pre><code class="language-javascript">class DynamicDiscountEngine {
    constructor(stablecoinContract, receivableContract) {
        this.stablecoin = stablecoinContract;
        this.receivable = receivableContract;
        this.discountCurves = new Map();
    }
    
    /**
     * è®¾ç½®æŠ˜æ‰£æ›²çº¿
     * @param {string} buyerAddress - ä¹°æ–¹åœ°å€
     * @param {Array} curve - æŠ˜æ‰£æ›²çº¿ [{days: 60, rate: 2}, {days: 30, rate: 1}]
     */
    setDiscountCurve(buyerAddress, curve) {
        // éªŒè¯æ›²çº¿æœ‰æ•ˆæ€§
        curve.sort((a, b) => b.days - a.days);
        this.discountCurves.set(buyerAddress, curve);
    }
    
    /**
     * è®¡ç®—å½“å‰æŠ˜æ‰£ç‡
     * @param {string} buyerAddress - ä¹°æ–¹åœ°å€
     * @param {number} daysUntilDue - è·ç¦»åˆ°æœŸå¤©æ•°
     * @returns {number} æŠ˜æ‰£ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰
     */
    calculateDiscountRate(buyerAddress, daysUntilDue) {
        const curve = this.discountCurves.get(buyerAddress);
        if (!curve) return 0;
        
        // çº¿æ€§æ’å€¼è®¡ç®—æŠ˜æ‰£ç‡
        for (let i = 0; i < curve.length - 1; i++) {
            if (daysUntilDue >= curve[i].days) {
                return curve[i].rate;
            }
            if (daysUntilDue >= curve[i + 1].days) {
                // çº¿æ€§æ’å€¼
                const ratio = (daysUntilDue - curve[i + 1].days) / 
                             (curve[i].days - curve[i + 1].days);
                return curve[i + 1].rate + 
                       ratio * (curve[i].rate - curve[i + 1].rate);
            }
        }
        return curve[curve.length - 1].rate;
    }
    
    /**
     * æè®®åŠ¨æ€æŠ˜æ‰£
     * @param {string} receivableId - åº”æ”¶è´¦æ¬¾ID
     * @returns {Object} æŠ˜æ‰£æè®®è¯¦æƒ…
     */
    async proposeDynamicDiscount(receivableId) {
        const receivable = await this.receivable.getReceivable(receivableId);
        const daysUntilDue = Math.floor(
            (receivable.dueDate - Date.now()) / (1000 * 60 * 60 * 24)
        );
        
        const discountRate = this.calculateDiscountRate(
            receivable.buyer,
            daysUntilDue
        );
        
        const discountAmount = receivable.amount * discountRate / 100;
        const paymentAmount = receivable.amount - discountAmount;
        
        return {
            receivableId,
            originalAmount: receivable.amount,
            discountRate,
            discountAmount,
            paymentAmount,
            daysUntilDue,
            expiresAt: Date.now() + 24 * 60 * 60 * 1000, // 24å°æ—¶æœ‰æ•ˆ
            benefits: {
                supplier: {
                    cashAdvance: daysUntilDue,
                    discountCost: discountAmount,
                    improveCashFlow: true
                },
                buyer: {
                    discountEarned: discountAmount,
                    annualizedReturn: (discountRate * 365 / daysUntilDue).toFixed(2) + '%'
                }
            }
        };
    }
    
    /**
     * æ‰§è¡ŒåŠ¨æ€æŠ˜æ‰£äº¤æ˜“
     * @param {Object} proposal - æŠ˜æ‰£æè®®
     * @param {string} buyerSignature - ä¹°æ–¹ç­¾å
     */
    async executeDynamicDiscount(proposal, buyerSignature) {
        // éªŒè¯æè®®ä»ç„¶æœ‰æ•ˆ
        if (Date.now() > proposal.expiresAt) {
            throw new Error('Proposal expired');
        }
        
        // éªŒè¯ä¹°æ–¹ç­¾å
        const signer = await this.verifySignature(proposal, buyerSignature);
        const receivable = await this.receivable.getReceivable(proposal.receivableId);
        
        if (signer !== receivable.buyer) {
            throw new Error('Invalid buyer signature');
        }
        
        // æ‰§è¡Œæ”¯ä»˜
        const tx = await this.stablecoin.transferFrom(
            receivable.buyer,
            receivable.supplier,
            proposal.paymentAmount
        );
        
        // æ›´æ–°åº”æ”¶è´¦æ¬¾çŠ¶æ€
        await this.receivable.markAsPaid(proposal.receivableId, {
            paidAmount: proposal.paymentAmount,
            discountApplied: proposal.discountAmount,
            paidDate: Date.now()
        });
        
        // è®°å½•äº¤æ˜“
        return {
            transactionHash: tx.hash,
            ...proposal,
            executedAt: Date.now()
        };
    }
    
    /**
     * æ‰¹é‡å¤„ç†åŠ¨æ€æŠ˜æ‰£
     * @param {Array} receivableIds - åº”æ”¶è´¦æ¬¾IDåˆ—è¡¨
     */
    async batchProcessDiscounts(receivableIds) {
        const proposals = [];
        
        for (const id of receivableIds) {
            try {
                const proposal = await this.proposeDynamicDiscount(id);
                if (proposal.discountRate > 0) {
                    proposals.push(proposal);
                }
            } catch (error) {
                console.error(`Failed to process ${id}:`, error);
            }
        }
        
        // æŒ‰æŠ˜æ‰£é‡‘é¢æ’åºï¼Œä¼˜å…ˆå¤„ç†å¤§é¢æŠ˜æ‰£
        proposals.sort((a, b) => b.discountAmount - a.discountAmount);
        
        return proposals;
    }
}</code></pre>
                </div>
            </div>
        </div>

        <div class="theory-section">
            <h4>14.1.2 åº“å­˜èèµ„ä¸ä»“å•ç®¡ç†</h4>
            
            <div class="info-box">
                <p><strong>ğŸ—ï¸ ä»“å•ä»£å¸åŒ–çš„ä¼˜åŠ¿ï¼š</strong></p>
                <ul>
                    <li><strong>å®æ—¶éªŒè¯</strong>ï¼šIoTè®¾å¤‡å®æ—¶æ›´æ–°åº“å­˜çŠ¶æ€</li>
                    <li><strong>é˜²æ­¢é‡å¤è´¨æŠ¼</strong>ï¼šåŒºå—é“¾ç¡®ä¿ä»“å•å”¯ä¸€æ€§</li>
                    <li><strong>å¿«é€Ÿæµè½¬</strong>ï¼šä»“å•å¯åœ¨é“¾ä¸Šå³æ—¶è½¬è®©</li>
                    <li><strong>è‡ªåŠ¨ä¼°å€¼</strong>ï¼šåŸºäºå¸‚åœºæ•°æ®çš„å®æ—¶å®šä»·</li>
                </ul>
            </div>

            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">
                    Solidity ä»£ç  - æ™ºèƒ½ä»“å•ç³»ç»Ÿ <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

/**
 * @title WarehouseReceipt
 * @dev æ™ºèƒ½ä»“å•ç³»ç»Ÿ - æ”¯æŒå¤šç§å•†å“çš„ä»“å•ä»£å¸åŒ–
 */
contract WarehouseReceipt is ERC1155 {
    struct Commodity {
        string name;
        string unit;
        uint256 minQuantity;
        address priceOracle;
        bool isActive;
    }
    
    struct Receipt {
        uint256 commodityId;
        uint256 quantity;
        uint256 grade; // è´¨é‡ç­‰çº§ 1-5
        address warehouse;
        uint256 storageStartDate;
        uint256 expiryDate;
        bytes32 iotDeviceId;
        bool isFinanced;
    }
    
    // å•†å“æ³¨å†Œ
    mapping(uint256 => Commodity) public commodities;
    uint256 public commodityCounter;
    
    // ä»“å•ä¿¡æ¯
    mapping(uint256 => Receipt) public receipts;
    uint256 public receiptCounter;
    
    // ä»“åº“ç™½åå•
    mapping(address => bool) public authorizedWarehouses;
    
    // IoTè®¾å¤‡æ³¨å†Œ
    mapping(bytes32 => bool) public registeredDevices;
    mapping(bytes32 => uint256) public deviceToReceipt;
    
    // èèµ„è®°å½•
    mapping(uint256 => uint256) public receiptFinancing;
    
    event ReceiptIssued(uint256 indexed receiptId, address indexed owner, uint256 commodityId, uint256 quantity);
    event ReceiptFinanced(uint256 indexed receiptId, uint256 amount);
    event CommodityUpdated(uint256 indexed receiptId, uint256 newQuantity, uint256 newGrade);
    
    constructor() ERC1155("https://api.warehouse.com/receipts/{id}.json") {}
    
    /**
     * @dev æ³¨å†Œæ–°å•†å“ç±»å‹
     */
    function registerCommodity(
        string memory name,
        string memory unit,
        uint256 minQuantity,
        address priceOracle
    ) external returns (uint256) {
        uint256 commodityId = commodityCounter++;
        commodities[commodityId] = Commodity({
            name: name,
            unit: unit,
            minQuantity: minQuantity,
            priceOracle: priceOracle,
            isActive: true
        });
        return commodityId;
    }
    
    /**
     * @dev ç­¾å‘ä»“å•
     */
    function issueReceipt(
        address owner,
        uint256 commodityId,
        uint256 quantity,
        uint256 grade,
        uint256 expiryDate,
        bytes32 iotDeviceId
    ) external returns (uint256) {
        require(authorizedWarehouses[msg.sender], "Unauthorized warehouse");
        require(commodities[commodityId].isActive, "Invalid commodity");
        require(quantity >= commodities[commodityId].minQuantity, "Below min quantity");
        require(grade >= 1 && grade <= 5, "Invalid grade");
        require(registeredDevices[iotDeviceId], "Unregistered IoT device");
        
        uint256 receiptId = receiptCounter++;
        
        receipts[receiptId] = Receipt({
            commodityId: commodityId,
            quantity: quantity,
            grade: grade,
            warehouse: msg.sender,
            storageStartDate: block.timestamp,
            expiryDate: expiryDate,
            iotDeviceId: iotDeviceId,
            isFinanced: false
        });
        
        deviceToReceipt[iotDeviceId] = receiptId;
        
        // é“¸é€ NFTç»™æ‰€æœ‰è€…
        _mint(owner, receiptId, 1, "");
        
        emit ReceiptIssued(receiptId, owner, commodityId, quantity);
        return receiptId;
    }
    
    /**
     * @dev IoTè®¾å¤‡æ›´æ–°å•†å“çŠ¶æ€
     */
    function updateCommodityStatus(
        bytes32 iotDeviceId,
        uint256 newQuantity,
        uint256 newGrade
    ) external {
        require(registeredDevices[iotDeviceId], "Unregistered device");
        uint256 receiptId = deviceToReceipt[iotDeviceId];
        require(receiptId > 0, "No receipt for device");
        
        Receipt storage receipt = receipts[receiptId];
        
        // æ›´æ–°æ•°é‡å’Œç­‰çº§
        receipt.quantity = newQuantity;
        receipt.grade = newGrade;
        
        emit CommodityUpdated(receiptId, newQuantity, newGrade);
        
        // å¦‚æœå·²èèµ„ä¸”ä»·å€¼ä¸‹é™ï¼Œå¯èƒ½è§¦å‘è¿½åŠ ä¿è¯é‡‘
        if (receipt.isFinanced) {
            uint256 currentValue = calculateReceiptValue(receiptId);
            uint256 financedAmount = receiptFinancing[receiptId];
            
            if (currentValue < financedAmount * 120 / 100) { // LTV > 83%
                // è§¦å‘è¿½åŠ ä¿è¯é‡‘äº‹ä»¶
                emit MarginCallTriggered(receiptId, currentValue, financedAmount);
            }
        }
    }
    
    /**
     * @dev è®¡ç®—ä»“å•ä»·å€¼
     */
    function calculateReceiptValue(uint256 receiptId) public view returns (uint256) {
        Receipt memory receipt = receipts[receiptId];
        Commodity memory commodity = commodities[receipt.commodityId];
        
        // ä»ä»·æ ¼é¢„è¨€æœºè·å–ä»·æ ¼
        AggregatorV3Interface priceFeed = AggregatorV3Interface(commodity.priceOracle);
        (, int256 price,,,) = priceFeed.latestRoundData();
        
        // æ ¹æ®ç­‰çº§è°ƒæ•´ä»·æ ¼
        uint256 gradeMultiplier = 80 + (receipt.grade * 5); // 85%-105%
        uint256 baseValue = uint256(price) * receipt.quantity / 1e8;
        
        return baseValue * gradeMultiplier / 100;
    }
    
    /**
     * @dev ä»“å•èèµ„
     */
    function financeReceipt(uint256 receiptId, uint256 amount) external returns (bool) {
        require(balanceOf(msg.sender, receiptId) > 0, "Not receipt owner");
        Receipt storage receipt = receipts[receiptId];
        require(!receipt.isFinanced, "Already financed");
        
        uint256 maxLoanAmount = calculateReceiptValue(receiptId) * 70 / 100; // 70% LTV
        require(amount <= maxLoanAmount, "Exceeds max loan amount");
        
        receipt.isFinanced = true;
        receiptFinancing[receiptId] = amount;
        
        // é”å®šNFTåˆ°åˆçº¦
        safeTransferFrom(msg.sender, address(this), receiptId, 1, "");
        
        emit ReceiptFinanced(receiptId, amount);
        return true;
    }
    
    event MarginCallTriggered(uint256 indexed receiptId, uint256 currentValue, uint256 loanAmount);
}</code></pre>
                </div>
            </div>
        </div>

        <h3 id="cross-border-trade">14.2 è·¨å¢ƒè´¸æ˜“ç»“ç®—ä¸ä¿¡ç”¨è¯ç³»ç»Ÿ</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>ğŸŒ é‡æ–°å®šä¹‰å›½é™…è´¸æ˜“ï¼šä»SWIFTåˆ°åŒºå—é“¾çš„è·¨è¶Š</h4>
            <p>ä¼ ç»Ÿè·¨å¢ƒè´¸æ˜“ç»“ç®—æ¶‰åŠå¤šä¸ªä¸­ä»‹æœºæ„ï¼Œæµç¨‹å¤æ‚ã€æˆæœ¬é«˜æ˜‚ã€‚ç¨³å®šå¸æ­£åœ¨åˆ›é€ ä¸€ä¸ªç‚¹å¯¹ç‚¹çš„å…¨çƒè´¸æ˜“ç½‘ç»œï¼Œè®©ä¸­å°ä¼ä¸šä¹Ÿèƒ½è½»æ¾å‚ä¸å›½é™…è´¸æ˜“ã€‚</p>
            
            <div style="background-color: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 15px;">
                <h5>ğŸ¯ ç¨³å®šå¸åœ¨è·¨å¢ƒè´¸æ˜“ä¸­çš„é©å‘½æ€§ä¼˜åŠ¿</h5>
                <ol>
                    <li><strong>å³æ—¶ç»“ç®—</strong>ï¼šä»T+3å¤©ç¼©çŸ­åˆ°å‡ åˆ†é’Ÿ</li>
                    <li><strong>ä½æˆæœ¬</strong>ï¼šè´¹ç”¨ä»3-5%é™è‡³0.1-0.5%</li>
                    <li><strong>å…¨å¤©å€™</strong>ï¼šä¸å—é“¶è¡Œå·¥ä½œæ—¶é—´é™åˆ¶</li>
                    <li><strong>é€æ˜è¿½è¸ª</strong>ï¼šå®æ—¶æŸ¥çœ‹èµ„é‡‘å’Œè´§ç‰©çŠ¶æ€</li>
                </ol>
            </div>
        </div>

        <div class="warning-box" style="background-color: #fef2f2; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>âš ï¸ ä¼ ç»Ÿä¿¡ç”¨è¯çš„ç—›ç‚¹</h4>
            <ul>
                <li><strong>æµç¨‹å†—é•¿</strong>ï¼šå¼€è¯åˆ°ä»˜æ¬¾å¹³å‡éœ€è¦5-10å¤©</li>
                <li><strong>æ–‡æ¡£ç¹ç</strong>ï¼šå¹³å‡æ¯ç¬”äº¤æ˜“æ¶‰åŠ20+ä»½æ–‡ä»¶</li>
                <li><strong>æˆæœ¬é«˜æ˜‚</strong>ï¼šé“¶è¡Œè´¹ç”¨å äº¤æ˜“é¢çš„1-2%</li>
                <li><strong>æ¬ºè¯ˆé£é™©</strong>ï¼šä¼ªé€ å•æ®é€ æˆå¹´æŸå¤±è¶…ç™¾äº¿ç¾å…ƒ</li>
            </ul>
        </div>

        <div class="theory-section">
            <h4>14.2.1 æ™ºèƒ½ä¿¡ç”¨è¯å®ç°</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">
                    Solidity ä»£ç  - åŒºå—é“¾ä¿¡ç”¨è¯ç³»ç»Ÿ <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

/**
 * @title SmartLetterOfCredit
 * @dev æ™ºèƒ½ä¿¡ç”¨è¯ç³»ç»Ÿ - è‡ªåŠ¨åŒ–å›½é™…è´¸æ˜“ç»“ç®—
 */
contract SmartLetterOfCredit is ReentrancyGuard {
    using ECDSA for bytes32;
    
    IERC20 public immutable settlementToken;
    
    enum LCStatus {
        Created,
        Confirmed,
        DocumentsSubmitted,
        DocumentsApproved,
        Paid,
        Cancelled,
        Disputed
    }
    
    struct LetterOfCredit {
        // åŸºæœ¬ä¿¡æ¯
        address buyer;
        address seller;
        address issuingBank;
        address advisingBank;
        
        // äº¤æ˜“è¯¦æƒ…
        uint256 amount;
        string currency;
        uint256 expiryDate;
        uint256 shipmentDeadline;
        
        // å•æ®è¦æ±‚
        bytes32[] requiredDocuments;
        mapping(bytes32 => Document) documents;
        uint256 documentsSubmitted;
        
        // çŠ¶æ€
        LCStatus status;
        uint256 createdAt;
        uint256 paidAt;
        
        // æ¡æ¬¾
        string termsHash; // IPFS hash
        bool partialShipmentAllowed;
        bool transshipmentAllowed;
    }
    
    struct Document {
        string documentType;
        string ipfsHash;
        address submittedBy;
        uint256 submittedAt;
        bool isVerified;
        address verifiedBy;
    }
    
    // ä¿¡ç”¨è¯å­˜å‚¨
    mapping(uint256 => LetterOfCredit) public letterOfCredits;
    uint256 public lcCounter;
    
    // é“¶è¡Œå’ŒéªŒè¯æ–¹æ³¨å†Œ
    mapping(address => bool) public registeredBanks;
    mapping(address => bool) public registeredVerifiers;
    
    // æ–‡æ¡£ç±»å‹
    bytes32 public constant BILL_OF_LADING = keccak256("BILL_OF_LADING");
    bytes32 public constant COMMERCIAL_INVOICE = keccak256("COMMERCIAL_INVOICE");
    bytes32 public constant PACKING_LIST = keccak256("PACKING_LIST");
    bytes32 public constant CERTIFICATE_OF_ORIGIN = keccak256("CERTIFICATE_OF_ORIGIN");
    bytes32 public constant INSURANCE_POLICY = keccak256("INSURANCE_POLICY");
    
    event LCCreated(uint256 indexed lcId, address indexed buyer, address indexed seller, uint256 amount);
    event LCConfirmed(uint256 indexed lcId, address advisingBank);
    event DocumentSubmitted(uint256 indexed lcId, bytes32 documentType, string ipfsHash);
    event DocumentVerified(uint256 indexed lcId, bytes32 documentType, address verifier);
    event PaymentReleased(uint256 indexed lcId, uint256 amount);
    
    modifier onlyBank() {
        require(registeredBanks[msg.sender], "Not a registered bank");
        _;
    }
    
    modifier onlyVerifier() {
        require(registeredVerifiers[msg.sender], "Not a registered verifier");
        _;
    }
    
    constructor(address _settlementToken) {
        settlementToken = IERC20(_settlementToken);
    }
    
    /**
     * @dev åˆ›å»ºä¿¡ç”¨è¯
     */
    function createLC(
        address seller,
        address advisingBank,
        uint256 amount,
        uint256 expiryDate,
        uint256 shipmentDeadline,
        bytes32[] calldata requiredDocs,
        string calldata termsHash
    ) external returns (uint256) {
        require(amount > 0, "Invalid amount");
        require(expiryDate > block.timestamp, "Invalid expiry");
        require(shipmentDeadline < expiryDate, "Invalid deadlines");
        
        uint256 lcId = lcCounter++;
        
        LetterOfCredit storage lc = letterOfCredits[lcId];
        lc.buyer = msg.sender;
        lc.seller = seller;
        lc.issuingBank = address(this); // ç®€åŒ–ï¼šåˆçº¦å³å‘è¯è¡Œ
        lc.advisingBank = advisingBank;
        lc.amount = amount;
        lc.expiryDate = expiryDate;
        lc.shipmentDeadline = shipmentDeadline;
        lc.requiredDocuments = requiredDocs;
        lc.status = LCStatus.Created;
        lc.createdAt = block.timestamp;
        lc.termsHash = termsHash;
        
        // ä¹°æ–¹èµ„é‡‘é”å®š
        settlementToken.transferFrom(msg.sender, address(this), amount);
        
        emit LCCreated(lcId, msg.sender, seller, amount);
        return lcId;
    }
    
    /**
     * @dev é€šçŸ¥è¡Œç¡®è®¤ä¿¡ç”¨è¯
     */
    function confirmLC(uint256 lcId) external onlyBank {
        LetterOfCredit storage lc = letterOfCredits[lcId];
        require(lc.status == LCStatus.Created, "Invalid status");
        require(msg.sender == lc.advisingBank, "Not advising bank");
        
        lc.status = LCStatus.Confirmed;
        emit LCConfirmed(lcId, msg.sender);
    }
    
    /**
     * @dev å–æ–¹æäº¤å•æ®
     */
    function submitDocument(
        uint256 lcId,
        bytes32 documentType,
        string calldata ipfsHash
    ) external {
        LetterOfCredit storage lc = letterOfCredits[lcId];
        require(lc.status == LCStatus.Confirmed || lc.status == LCStatus.DocumentsSubmitted, "Cannot submit");
        require(msg.sender == lc.seller, "Not seller");
        require(block.timestamp < lc.expiryDate, "LC expired");
        
        // éªŒè¯æ˜¯å¿…éœ€æ–‡æ¡£
        bool isRequired = false;
        for (uint i = 0; i < lc.requiredDocuments.length; i++) {
            if (lc.requiredDocuments[i] == documentType) {
                isRequired = true;
                break;
            }
        }
        require(isRequired, "Document not required");
        
        // å­˜å‚¨æ–‡æ¡£
        Document storage doc = lc.documents[documentType];
        require(bytes(doc.ipfsHash).length == 0, "Document already submitted");
        
        doc.documentType = string(abi.encodePacked(documentType));
        doc.ipfsHash = ipfsHash;
        doc.submittedBy = msg.sender;
        doc.submittedAt = block.timestamp;
        
        lc.documentsSubmitted++;
        
        if (lc.documentsSubmitted == lc.requiredDocuments.length) {
            lc.status = LCStatus.DocumentsSubmitted;
        }
        
        emit DocumentSubmitted(lcId, documentType, ipfsHash);
    }
    
    /**
     * @dev éªŒè¯å•æ®
     */
    function verifyDocument(
        uint256 lcId,
        bytes32 documentType,
        bool isValid
    ) external onlyVerifier {
        LetterOfCredit storage lc = letterOfCredits[lcId];
        Document storage doc = lc.documents[documentType];
        
        require(bytes(doc.ipfsHash).length > 0, "Document not submitted");
        require(!doc.isVerified, "Already verified");
        
        if (isValid) {
            doc.isVerified = true;
            doc.verifiedBy = msg.sender;
            emit DocumentVerified(lcId, documentType, msg.sender);
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ–‡æ¡£éƒ½å·²éªŒè¯
            bool allVerified = true;
            for (uint i = 0; i < lc.requiredDocuments.length; i++) {
                if (!lc.documents[lc.requiredDocuments[i]].isVerified) {
                    allVerified = false;
                    break;
                }
            }
            
            if (allVerified) {
                lc.status = LCStatus.DocumentsApproved;
            }
        } else {
            lc.status = LCStatus.Disputed;
        }
    }
    
    /**
     * @dev é“¶è¡Œæ”¾æ¬¾
     */
    function releasePayment(uint256 lcId) external onlyBank nonReentrant {
        LetterOfCredit storage lc = letterOfCredits[lcId];
        require(lc.status == LCStatus.DocumentsApproved, "Documents not approved");
        require(msg.sender == lc.issuingBank || msg.sender == lc.advisingBank, "Not authorized");
        
        uint256 amount = lc.amount;
        lc.status = LCStatus.Paid;
        lc.paidAt = block.timestamp;
        
        // æ”¯ä»˜ç»™å–æ–¹
        settlementToken.transfer(lc.seller, amount);
        
        emit PaymentReleased(lcId, amount);
    }
    
    /**
     * @dev å–æ¶ˆè¿‡æœŸä¿¡ç”¨è¯
     */
    function cancelExpiredLC(uint256 lcId) external {
        LetterOfCredit storage lc = letterOfCredits[lcId];
        require(block.timestamp > lc.expiryDate, "Not expired");
        require(lc.status != LCStatus.Paid, "Already paid");
        require(lc.status != LCStatus.Cancelled, "Already cancelled");
        
        lc.status = LCStatus.Cancelled;
        
        // é€€è¿˜ä¹°æ–¹èµ„é‡‘
        settlementToken.transfer(lc.buyer, lc.amount);
    }
    
    /**
     * @dev è·å–ä¿¡ç”¨è¯è¯¦æƒ…
     */
    function getLCDetails(uint256 lcId) external view returns (
        address buyer,
        address seller,
        uint256 amount,
        LCStatus status,
        uint256 documentsRequired,
        uint256 documentsSubmitted,
        uint256 expiryDate
    ) {
        LetterOfCredit storage lc = letterOfCredits[lcId];
        return (
            lc.buyer,
            lc.seller,
            lc.amount,
            lc.status,
            lc.requiredDocuments.length,
            lc.documentsSubmitted,
            lc.expiryDate
        );
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <div class="summary-box">
            <h3>æœ¬ç« å°ç»“</h3>
            <p>ä¼ä¸šçº§ç¨³å®šå¸åº”ç”¨æ­£åœ¨é‡å¡‘B2Bæ”¯ä»˜å’Œé‡‘èæœåŠ¡ã€‚æœ¬ç« ä»‹ç»äº†ï¼š</p>
            <ul>
                <li><strong>ä¾›åº”é“¾é‡‘è</strong>ï¼šå®æ—¶ç»“ç®—ã€è‡ªåŠ¨åŒ–èèµ„ã€é£é™©ç®¡ç†</li>
                <li><strong>è·¨å¢ƒè´¸æ˜“</strong>ï¼šå³æ—¶ç»“ç®—ã€ä½æˆæœ¬ã€é€æ˜å¯è¿½æº¯</li>
                <li><strong>ä¼ä¸šèµ„é‡‘ç®¡ç†</strong>ï¼šå…¨çƒæµåŠ¨æ€§æ± ã€è‡ªåŠ¨åŒ–èµ„é‡‘è°ƒé…</li>
                <li><strong>è´¢åŠ¡è‡ªåŠ¨åŒ–</strong>ï¼šæ™ºèƒ½å‘ç¥¨ã€è‡ªåŠ¨å¯¹è´¦ã€å®æ—¶å®¡è®¡</li>
                <li><strong>B2BåŸºç¡€è®¾æ–½</strong>ï¼šä¼ä¸šçº§é’±åŒ…ã€æ‰¹é‡æ”¯ä»˜ã€åˆè§„æ¡†æ¶</li>
            </ul>
            
            <p>ç¨³å®šå¸ä¸ºä¼ä¸šå¸¦æ¥äº†å‰æ‰€æœªæœ‰çš„æ•ˆç‡æå‡å’Œæˆæœ¬èŠ‚çº¦ã€‚é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ åº”è¯¥èƒ½å¤Ÿè®¾è®¡å’Œå®ç°é€‚åˆä¼ä¸šéœ€æ±‚çš„ç¨³å®šå¸è§£å†³æ–¹æ¡ˆï¼Œæ¨åŠ¨ä¼ ç»Ÿå•†ä¸šçš„æ•°å­—åŒ–è½¬å‹ã€‚</p>
        
            
            <!-- ç« èŠ‚å¯¼èˆª -->
            <div class="chapter-nav">
                <a href="chapter13.html">â† ç¬¬13ç« </a>
                <a href="index.html">è¿”å›é¦–é¡µ â†’</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>