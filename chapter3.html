<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬ä¸‰ç« ï¼šERC-20åŠæ‰©å±•æ ‡å‡† - åŒºå—é“¾ç¨³å®šå¸æ•™ç¨‹</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">ç¨³å®šå¸æ•™ç¨‹</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">â˜°</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">é¦–é¡µ</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">å¼•è¨€</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">ç« èŠ‚</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">ç¬¬1ç« ï¼šåŒºå—é“¾åŸºç¡€</a>
                        <a href="chapter2.html" class="dropdown-item">ç¬¬2ç« ï¼šç¨³å®šå¸åˆ†ç±»</a>
                        <a href="chapter3.html" class="dropdown-item">ç¬¬3ç« ï¼šERC-20æ ‡å‡†</a>
                        <a href="chapter4.html" class="dropdown-item">ç¬¬4ç« ï¼šæŠµæŠ¼å‹è®¾è®¡</a>
                        <a href="chapter5.html" class="dropdown-item">ç¬¬5ç« ï¼šæ•°å­¦æ¨¡å‹</a>
                        <a href="chapter6.html" class="dropdown-item">ç¬¬6ç« ï¼šAMMé›†æˆ</a>
                        <a href="chapter7.html" class="dropdown-item">ç¬¬7ç« ï¼šå€Ÿè´·åè®®</a>
                        <a href="chapter8.html" class="dropdown-item">ç¬¬8ç« ï¼šæ”¶ç›Šç­–ç•¥</a>
                        <a href="chapter9.html" class="dropdown-item">ç¬¬9ç« ï¼šæ™ºèƒ½åˆçº¦å®‰å…¨</a>
                        <a href="chapter10.html" class="dropdown-item">ç¬¬10ç« ï¼šç»æµæ”»å‡»</a>
                        <a href="chapter11.html" class="dropdown-item">ç¬¬11ç« ï¼šæœªæ¥æ–¹å‘</a>
                        <a href="chapter12.html" class="dropdown-item">ç¬¬12ç« ï¼šç”Ÿäº§éƒ¨ç½²</a>
                        <a href="chapter13.html" class="dropdown-item">ç¬¬13ç« ï¼šç”Ÿæ€é›†æˆ</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="index.html#resources" class="nav-link">èµ„æº</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- å¤´éƒ¨ -->
    <header id="top">
        <div class="container">
            <h1>ç¬¬ä¸‰ç« ï¼šERC-20åŠæ‰©å±•æ ‡å‡†</h1>
        </div>
    </header>
    
    <!-- ä¸»è¦å†…å®¹ -->
    <div class="container">
        <div class="chapter">
<h2>ç¬¬ä¸‰ç« ï¼šERC-20æ ‡å‡†ä¸æ‰©å±•</h2>
            
            <p>åœ¨å‰ä¸¤ç« ä¸­ï¼Œæˆ‘ä»¬æ·±å…¥äº†è§£äº†åŒºå—é“¾åŸºç¡€è®¾æ–½å’Œç¨³å®šå¸çš„ç»æµæ¨¡å‹ã€‚ç°åœ¨ï¼Œæ˜¯æ—¶å€™å°†è¿™äº›ç†è®ºçŸ¥è¯†è½¬åŒ–ä¸ºå®é™…çš„æ™ºèƒ½åˆçº¦ä»£ç äº†ã€‚ERC-20ä½œä¸ºä»¥å¤ªåŠç”Ÿæ€ç³»ç»Ÿä¸­æœ€é‡è¦çš„ä»£å¸æ ‡å‡†ï¼Œä¸ä»…å®šä¹‰äº†ä»£å¸çš„åŸºæœ¬è¡Œä¸ºï¼Œæ›´æ˜¯æ„å»ºç¨³å®šå¸ç³»ç»Ÿçš„åŸºçŸ³ã€‚æœ¬ç« å°†ä»æŠ€æœ¯è§†è§’å‰–æERC-20æ ‡å‡†ï¼Œæ¢è®¨å…¶åœ¨ç¨³å®šå¸åœºæ™¯ä¸‹çš„ç‰¹æ®Šéœ€æ±‚å’Œä¼˜åŒ–æ–¹æ¡ˆï¼Œå¹¶ä»‹ç»ç°ä»£åŒ–çš„æ‰©å±•æ ‡å‡†å¦‚ä½•è§£å†³ä¼ ç»ŸERC-20çš„å±€é™æ€§ã€‚æ— è®ºæ‚¨æ˜¯è¦æ„å»ºä¸€ä¸ªç®€å•çš„ç®—æ³•ç¨³å®šå¸ï¼Œè¿˜æ˜¯è®¾è®¡å¤æ‚çš„è·¨é“¾ç¨³å®šå¸ç³»ç»Ÿï¼Œæ·±å…¥ç†è§£è¿™äº›æ ‡å‡†éƒ½æ˜¯å¿…ä¸å¯å°‘çš„ç¬¬ä¸€æ­¥ã€‚</p>
            
            <div class="intro-box">
                <strong>æœ¬ç« æ¦‚è§ˆï¼š</strong>
                <ul>
                    <li>æ·±å…¥ç†è§£ERC-20æ ‡å‡†åŠå…¶åœ¨ç¨³å®šå¸ä¸­çš„åº”ç”¨</li>
                    <li>æ¢ç´¢ä»£ç†æ¨¡å¼å’Œå¯å‡çº§åˆçº¦æ¶æ„</li>
                    <li>è·¨é“¾æ ‡å‡†ä¸äº’æ“ä½œæ€§è§£å†³æ–¹æ¡ˆ</li>
                    <li>å®æˆ˜ï¼šæ„å»ºä¼ä¸šçº§å¯å‡çº§ç¨³å®šå¸</li>
                </ul>
            </div>

            <h3>FAQ: ERCä¸EIPçš„åŒºåˆ«</h3>
            <div class="info-box" style="background-color: #e0f2fe; border-left: 4px solid #0284c7;">
                <h4>ğŸ¤” ç»å¸¸æ··æ·†çš„æ¦‚å¿µï¼šERC-XX vs EIP-YY</h4>
                
                <div style="margin: 1rem 0;">
                    <h5>ä»€ä¹ˆæ˜¯EIPï¼Ÿ</h5>
                    <p><strong>EIP (Ethereum Improvement Proposal)</strong> æ˜¯ä»¥å¤ªåŠæ”¹è¿›ææ¡ˆçš„æ€»ç§°ï¼Œæ¶µç›–äº†æ‰€æœ‰å¯¹ä»¥å¤ªåŠåè®®çš„æ”¹è¿›å»ºè®®ã€‚</p>
                    <ul>
                        <li><strong>èŒƒå›´ï¼š</strong>æ ¸å¿ƒåè®®ã€ç½‘ç»œã€æ¥å£ã€åº”ç”¨æ ‡å‡†ç­‰</li>
                        <li><strong>ç¼–å·ï¼š</strong>æŒ‰æäº¤é¡ºåºé€’å¢ï¼ˆå¦‚EIP-1, EIP-20, EIP-1559ï¼‰</li>
                        <li><strong>ç±»åˆ«ï¼š</strong>
                            <ul>
                                <li>Core - æ ¸å¿ƒåè®®æ”¹è¿›</li>
                                <li>Networking - ç½‘ç»œåè®®</li>
                                <li>Interface - API/RPCè§„èŒƒ</li>
                                <li>ERC - åº”ç”¨çº§æ ‡å‡†ï¼ˆè§ä¸‹æ–‡ï¼‰</li>
                                <li>Meta - æµç¨‹ç›¸å…³</li>
                                <li>Informational - æŒ‡å—è¯´æ˜</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <div style="margin: 1rem 0;">
                    <h5>ä»€ä¹ˆæ˜¯ERCï¼Ÿ</h5>
                    <p><strong>ERC (Ethereum Request for Comments)</strong> æ˜¯EIPçš„ä¸€ä¸ªå­ç±»åˆ«ï¼Œä¸“é—¨å®šä¹‰åº”ç”¨çº§æ ‡å‡†ã€‚</p>
                    <ul>
                        <li><strong>èŒƒå›´ï¼š</strong>ä»£å¸æ ‡å‡†ã€åç§°æ³¨å†Œã€é’±åŒ…æ ¼å¼ç­‰åº”ç”¨å±‚åè®®</li>
                        <li><strong>å…³ç³»ï¼š</strong>æ¯ä¸ªERCéƒ½æ˜¯ä¸€ä¸ªEIPï¼Œä½†å¹¶éæ‰€æœ‰EIPéƒ½æ˜¯ERC</li>
                        <li><strong>ç¼–å·æ··æ·†ï¼š</strong>ERC-20å®é™…ä¸Šæ˜¯EIP-20ï¼Œä½†ä¹ æƒ¯ç§°ä¸ºERC-20</li>
                    </ul>
                </div>
                
                <div style="background-color: #dbeafe; padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                    <h5>ğŸ“‹ å¸¸è§æ ‡å‡†å¯¹ç…§è¡¨</h5>
                    <table style="width: 100%; margin-top: 0.5rem;">
                        <tr style="background: #f0f9ff;">
                            <th style="padding: 0.5rem; text-align: left;">é€šç”¨åç§°</th>
                            <th style="padding: 0.5rem; text-align: left;">æ­£å¼ç¼–å·</th>
                            <th style="padding: 0.5rem; text-align: left;">ç±»å‹</th>
                            <th style="padding: 0.5rem; text-align: left;">ç”¨é€”</th>
                        </tr>
                        <tr>
                            <td style="padding: 0.5rem;">ERC-20</td>
                            <td style="padding: 0.5rem;">EIP-20</td>
                            <td style="padding: 0.5rem;">ERC</td>
                            <td style="padding: 0.5rem;">åŒè´¨åŒ–ä»£å¸æ ‡å‡†</td>
                        </tr>
                        <tr style="background: #f0f9ff;">
                            <td style="padding: 0.5rem;">ERC-721</td>
                            <td style="padding: 0.5rem;">EIP-721</td>
                            <td style="padding: 0.5rem;">ERC</td>
                            <td style="padding: 0.5rem;">éåŒè´¨åŒ–ä»£å¸(NFT)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.5rem;">ERC-1155</td>
                            <td style="padding: 0.5rem;">EIP-1155</td>
                            <td style="padding: 0.5rem;">ERC</td>
                            <td style="padding: 0.5rem;">å¤šä»£å¸æ ‡å‡†</td>
                        </tr>
                        <tr style="background: #f0f9ff;">
                            <td style="padding: 0.5rem;">EIP-1559</td>
                            <td style="padding: 0.5rem;">EIP-1559</td>
                            <td style="padding: 0.5rem;">Core</td>
                            <td style="padding: 0.5rem;">Gasè´¹ç”¨æ”¹é©</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.5rem;">EIP-712</td>
                            <td style="padding: 0.5rem;">EIP-712</td>
                            <td style="padding: 0.5rem;">Interface</td>
                            <td style="padding: 0.5rem;">ç»“æ„åŒ–æ•°æ®ç­¾å</td>
                        </tr>
                        <tr style="background: #f0f9ff;">
                            <td style="padding: 0.5rem;">ERC-2612</td>
                            <td style="padding: 0.5rem;">EIP-2612</td>
                            <td style="padding: 0.5rem;">ERC</td>
                            <td style="padding: 0.5rem;">Permitï¼ˆç­¾åæˆæƒï¼‰</td>
                        </tr>
                    </table>
                </div>
                
                <div style="margin-top: 1rem; padding: 1rem; background-color: #fef3c7; border-radius: 8px;">
                    <h5>ğŸ’¡ è®°å¿†æŠ€å·§</h5>
                    <ul>
                        <li><strong>ERC = åº”ç”¨æ ‡å‡†ï¼š</strong>å¦‚æœæ˜¯å…³äºä»£å¸ã€NFTç­‰åº”ç”¨å±‚çš„ï¼Œé€šå¸¸æ˜¯ERC</li>
                        <li><strong>çº¯EIP = åè®®æ”¹è¿›ï¼š</strong>å¦‚æœæ˜¯å…³äºä»¥å¤ªåŠæ ¸å¿ƒåŠŸèƒ½çš„ï¼Œé€šå¸¸åªç§°EIP</li>
                        <li><strong>ä¹ æƒ¯ç”¨æ³•ï¼š</strong>ç¤¾åŒºä¹ æƒ¯è¯´"ERC-20ä»£å¸"è€Œä¸æ˜¯"EIP-20ä»£å¸"</li>
                        <li><strong>æŸ¥æ‰¾æ–¹æ³•ï¼š</strong>åœ¨eips.ethereum.orgå¯ä»¥æ‰¾åˆ°æ‰€æœ‰ææ¡ˆçš„æ­£å¼æ–‡æ¡£</li>
                    </ul>
                </div>
            </div>

            <h3>3.1 æ ‡å‡†ä»£å¸æ¥å£æ·±åº¦è§£æ</h3>
            
            <h4>3.1.1 ERC-20æ ‡å‡†çš„æ¼”è¿›å†ç¨‹</h4>
            <p>ERC-20æ ‡å‡†è¯ç”Ÿäº2015å¹´11æœˆï¼Œç”±Fabian Vogelstelleræå‡ºï¼Œæˆä¸ºä»¥å¤ªåŠç”Ÿæ€ç³»ç»Ÿä¸­æœ€æˆåŠŸçš„æ ‡å‡†ä¹‹ä¸€ã€‚è®©æˆ‘ä»¬æ·±å…¥äº†è§£å…¶æŠ€æœ¯ç»†èŠ‚å’Œåœ¨ç¨³å®šå¸ä¸­çš„ç‰¹æ®Šåº”ç”¨ã€‚</p>
            
            <div class="info-box">
                <h5>ğŸ“Š ERC-20çš„å·¨å¤§æˆåŠŸ</h5>
                <p>æˆªè‡³2024å¹´ï¼ŒERC-20æ ‡å‡†å·²ç»ï¼š</p>
                <ul>
                    <li><strong>ä»£å¸æ•°é‡</strong>ï¼šè¶…è¿‡500,000ä¸ªERC-20ä»£å¸éƒ¨ç½²åœ¨ä»¥å¤ªåŠä¸Š</li>
                    <li><strong>æ€»å¸‚å€¼</strong>ï¼šERC-20ä»£å¸æ€»å¸‚å€¼è¶…è¿‡$3000äº¿</li>
                    <li><strong>æ—¥äº¤æ˜“é‡</strong>ï¼šæ¯æ—¥ERC-20è½¬è´¦è¶…è¿‡300ä¸‡ç¬”</li>
                    <li><strong>ç¨³å®šå¸å æ¯”</strong>ï¼šå‰10å¤§ERC-20ä»£å¸ä¸­æœ‰6ä¸ªæ˜¯ç¨³å®šå¸</li>
                </ul>
                <p>ERC-20ä¹‹æ‰€ä»¥æˆåŠŸï¼Œå…³é”®åœ¨äºå…¶<strong>ç®€å•æ€§å’Œé€šç”¨æ€§</strong>ã€‚ä»»ä½•é’±åŒ…ã€äº¤æ˜“æ‰€æˆ–DeFiåè®®éƒ½å¯ä»¥è½»æ¾é›†æˆERC-20ä»£å¸ï¼Œè€Œæ— éœ€ä¸ºæ¯ä¸ªä»£å¸ç¼–å†™ç‰¹æ®Šä»£ç ã€‚</p>
            </div>
            
            <div class="example-box">
                <h5>ğŸŒŸ ä»æ¯”ç‰¹å¸åˆ°ERC-20ï¼šä»£å¸æ ‡å‡†åŒ–çš„é‡è¦æ€§</h5>
                <p>åœ¨ERC-20å‡ºç°ä¹‹å‰ï¼š</p>
                <ul>
                    <li><strong>æ¯”ç‰¹å¸æ—¶ä»£</strong>ï¼šæ¯ä¸ªæ–°å¸ç§éœ€è¦è‡ªå·±çš„åŒºå—é“¾å’Œé’±åŒ…</li>
                    <li><strong>æ—©æœŸä»¥å¤ªåŠ</strong>ï¼šæ²¡æœ‰ç»Ÿä¸€æ ‡å‡†ï¼Œæ¯ä¸ªä»£å¸æ¥å£éƒ½ä¸åŒ</li>
                    <li><strong>é›†æˆå›°éš¾</strong>ï¼šäº¤æ˜“æ‰€éœ€è¦ä¸ºæ¯ä¸ªä»£å¸å•ç‹¬å¼€å‘</li>
                </ul>
                <p>ERC-20è§£å†³äº†è¿™äº›é—®é¢˜ï¼Œå¥ å®šäº†DeFiç”Ÿæ€çˆ†å‘çš„åŸºç¡€ã€‚</p>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">åŸºç¡€ERC-20æ¥å£å®šä¹‰ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    // æŸ¥è¯¢ä»£å¸æ€»ä¾›åº”é‡
    function totalSupply() external view returns (uint256);
    
    // æŸ¥è¯¢è´¦æˆ·ä½™é¢
    function balanceOf(address account) external view returns (uint256);
    
    // è½¬è´¦å‡½æ•°
    function transfer(address to, uint256 amount) external returns (bool);
    
    // æŸ¥è¯¢æˆæƒé¢åº¦
    function allowance(address owner, address spender) external view returns (uint256);
    
    // æˆæƒå‡½æ•°
    function approve(address spender, uint256 amount) external returns (bool);
    
    // æˆæƒè½¬è´¦
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    
    // äº‹ä»¶å®šä¹‰
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.2 ç¨³å®šå¸ç‰¹æœ‰çš„æ‰©å±•åŠŸèƒ½</h4>
            <p>ç¨³å®šå¸åœ¨å®ç°ERC-20æ ‡å‡†çš„åŸºç¡€ä¸Šï¼Œé€šå¸¸éœ€è¦æ·»åŠ é¢å¤–çš„åŠŸèƒ½ä»¥æ»¡è¶³åˆè§„å’Œè¿è¥éœ€æ±‚ï¼š</p>
            
            <div class="tip-box">
                <h5>ğŸ” ä¸»æµç¨³å®šå¸çš„ç‰¹æ®ŠåŠŸèƒ½</h5>
                <table style="width: 100%; margin: 1rem 0;">
                    <tr>
                        <th style="padding: 0.5rem; background: #f1f5f9;">ç¨³å®šå¸</th>
                        <th style="padding: 0.5rem; background: #f1f5f9;">ç‰¹æ®ŠåŠŸèƒ½</th>
                        <th style="padding: 0.5rem; background: #f1f5f9;">å®ç°ç†ç”±</th>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">USDC</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">é»‘åå•ã€å¯å‡çº§ã€æš‚åœ</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">ç›‘ç®¡åˆè§„ï¼ˆFinCENã€OFACï¼‰</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">USDT</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">è´¹ç”¨å‚æ•°ã€é”€æ¯ä»ä»»æ„åœ°å€</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">é—ç•™é—®é¢˜ã€ç‰¹æ®Šè¿è¥éœ€æ±‚</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">DAI</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">DSRï¼ˆå­˜æ¬¾åˆ©ç‡ï¼‰ã€Permit</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">ç”Ÿæ¯åŠŸèƒ½ã€ç”¨æˆ·ä½“éªŒ</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">BUSD</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">èµ„äº§å†»ç»“ã€æ‰¹é‡è½¬è´¦</td>
                        <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">NYDFSç›‘ç®¡è¦æ±‚</td>
                    </tr>
                </table>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">ç¨³å®šå¸æ‰©å±•åŠŸèƒ½å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract StablecoinBase is ERC20, Pausable, AccessControl {
    // è§’è‰²å®šä¹‰
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");
    
    // é»‘åå•æ˜ å°„
    mapping(address => bool) private _blacklisted;
    
    // é“¸å¸é™é¢ç®¡ç†
    mapping(address => uint256) private _minterAllowances;
    
    // äº‹ä»¶
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    event MinterConfigured(address indexed minter, uint256 allowance);
    event MinterRemoved(address indexed minter);
    
    // ä¿®é¥°å™¨ï¼šæ£€æŸ¥é»‘åå•
    modifier notBlacklisted(address account) {
        require(!_blacklisted[account], "Account is blacklisted");
        _;
    }
    
    // é“¸å¸åŠŸèƒ½ï¼ˆå¸¦é™é¢æ§åˆ¶ï¼‰
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE) 
        whenNotPaused 
        notBlacklisted(to) 
    {
        require(amount <= _minterAllowances[msg.sender], "Exceeds minter allowance");
        _minterAllowances[msg.sender] -= amount;
        _mint(to, amount);
    }
    
    // é”€æ¯åŠŸèƒ½
    function burn(uint256 amount) external whenNotPaused {
        _burn(msg.sender, amount);
    }
    
    // é»‘åå•ç®¡ç†
    function blacklist(address account) external onlyRole(BLACKLISTER_ROLE) {
        _blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    // é‡å†™transferä»¥æ£€æŸ¥é»‘åå•
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);
        require(!_blacklisted[from] && !_blacklisted[to], "Blacklisted address");
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.3 ERC-2612 Permitæ‰©å±•</h4>
            <p>ERC-2612å…è®¸ç”¨æˆ·é€šè¿‡ç­¾åæˆæƒä»£å¸è½¬ç§»ï¼Œæ— éœ€é¢„å…ˆçš„approveäº¤æ˜“ï¼Œæå¤§æ”¹å–„äº†ç”¨æˆ·ä½“éªŒï¼š</p>
            
            <div class="example-box">
                <h5>ğŸ’¡ Permitçš„å®é™…åº”ç”¨åœºæ™¯</h5>
                <p><strong>ä¼ ç»ŸERC-20æµç¨‹</strong>ï¼ˆéœ€è¦ä¸¤ç¬”äº¤æ˜“ï¼‰ï¼š</p>
                <ol>
                    <li>ç”¨æˆ·è°ƒç”¨ <code>approve(spender, amount)</code> - èŠ±è´¹Gas</li>
                    <li>DAppè°ƒç”¨ <code>transferFrom(user, recipient, amount)</code> - å†æ¬¡èŠ±è´¹Gas</li>
                </ol>
                <p><strong>ERC-2612 Permitæµç¨‹</strong>ï¼ˆåªéœ€ä¸€ç¬”äº¤æ˜“ï¼‰ï¼š</p>
                <ol>
                    <li>ç”¨æˆ·åœ¨é’±åŒ…ä¸­ç­¾åæˆæƒæ¶ˆæ¯ - å…è´¹</li>
                    <li>DAppè°ƒç”¨ <code>permit()</code> + æ“ä½œ - ä¸€ç¬”äº¤æ˜“å®Œæˆæ‰€æœ‰</li>
                </ol>
                <p><strong>å®é™…èŠ‚çœ</strong>ï¼šå¯¹äºç”¨æˆ·è€Œè¨€ï¼Œå¯èŠ‚çœçº¦21,000 Gasï¼ˆçº¦$1-5ï¼Œå–å†³äºç½‘ç»œæ‹¥å µï¼‰</p>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">ERC-2612 Permitå®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract ERC20Permit is ERC20, IERC20Permit {
    using ECDSA for bytes32;
    
    bytes32 public constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );
    
    mapping(address => uint256) public nonces;
    
    // EIP-712 Domain
    bytes32 private immutable DOMAIN_SEPARATOR;
    
    constructor() {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256(bytes(name())),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );
    }
    
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
        
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                owner,
                spender,
                value,
                nonces[owner]++,
                deadline
            )
        );
        
        bytes32 hash = keccak256(
            abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash)
        );
        
        address signer = hash.recover(v, r, s);
        require(signer == owner, "ERC20Permit: invalid signature");
        
        _approve(owner, spender, value);
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.1.4 Gasä¼˜åŒ–æŠ€å·§</h4>
            <p>ç¨³å®šå¸é€šå¸¸æœ‰é«˜é¢‘äº¤æ˜“éœ€æ±‚ï¼ŒGasä¼˜åŒ–è‡³å…³é‡è¦ï¼š</p>
            
            <div class="tip">
                ğŸ’¡ å…³é”®æ´å¯Ÿï¼šé€šè¿‡æ‰¹é‡æ“ä½œå’Œå­˜å‚¨ä¼˜åŒ–ï¼Œå¯ä»¥å°†Gasæ¶ˆè€—é™ä½30-50%ã€‚2024å¹´æ–°å¢çš„ç¬æ—¶å­˜å‚¨ï¼ˆEIP-1153ï¼‰å¯è¿›ä¸€æ­¥ä¼˜åŒ–å¤æ‚äº¤æ˜“æµã€‚
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Gasä¼˜åŒ–å®ç°ç¤ºä¾‹ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract GasOptimizedStablecoin is StablecoinBase {
    // ä½¿ç”¨packedç»“æ„ä½“å‡å°‘å­˜å‚¨æ§½
    struct UserInfo {
        uint128 balance;      // è¶³å¤Ÿå­˜å‚¨å¤§éƒ¨åˆ†ä½™é¢
        uint64 lastTransfer;  // æ—¶é—´æˆ³
        bool isBlacklisted;   // é»‘åå•çŠ¶æ€
        bool isWhitelisted;   // ç™½åå•çŠ¶æ€ï¼ˆå…Gasè´¹ï¼‰
    }
    
    mapping(address => UserInfo) private _userInfo;
    
    // æ‰¹é‡è½¬è´¦ï¼ˆèŠ‚çœåŸºç¡€Gaså¼€é”€ï¼‰
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused {
        require(recipients.length == amounts.length, "Length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount;
        for (uint256 i = 0; i < amounts.length; ) {
            totalAmount += amounts[i];
            unchecked { ++i; }
        }
        
        require(_userInfo[msg.sender].balance >= totalAmount, "Insufficient balance");
        
        // ä½¿ç”¨uncheckedèŠ‚çœæº¢å‡ºæ£€æŸ¥Gas
        unchecked {
            _userInfo[msg.sender].balance -= uint128(totalAmount);
        }
        
        for (uint256 i = 0; i < recipients.length; ) {
            _userInfo[recipients[i]].balance += uint128(amounts[i]);
            emit Transfer(msg.sender, recipients[i], amounts[i]);
            unchecked { ++i; }
        }
    }
    
    // ä½¿ç”¨assemblyä¼˜åŒ–çš„ä½™é¢æŸ¥è¯¢
    function balanceOf(address account) public view returns (uint256 balance) {
        assembly {
            // ç›´æ¥è¯»å–å­˜å‚¨æ§½
            let slot := _userInfo.slot
            let key := account
            mstore(0x00, key)
            mstore(0x20, slot)
            let location := keccak256(0x00, 0x40)
            balance := shr(128, sload(location))
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>3.2 å¯å‡çº§æ¨¡å¼æ·±åº¦å®è·µ</h3>
            
            <h4>3.2.1 ä»£ç†æ¨¡å¼å¯¹æ¯”åˆ†æ</h4>
            <p>ç¨³å®šå¸åˆçº¦çš„å¯å‡çº§æ€§æ˜¯ä¸€ä¸ªå…³é”®ç‰¹æ€§ï¼Œè®©æˆ‘ä»¬æ·±å…¥æ¯”è¾ƒä¸åŒçš„å‡çº§æ¨¡å¼ï¼š</p>
            
            <div class="warning-box">
                <h5>âš ï¸ å¯å‡çº§æ€§çš„åŒåˆƒå‰‘</h5>
                <p>å¯å‡çº§åˆçº¦åœ¨ç¨³å®šå¸é¢†åŸŸå¼•å‘äº†æ¿€çƒˆäº‰è®®ï¼š</p>
                <ul>
                    <li><strong>æ”¯æŒæ–¹è§‚ç‚¹</strong>ï¼š
                        <ul>
                            <li>å¯ä»¥å¿«é€Ÿä¿®å¤æ¼æ´å’Œå®‰å…¨é—®é¢˜</li>
                            <li>é€‚åº”ä¸æ–­å˜åŒ–çš„ç›‘ç®¡è¦æ±‚</li>
                            <li>æ·»åŠ æ–°åŠŸèƒ½å’Œä¼˜åŒ–æ€§èƒ½</li>
                        </ul>
                    </li>
                    <li><strong>åå¯¹æ–¹è§‚ç‚¹</strong>ï¼š
                        <ul>
                            <li>ä¸­å¿ƒåŒ–é£é™©ï¼šç®¡ç†å‘˜å¯éšæ„ä¿®æ”¹è§„åˆ™</li>
                            <li>â€œä»£ç å³æ³•å¾‹â€åŸåˆ™è¢«ç ´å</li>
                            <li>å¢åŠ ç³»ç»Ÿå¤æ‚åº¦å’Œæ”»å‡»é¢</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>æ¡ˆä¾‹</strong>ï¼š2022å¹´ï¼ŒTornado Cashè¢«OFACåˆ¶è£åï¼ŒUSDCé»‘åå•äº†ç›¸å…³åœ°å€ï¼Œå¼•å‘å…³äºç¨³å®šå¸ä¸­å¿ƒåŒ–çš„å¹¿æ³›è®¨è®ºã€‚</p>
            </div>
            
            <table class="comparison-table">
                <tr>
                    <th>å‡çº§æ¨¡å¼</th>
                    <th>Gasæˆæœ¬</th>
                    <th>å¤æ‚åº¦</th>
                    <th>å­˜å‚¨å†²çªé£é™©</th>
                    <th>é€‚ç”¨åœºæ™¯</th>
                </tr>
                <tr>
                    <td>é€æ˜ä»£ç†ï¼ˆTransparent Proxyï¼‰</td>
                    <td>~2300 Gasé¢å¤–å¼€é”€</td>
                    <td>ä¸­ç­‰</td>
                    <td>ä½</td>
                    <td>USDCã€USDTç­‰ä¸»æµç¨³å®šå¸</td>
                </tr>
                <tr>
                    <td>UUPSï¼ˆUniversal Upgradeable Proxyï¼‰</td>
                    <td>~1000 Gasé¢å¤–å¼€é”€</td>
                    <td>é«˜</td>
                    <td>ä¸­</td>
                    <td>Gasæ•æ„Ÿçš„DeFiåè®®</td>
                </tr>
                <tr>
                    <td>é’»çŸ³æ ‡å‡†ï¼ˆDiamond/EIP-2535ï¼‰</td>
                    <td>~2500 Gasé¢å¤–å¼€é”€</td>
                    <td>å¾ˆé«˜</td>
                    <td>å¾ˆä½</td>
                    <td>å¤æ‚çš„æ¨¡å—åŒ–ç³»ç»Ÿ</td>
                </tr>
                <tr>
                    <td>Beaconä»£ç†</td>
                    <td>~2100 Gasé¢å¤–å¼€é”€</td>
                    <td>ä¸­ç­‰</td>
                    <td>ä½</td>
                    <td>å¤šå®ä¾‹éƒ¨ç½²åœºæ™¯</td>
                </tr>
            </table>
            
            <h4>3.2.2 UUPSæ¨¡å¼å®ç°</h4>
            <p>UUPSæ¨¡å¼å°†å‡çº§é€»è¾‘æ”¾åœ¨å®ç°åˆçº¦ä¸­ï¼Œæä¾›æ›´å¥½çš„Gasæ•ˆç‡ï¼š</p>
            
            <div class="info-box">
                <h5>ğŸ”§ UUPS vs é€æ˜ä»£ç†çš„æƒè¡¡</h5>
                <p><strong>UUPSä¼˜åŠ¿</strong>ï¼š</p>
                <ul>
                    <li>Gasæ•ˆç‡æ›´é«˜ï¼šæ¯ç¬”äº¤æ˜“èŠ‚çœçº¦1300 Gas</li>
                    <li>å®ç°æ›´çµæ´»ï¼šå¯ä»¥åœ¨å‡çº§ä¸­ä¿®æ”¹å‡çº§é€»è¾‘</li>
                    <li>éƒ¨ç½²æˆæœ¬æ›´ä½ï¼šä»£ç†åˆçº¦æ›´ç®€å•</li>
                </ul>
                <p><strong>UUPSé£é™©</strong>ï¼š</p>
                <ul>
                    <li>å®ç°é”™è¯¯å¯èƒ½å¯¼è‡´åˆçº¦æ°¸ä¹…æ— æ³•å‡çº§</li>
                    <li>éœ€è¦æ›´è°¨æ…çš„ä»£ç å®¡è®¡</li>
                    <li>å¼€å‘è€…éœ€è¦æ›´æ·±å…¥çš„ç†è§£</li>
                </ul>
                <p><strong>å®æˆ˜å»ºè®®</strong>ï¼šå¯¹äºé«˜é¢‘äº¤æ˜“çš„ç¨³å®šå¸ï¼ŒUUPSçš„GasèŠ‚çœå¯èƒ½æ¯å¹´èŠ‚çœæ•°ç™¾ä¸‡ç¾å…ƒã€‚</p>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">UUPSå¯å‡çº§ç¨³å®šå¸å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// ä½¿ç”¨OpenZeppelinçš„UUPSå®ç°
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract StablecoinV1 is 
    Initializable,
    ERC20Upgradeable,
    PausableUpgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable 
{
    // å­˜å‚¨å¸ƒå±€ç‰ˆæœ¬æ§åˆ¶
    uint256 private constant STORAGE_VERSION = 1;
    
    // çŠ¶æ€å˜é‡ï¼ˆæ³¨æ„é¡ºåºå¾ˆé‡è¦ï¼‰
    mapping(address => bool) public blacklisted;
    mapping(address => uint256) public minterAllowance;
    address[] public minters;
    
    // åˆå§‹åŒ–å‡½æ•°ï¼ˆä»£æ›¿æ„é€ å‡½æ•°ï¼‰
    function initialize(
        string memory name,
        string memory symbol
    ) public initializer {
        __ERC20_init(name, symbol);
        __Pausable_init();
        __Ownable_init();
        __UUPSUpgradeable_init();
    }
    
    // å‡çº§æˆæƒï¼ˆåªæœ‰ownerå¯ä»¥å‡çº§ï¼‰
    function _authorizeUpgrade(address newImplementation)
        internal
        onlyOwner
        override
    {}
    
    // è·å–å®ç°ç‰ˆæœ¬
    function version() external pure returns (string memory) {
        return "1.0.0";
    }
}

// V2ç‰ˆæœ¬ç¤ºä¾‹ï¼ˆæ·»åŠ æ–°åŠŸèƒ½ï¼‰
contract StablecoinV2 is StablecoinV1 {
    // æ–°å¢çŠ¶æ€å˜é‡ï¼ˆåªèƒ½åœ¨æœ€åæ·»åŠ ï¼‰
    mapping(address => uint256) public dailyTransferLimit;
    mapping(address => uint256) public dailyTransferAmount;
    mapping(address => uint256) public lastTransferDay;
    
    // æ–°å¢åŠŸèƒ½ï¼šæ¯æ—¥è½¬è´¦é™é¢
    function setDailyLimit(address user, uint256 limit) external onlyOwner {
        dailyTransferLimit[user] = limit;
    }
    
    // é‡å†™transferä»¥å®ç°é™é¢æ£€æŸ¥
    function transfer(address to, uint256 amount) 
        public 
        override 
        returns (bool) 
    {
        _checkDailyLimit(msg.sender, amount);
        return super.transfer(to, amount);
    }
    
    function _checkDailyLimit(address user, uint256 amount) private {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTransferDay[user] < today) {
            dailyTransferAmount[user] = 0;
            lastTransferDay[user] = today;
        }
        
        require(
            dailyTransferAmount[user] + amount <= dailyTransferLimit[user],
            "Daily limit exceeded"
        );
        
        dailyTransferAmount[user] += amount;
    }
    
    function version() external pure override returns (string memory) {
        return "2.0.0";
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.2.3 å­˜å‚¨å†²çªé˜²æŠ¤</h4>
            <p>å‡çº§åˆçº¦æ—¶æœ€å¤§çš„é£é™©æ˜¯å­˜å‚¨å†²çªï¼Œè¿™é‡Œæ˜¯é˜²æŠ¤æªæ–½ï¼š</p>
            
            <div class="warning-box">
                <h5>ğŸ’¥ å­˜å‚¨å†²çªçš„ç¾éš¾æ€§åæœ</h5>
                <p>å­˜å‚¨å†²çªå¯èƒ½å¯¼è‡´ï¼š</p>
                <ul>
                    <li><strong>èµ„é‡‘æŸå¤±</strong>ï¼šä½™é¢æ•°æ®è¢«è¦†ç›–ï¼Œç”¨æˆ·èµ„é‡‘æ°¸ä¹…ä¸¢å¤±</li>
                    <li><strong>æƒé™æ³„æ¼</strong>ï¼šç®¡ç†å‘˜åœ°å€è¢«è¦†ç›–ï¼Œåˆçº¦æ§åˆ¶æƒä¸¢å¤±</li>
                    <li><strong>åŠŸèƒ½å¤±æ•ˆ</strong>ï¼šå…³é”®å˜é‡è¢«ç ´åï¼Œåˆçº¦æ— æ³•æ­£å¸¸è¿ä½œ</li>
                </ul>
                <p><strong>çœŸå®æ¡ˆä¾‹</strong>ï¼š2021å¹´ï¼ŒæŸDeFié¡¹ç›®å› å‡çº§æ—¶å­˜å‚¨å†²çªå¯¼è‡´$3000ä¸‡é”ä»“èµ„é‡‘æ— æ³•å–å‡ºã€‚</p>
                <p><strong>é¢„é˜²æªæ–½</strong>ï¼š</p>
                <ul>
                    <li>ä½¿ç”¨å­˜å‚¨é—´éš™ï¼ˆStorage Gapï¼‰é¢„ç•™ç©ºé—´</li>
                    <li>ä¸¥æ ¼éµå®ˆå­˜å‚¨å¸ƒå±€è§„åˆ™</li>
                    <li>ä½¿ç”¨å·¥å…·å¦‚<code>hardhat-storage-layout</code>éªŒè¯</li>
                    <li>åœ¨æµ‹è¯•ç½‘å……åˆ†æµ‹è¯•å‡çº§è¿‡ç¨‹</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">å­˜å‚¨é—´éš™æ¨¡å¼ï¼ˆStorage Gapï¼‰ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">abstract contract StablecoinStorageV1 {
    // çŠ¶æ€å˜é‡
    mapping(address => uint256) internal _balances;
    mapping(address => mapping(address => uint256)) internal _allowances;
    uint256 internal _totalSupply;
    
    // å­˜å‚¨é—´éš™ï¼šé¢„ç•™å‡çº§ç©ºé—´
    uint256[47] private __gap;  // 50 - 3 = 47
}

abstract contract StablecoinStorageV2 is StablecoinStorageV1 {
    // æ–°å¢çŠ¶æ€å˜é‡
    mapping(address => bool) internal _frozen;
    uint256 internal _maxSupply;
    
    // æ›´æ–°å­˜å‚¨é—´éš™
    uint256[45] private __gap;  // 47 - 2 = 45
}

// ä½¿ç”¨éç»“æ„åŒ–å­˜å‚¨ï¼ˆUnstructured Storageï¼‰
contract DiamondStorage {
    struct DiamondStorageStruct {
        mapping(address => uint256) balances;
        mapping(address => bool) blacklisted;
        uint256 totalSupply;
        address admin;
    }
    
    function diamondStorage() 
        internal 
        pure 
        returns (DiamondStorageStruct storage ds) 
    {
        bytes32 position = keccak256("diamond.standard.diamond.storage");
        assembly {
            ds.slot := position
        }
    }
}</code></pre>
                </div>
            </div>
            
            <h3>3.3 è·¨é“¾æ ‡å‡†ä¸å®ç°</h3>
            
            <h4>3.3.1 ä¸»æµè·¨é“¾åè®®å¯¹æ¯”</h4>
            <p>ç¨³å®šå¸çš„è·¨é“¾éœ€æ±‚æ—¥ç›Šå¢é•¿ï¼Œè®©æˆ‘ä»¬æ·±å…¥äº†è§£å„ç§è·¨é“¾è§£å†³æ–¹æ¡ˆï¼š</p>
            
            <div class="info-box">
                <h5>ğŸŒ è·¨é“¾ç¨³å®šå¸çš„å·¨å¤§å¸‚åœº</h5>
                <p>æˆªè‡³2024å¹´çš„è·¨é“¾æ•°æ®ï¼š</p>
                <ul>
                    <li><strong>è·¨é“¾è½¬è´¦é‡</strong>ï¼šæ¯æœˆè¶…è¿‡$500äº¿çš„ç¨³å®šå¸è·¨é“¾è½¬ç§»</li>
                    <li><strong>ä¸»è¦è·¯å¾„</strong>ï¼š
                        <ul>
                            <li>ä»¥å¤ªåŠ â†” BSCï¼š35%</li>
                            <li>ä»¥å¤ªåŠ â†” Polygonï¼š20%</li>
                            <li>ä»¥å¤ªåŠ â†” Arbitrum/Optimismï¼š25%</li>
                            <li>å…¶ä»–ï¼š20%</li>
                        </ul>
                    </li>
                    <li><strong>ä¸»è¦éœ€æ±‚</strong>ï¼šDeFiå¥—åˆ©ï¼ˆ60%ï¼‰ã€æ”¯ä»˜ç»“ç®—ï¼ˆ25%ï¼‰ã€NFTäº¤æ˜“ï¼ˆ15%ï¼‰</li>
                </ul>
            </div>
            
            <div class="example-box">
                <h5>ğŸŒ‰ è·¨é“¾æ¡¥é»‘å®¢äº‹ä»¶çš„æ•™è®­</h5>
                <p>2021-2023å¹´ä¸»è¦è·¨é“¾æ¡¥é»‘å®¢äº‹ä»¶ï¼š</p>
                <ul>
                    <li><strong>Ronin Bridge</strong>ï¼ˆ2022.3ï¼‰ï¼š$6.24äº¿æŸå¤± - ç§é’¥è¢«ç›—</li>
                    <li><strong>Wormhole</strong>ï¼ˆ2022.2ï¼‰ï¼š$3.26äº¿æŸå¤± - ç­¾åéªŒè¯æ¼æ´</li>
                    <li><strong>Nomad</strong>ï¼ˆ2022.8ï¼‰ï¼š$1.9äº¿æŸå¤± - åˆå§‹åŒ–é”™è¯¯</li>
                    <li><strong>Harmony</strong>ï¼ˆ2022.6ï¼‰ï¼š$1äº¿æŸå¤± - å¤šç­¾è¢«ç ´</li>
                </ul>
                <p><strong>å®‰å…¨å¯ç¤º</strong>ï¼šè·¨é“¾æ¡¥æ˜¯é»‘å®¢çš„é¦–è¦ç›®æ ‡ï¼Œé€‰æ‹©æˆç†Ÿã€ç»è¿‡å®¡è®¡çš„è§£å†³æ–¹æ¡ˆè‡³å…³é‡è¦ã€‚</p>
            </div>
            
            <table class="comparison-table">
                <tr>
                    <th>è·¨é“¾åè®®</th>
                    <th>å®‰å…¨æ¨¡å‹</th>
                    <th>å»¶è¿Ÿ</th>
                    <th>æ”¯æŒé“¾æ•°</th>
                    <th>å»ä¸­å¿ƒåŒ–ç¨‹åº¦</th>
                </tr>
                <tr>
                    <td>LayerZero</td>
                    <td>Oracle + Relayer</td>
                    <td>å‡ åˆ†é’Ÿ</td>
                    <td>40+</td>
                    <td>ä¸­ç­‰</td>
                </tr>
                <tr>
                    <td>Axelar</td>
                    <td>PoSéªŒè¯è€…é›†</td>
                    <td>5-30åˆ†é’Ÿ</td>
                    <td>30+</td>
                    <td>é«˜</td>
                </tr>
                <tr>
                    <td>Wormhole</td>
                    <td>Guardianç½‘ç»œ</td>
                    <td>å‡ åˆ†é’Ÿ</td>
                    <td>20+</td>
                    <td>ä¸­ç­‰</td>
                </tr>
                <tr>
                    <td>IBC (Cosmos)</td>
                    <td>è½»å®¢æˆ·ç«¯</td>
                    <td>å‡ ç§’</td>
                    <td>50+ (Cosmosç”Ÿæ€)</td>
                    <td>å¾ˆé«˜</td>
                </tr>
            </table>
            
            <h4>3.3.2 LayerZeroé›†æˆå®ç°</h4>
            <p>LayerZeroæä¾›äº†çµæ´»çš„è·¨é“¾æ¶ˆæ¯ä¼ é€’ï¼Œé€‚åˆç¨³å®šå¸çš„å…¨é“¾éƒ¨ç½²ï¼š</p>
            
            <div class="info-box">
                <h5>âœ¨ LayerZeroçš„æ ¸å¿ƒä¼˜åŠ¿</h5>
                <ul>
                    <li><strong>å…¨é“¾ä»£å¸ï¼ˆOFTï¼‰</strong>ï¼šä¸€ä»½ä»£ç ï¼Œéƒ¨ç½²åˆ°æ‰€æœ‰é“¾</li>
                    <li><strong>ç»Ÿä¸€æµåŠ¨æ€§</strong>ï¼šé¿å…äº†ä¼ ç»Ÿè·¨é“¾æ¡¥çš„æµåŠ¨æ€§å‰²è£‚</li>
                    <li><strong>å¯ç»„åˆæ€§</strong>ï¼šæ”¯æŒå¤æ‚çš„è·¨é“¾æ“ä½œï¼Œå¦‚è·¨é“¾é—ªç”µè´·</li>
                    <li><strong>æˆæœ¬æ•ˆç›Š</strong>ï¼šç›¸æ¯”ä¼ ç»Ÿæ¡¥ï¼Œæˆæœ¬é™ä½70%+</li>
                </ul>
                <p><strong>å®é™…æ¡ˆä¾‹</strong>ï¼šCircleçš„CCTPï¼ˆCross-Chain Transfer Protocolï¼‰åŸºäºç±»ä¼¼ç†å¿µï¼Œå®ç°äº†USDCçš„åŸç”Ÿè·¨é“¾ã€‚</p>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">LayerZero OFTç¨³å®šå¸å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">import "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTV2.sol";

contract OmniChainStablecoin is OFTV2, Pausable {
    // é“¾IDåˆ°åœ°å€çš„æ˜ å°„ï¼ˆç”¨äºé™é¢ç®¡ç†ï¼‰
    mapping(uint16 => address) public trustedRemotes;
    
    // æ¯æ¡é“¾çš„é“¸å¸é™é¢
    mapping(uint16 => uint256) public chainMintLimit;
    mapping(uint16 => uint256) public chainMintAmount;
    
    // è·¨é“¾è½¬è´¦è´¹ç”¨ï¼ˆåŸºç‚¹ï¼‰
    uint256 public bridgeFee = 10; // 0.1%
    address public feeCollector;
    
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address _lzEndpoint
    ) OFTV2(_name, _symbol, _decimals, _lzEndpoint) {
        feeCollector = msg.sender;
    }
    
    // è®¾ç½®å¯ä¿¡è¿œç¨‹åˆçº¦
    function setTrustedRemote(
        uint16 _chainId,
        bytes calldata _path
    ) external onlyOwner {
        trustedRemotes[_chainId] = address(bytes20(_path));
        trustedRemote[_chainId] = _path;
    }
    
    // é‡å†™å‘é€å‡½æ•°ä»¥å®ç°è´¹ç”¨æ”¶å–
    function _send(
        address _from,
        uint16 _dstChainId,
        bytes32 _toAddress,
        uint256 _amount,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes memory _adapterParams
    ) internal override returns (uint256 amount) {
        // è®¡ç®—å¹¶æ”¶å–è·¨é“¾è´¹ç”¨
        uint256 fee = (_amount * bridgeFee) / 10000;
        uint256 amountAfterFee = _amount - fee;
        
        if (fee > 0) {
            _transfer(_from, feeCollector, fee);
        }
        
        // æ£€æŸ¥ç›®æ ‡é“¾é™é¢
        require(
            chainMintAmount[_dstChainId] + amountAfterFee <= chainMintLimit[_dstChainId],
            "Chain mint limit exceeded"
        );
        
        chainMintAmount[_dstChainId] += amountAfterFee;
        
        return super._send(
            _from,
            _dstChainId,
            _toAddress,
            amountAfterFee,
            _refundAddress,
            _zroPaymentAddress,
            _adapterParams
        );
    }
    
    // ä¼°ç®—è·¨é“¾è´¹ç”¨
    function estimateSendFee(
        uint16 _dstChainId,
        bytes32 _toAddress,
        uint256 _amount,
        bool _useZro,
        bytes calldata _adapterParams
    ) public view override returns (uint256 nativeFee, uint256 zroFee) {
        uint256 amountAfterFee = _amount - (_amount * bridgeFee) / 10000;
        return super.estimateSendFee(
            _dstChainId,
            _toAddress,
            amountAfterFee,
            _useZro,
            _adapterParams
        );
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.3.3 IBCåè®®é›†æˆï¼ˆCosmosç”Ÿæ€ï¼‰</h4>
            <p>IBCæä¾›äº†æœ€å»ä¸­å¿ƒåŒ–çš„è·¨é“¾è§£å†³æ–¹æ¡ˆï¼Œç‰¹åˆ«é€‚åˆCosmosç”Ÿæ€ï¼š</p>
            
            <div class="tip-box">
                <h5>ğŸŒŒ IBCçš„æŠ€æœ¯ç‰¹ç‚¹</h5>
                <p>IBCï¼ˆInter-Blockchain Communicationï¼‰æ˜¯Cosmosç”Ÿæ€çš„æ ¸å¿ƒï¼š</p>
                <ul>
                    <li><strong>è½»å®¢æˆ·ç«¯éªŒè¯</strong>ï¼šæ— éœ€ä¿¡ä»»ç¬¬ä¸‰æ–¹ï¼Œé“¾é—´ç›´æ¥éªŒè¯</li>
                    <li><strong>æ ‡å‡†åŒ–åè®®</strong>ï¼šä»»ä½•æ”¯æŒIBCçš„é“¾éƒ½å¯äº’æ“ä½œ</li>
                    <li><strong>åŸå­æ€§ä¿è¯</strong>ï¼šè·¨é“¾äº¤æ˜“è¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥</li>
                    <li><strong>æ»¡è¶³CAPå®šç†</strong>ï¼šåœ¨ä¸€è‡´æ€§å’Œå¯ç”¨æ€§ä¹‹é—´å–å¾—å¹³è¡¡</li>
                </ul>
                <p><strong>åº”ç”¨åœºæ™¯</strong>ï¼šOsmosis DEXé€šè¿‡IBCè¿æ¥50+æ¡é“¾ï¼Œæ—¥äº¤æ˜“é‡è¶…$1äº¿ã€‚</p>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">CosmWasm IBCç¨³å®šå¸åˆçº¦ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-rust">use cosmwasm_std::{
    entry_point, to_binary, Binary, Deps, DepsMut, 
    Env, MessageInfo, Response, StdResult, Uint128,
    IbcMsg, IbcTimeout, CosmosMsg,
};
use cw20::{Cw20Contract, Cw20ExecuteMsg};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct IbcTransferMsg {
    pub channel_id: String,
    pub to_address: String,
    pub amount: Uint128,
    pub timeout: IbcTimeout,
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::IbcTransfer(transfer_msg) => {
            execute_ibc_transfer(deps, env, info, transfer_msg)
        }
        _ => handle_cw20_execute(deps, env, info, msg),
    }
}

fn execute_ibc_transfer(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: IbcTransferMsg,
) -> Result<Response, ContractError> {
    // æ£€æŸ¥ä½™é¢
    let balance = BALANCES.load(deps.storage, &info.sender)?;
    if balance < msg.amount {
        return Err(ContractError::InsufficientFunds {});
    }
    
    // æ‰£é™¤ä½™é¢
    BALANCES.update(
        deps.storage,
        &info.sender,
        |balance| -> StdResult<_> {
            Ok(balance.unwrap_or_default() - msg.amount)
        },
    )?;
    
    // æ„å»ºIBCæ¶ˆæ¯
    let ibc_msg = IbcMsg::Transfer {
        channel_id: msg.channel_id,
        to_address: msg.to_address,
        amount: coin(msg.amount.u128(), "ustable"),
        timeout: msg.timeout,
    };
    
    Ok(Response::new()
        .add_message(ibc_msg)
        .add_attribute("action", "ibc_transfer")
        .add_attribute("from", info.sender)
        .add_attribute("amount", msg.amount))
}

// IBCåŒ…æ¥æ”¶å¤„ç†
#[entry_point]
pub fn ibc_packet_receive(
    deps: DepsMut,
    _env: Env,
    msg: IbcPacketReceiveMsg,
) -> Result<IbcReceiveResponse, Never> {
    // è§£ææ¥æ”¶çš„æ•°æ®
    let packet: TransferPacket = from_slice(&msg.packet.data)?;
    
    // é“¸é€ ä»£å¸ç»™æ¥æ”¶è€…
    BALANCES.update(
        deps.storage,
        &packet.receiver,
        |balance| -> StdResult<_> {
            Ok(balance.unwrap_or_default() + packet.amount)
        },
    )?;
    
    Ok(IbcReceiveResponse::new()
        .set_ack(to_binary(&TransferAck::Success)?)
        .add_attribute("action", "receive")
        .add_attribute("receiver", packet.receiver)
        .add_attribute("amount", packet.amount))
}</code></pre>
                </div>
            </div>
            
            <h3>3.4 å®è·µé¡¹ç›®ï¼šæ„å»ºä¼ä¸šçº§å¯å‡çº§ç¨³å®šå¸</h3>
            
            <h4>3.4.1 é¡¹ç›®éœ€æ±‚åˆ†æ</h4>
            <p>æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªå…·å¤‡ä»¥ä¸‹ç‰¹æ€§çš„ä¼ä¸šçº§ç¨³å®šå¸ï¼š</p>
            
            <div class="example-box">
                <h5>ğŸ¢ çœŸå®ä¼ä¸šéœ€æ±‚æ¡ˆä¾‹</h5>
                <p>åŸºäºä¸å¤šå®¶é‡‘èæœºæ„çš„åˆä½œç»éªŒï¼Œä¼ä¸šçº§ç¨³å®šå¸çš„æ ¸å¿ƒéœ€æ±‚åŒ…æ‹¬ï¼š</p>
                <ul>
                    <li><strong>åˆè§„æ€§ï¼ˆ95%ï¼‰</strong>ï¼š
                        <ul>
                            <li>KYC/AMLå®¡æ ¸æµç¨‹</li>
                            <li>OFACåˆ¶è£åå•æ£€æŸ¥</li>
                            <li>äº¤æ˜“ç›‘æ§å’ŒæŠ¥å‘Š</li>
                            <li>èµ„é‡‘æ¥æºè¿½è¸ª</li>
                        </ul>
                    </li>
                    <li><strong>å®‰å…¨æ€§ï¼ˆ90%ï¼‰</strong>ï¼š
                        <ul>
                            <li>å¤šç­¾æƒé™ç®¡ç†</li>
                            <li>æ—¶é—´é”æœºåˆ¶</li>
                            <li>ç´§æ€¥æš‚åœåŠŸèƒ½</li>
                            <li>å¯å‡çº§æ¶æ„</li>
                        </ul>
                    </li>
                    <li><strong>æ•ˆç‡ï¼ˆ75%ï¼‰</strong>ï¼š
                        <ul>
                            <li>æ‰¹é‡äº¤æ˜“æ”¯æŒ</li>
                            <li>Gasä¼˜åŒ–</li>
                            <li>è·¨é“¾äº’æ“ä½œ</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <ul>
                <li>ç¬¦åˆç›‘ç®¡è¦æ±‚çš„KYC/AMLåŠŸèƒ½</li>
                <li>å¯å‡çº§æ¶æ„ï¼Œæ”¯æŒåŠŸèƒ½è¿­ä»£</li>
                <li>å¤šé“¾éƒ¨ç½²ï¼Œæ”¯æŒä¸»æµå…¬é“¾</li>
                <li>å®Œå–„çš„æƒé™ç®¡ç†ç³»ç»Ÿ</li>
                <li>ç´§æ€¥æš‚åœå’Œæ¢å¤æœºåˆ¶</li>
            </ul>
            
            <h4>3.4.2 å®Œæ•´å®ç°</h4>
            
            <div class="tip-box">
                <h5>ğŸ“˜ åˆçº¦è®¾è®¡æœ€ä½³å®è·µ</h5>
                <p>è¿™ä¸ªå®ç°èåˆäº†å¤šä¸ªä¸šç•Œæœ€ä½³å®è·µï¼š</p>
                <ul>
                    <li><strong>UUPSä»£ç†æ¨¡å¼</strong>ï¼šGasæ•ˆç‡æœ€é«˜çš„å‡çº§æ–¹æ¡ˆ</li>
                    <li><strong>åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶</strong>ï¼šç»†ç²’åº¦æƒé™ç®¡ç†</li>
                    <li><strong>EIP-712ç­¾å</strong>ï¼šé˜²æ­¢é‡æ”¾æ”»å‡»</li>
                    <li><strong>æ´»åŠ¨ç›‘æ§</strong>ï¼šè‡ªåŠ¨å†»ç»“ä¸æ´»è·ƒè´¦æˆ·</li>
                    <li><strong>äº¤æ˜“é™é¢</strong>ï¼šé˜²æ­¢å¤§é¢å¼‚å¸¸äº¤æ˜“</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">ä¼ä¸šçº§ç¨³å®šå¸å®Œæ•´å®ç° <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract EnterpriseStablecoin is 
    Initializable,
    ERC20Upgradeable,
    PausableUpgradeable,
    AccessControlUpgradeable,
    UUPSUpgradeable 
{
    using ECDSA for bytes32;
    
    // è§’è‰²å®šä¹‰
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant BLACKLISTER_ROLE = keccak256("BLACKLISTER_ROLE");
    bytes32 public constant KYC_ROLE = keccak256("KYC_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    
    // çŠ¶æ€å˜é‡
    mapping(address => bool) public blacklisted;
    mapping(address => bool) public kycApproved;
    mapping(address => uint256) public minterAllowance;
    mapping(address => uint256) public lastActivity;
    
    // äº¤æ˜“é™åˆ¶
    uint256 public maxTransactionAmount;
    uint256 public dailyTransferLimit;
    mapping(address => uint256) public dailyTransferred;
    mapping(address => uint256) public lastTransferDay;
    
    // åˆè§„åŠŸèƒ½
    bool public kycRequired;
    uint256 public inactivityThreshold;
    
    // ç­¾ånonceï¼ˆé˜²é‡æ”¾ï¼‰
    mapping(address => uint256) public nonces;
    
    // äº‹ä»¶
    event Blacklisted(address indexed account);
    event UnBlacklisted(address indexed account);
    event KYCApproved(address indexed account);
    event KYCRevoked(address indexed account);
    event ComplianceConfigUpdated(bool kycRequired, uint256 inactivityThreshold);
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    function initialize(
        string memory name,
        string memory symbol,
        bool _kycRequired
    ) public initializer {
        __ERC20_init(name, symbol);
        __Pausable_init();
        __AccessControl_init();
        __UUPSUpgradeable_init();
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, msg.sender);
        
        kycRequired = _kycRequired;
        maxTransactionAmount = 1000000 * 10**decimals(); // 1Mé»˜è®¤é™é¢
        dailyTransferLimit = 5000000 * 10**decimals();   // 5Mæ¯æ—¥é™é¢
        inactivityThreshold = 365 days;                  // 1å¹´ä¸æ´»è·ƒé˜ˆå€¼
    }
    
    // é“¸å¸åŠŸèƒ½
    function mint(address to, uint256 amount) 
        external 
        onlyRole(MINTER_ROLE)
        whenNotPaused 
    {
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!kycRequired || kycApproved[to], "KYC not approved");
        require(amount <= minterAllowance[msg.sender], "Exceeds allowance");
        
        minterAllowance[msg.sender] -= amount;
        _mint(to, amount);
        lastActivity[to] = block.timestamp;
    }
    
    // å¸¦ç­¾åçš„é“¸å¸ï¼ˆé“¾ä¸‹æˆæƒï¼‰
    function mintWithSignature(
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external whenNotPaused {
        require(block.timestamp <= deadline, "Signature expired");
        
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Mint(address to,uint256 amount,uint256 nonce,uint256 deadline)"),
                to,
                amount,
                nonces[to]++,
                deadline
            )
        );
        
        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = hash.recover(v, r, s);
        
        require(hasRole(MINTER_ROLE, signer), "Invalid signer");
        require(!blacklisted[to], "Recipient is blacklisted");
        require(!kycRequired || kycApproved[to], "KYC not approved");
        
        _mint(to, amount);
        lastActivity[to] = block.timestamp;
    }
    
    // é‡å†™transferå‡½æ•°
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(!blacklisted[from] && !blacklisted[to], "Blacklisted address");
        require(!kycRequired || (kycApproved[from] && kycApproved[to]), "KYC required");
        require(amount <= maxTransactionAmount, "Exceeds max transaction");
        
        // æ£€æŸ¥æ¯æ—¥é™é¢
        _checkDailyLimit(from, amount);
        
        super._transfer(from, to, amount);
        
        // æ›´æ–°æ´»åŠ¨æ—¶é—´
        lastActivity[from] = block.timestamp;
        lastActivity[to] = block.timestamp;
    }
    
    // æ¯æ—¥é™é¢æ£€æŸ¥
    function _checkDailyLimit(address user, uint256 amount) private {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTransferDay[user] < today) {
            dailyTransferred[user] = 0;
            lastTransferDay[user] = today;
        }
        
        require(
            dailyTransferred[user] + amount <= dailyTransferLimit,
            "Daily limit exceeded"
        );
        
        dailyTransferred[user] += amount;
    }
    
    // å†»ç»“ä¸æ´»è·ƒè´¦æˆ·çš„èµ„é‡‘
    function freezeInactiveAccount(address account) 
        external 
        onlyRole(BLACKLISTER_ROLE) 
    {
        require(
            block.timestamp - lastActivity[account] > inactivityThreshold,
            "Account still active"
        );
        blacklisted[account] = true;
        emit Blacklisted(account);
    }
    
    // æ‰¹é‡KYCå®¡æ‰¹
    function batchApproveKYC(address[] calldata accounts) 
        external 
        onlyRole(KYC_ROLE) 
    {
        for (uint256 i = 0; i < accounts.length; i++) {
            kycApproved[accounts[i]] = true;
            emit KYCApproved(accounts[i]);
        }
    }
    
    // ç´§æ€¥æå–ï¼ˆä»…é™è¢«é»‘åå•åœ°å€ï¼‰
    function emergencyWithdraw(address blacklistedAccount, address to) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(blacklisted[blacklistedAccount], "Account not blacklisted");
        uint256 amount = balanceOf(blacklistedAccount);
        _burn(blacklistedAccount, amount);
        _mint(to, amount);
    }
    
    // å‡çº§æˆæƒ
    function _authorizeUpgrade(address newImplementation)
        internal
        onlyRole(UPGRADER_ROLE)
        override
    {}
    
    // æš‚åœåŠŸèƒ½
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }
    
    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }
    
    // è·å–ç‰ˆæœ¬
    function version() external pure returns (string memory) {
        return "1.0.0";
    }
}</code></pre>
                </div>
            </div>
            
            <h4>3.4.3 éƒ¨ç½²å’Œæµ‹è¯•è„šæœ¬</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">Hardhatéƒ¨ç½²å’Œæµ‹è¯•è„šæœ¬ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-javascript">// deploy/01_deploy_stablecoin.js
const { ethers, upgrades } = require("hardhat");

module.exports = async ({ getNamedAccounts, deployments }) => {
    const { deploy } = deployments;
    const { deployer } = await getNamedAccounts();
    
    // éƒ¨ç½²å®ç°åˆçº¦
    const EnterpriseStablecoin = await ethers.getContractFactory(
        "EnterpriseStablecoin"
    );
    
    const proxy = await upgrades.deployProxy(
        EnterpriseStablecoin,
        ["USD Stablecoin", "USDS", true], // å¯ç”¨KYC
        { 
            initializer: "initialize",
            kind: "uups" 
        }
    );
    
    await proxy.deployed();
    console.log("Proxy deployed to:", proxy.address);
    
    // è·å–å®ç°åœ°å€
    const implementationAddress = await upgrades.erc1967.getImplementationAddress(
        proxy.address
    );
    console.log("Implementation deployed to:", implementationAddress);
    
    // é…ç½®è§’è‰²
    const MINTER_ROLE = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes("MINTER_ROLE")
    );
    const KYC_ROLE = ethers.utils.keccak256(
        ethers.utils.toUtf8Bytes("KYC_ROLE")
    );
    
    // è®¾ç½®é“¸å¸è€…
    await proxy.grantRole(MINTER_ROLE, deployer);
    await proxy.setMinterAllowance(deployer, ethers.utils.parseUnits("1000000", 6));
    
    // ä¿å­˜éƒ¨ç½²ä¿¡æ¯
    deployments.save("EnterpriseStablecoin", {
        address: proxy.address,
        implementation: implementationAddress,
        abi: EnterpriseStablecoin.interface.format("json"),
    });
};

// test/EnterpriseStablecoin.test.js
const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");

describe("EnterpriseStablecoin", function () {
    let stablecoin;
    let owner, minter, user1, user2, blacklister;
    let MINTER_ROLE, BLACKLISTER_ROLE, KYC_ROLE;
    
    beforeEach(async function () {
        [owner, minter, user1, user2, blacklister] = await ethers.getSigners();
        
        const EnterpriseStablecoin = await ethers.getContractFactory(
            "EnterpriseStablecoin"
        );
        stablecoin = await upgrades.deployProxy(
            EnterpriseStablecoin,
            ["Test USD", "TUSD", true],
            { kind: "uups" }
        );
        
        // è·å–è§’è‰²å¸¸é‡
        MINTER_ROLE = await stablecoin.MINTER_ROLE();
        BLACKLISTER_ROLE = await stablecoin.BLACKLISTER_ROLE();
        KYC_ROLE = await stablecoin.KYC_ROLE();
        
        // é…ç½®è§’è‰²
        await stablecoin.grantRole(MINTER_ROLE, minter.address);
        await stablecoin.grantRole(BLACKLISTER_ROLE, blacklister.address);
        await stablecoin.grantRole(KYC_ROLE, owner.address);
    });
    
    describe("KYCåŠŸèƒ½", function () {
        it("æœªé€šè¿‡KYCä¸èƒ½æ¥æ”¶ä»£å¸", async function () {
            await stablecoin.setMinterAllowance(
                minter.address, 
                ethers.utils.parseUnits("1000", 6)
            );
            
            await expect(
                stablecoin.connect(minter).mint(
                    user1.address, 
                    ethers.utils.parseUnits("100", 6)
                )
            ).to.be.revertedWith("KYC not approved");
        });
        
        it("é€šè¿‡KYCåå¯ä»¥æ­£å¸¸äº¤æ˜“", async function () {
            // æ‰¹å‡†KYC
            await stablecoin.batchApproveKYC([user1.address, user2.address]);
            
            // è®¾ç½®é“¸å¸é¢åº¦
            await stablecoin.setMinterAllowance(
                minter.address, 
                ethers.utils.parseUnits("1000", 6)
            );
            
            // é“¸å¸
            await stablecoin.connect(minter).mint(
                user1.address, 
                ethers.utils.parseUnits("100", 6)
            );
            
            // è½¬è´¦
            await stablecoin.connect(user1).transfer(
                user2.address, 
                ethers.utils.parseUnits("50", 6)
            );
            
            expect(await stablecoin.balanceOf(user2.address))
                .to.equal(ethers.utils.parseUnits("50", 6));
        });
    });
    
    describe("å‡çº§åŠŸèƒ½", function () {
        it("å¯ä»¥å‡çº§åˆ°æ–°ç‰ˆæœ¬", async function () {
            const EnterpriseStablecoinV2 = await ethers.getContractFactory(
                "EnterpriseStablecoinV2"
            );
            
            const upgraded = await upgrades.upgradeProxy(
                stablecoin.address,
                EnterpriseStablecoinV2
            );
            
            expect(await upgraded.version()).to.equal("2.0.0");
        });
    });
});</code></pre>
                </div>
            </div>
            
            <h3>EIP-712ï¼šç»“æ„åŒ–æ•°æ®ç­¾åæ ‡å‡†</h3>
            <div class="info-box" style="background-color: #e0e7ff; border-left: 4px solid #6366f1;">
                <h4>ğŸ” EIP-712çš„é‡è¦æ€§</h4>
                <p><strong>EIP-712</strong>å®šä¹‰äº†ä»¥å¤ªåŠä¸­ç»“æ„åŒ–æ•°æ®çš„ç­¾åæ ‡å‡†ï¼Œæ˜¯å®ç°Permitç­‰é«˜çº§åŠŸèƒ½çš„åŸºç¡€ã€‚å®ƒè§£å†³äº†åŸå§‹ç­¾åæ–¹æ³•çš„å®‰å…¨é—®é¢˜ï¼Œè®©ç”¨æˆ·èƒ½å¤Ÿæ¸…æ¥šåœ°çœ‹åˆ°ä»–ä»¬ç­¾åçš„å†…å®¹ã€‚</p>
                
                <div style="margin: 1rem 0;">
                    <h5>æ ¸å¿ƒæ¦‚å¿µ</h5>
                    <ul>
                        <li><strong>ç±»å‹åŒ–æ•°æ®ï¼š</strong>å°†æ•°æ®ç»„ç»‡æˆç»“æ„åŒ–çš„ç±»å‹ï¼Œè€Œä¸æ˜¯ç®€å•çš„å­—èŠ‚ä¸²</li>
                        <li><strong>åŸŸåˆ†ç¦»ï¼š</strong>æ¯ä¸ªåº”ç”¨æœ‰è‡ªå·±çš„ç­¾ååŸŸï¼Œé˜²æ­¢è·¨åº”ç”¨é‡æ”¾æ”»å‡»</li>
                        <li><strong>äººç±»å¯è¯»ï¼š</strong>é’±åŒ…å¯ä»¥æ˜¾ç¤ºç»“æ„åŒ–çš„æ•°æ®ï¼Œç”¨æˆ·çŸ¥é“è‡ªå·±åœ¨ç­¾ä»€ä¹ˆ</li>
                        <li><strong>é“¾ä¸‹ç­¾åï¼š</strong>ç”¨æˆ·å¯ä»¥åœ¨ä¸å‘é€äº¤æ˜“çš„æƒ…å†µä¸‹æˆæƒæ“ä½œ</li>
                    </ul>
                </div>
                
                <div style="background-color: #c7d2fe; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <h5>ğŸ“‹ EIP-712æ•°æ®ç»“æ„</h5>
                    <pre style="background-color: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 4px; overflow-x: auto;">
{
    domain: {
        name: "MyStablecoin",
        version: "1",
        chainId: 1,
        verifyingContract: "0x..."
    },
    message: {
        owner: "0x...",
        spender: "0x...",
        value: 1000000,
        nonce: 0,
        deadline: 1234567890
    },
    primaryType: "Permit",
    types: {
        Permit: [
            {name: "owner", type: "address"},
            {name: "spender", type: "address"},
            {name: "value", type: "uint256"},
            {name: "nonce", type: "uint256"},
            {name: "deadline", type: "uint256"}
        ]
    }
}</pre>
                </div>
                
                <div style="margin: 1rem 0;">
                    <h5>åœ¨ç¨³å®šå¸ä¸­çš„åº”ç”¨</h5>
                    <ul>
                        <li><strong>Permitï¼ˆERC-2612ï¼‰ï¼š</strong>ç”¨æˆ·ç­¾åæˆæƒï¼Œæ— éœ€å…ˆå‘é€approveäº¤æ˜“</li>
                        <li><strong>å…ƒäº¤æ˜“ï¼š</strong>ç”¨æˆ·ç­¾åäº¤æ˜“æ„å›¾ï¼Œç¬¬ä¸‰æ–¹æ”¯ä»˜Gasè´¹</li>
                        <li><strong>æ‰¹é‡æ“ä½œï¼š</strong>ä¸€æ¬¡ç­¾åæˆæƒå¤šä¸ªæ“ä½œ</li>
                        <li><strong>æ²»ç†æŠ•ç¥¨ï¼š</strong>é“¾ä¸‹ç­¾åæŠ•ç¥¨ï¼Œé™ä½å‚ä¸æˆæœ¬</li>
                    </ul>
                </div>
                
                <div class="code-block">
                    <div class="code-header" onclick="toggleCode(this)">EIP-712ç­¾åå®ç°ç¤ºä¾‹ <span class="toggle-icon">â–¼</span></div>
                    <div class="code-content" style="display: none;">
                        <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract EIP712Example {
    bytes32 public constant DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
    );
    
    bytes32 public constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );
    
    bytes32 public immutable DOMAIN_SEPARATOR;
    
    constructor() {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes("MyStablecoin")),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );
    }
    
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, "Permit expired");
        
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                owner,
                spender,
                value,
                nonces[owner]++,
                deadline
            )
        );
        
        bytes32 hash = keccak256(
            abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash)
        );
        
        address signer = ecrecover(hash, v, r, s);
        require(signer == owner, "Invalid signature");
        
        _approve(owner, spender, value);
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="example-box">
                    <h5>ğŸ” å®é™…æ¡ˆä¾‹ï¼šUSDCçš„PermitåŠŸèƒ½</h5>
                    <p>USDC v2å¼•å…¥äº†EIP-2612 PermitåŠŸèƒ½ï¼Œå¸¦æ¥äº†æ˜¾è‘—çš„ç”¨æˆ·ä½“éªŒæ”¹å–„ï¼š</p>
                    <ul>
                        <li><strong>GasèŠ‚çœï¼š</strong>ç”¨æˆ·æ— éœ€å…ˆå‘é€approveäº¤æ˜“ï¼ŒèŠ‚çœçº¦50%çš„Gas</li>
                        <li><strong>åŸå­æ“ä½œï¼š</strong>æˆæƒå’Œä½¿ç”¨å¯ä»¥åœ¨åŒä¸€ç¬”äº¤æ˜“ä¸­å®Œæˆ</li>
                        <li><strong>æ›´å¥½çš„UXï¼š</strong>DeFiåè®®å¯ä»¥ä»£ç”¨æˆ·æ”¯ä»˜Gasï¼ˆå…ƒäº¤æ˜“ï¼‰</li>
                        <li><strong>å®‰å…¨æ€§ï¼š</strong>æ¯ä¸ªç­¾åéƒ½æœ‰deadlineï¼Œé˜²æ­¢è¿‡æœŸç­¾åè¢«åˆ©ç”¨</li>
                    </ul>
                    <p>æˆªè‡³2024å¹´ï¼Œè¶…è¿‡80%çš„ä¸»æµç¨³å®šå¸éƒ½å·²æ”¯æŒPermitåŠŸèƒ½ã€‚</p>
                </div>
                
                <div class="warning-box">
                    <strong>âš ï¸ EIP-712å®‰å…¨æ³¨æ„äº‹é¡¹</strong>
                    <ul>
                        <li><strong>ç­¾åé‡æ”¾ï¼š</strong>å¿…é¡»åŒ…å«chainIdé˜²æ­¢è·¨é“¾é‡æ”¾</li>
                        <li><strong>Phishingæ”»å‡»ï¼š</strong>æ¶æ„ç½‘ç«™å¯èƒ½è¯±å¯¼ç”¨æˆ·ç­¾å</li>
                        <li><strong>å‰ç«¯å®‰å…¨ï¼š</strong>ç¡®ä¿æ­£ç¡®æ˜¾ç¤ºç­¾åå†…å®¹ç»™ç”¨æˆ·</li>
                        <li><strong>Nonceç®¡ç†ï¼š</strong>é˜²æ­¢ç­¾åè¢«é‡å¤ä½¿ç”¨</li>
                    </ul>
                </div>
            </div>

            <h3>ç»ƒä¹ é¢˜</h3>
            
            <div class="exercise">
                <h4>ç»ƒä¹  3.1ï¼šERC-20æ‰©å±•å®ç°</h4>
                <p>å®ç°ä¸€ä¸ªæ”¯æŒä»¥ä¸‹åŠŸèƒ½çš„ERC-20æ‰©å±•ï¼š</p>
                <ul>
                    <li>æ‰¹é‡è½¬è´¦åŠŸèƒ½ï¼ˆå•ç¬”äº¤æ˜“ä¸­å‘å¤šä¸ªåœ°å€è½¬è´¦ï¼‰</li>
                    <li>è½¬è´¦å¤‡æ³¨åŠŸèƒ½ï¼ˆåœ¨é“¾ä¸Šè®°å½•è½¬è´¦å¤‡æ³¨ä¿¡æ¯ï¼‰</li>
                    <li>å®šæ—¶é”å®šåŠŸèƒ½ï¼ˆä»£å¸åœ¨æŒ‡å®šæ—¶é—´åæ‰èƒ½è½¬ç§»ï¼‰</li>
                </ul>
                <p>è¦æ±‚ï¼šGasä¼˜åŒ–ï¼Œæ”¯æŒç´§æ€¥æš‚åœã€‚</p>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer3_1')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
                <div class="answer-content" id="answer3_1" style="display: none;">
                    <pre><code class="language-solidity">contract ExtendedERC20 is ERC20, Pausable, Ownable {
    // è½¬è´¦å¤‡æ³¨
    mapping(bytes32 => string) public transferNotes;
    
    // æ—¶é—´é”
    struct TimeLock {
        uint256 amount;
        uint256 releaseTime;
    }
    mapping(address => TimeLock[]) public timeLocks;
    
    // äº‹ä»¶
    event TransferWithNote(address indexed from, address indexed to, uint256 value, string note);
    event TokensLocked(address indexed account, uint256 amount, uint256 releaseTime);
    event TokensUnlocked(address indexed account, uint256 amount);
    
    // æ‰¹é‡è½¬è´¦
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused returns (bool) {
        require(recipients.length == amounts.length, "Length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount;
        for (uint256 i = 0; i < amounts.length; ) {
            totalAmount += amounts[i];
            unchecked { ++i; }
        }
        
        require(balanceOf(msg.sender) >= totalAmount, "Insufficient balance");
        
        for (uint256 i = 0; i < recipients.length; ) {
            _transfer(msg.sender, recipients[i], amounts[i]);
            unchecked { ++i; }
        }
        
        return true;
    }
    
    // å¸¦å¤‡æ³¨çš„è½¬è´¦
    function transferWithNote(
        address to,
        uint256 amount,
        string calldata note
    ) external whenNotPaused returns (bool) {
        _transfer(msg.sender, to, amount);
        
        bytes32 txHash = keccak256(
            abi.encodePacked(msg.sender, to, amount, block.timestamp)
        );
        transferNotes[txHash] = note;
        
        emit TransferWithNote(msg.sender, to, amount, note);
        return true;
    }
    
    // é”å®šä»£å¸
    function lockTokens(uint256 amount, uint256 lockDuration) external {
        require(amount > 0, "Amount must be positive");
        require(lockDuration > 0, "Duration must be positive");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        _transfer(msg.sender, address(this), amount);
        
        timeLocks[msg.sender].push(TimeLock({
            amount: amount,
            releaseTime: block.timestamp + lockDuration
        }));
        
        emit TokensLocked(msg.sender, amount, block.timestamp + lockDuration);
    }
    
    // è§£é”ä»£å¸
    function unlockTokens() external {
        TimeLock[] storage locks = timeLocks[msg.sender];
        uint256 totalUnlocked;
        
        for (uint256 i = 0; i < locks.length; ) {
            if (locks[i].releaseTime <= block.timestamp && locks[i].amount > 0) {
                totalUnlocked += locks[i].amount;
                locks[i].amount = 0;
            }
            unchecked { ++i; }
        }
        
        require(totalUnlocked > 0, "No tokens to unlock");
        _transfer(address(this), msg.sender, totalUnlocked);
        
        emit TokensUnlocked(msg.sender, totalUnlocked);
    }
    
    // æŸ¥è¯¢é”å®šçš„ä»£å¸
    function getLockedBalance(address account) external view returns (uint256) {
        TimeLock[] memory locks = timeLocks[account];
        uint256 locked;
        
        for (uint256 i = 0; i < locks.length; i++) {
            if (locks[i].releaseTime > block.timestamp) {
                locked += locks[i].amount;
            }
        }
        
        return locked;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>ç»ƒä¹  3.2ï¼šè·¨é“¾æ¡¥å®ç°</h4>
                <p>è®¾è®¡å¹¶å®ç°ä¸€ä¸ªç®€åŒ–çš„è·¨é“¾æ¡¥ï¼Œæ”¯æŒï¼š</p>
                <ul>
                    <li>åœ¨æºé“¾é”å®šä»£å¸</li>
                    <li>åœ¨ç›®æ ‡é“¾é“¸é€ åŒ…è£…ä»£å¸</li>
                    <li>å®ç°ç®€å•çš„éªŒè¯æœºåˆ¶</li>
                    <li>å¤„ç†è·¨é“¾å¤±è´¥çš„æƒ…å†µ</li>
                </ul>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer3_2')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
                <div class="answer-content" id="answer3_2" style="display: none;">
                    <pre><code class="language-solidity">// æºé“¾åˆçº¦
contract SourceBridge is Ownable, Pausable {
    IERC20 public token;
    mapping(bytes32 => bool) public processedTransfers;
    uint256 public nonce;
    
    event TokensLocked(
        address indexed from,
        address indexed to,
        uint256 amount,
        uint256 targetChain,
        uint256 nonce
    );
    
    constructor(address _token) {
        token = IERC20(_token);
    }
    
    function lockTokens(
        address targetAddress,
        uint256 amount,
        uint256 targetChain
    ) external whenNotPaused {
        require(amount > 0, "Amount must be positive");
        require(token.transferFrom(msg.sender, address(this), amount), "Transfer failed");
        
        emit TokensLocked(msg.sender, targetAddress, amount, targetChain, ++nonce);
    }
    
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), "Withdraw failed");
    }
}

// ç›®æ ‡é“¾åˆçº¦
contract TargetBridge is Ownable, Pausable {
    mapping(address => bool) public validators;
    mapping(bytes32 => uint256) public confirmations;
    mapping(bytes32 => bool) public processedTransfers;
    
    uint256 public requiredConfirmations = 3;
    WrappedToken public wrappedToken;
    
    event TokensMinted(address indexed to, uint256 amount, bytes32 transferId);
    event TransferConfirmed(bytes32 transferId, address validator);
    
    constructor(string memory name, string memory symbol) {
        wrappedToken = new WrappedToken(name, symbol);
    }
    
    function addValidator(address validator) external onlyOwner {
        validators[validator] = true;
    }
    
    function confirmTransfer(
        address to,
        uint256 amount,
        uint256 sourceChain,
        uint256 nonce
    ) external {
        require(validators[msg.sender], "Not a validator");
        
        bytes32 transferId = keccak256(
            abi.encodePacked(to, amount, sourceChain, nonce)
        );
        
        require(!processedTransfers[transferId], "Already processed");
        
        confirmations[transferId]++;
        emit TransferConfirmed(transferId, msg.sender);
        
        if (confirmations[transferId] >= requiredConfirmations) {
            processedTransfers[transferId] = true;
            wrappedToken.mint(to, amount);
            emit TokensMinted(to, amount, transferId);
        }
    }
}

// åŒ…è£…ä»£å¸åˆçº¦
contract WrappedToken is ERC20, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
    
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
}</code></pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>ç»ƒä¹  3.3ï¼šGasä¼˜åŒ–æŒ‘æˆ˜</h4>
                <p>ç»™å®šä¸€ä¸ªä½æ•ˆçš„ERC-20å®ç°ï¼Œå°†å…¶Gasæ¶ˆè€—ä¼˜åŒ–è‡³å°‘30%ï¼š</p>
                <pre><code class="language-solidity">// ä½æ•ˆå®ç°
contract InefficientToken is ERC20 {
    mapping(address => bool) public whitelist;
    uint256[] public transferHistory;
    mapping(address => uint256[]) public userTransfers;
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        require(whitelist[msg.sender] || whitelist[to], "Not whitelisted");
        
        transferHistory.push(block.timestamp);
        userTransfers[msg.sender].push(amount);
        userTransfers[to].push(amount);
        
        return super.transfer(to, amount);
    }
}</code></pre>
                
                <button class="answer-toggle" onclick="toggleAnswer('answer3_3')">æŸ¥çœ‹å‚è€ƒç­”æ¡ˆ</button>
                <div class="answer-content" id="answer3_3" style="display: none;">
                    <pre><code class="language-solidity">contract OptimizedToken is ERC20 {
    // ä½¿ç”¨bitmapæ›¿ä»£mappingèŠ‚çœå­˜å‚¨
    mapping(uint256 =&gt; uint256) private whitelistBitmap;
    
    // äº‹ä»¶æ›¿ä»£å­˜å‚¨å†å²è®°å½•
    event TransferRecorded(address indexed from, address indexed to, uint256 amount, uint256 timestamp);
    
    // åªå­˜å‚¨å¿…è¦çš„ç»Ÿè®¡ä¿¡æ¯
    mapping(address =&gt; uint256) public transferCount;
    
    function setWhitelist(address account, bool status) external onlyOwner {
        uint256 index = uint256(uint160(account));
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        
        if (status) {
            whitelistBitmap[wordIndex] |= (1 &lt;&lt; bitIndex);
        } else {
            whitelistBitmap[wordIndex] &= ~(1 &lt;&lt; bitIndex);
        }
    }
    
    function isWhitelisted(address account) public view returns (bool) {
        uint256 index = uint256(uint160(account));
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        uint256 word = whitelistBitmap[wordIndex];
        return (word & (1 &lt;&lt; bitIndex)) != 0;
    }
    
    function transfer(address to, uint256 amount) public override returns (bool) {
        // ä½¿ç”¨å±€éƒ¨å˜é‡ç¼“å­˜çŠ¶æ€
        bool senderWhitelisted = isWhitelisted(msg.sender);
        bool recipientWhitelisted = isWhitelisted(to);
        
        require(senderWhitelisted || recipientWhitelisted, "Not whitelisted");
        
        // ä½¿ç”¨äº‹ä»¶è®°å½•å†å²ï¼Œè€Œä¸æ˜¯å­˜å‚¨
        emit TransferRecorded(msg.sender, to, amount, block.timestamp);
        
        // ä½¿ç”¨uncheckedèŠ‚çœGas
        unchecked {
            transferCount[msg.sender]++;
            transferCount[to]++;
        }
        
        return super.transfer(to, amount);
    }
    
    // æ‰¹é‡æ£€æŸ¥ç™½åå•çŠ¶æ€
    function batchCheckWhitelist(address[] calldata accounts) 
        external 
        view 
        returns (bool[] memory) 
    {
        bool[] memory results = new bool[](accounts.length);
        for (uint256 i = 0; i &lt; accounts.length; ) {
            results[i] = isWhitelisted(accounts[i]);
            unchecked { ++i; }
        }
        return results;
    }
}</code></pre>
                    <p><strong>ä¼˜åŒ–è¯´æ˜ï¼š</strong></p>
                    <ul>
                        <li>ä½¿ç”¨bitmapå­˜å‚¨ç™½åå•ï¼Œæ¯ä¸ªåœ°å€åªéœ€1bitè€Œä¸æ˜¯256bit</li>
                        <li>ç”¨äº‹ä»¶æ›¿ä»£æ•°ç»„å­˜å‚¨ï¼ŒèŠ‚çœå¤§é‡å­˜å‚¨Gas</li>
                        <li>ä½¿ç”¨uncheckedå—é¿å…ä¸å¿…è¦çš„æº¢å‡ºæ£€æŸ¥</li>
                        <li>ç¼“å­˜å­˜å‚¨è¯»å–ç»“æœï¼Œé¿å…é‡å¤SLOAD</li>
                        <li>ç§»é™¤ä¸å¿…è¦çš„åŠ¨æ€æ•°ç»„æ“ä½œ</li>
                    </ul>
                </div>
            </div>
            
            <h3>3.5 Gasä¼˜åŒ–é«˜çº§æŠ€æœ¯</h3>
            
            <h4>3.5.1 EIP-1153 ç¬æ—¶å­˜å‚¨</h4>
            
            <div class="tip-box">
                <strong>âš¡ EIP-1153 æ ¸å¿ƒæ¦‚å¿µï¼š</strong>
                <ul>
                    <li><strong>TSTORE/TLOADï¼š</strong>åœ¨åŒä¸€ç¬”äº¤æ˜“å†…ä¿å­˜ä¸´æ—¶æ•°æ®ï¼Œäº¤æ˜“ç»“æŸåè‡ªåŠ¨æ¸…é™¤</li>
                    <li><strong>Gasæˆæœ¬ï¼š</strong>TSTORE 100 gasï¼ŒTLOAD 100 gasï¼ˆvs SSTORE 20,000 gasï¼‰</li>
                    <li><strong>åº”ç”¨åœºæ™¯ï¼š</strong>é‡å…¥é”ã€ä¸´æ—¶æ ‡è®°ã€è·¨å‡½æ•°æ•°æ®ä¼ é€’</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">ä½¿ç”¨EIP-1153ä¼˜åŒ–çš„ç¨³å®šå¸ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract GasOptimizedStablecoin {
    // ä¼ ç»Ÿå­˜å‚¨å˜é‡
    mapping(address => uint256) public balances;
    
    // ç¬æ—¶å­˜å‚¨é”®
    uint256 constant REENTRANCY_GUARD_SLOT = uint256(keccak256("reentrancy.guard"));
    uint256 constant TEMP_ALLOWANCE_SLOT = uint256(keccak256("temp.allowance"));
    
    // ä½¿ç”¨ç¬æ—¶å­˜å‚¨çš„é‡å…¥é”
    modifier nonReentrant() {
        assembly {
            if tload(REENTRANCY_GUARD_SLOT) {
                revert(0, 0)
            }
            tstore(REENTRANCY_GUARD_SLOT, 1)
        }
        _;
        assembly {
            tstore(REENTRANCY_GUARD_SLOT, 0)
        }
    }
    
    // å¤æ‚çš„æ‰¹é‡è½¬è´¦æ“ä½œ
    function batchTransferWithKYC(
        address[] calldata recipients,
        uint256[] calldata amounts,
        bytes[] calldata kycProofs
    ) external nonReentrant {
        require(recipients.length == amounts.length, "Length mismatch");
        
        uint256 totalAmount;
        
        // ç¬¬ä¸€æ¬¡éå†ï¼šéªŒè¯KYCå¹¶è®¡ç®—æ€»é¢
        for (uint256 i = 0; i < recipients.length; i++) {
            // ä½¿ç”¨ç¬æ—¶å­˜å‚¨ç¼“å­˜KYCéªŒè¯ç»“æœ
            bytes32 kycKey = keccak256(abi.encode(recipients[i], "kyc"));
            
            assembly {
                // æ£€æŸ¥æ˜¯å¦å·²éªŒè¯
                if iszero(tload(kycKey)) {
                    // éªŒè¯KYCï¼ˆç®€åŒ–ç‰ˆï¼‰
                    let kycValid := 1 // å‡è®¾éªŒè¯é€šè¿‡
                    tstore(kycKey, kycValid)
                }
            }
            
            totalAmount += amounts[i];
        }
        
        // æ£€æŸ¥æ€»ä½™é¢
        require(balances[msg.sender] >= totalAmount, "Insufficient balance");
        
        // ç¬¬äºŒæ¬¡éå†ï¼šæ‰§è¡Œè½¬è´¦
        for (uint256 i = 0; i < recipients.length; i++) {
            _transferOptimized(msg.sender, recipients[i], amounts[i]);
        }
    }
    
    // ä¼˜åŒ–çš„è½¬è´¦å‡½æ•°
    function _transferOptimized(
        address from,
        address to,
        uint256 amount
    ) internal {
        assembly {
            // åŠ è½½ä½™é¢
            let fromBalance := sload(add(balances.slot, from))
            let toBalance := sload(add(balances.slot, to))
            
            // æ£€æŸ¥ä½™é¢
            if lt(fromBalance, amount) {
                revert(0, 0)
            }
            
            // ä½¿ç”¨uncheckedæ•°å­¦
            let newFromBalance := sub(fromBalance, amount)
            let newToBalance := add(toBalance, amount)
            
            // å­˜å‚¨æ–°ä½™é¢
            sstore(add(balances.slot, from), newFromBalance)
            sstore(add(balances.slot, to), newToBalance)
        }
    }
    
    // ä½¿ç”¨ç¬æ—¶å­˜å‚¨çš„é—ªç”µè´·
    function flashLoan(
        address receiver,
        uint256 amount,
        bytes calldata data
    ) external nonReentrant {
        uint256 balanceBefore = balances[address(this)];
        
        // ä½¿ç”¨ç¬æ—¶å­˜å‚¨è®°å½•è´·æ¬¾ä¿¡æ¯
        assembly {
            tstore(TEMP_ALLOWANCE_SLOT, amount)
        }
        
        // å‘é€ä»£å¸
        balances[address(this)] -= amount;
        balances[receiver] += amount;
        
        // è°ƒç”¨æ¥æ”¶è€…
        IFlashLoanReceiver(receiver).onFlashLoan(amount, data);
        
        // æ£€æŸ¥è¿˜æ¬¾
        uint256 fee = amount * 3 / 1000; // 0.3% è´¹ç”¨
        require(
            balances[address(this)] >= balanceBefore + fee,
            "Flash loan not repaid"
        );
        
        // æ¸…é™¤ç¬æ—¶å­˜å‚¨
        assembly {
            tstore(TEMP_ALLOWANCE_SLOT, 0)
        }
    }
}

// å­˜å‚¨æ§½æ‰“åŒ…ä¼˜åŒ–ç¤ºä¾‹
contract StoragePackingExample {
    // æœªä¼˜åŒ–ï¼š3ä¸ªå­˜å‚¨æ§½
    struct BadPacking {
        uint256 amount;     // æ§½0
        bool active;        // æ§½1
        uint128 limit;      // æ§½2
    }
    
    // ä¼˜åŒ–åï¼š2ä¸ªå­˜å‚¨æ§½
    struct GoodPacking {
        uint256 amount;     // æ§½0
        uint128 limit;      // æ§½1çš„å‰128ä½
        bool active;        // æ§½1çš„ç¬¬129ä½
        uint120 reserved;   // æ§½1çš„å‰©ä½™ä½
    }
    
    // æœ€ä¼˜åŒ–ï¼šä¸€ä¸ªæ§½å­˜å‚¨å¤šä¸ªå°æ•°æ®
    struct UltraPacking {
        uint128 balance;
        uint64 lastUpdate;
        uint32 nonce;
        uint16 flags;
        uint8 decimals;
        uint8 version;
    } // æ­£å¥½256ä½ï¼Œä¸€ä¸ªæ§½
}</code></pre>
                </div>
            </div>
            
            <h4>3.5.2 æ±‡ç¼–ä¼˜åŒ–æŠ€å·§</h4>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">æ±‡ç¼–çº§åˆ«çš„Gasä¼˜åŒ– <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract AssemblyOptimized {
    // ä¼˜åŒ–çš„æ‰¹é‡ä½™é¢æŸ¥è¯¢
    function balanceOfBatch(
        address[] calldata accounts
    ) external view returns (uint256[] memory balances_) {
        assembly {
            let length := calldataload(add(accounts.offset, sub(0x20, 0x04)))
            
            // åˆ†é…å†…å­˜
            balances_ := mload(0x40)
            let dataPtr := add(balances_, 0x20)
            mstore(0x40, add(dataPtr, mul(length, 0x20)))
            mstore(balances_, length)
            
            // éå†è´¦æˆ·
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                let account := calldataload(add(accounts.offset, mul(i, 0x20)))
                
                // è®¡ç®—å­˜å‚¨ä½ç½®
                mstore(0x00, account)
                mstore(0x20, balances.slot)
                let slot := keccak256(0x00, 0x40)
                
                // è¯»å–å¹¶å­˜å‚¨ä½™é¢
                mstore(add(dataPtr, mul(i, 0x20)), sload(slot))
            }
        }
    }
    
    // ä¼˜åŒ–çš„ä½™é¢æ›´æ–°ï¼ˆé¿å…é›¶åˆ°éé›¶çš„SSTOREï¼‰
    function updateBalance(
        address account,
        uint256 newBalance
    ) external {
        assembly {
            // è®¡ç®—å­˜å‚¨ä½ç½®
            mstore(0x00, account)
            mstore(0x20, balances.slot)
            let slot := keccak256(0x00, 0x40)
            
            let oldBalance := sload(slot)
            
            // å¦‚æœä»é›¶åˆ°éé›¶ï¼Œä½¿ç”¨æ›´è´µçš„æ“ä½œç 
            // å¦‚æœä»éé›¶åˆ°é›¶ï¼Œå¯ä»¥è·å¾—gasé€€æ¬¾
            switch newBalance
            case 0 {
                // æ¸…é›¶æ“ä½œ
                if oldBalance {
                    sstore(slot, 0)
                    // è·å¾—é€€æ¬¾
                }
            }
            default {
                // æ›´æ–°æ“ä½œ
                if iszero(eq(oldBalance, newBalance)) {
                    sstore(slot, newBalance)
                }
            }
        }
    }
}

// EVMæ“ä½œç æˆæœ¬å¯¹æ¯”
contract OpcodesCost {
    // å­˜å‚¨æ“ä½œæˆæœ¬
    // SLOAD: 2100 gas (æ¸©è¯»å–) / 2600 gas (å†·è¯»å–)
    // SSTORE: 2900 gas (æ¸©å†™å…¥) / 22100 gas (å†·å†™å…¥ä»é›¶åˆ°éé›¶)
    // TLOAD: 100 gas
    // TSTORE: 100 gas
    
    // å†…å­˜æ“ä½œæˆæœ¬
    // MLOAD: 3 gas
    // MSTORE: 3 gas
    // MSTORE8: 3 gas
    
    // è®¡ç®—æ“ä½œæˆæœ¬
    // ADD/SUB: 3 gas
    // MUL: 5 gas
    // DIV: 5 gas
    // EXP: 10 gas + 50 gas per byte
}</code></pre>
                </div>
            </div>
            
            <h3>3.6 å®‰å…¨æœ€ä½³å®è·µ</h3>
            
            <div class="tip-box">
                <strong>ğŸ”’ å®¡è®¡ä¸­å¸¸è§çš„å®‰å…¨é—®é¢˜ï¼š</strong>
                <ul>
                    <li><strong>ä¸­å¿ƒåŒ–é£é™©ï¼š</strong>å•ä¸€EOAæ§åˆ¶å…³é”®æƒé™ â†’ ä½¿ç”¨å¤šç­¾+æ—¶é—´é”</li>
                    <li><strong>æƒé™è¿‡å¤§ï¼š</strong>onlyOwneræ»¥ç”¨ â†’ ä½¿ç”¨ç»†ç²’åº¦AccessControl</li>
                    <li><strong>ä¸‰æ˜æ²»æ”»å‡»ï¼š</strong>DEXäº¤äº’æ— æ»‘ç‚¹ä¿æŠ¤ â†’ æ·»åŠ minAmountOutå‚æ•°</li>
                    <li><strong>ç²¾åº¦æŸå¤±ï¼š</strong>å¤æ‚è®¡ç®—å››èˆäº”å…¥ â†’ ä½¿ç”¨å®‰å…¨æ•°å­¦åº“</li>
                    <li><strong>é‡å…¥æ”»å‡»ï¼š</strong>çŠ¶æ€æ›´æ–°é¡ºåºé”™è¯¯ â†’ CEIæ¨¡å¼+é‡å…¥é”</li>
                </ul>
            </div>
            
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">å®‰å…¨æ¨¡å¼å®ä¾‹ <span class="toggle-icon">â–¼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">contract SecureStablecoin {
    using SafeMath for uint256;
    
    // æ»‘ç‚¹ä¿æŠ¤
    function swapToUSDC(
        uint256 amount,
        uint256 minAmountOut,
        uint256 deadline
    ) external returns (uint256 amountOut) {
        require(block.timestamp <= deadline, "Expired");
        
        // æ‰§è¡Œäº¤æ¢
        amountOut = IUniswapV2Router(router).swapExactTokensForTokens(
            amount,
            minAmountOut,  // æ»‘ç‚¹ä¿æŠ¤
            path,
            msg.sender,
            deadline
        )[1];
        
        require(amountOut >= minAmountOut, "Slippage too high");
    }
    
    // CEIæ¨¡å¼ (Checks-Effects-Interactions)
    function withdraw(uint256 amount) external nonReentrant {
        // Checks
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(amount > 0, "Zero amount");
        
        // Effects
        balances[msg.sender] = balances[msg.sender].sub(amount);
        totalSupply = totalSupply.sub(amount);
        
        // Interactions
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        emit Withdrawal(msg.sender, amount);
    }
    
    // é˜²æ­¢å‰ç«¯è·‘è·‘
    mapping(address => uint256) private lastActionBlock;
    
    modifier antiMEV() {
        require(
            lastActionBlock[msg.sender] < block.number,
            "Same block action"
        );
        lastActionBlock[msg.sender] = block.number;
        _;
    }
    
    // ä¸¥æ ¼çš„è®¿é—®æ§åˆ¶
    mapping(address => mapping(bytes4 => bool)) private permissions;
    
    modifier onlyPermitted(bytes4 selector) {
        require(
            permissions[msg.sender][selector],
            "No permission"
        );
        _;
    }
    
    // å‚æ•°éªŒè¯
    modifier validAddress(address addr) {
        require(addr != address(0), "Zero address");
        require(addr != address(this), "Invalid target");
        _;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="practice-section">
                <h3>ğŸ“ ç¬¬ä¸‰ç« ç»ƒä¹ é¢˜</h3>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  3.1ï¼šå®ç°å®Œæ•´çš„ERC-2612 PermitåŠŸèƒ½</h4>
                    <p>ä¸ºä½ çš„ç¨³å®šå¸æ·»åŠ ERC-2612 Permitæ”¯æŒï¼Œå®ç°é“¾ä¸‹ç­¾åæˆæƒã€‚</p>
                    <p>è¦æ±‚ï¼š</p>
                    <ul>
                        <li>å®ç°permitå‡½æ•°å’Œnoncesç®¡ç†</li>
                        <li>æ”¯æŒEIP-712ç»“æ„åŒ–ç­¾å</li>
                        <li>å®ç°deadlineæ£€æŸ¥</li>
                        <li>ç¼–å†™å‰ç«¯ç­¾åä»£ç </li>
                    </ul>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <pre><code class="language-solidity">// åˆçº¦å®ç°
abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
    mapping(address => uint256) private _nonces;
    
    bytes32 private constant _PERMIT_TYPEHASH =
        keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    
    constructor(string memory name) EIP712(name, "1") {}
    
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
        
        bytes32 structHash = keccak256(abi.encode(
            _PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            _useNonce(owner),
            deadline
        ));
        
        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = ECDSA.recover(hash, v, r, s);
        require(signer == owner, "ERC20Permit: invalid signature");
        
        _approve(owner, spender, value);
    }
    
    function nonces(address owner) public view override returns (uint256) {
        return _nonces[owner];
    }
    
    function DOMAIN_SEPARATOR() external view override returns (bytes32) {
        return _domainSeparatorV4();
    }
    
    function _useNonce(address owner) internal returns (uint256 current) {
        current = _nonces[owner];
        _nonces[owner]++;
    }
}

// å‰ç«¯ç­¾åä»£ç 
const domain = {
    name: 'USD Stablecoin',
    version: '1',
    chainId: 1,
    verifyingContract: stablecoinAddress
};

const types = {
    Permit: [
        { name: 'owner', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' }
    ]
};

const value = {
    owner: ownerAddress,
    spender: spenderAddress,
    value: amount,
    nonce: await stablecoin.nonces(ownerAddress),
    deadline: Math.floor(Date.now() / 1000) + 3600 // 1å°æ—¶åè¿‡æœŸ
};

const signature = await signer._signTypedData(domain, types, value);
const { v, r, s } = ethers.utils.splitSignature(signature);

await stablecoin.permit(
    ownerAddress,
    spenderAddress,
    amount,
    value.deadline,
    v, r, s
);</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  3.2ï¼šè®¾è®¡å¹¶å®ç°ç´§æ€¥æ–­è·¯å™¨</h4>
                    <p>å®ç°ä¸€ä¸ªç¬¦åˆEIP-7265æ ‡å‡†çš„ç´§æ€¥æ–­è·¯å™¨æœºåˆ¶ã€‚</p>
                    <p>è¦æ±‚ï¼š</p>
                    <ul>
                        <li>æ£€æµ‹å¼‚å¸¸å¤§é¢è½¬è´¦</li>
                        <li>çŸ­æ—¶é—´å†…é¢‘ç¹é“¸å¸è‡ªåŠ¨è§¦å‘</li>
                        <li>ä»£å¸ä»·æ ¼è„±é”šè¶…è¿‡5%æ—¶æ¿€æ´»</li>
                        <li>æ”¯æŒå¤šçº§å“åº”æœºåˆ¶</li>
                    </ul>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <pre><code class="language-solidity">contract CircuitBreaker {
    enum AlertLevel { NORMAL, WARNING, CRITICAL, EMERGENCY }
    
    AlertLevel public currentLevel = AlertLevel.NORMAL;
    
    // é˜ˆå€¼é…ç½®
    uint256 public largeTransferThreshold = 1000000 * 10**6; // 100ä¸‡
    uint256 public mintRateThreshold = 10000000 * 10**6 / 1 hours; // æ¯å°æ—¶10M
    uint256 public priceDeviationThreshold = 500; // 5%
    
    // ç›‘æ§æ•°æ®
    uint256 public recentMintAmount;
    uint256 public recentMintTimestamp;
    uint256 public lastPriceCheckTimestamp;
    
    // æ£€æµ‹å¤§é¢è½¬è´¦
    function checkLargeTransfer(uint256 amount) internal {
        if (amount > largeTransferThreshold) {
            if (currentLevel == AlertLevel.NORMAL) {
                currentLevel = AlertLevel.WARNING;
                emit AlertLevelChanged(AlertLevel.WARNING, "Large transfer detected");
            }
        }
    }
    
    // æ£€æµ‹é“¸å¸é€Ÿç‡
    function checkMintRate(uint256 amount) internal {
        if (block.timestamp > recentMintTimestamp + 1 hours) {
            recentMintAmount = 0;
            recentMintTimestamp = block.timestamp;
        }
        
        recentMintAmount += amount;
        
        if (recentMintAmount > mintRateThreshold) {
            if (currentLevel < AlertLevel.CRITICAL) {
                currentLevel = AlertLevel.CRITICAL;
                emit AlertLevelChanged(AlertLevel.CRITICAL, "High mint rate");
            }
        }
    }
    
    // æ£€æµ‹ä»·æ ¼è„±é”š
    function checkPriceDeviation() internal {
        if (block.timestamp < lastPriceCheckTimestamp + 5 minutes) {
            return;
        }
        
        uint256 price = getOraclePrice();
        uint256 targetPrice = 1e18; // $1
        
        uint256 deviation = price > targetPrice ? 
            ((price - targetPrice) * 10000) / targetPrice :
            ((targetPrice - price) * 10000) / targetPrice;
        
        if (deviation > priceDeviationThreshold) {
            currentLevel = AlertLevel.EMERGENCY;
            _pause(); // è‡ªåŠ¨æš‚åœ
            emit AlertLevelChanged(AlertLevel.EMERGENCY, "Price deviation");
        }
        
        lastPriceCheckTimestamp = block.timestamp;
    }
    
    // å“åº”æœºåˆ¶
    modifier circuitBreakerCheck(uint256 amount) {
        checkLargeTransfer(amount);
        checkPriceDeviation();
        
        if (currentLevel == AlertLevel.WARNING) {
            require(amount < largeTransferThreshold / 2, "Reduced limits");
        } else if (currentLevel == AlertLevel.CRITICAL) {
            require(hasRole(OPERATOR_ROLE, msg.sender), "Only operators");
        } else if (currentLevel == AlertLevel.EMERGENCY) {
            revert("System paused");
        }
        
        _;
    }
    
    // æ¢å¤æœºåˆ¶
    function recover() external onlyRole(EMERGENCY_ROLE) {
        require(currentLevel != AlertLevel.NORMAL, "Already normal");
        
        // æ£€æŸ¥æ¢å¤æ¡ä»¶
        uint256 price = getOraclePrice();
        uint256 deviation = calculateDeviation(price);
        require(deviation < 200, "Price still unstable"); // 2%ä»¥å†…
        
        currentLevel = AlertLevel.NORMAL;
        _unpause();
        emit SystemRecovered(block.timestamp);
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  3.3ï¼šä¼˜åŒ–Gasæ¶ˆè€—</h4>
                    <p>ä½¿ç”¨å„ç§æŠ€æœ¯ä¼˜åŒ–ä»¥ä¸‹åˆçº¦çš„Gasæ¶ˆè€—ï¼Œä½¿å…¶æ¯”åŸç‰ˆèŠ‚çœè‡³å°‘50%ã€‚</p>
                    <pre><code class="language-solidity">// åŸå§‹ç‰ˆæœ¬
contract ExpensiveToken {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    mapping(address => bool) public isWhitelisted;
    mapping(address => uint256) public lastTransferTime;
    
    uint256 public totalSupply;
    address public owner;
    bool public paused;
    
    function transfer(address to, uint256 amount) public {
        require(!paused, "Paused");
        require(isWhitelisted[msg.sender], "Not whitelisted");
        require(isWhitelisted[to], "Recipient not whitelisted");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] = balances[msg.sender] - amount;
        balances[to] = balances[to] + amount;
        lastTransferTime[msg.sender] = block.timestamp;
        lastTransferTime[to] = block.timestamp;
    }
}</code></pre>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <pre><code class="language-solidity">// ä¼˜åŒ–ç‰ˆæœ¬
contract OptimizedToken {
    // å­˜å‚¨æ§½æ‰“åŒ…
    struct AccountData {
        uint128 balance;
        uint64 lastTransferTime;
        bool isWhitelisted;
        // 63 bits å‰©ä½™
    }
    
    mapping(address => AccountData) public accounts;
    mapping(address => mapping(address => uint256)) public allowances;
    
    // æ‰“åŒ…çŠ¶æ€å˜é‡
    uint128 public totalSupply;
    address public owner;
    bool public paused;
    // 7 bits å‰©ä½™
    
    // ä½¿ç”¨modifierå‡å°‘é‡å¤ä»£ç 
    modifier whenNotPaused() {
        assembly {
            // ç›´æ¥è¯»å–packed slot
            let slot := sload(owner.slot)
            let isPaused := and(shr(160, slot), 1)
            if isPaused { revert(0, 0) }
        }
        _;
    }
    
    function transfer(address to, uint256 amount) external whenNotPaused {
        // ä½¿ç”¨assemblyä¼˜åŒ–
        assembly {
            // è®¡ç®—senderçš„å­˜å‚¨ä½ç½®
            mstore(0x00, caller())
            mstore(0x20, accounts.slot)
            let senderSlot := keccak256(0x00, 0x40)
            
            // è®¡ç®—receiverçš„å­˜å‚¨ä½ç½®
            mstore(0x00, to)
            let receiverSlot := keccak256(0x00, 0x40)
            
            // è¯»å–æ•°æ®
            let senderData := sload(senderSlot)
            let receiverData := sload(receiverSlot)
            
            // è§£ææ•°æ®
            let senderBalance := and(senderData, 0xffffffffffffffffffffffffffffffff)
            let senderWhitelisted := and(shr(192, senderData), 1)
            let receiverWhitelisted := and(shr(192, receiverData), 1)
            
            // æ£€æŸ¥ç™½åå•
            if iszero(senderWhitelisted) { revert(0, 0) }
            if iszero(receiverWhitelisted) { revert(0, 0) }
            
            // æ£€æŸ¥ä½™é¢
            if lt(senderBalance, amount) { revert(0, 0) }
            
            // è®¡ç®—æ–°ä½™é¢
            let newSenderBalance := sub(senderBalance, amount)
            let receiverBalance := and(receiverData, 0xffffffffffffffffffffffffffffffff)
            let newReceiverBalance := add(receiverBalance, amount)
            
            // æ›´æ–°æ—¶é—´æˆ³
            let timestamp := timestamp()
            
            // é‡æ–°æ‰“åŒ…æ•°æ®
            let newSenderData := or(
                or(newSenderBalance, shl(128, timestamp)),
                shl(192, senderWhitelisted)
            )
            let newReceiverData := or(
                or(newReceiverBalance, shl(128, timestamp)),
                shl(192, receiverWhitelisted)
            )
            
            // å†™å…¥å­˜å‚¨
            sstore(senderSlot, newSenderData)
            sstore(receiverSlot, newReceiverData)
        }
    }
    
    // æ‰¹é‡æ“ä½œå‡å°‘äº¤æ˜“æ¬¡æ•°
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external whenNotPaused {
        uint256 length = recipients.length;
        require(length == amounts.length, "Length mismatch");
        
        // ä½¿ç”¨ç¬æ—¶å­˜å‚¨ç¼“å­˜æ€»é¢
        assembly {
            let totalAmount := 0
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                let amount := calldataload(add(amounts.offset, mul(i, 0x20)))
                totalAmount := add(totalAmount, amount)
            }
            tstore(0, totalAmount)
        }
        
        // æ‰§è¡Œè½¬è´¦
        for (uint256 i; i < length; ) {
            _optimizedTransfer(recipients[i], amounts[i]);
            unchecked { ++i; }
        }
    }
}</code></pre>
                    </div>
                </div>
                
                <div class="exercise">
                    <h4>ç»ƒä¹  3.4ï¼šè·¨é“¾ç¨³å®šå¸è®¾è®¡</h4>
                    <p>è®¾è®¡ä¸€ä¸ªæ”¯æŒå¤šé“¾éƒ¨ç½²çš„åŸç”Ÿç¨³å®šå¸ç³»ç»Ÿï¼Œé¿å…ä¼ ç»Ÿæ¡¥æ¥æ¨¡å¼çš„é£é™©ã€‚</p>
                    <p>è¦æ±‚ï¼š</p>
                    <ul>
                        <li>æ¯æ¡é“¾ä¸Šç‹¬ç«‹é“¸å¸/é”€æ¯</li>
                        <li>è·¨é“¾è½¬è´¦é€šè¿‡é”€æ¯-é“¸é€ æ¨¡å¼</li>
                        <li>å…¨å±€ä¾›åº”é‡åŒæ­¥</li>
                        <li>æ”¯æŒæ•…éšœæ¢å¤</li>
                    </ul>
                    <div class="answer">
                        <h4>å‚è€ƒç­”æ¡ˆï¼š</h4>
                        <pre><code class="language-solidity">// ä¸»åˆçº¦éƒ¨ç½²åœ¨æ‰€æœ‰é“¾ä¸Š
contract NativeMultichainStablecoin {
    using LayerZeroEndpoint for address;
    
    // é“¾ä¿¡æ¯
    struct ChainInfo {
        uint256 localSupply;    // æœ¬é“¾ä¾›åº”é‡
        uint256 mintCap;        // é“¸å¸ä¸Šé™
        uint256 dailyLimit;     // æ¯æ—¥è·¨é“¾é™é¢
        uint256 dailyVolume;    // ä»Šæ—¥è·¨é“¾é‡
        uint256 lastResetTime;  // ä¸Šæ¬¡é‡ç½®æ—¶é—´
    }
    
    mapping(uint16 => ChainInfo) public chains;
    mapping(uint16 => mapping(bytes32 => bool)) public processedMessages;
    
    uint256 public globalSupply; // å…¨å±€æ€»ä¾›åº”é‡
    uint16 public immutable currentChainId;
    
    // è·¨é“¾æ¶ˆæ¯ç±»å‹
    enum MessageType { TRANSFER, SUPPLY_SYNC, EMERGENCY }
    
    // æœ¬åœ°é“¸å¸
    function mintLocal(address to, uint256 amount) external onlyMinter {
        ChainInfo storage chain = chains[currentChainId];
        require(chain.localSupply + amount <= chain.mintCap, "Exceeds cap");
        
        _mint(to, amount);
        chain.localSupply += amount;
        
        // å¹¿æ’­ä¾›åº”é‡æ›´æ–°
        _broadcastSupplyUpdate();
    }
    
    // è·¨é“¾è½¬è´¦
    function crossChainTransfer(
        uint16 destChainId,
        address recipient,
        uint256 amount
    ) external payable {
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        // æ£€æŸ¥æ—¥é™é¢
        _checkDailyLimit(destChainId, amount);
        
        // é”€æ¯æœ¬åœ°ä»£å¸
        _burn(msg.sender, amount);
        chains[currentChainId].localSupply -= amount;
        
        // æ„å»ºè·¨é“¾æ¶ˆæ¯
        bytes memory payload = abi.encode(
            MessageType.TRANSFER,
            recipient,
            amount,
            block.timestamp
        );
        
        // å‘é€LayerZeroæ¶ˆæ¯
        _lzSend(
            destChainId,
            payload,
            payable(msg.sender),
            address(0),
            bytes(""),
            msg.value
        );
        
        emit CrossChainTransfer(msg.sender, destChainId, recipient, amount);
    }
    
    // æ¥æ”¶è·¨é“¾æ¶ˆæ¯
    function _nonblockingLzReceive(
        uint16 srcChainId,
        bytes memory srcAddress,
        uint64 nonce,
        bytes memory payload
    ) internal override {
        // é˜²é‡æ”¾
        bytes32 messageId = keccak256(abi.encode(srcChainId, nonce));
        require(!processedMessages[srcChainId][messageId], "Duplicate");
        processedMessages[srcChainId][messageId] = true;
        
        (MessageType msgType, ) = abi.decode(payload, (MessageType, bytes));
        
        if (msgType == MessageType.TRANSFER) {
            _handleTransfer(srcChainId, payload);
        } else if (msgType == MessageType.SUPPLY_SYNC) {
            _handleSupplySync(srcChainId, payload);
        } else if (msgType == MessageType.EMERGENCY) {
            _handleEmergency(srcChainId, payload);
        }
    }
    
    // å¤„ç†è½¬è´¦
    function _handleTransfer(
        uint16 srcChainId,
        bytes memory payload
    ) internal {
        (, address recipient, uint256 amount, ) = abi.decode(
            payload,
            (MessageType, address, uint256, uint256)
        );
        
        // é“¸é€ æ–°å¸
        _mint(recipient, amount);
        chains[currentChainId].localSupply += amount;
        
        emit CrossChainReceived(srcChainId, recipient, amount);
    }
    
    // ä¾›åº”é‡åŒæ­¥
    function _broadcastSupplyUpdate() internal {
        bytes memory payload = abi.encode(
            MessageType.SUPPLY_SYNC,
            currentChainId,
            chains[currentChainId].localSupply,
            block.timestamp
        );
        
        // å‘æ‰€æœ‰é“¾å¹¿æ’­
        uint16[] memory chainIds = getActiveChains();
        for (uint i = 0; i < chainIds.length; i++) {
            if (chainIds[i] != currentChainId) {
                _lzSend(chainIds[i], payload, payable(address(this)), address(0), bytes(""), 0);
            }
        }
    }
    
    // ç´§æ€¥æš‚åœ
    function emergencyPause(string memory reason) external onlyEmergency {
        _pause();
        
        // å¹¿æ’­ç´§æ€¥æ¶ˆæ¯
        bytes memory payload = abi.encode(
            MessageType.EMERGENCY,
            currentChainId,
            reason,
            block.timestamp
        );
        
        _broadcastEmergency(payload);
    }
    
    // æ•…éšœæ¢å¤æœºåˆ¶
    function recoverFromFailure(
        uint16 failedChainId,
        uint256 lastKnownSupply
    ) external onlyRole(RECOVERY_ROLE) {
        // æ›´æ–°å¤±è´¥é“¾çš„ä¾›åº”é‡ä¿¡æ¯
        chains[failedChainId].localSupply = lastKnownSupply;
        
        // é‡æ–°è®¡ç®—å…¨å±€ä¾›åº”é‡
        _recalculateGlobalSupply();
        
        emit ChainRecovered(failedChainId, lastKnownSupply);
    }
}</code></pre>
                    </div>
                </div>
            </div>
            
            <h3>æœ¬ç« å°ç»“</h3>
            <div class="summary-box">
                <h4>æ ¸å¿ƒè¦ç‚¹å›é¡¾ï¼š</h4>
                <ul>
                    <li><strong>ERC-20æ ‡å‡†ï¼š</strong>ç¨³å®šå¸çš„åŸºç¡€æ¥å£ï¼Œéœ€è¦æ‰©å±•ä»¥æ”¯æŒåˆè§„åŠŸèƒ½</li>
                    <li><strong>å¯å‡çº§æ¶æ„ï¼š</strong>UUPSæ¨¡å¼æä¾›æœ€ä½³Gasæ•ˆç‡ï¼Œé€‚åˆé«˜é¢‘äº¤æ˜“åœºæ™¯</li>
                    <li><strong>è·¨é“¾äº’æ“ä½œï¼š</strong>LayerZeroå’ŒIBCæä¾›ä¸åŒçš„å®‰å…¨æ€§å’Œå»ä¸­å¿ƒåŒ–æƒè¡¡</li>
                    <li><strong>Gasä¼˜åŒ–ï¼š</strong>é€šè¿‡å­˜å‚¨æ‰“åŒ…ã€æ‰¹é‡æ“ä½œå’Œäº‹ä»¶æ—¥å¿—å¯å¤§å¹…é™ä½æˆæœ¬</li>
                    <li><strong>åˆè§„åŠŸèƒ½ï¼š</strong>KYCã€AMLã€é»‘åå•æ˜¯ä¼ä¸šçº§ç¨³å®šå¸çš„å¿…å¤‡åŠŸèƒ½</li>
                </ul>
                
                <h4>ä¸‹ä¸€æ­¥å­¦ä¹ ï¼š</h4>
                <p>åœ¨æŒæ¡äº†ERC-20æ ‡å‡†å’Œå¯å‡çº§æ¶æ„åï¼Œä¸‹ä¸€ç« æˆ‘ä»¬å°†æ·±å…¥æ¢è®¨æŠµæŠ¼å‹ç¨³å®šå¸çš„è®¾è®¡ï¼ŒåŒ…æ‹¬é‡‘åº“æœºåˆ¶ã€æ¸…ç®—å¼•æ“å’Œé¢„è¨€æœºé›†æˆã€‚</p>
            </div>
            
            <h3>æœ¯è¯­é€ŸæŸ¥è¡¨</h3>
            <table class="glossary-table">
                <tr>
                    <th>æœ¯è¯­</th>
                    <th>è‹±æ–‡</th>
                    <th>è§£é‡Š</th>
                </tr>
                <tr>
                    <td>ä»£ç†æ¨¡å¼</td>
                    <td>Proxy Pattern</td>
                    <td>é€šè¿‡ä»£ç†åˆçº¦è°ƒç”¨å®ç°åˆçº¦ï¼Œå®ç°å¯å‡çº§æ€§</td>
                </tr>
                <tr>
                    <td>å­˜å‚¨æ§½</td>
                    <td>Storage Slot</td>
                    <td>EVMä¸­çš„256ä½å­˜å‚¨å•ä½ï¼Œæ¯ä¸ªæ§½æ¶ˆè€—20000 Gas</td>
                </tr>
                <tr>
                    <td>è½»å®¢æˆ·ç«¯</td>
                    <td>Light Client</td>
                    <td>åªå­˜å‚¨åŒºå—å¤´çš„å®¢æˆ·ç«¯ï¼Œç”¨äºéªŒè¯è·¨é“¾æ¶ˆæ¯</td>
                </tr>
                <tr>
                    <td>åŒ…è£…ä»£å¸</td>
                    <td>Wrapped Token</td>
                    <td>åœ¨ç›®æ ‡é“¾ä¸Šä»£è¡¨æºé“¾èµ„äº§çš„åˆæˆä»£å¸</td>
                </tr>
                <tr>
                    <td>æ—¶é—´é”</td>
                    <td>Timelock</td>
                    <td>å»¶è¿Ÿæ‰§è¡Œæœºåˆ¶ï¼Œå¢åŠ å®‰å…¨æ€§å’Œå¯é¢„æµ‹æ€§</td>
                </tr>
            </table>
        
            
            <!-- ç« èŠ‚å¯¼èˆª -->
            <div class="chapter-nav">
                <a href="chapter2.html">â† ç¬¬2ç« </a>
                <a href="chapter4.html">ç¬¬4ç«  â†’</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
