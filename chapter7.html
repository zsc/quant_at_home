<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第七章：借贷协议 - 区块链稳定币教程</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <a href="index.html" class="navbar-brand">稳定币教程</a>
            <button class="navbar-toggle" onclick="toggleMobileNav()">☰</button>
            <ul class="navbar-nav">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">首页</a>
                </li>
                <li class="nav-item">
                    <a href="intro.html" class="nav-link">引言</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link">章节</a>
                    <div class="dropdown-menu">
                        <a href="chapter1.html" class="dropdown-item">第1章：区块链基础</a>
                        <a href="chapter2.html" class="dropdown-item">第2章：稳定币分类</a>
                        <a href="chapter3.html" class="dropdown-item">第3章：ERC-20标准</a>
                        <a href="chapter4.html" class="dropdown-item">第4章：抵押型设计</a>
                        <a href="chapter5.html" class="dropdown-item">第5章：数学模型</a>
                        <a href="chapter6.html" class="dropdown-item">第6章：AMM集成</a>
                        <a href="chapter7.html" class="dropdown-item">第7章：借贷协议</a>
                        <a href="chapter8.html" class="dropdown-item">第8章：收益策略</a>
                        <a href="chapter9.html" class="dropdown-item">第9章：智能合约安全</a>
                        <a href="chapter10.html" class="dropdown-item">第10章：经济攻击</a>
                        <a href="chapter11.html" class="dropdown-item">第11章：未来方向</a>
                        <a href="chapter12.html" class="dropdown-item">第12章：生产部署</a>
                        <a href="chapter13.html" class="dropdown-item">第13章：生态集成</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="#resources" class="nav-link">资源</a>
                </li>
            </ul>
        </div>
    </nav>
    
    <!-- 头部 -->
    <header id="top">
        <div class="container">
            <h1>第七章：借贷协议</h1>
        </div>
    </header>
    
    <!-- 主要内容 -->
    <div class="container">
        <div class="chapter">
<h2>第七章：借贷协议（Lending Protocols）</h2>
        
        <div class="overview">
            <h3>本章概览</h3>
            <p>本章深入探讨稳定币在去中心化借贷协议中的核心作用。我们将学习主流借贷协议的架构设计、利率模型的数学原理、稳定币特有的风险管理机制，以及闪电贷的实现和防御策略。通过实践，您将构建一个功能完整的稳定币借贷池。</p>
        </div>

        <h3 id="lending-architecture">7.1 借贷协议基础架构</h3>
        
        <h4>7.1.1 核心概念与设计哲学</h4>
        <div class="concept">
            <p><strong>借贷协议三要素：</strong></p>
            <ul>
                <li><strong>流动性池（Liquidity Pool）</strong>：资金聚合的智能合约</li>
                <li><strong>利率模型（Interest Rate Model）</strong>：动态定价机制</li>
                <li><strong>风险管理（Risk Management）</strong>：清算和保险机制</li>
            </ul>
        </div>

        <div class="info-box">
            <h4>设计哲学对比：Compound vs Aave</h4>
            <ul>
                <li><strong>Compound：</strong>追求极致简洁和同质化
                    <ul>
                        <li>所有市场使用相似参数</li>
                        <li>单一利率模型</li>
                        <li>最小化治理复杂性</li>
                    </ul>
                </li>
                <li><strong>Aave：</strong>追求灵活性和风险隔离
                    <ul>
                        <li>每个资产独立参数配置</li>
                        <li>多种借贷模式（稳定/可变利率）</li>
                        <li>E-Mode、隔离模式等高级功能</li>
                    </ul>
                </li>
            </ul>
        </div>

        <h4>7.1.2 资本效率的演进</h4>
        <div class="example-box">
            <h4>从池化到点对点：借贷协议的进化</h4>
            <ol>
                <li><strong>第一代 - 池化模型（Compound/Aave V1）</strong>
                    <ul>
                        <li>资本效率：~30-40%</li>
                        <li>简单但低效的资金利用</li>
                    </ul>
                </li>
                <li><strong>第二代 - 风险分层（Aave V2/V3）</strong>
                    <ul>
                        <li>E-Mode将稳定币LTV提升至97%</li>
                        <li>隔离模式控制新资产风险</li>
                    </ul>
                </li>
                <li><strong>第三代 - P2P匹配层（Morpho）</strong>
                    <ul>
                        <li>在Compound/Aave之上构建P2P匹配</li>
                        <li>匹配成功时零利差，失败时回退到底层协议</li>
                        <li>数学证明：Pareto改进（用户永远不会更差）</li>
                    </ul>
                </li>
                <li><strong>第四代 - 无预言机借贷（Ajna）</strong>
                    <ul>
                        <li>通过荷兰拍卖发现价格</li>
                        <li>消除预言机风险但牺牲资本效率</li>
                    </ul>
                </li>
            </ol>
        </div>

        <h4>7.1.3 Compound协议架构</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// cToken接口 - Compound的核心抽象
interface ICToken {
    // 存款
    function mint(uint mintAmount) external returns (uint);
    
    // 取款
    function redeem(uint redeemTokens) external returns (uint);
    function redeemUnderlying(uint redeemAmount) external returns (uint);
    
    // 借款
    function borrow(uint borrowAmount) external returns (uint);
    
    // 还款
    function repayBorrow(uint repayAmount) external returns (uint);
    
    // 查询函数
    function balanceOf(address owner) external view returns (uint);
    function borrowBalanceStored(address account) external view returns (uint);
    function exchangeRateStored() external view returns (uint);
}

// 稳定币专用的cToken实现
contract CStablecoin is ICToken, ERC20 {
    IERC20 public underlying;  // 底层稳定币
    uint public reserveFactorMantissa;  // 准备金率
    uint public accrualBlockNumber;  // 上次计息区块
    uint public borrowIndex;  // 借款指数
    uint public totalBorrows;  // 总借款
    uint public totalReserves;  // 总准备金
    
    // 关键参数
    uint constant expScale = 1e18;
    uint constant blocksPerYear = 2102400;  // 约15秒一个块
    
    // 利率模型
    IInterestRateModel public interestRateModel;
    
    struct BorrowSnapshot {
        uint principal;  // 本金
        uint interestIndex;  // 借款时的指数
    }
    
    mapping(address => BorrowSnapshot) internal accountBorrows;
    
    // 计算并累积利息
    function accrueInterest() public returns (uint) {
        uint currentBlockNumber = block.number;
        uint accrualBlockNumberPrior = accrualBlockNumber;
        
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return 0;
        }
        
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;
        uint borrowIndexPrior = borrowIndex;
        
        // 计算借款利率
        uint borrowRateMantissa = interestRateModel.getBorrowRate(
            cashPrior,
            borrowsPrior,
            reservesPrior
        );
        
        // 计算区块数差
        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;
        
        // 计算利息因子
        uint simpleInterestFactor = borrowRateMantissa * blockDelta;
        uint interestAccumulated = simpleInterestFactor * borrowsPrior / expScale;
        
        // 更新状态
        totalBorrows = borrowsPrior + interestAccumulated;
        totalReserves = reservesPrior + (interestAccumulated * reserveFactorMantissa / expScale);
        borrowIndex = borrowIndexPrior + (simpleInterestFactor * borrowIndexPrior / expScale);
        accrualBlockNumber = currentBlockNumber;
        
        return interestAccumulated;
    }
    
    // 存款实现
    function mintInternal(uint mintAmount) internal returns (uint) {
        accrueInterest();
        
        // 转入底层代币
        underlying.transferFrom(msg.sender, address(this), mintAmount);
        
        // 计算兑换率
        uint exchangeRateMantissa = exchangeRateStoredInternal();
        uint mintTokens = mintAmount * expScale / exchangeRateMantissa;
        
        // 铸造cToken
        _mint(msg.sender, mintTokens);
        
        return mintTokens;
    }
}</code></pre>
        </div>

        <h4>7.1.4 Aave V3架构创新</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// Aave V3的高级功能
contract AaveV3Pool {
    using WadRayMath for uint256;
    
    // 核心数据结构
    struct ReserveData {
        ReserveConfigurationMap configuration;
        uint128 liquidityIndex;
        uint128 variableBorrowIndex;
        uint128 currentLiquidityRate;
        uint128 currentVariableBorrowRate;
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        address interestRateStrategyAddress;
        uint8 id;
    }
    
    // 效率模式（E-Mode）- 稳定币专用优化
    struct EModeCategory {
        uint16 ltv;  // 贷款价值比
        uint16 liquidationThreshold;  // 清算阈值
        uint16 liquidationBonus;  // 清算奖励
        address priceSource;  // 价格源
        string label;  // 类别标签
    }
    
    mapping(uint8 => EModeCategory) internal _eModeCategories;
    
    // 供应函数 - 支持多种模式
    function supply(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external {
        DataTypes.ReserveData storage reserve = _reserves[asset];
        
        // 验证
        ValidationLogic.validateSupply(reserve, amount);
        
        // 更新状态
        reserve.updateState();
        reserve.updateInterestRates(asset, amount, 0);
        
        // 转入资产
        IERC20(asset).safeTransferFrom(msg.sender, reserve.aTokenAddress, amount);
        
        // 铸造aToken
        IAToken(reserve.aTokenAddress).mint(onBehalfOf, amount, reserve.liquidityIndex);
        
        emit Supply(asset, msg.sender, onBehalfOf, amount, referralCode);
    }
    
    // 隔离模式借款 - 风险隔离
    function borrowInIsolation(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        address onBehalfOf
    ) external {
        require(_usersConfig[onBehalfOf].isolationModeActive, "Not in isolation mode");
        
        DataTypes.ReserveData storage reserve = _reserves[asset];
        
        // 隔离模式特殊验证
        ValidationLogic.validateBorrowInIsolation(
            _reserves,
            _usersConfig[onBehalfOf],
            asset,
            amount
        );
        
        _executeBorrow(ExecuteBorrowParams({
            asset: asset,
            user: msg.sender,
            onBehalfOf: onBehalfOf,
            amount: amount,
            interestRateMode: interestRateMode,
            referralCode: 0,
            releaseUnderlying: true
        }));
    }
}</code></pre>
        </div>

        <div class="info-box">
            <h4>E-Mode的数学原理</h4>
            <p><strong>核心假设：</strong>相关资产（如USDC、USDT、DAI）的价格相关性极高</p>
            <div class="formula">
                <p><strong>价格相关性矩阵：</strong></p>
                <p>ρ(USDC, USDT) ≈ 0.99+</p>
                <p>ρ(USDC, DAI) ≈ 0.98+</p>
                <p>ρ(USDT, DAI) ≈ 0.97+</p>
            </div>
            <p><strong>风险参数优化：</strong></p>
            <ul>
                <li>普通模式LTV：75-80%</li>
                <li>E-Mode LTV：97%（基于高相关性假设）</li>
                <li>清算阈值：98%（仅2%缓冲区）</li>
            </ul>
            <p><strong>统计验证：</strong>使用历史数据计算VaR（Value at Risk）和CVaR（Conditional VaR）验证参数安全性</p>
        </div>

        <div class="example-box">
            <h4>隔离模式的风险分区原理</h4>
            <p><strong>风险分区（Risk Partitioning）：</strong>系统工程中的重要概念</p>
            <ul>
                <li><strong>新资产隔离：</strong>高风险资产只能借出特定稳定币</li>
                <li><strong>债务上限：</strong>设置协议级别的最大敞口</li>
                <li><strong>单向隔离：</strong>隔离模式用户不能使用其他资产作抵押</li>
            </ul>
            <p>数学模型：将风险空间R分解为相互独立的子空间{R₁, R₂, ..., Rₙ}，确保∀i≠j: Rᵢ ∩ Rⱼ = ∅</p>
        </div>

        <h3 id="interest-models">7.2 利率模型设计</h3>
        
        <h4>7.2.1 基础利率模型的数学原理</h4>
        <div class="formula">
            <p><strong>利用率（Utilization Rate）：</strong></p>
            <p>U = Borrows / (Cash + Borrows - Reserves)</p>
            
            <p><strong>分段线性利率函数（Piecewise Linear Function）：</strong></p>
            <pre>
Rate(U) = {
    R_base + (U / U_optimal) × R_slope1,                    if U ≤ U_optimal
    R_base + R_slope1 + ((U - U_optimal) / (1 - U_optimal)) × R_slope2,  if U > U_optimal
}
            </pre>
            
            <p><strong>参数经济学意义：</strong></p>
            <ul>
                <li><strong>R_base：</strong>基础利率，覆盖协议运营成本</li>
                <li><strong>R_slope1：</strong>正常区间斜率，平衡供需</li>
                <li><strong>R_slope2：</strong>高利用率惩罚斜率，防止流动性枯竭</li>
                <li><strong>U_optimal：</strong>最优利用率（80-90%），平衡资本效率与流动性风险</li>
            </ul>
        </div>

        <div class="info-box">
            <h4>控制论视角：利率作为负反馈系统</h4>
            <p><strong>系统目标：</strong>维持利用率在U_optimal附近</p>
            <p><strong>反馈机制：</strong></p>
            <ul>
                <li>当U > U_optimal：利率急剧上升→借款成本增加→借款人还款/存款人存入→U下降</li>
                <li>当U < U_optimal：利率降低→借款变得便宜→借款增加→U上升</li>
            </ul>
            <p><strong>控制器类型：</strong>比例控制器（P-Controller），其中R_slope2 >> R_slope1实现非线性增益</p>
        </div>

        <div class="code-block">
            <pre><code class="language-solidity">// 跳跃率模型实现
contract JumpRateModelV2 is IInterestRateModel {
    uint256 public constant blocksPerYear = 2102400;
    
    uint256 public baseRatePerBlock;
    uint256 public multiplierPerBlock;
    uint256 public jumpMultiplierPerBlock;
    uint256 public kink;  // 拐点
    
    constructor(
        uint256 baseRatePerYear,
        uint256 multiplierPerYear,
        uint256 jumpMultiplierPerYear,
        uint256 kink_
    ) {
        baseRatePerBlock = baseRatePerYear / blocksPerYear;
        multiplierPerBlock = multiplierPerYear / blocksPerYear;
        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;
        kink = kink_;
    }
    
    function utilizationRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) public pure returns (uint256) {
        if (borrows == 0) {
            return 0;
        }
        return borrows * 1e18 / (cash + borrows - reserves);
    }
    
    function getBorrowRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) public view override returns (uint256) {
        uint256 util = utilizationRate(cash, borrows, reserves);
        
        if (util <= kink) {
            return baseRatePerBlock + util * multiplierPerBlock / 1e18;
        } else {
            uint256 normalRate = baseRatePerBlock + kink * multiplierPerBlock / 1e18;
            uint256 excessUtil = util - kink;
            return normalRate + excessUtil * jumpMultiplierPerBlock / 1e18;
        }
    }
    
    function getSupplyRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves,
        uint256 reserveFactorMantissa
    ) public view override returns (uint256) {
        uint256 oneMinusReserveFactor = 1e18 - reserveFactorMantissa;
        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);
        uint256 rateToPool = borrowRate * oneMinusReserveFactor / 1e18;
        return utilizationRate(cash, borrows, reserves) * rateToPool / 1e18;
    }
}</code></pre>
        </div>

        <h4>7.2.2 稳定币特殊利率策略</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// 稳定币优化利率模型
contract StablecoinRateStrategy is IInterestRateStrategy {
    using WadRayMath for uint256;
    
    // 稳定币特有参数
    uint256 public immutable OPTIMAL_UTILIZATION_RATE = 0.9e27;  // 90%
    uint256 public immutable BASE_VARIABLE_BORROW_RATE = 0.01e27;  // 1%
    uint256 public immutable VARIABLE_RATE_SLOPE1 = 0.04e27;  // 4%
    uint256 public immutable VARIABLE_RATE_SLOPE2 = 0.6e27;  // 60%
    uint256 public immutable STABLE_RATE_SLOPE1 = 0.02e27;  // 2%
    uint256 public immutable STABLE_RATE_SLOPE2 = 0.6e27;  // 60%
    
    // 动态调整机制
    uint256 public immutable OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = 0.2e27;  // 20%
    
    function calculateInterestRates(
        DataTypes.CalculateInterestRatesParams memory params
    ) public view override returns (uint256, uint256, uint256) {
        uint256 utilizationRate = params.totalDebt.rayDiv(params.totalLiquidity);
        
        uint256 currentVariableBorrowRate;
        uint256 currentStableBorrowRate;
        
        if (utilizationRate <= OPTIMAL_UTILIZATION_RATE) {
            // 正常区间 - 线性增长
            currentVariableBorrowRate = BASE_VARIABLE_BORROW_RATE +
                utilizationRate.rayMul(VARIABLE_RATE_SLOPE1).rayDiv(OPTIMAL_UTILIZATION_RATE);
                
            currentStableBorrowRate = currentVariableBorrowRate +
                utilizationRate.rayMul(STABLE_RATE_SLOPE1).rayDiv(OPTIMAL_UTILIZATION_RATE);
        } else {
            // 高利用率区间 - 快速增长
            uint256 excessUtilizationRateRatio = 
                (utilizationRate - OPTIMAL_UTILIZATION_RATE).rayDiv(1e27 - OPTIMAL_UTILIZATION_RATE);
                
            currentVariableBorrowRate = BASE_VARIABLE_BORROW_RATE +
                VARIABLE_RATE_SLOPE1 +
                VARIABLE_RATE_SLOPE2.rayMul(excessUtilizationRateRatio);
                
            currentStableBorrowRate = currentVariableBorrowRate +
                STABLE_RATE_SLOPE1 +
                STABLE_RATE_SLOPE2.rayMul(excessUtilizationRateRatio);
        }
        
        // 稳定利率调整
        if (params.stableDebt > 0) {
            uint256 stableToTotalDebtRatio = params.stableDebt.rayDiv(params.totalDebt);
            
            if (stableToTotalDebtRatio > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO) {
                uint256 excessStableDebtRatio = 
                    (stableToTotalDebtRatio - OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO)
                    .rayDiv(1e27 - OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO);
                    
                currentStableBorrowRate = currentStableBorrowRate +
                    STABLE_RATE_SLOPE2.rayMul(excessStableDebtRatio);
            }
        }
        
        // 计算流动性利率
        uint256 currentLiquidityRate = _getOverallBorrowRate(
            params.totalStableDebt,
            params.totalVariableDebt,
            currentVariableBorrowRate,
            params.averageStableBorrowRate
        ).rayMul(utilizationRate).rayMul(1e27 - params.reserveFactor);
        
        return (currentLiquidityRate, currentStableBorrowRate, currentVariableBorrowRate);
    }
}</code></pre>
        </div>

        <h4>7.2.3 GHO稳定币利率机制（2024年创新）</h4>
        <div class="info-box">
            <h4>GHO的Bucket机制</h4>
            <p>Aave的GHO稳定币引入了革命性的"Bucket"概念，实现更复杂的供需控制：</p>
            <ul>
                <li><strong>Facilitator Buckets：</strong>不同实体（如Aave V3池）有独立的铸造上限</li>
                <li><strong>动态利率调整：</strong>基于GHO市场价格偏离程度自动调整借款利率</li>
                <li><strong>stkAAVE折扣：</strong>质押AAVE的用户享受利率折扣，增强代币价值捕获</li>
            </ul>
        </div>

        <div class="code-block">
            <pre><code class="language-solidity">// GHO利率策略实现
contract GhoInterestRateStrategy {
    // 基于市场价格的动态调整
    function calculateGhoRate(
        uint256 ghoMarketPrice,  // 当前市场价格
        uint256 targetPrice,     // 目标价格（1美元）
        uint256 currentRate,     // 当前利率
        uint256 bucketUtilization // Bucket利用率
    ) public pure returns (uint256 newRate) {
        // 价格偏离度计算
        int256 priceDelta = int256(ghoMarketPrice) - int256(targetPrice);
        int256 priceDeviation = (priceDelta * 1e18) / int256(targetPrice);
        
        // PID控制器调整利率
        int256 rateAdjustment = (priceDeviation * KP) / 1e18;
        
        // Bucket利用率影响
        if (bucketUtilization > OPTIMAL_UTILIZATION) {
            uint256 utilizationPremium = 
                (bucketUtilization - OPTIMAL_UTILIZATION) * UTILIZATION_SLOPE / 1e18;
            rateAdjustment += int256(utilizationPremium);
        }
        
        // 应用调整并限制范围
        newRate = uint256(int256(currentRate) + rateAdjustment);
        newRate = bound(newRate, MIN_RATE, MAX_RATE);
    }
}</code></pre>
        </div>

        <h3 id="flash-loans">7.3 闪电贷：DeFi的原子性保证</h3>
        
        <div class="concept">
            <p><strong>闪电贷的本质：</strong>在单个交易内完成借款、使用、还款的原子操作</p>
            <p><strong>核心价值：</strong>实现无需抵押的套利，维持市场效率</p>
            <p><strong>技术保证：</strong>EVM的交易原子性 - 要么全部成功，要么全部回滚</p>
        </div>
        
        <h4>7.3.1 闪电贷实现（含安全注释）</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// EIP-3156 闪电贷标准实现 - 生产级安全考量
contract FlashLoanProvider is IERC3156FlashLender, ReentrancyGuard {
    using SafeERC20 for IERC20;
    
    // 闪电贷费率（基点）
    uint256 public constant FLASH_LOAN_FEE = 9;  // 0.09%
    bytes32 public constant CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan");
    
    mapping(address => bool) public supportedTokens;
    
    // 防止重入攻击的状态变量
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    uint256 private _status;
    
    // 闪电贷核心函数 - 遵循 check-effects-interactions 模式
    function flashLoan(
        IERC3156FlashBorrower receiver,
        address token,
        uint256 amount,
        bytes calldata data
    ) external override nonReentrant returns (bool) {
        // 1. Checks - 验证输入
        require(supportedTokens[token], "Token not supported");
        require(amount > 0, "Invalid amount");
        
        uint256 fee = _flashFee(amount);
        uint256 balanceBefore = IERC20(token).balanceOf(address(this));
        require(balanceBefore >= amount, "Insufficient liquidity");
        
        // 2. Effects - 状态变更（此处无需变更状态）
        
        // 3. Interactions - 外部调用
        // 发送代币给借款人 - 使用 SafeERC20 防止假币攻击
        IERC20(token).safeTransfer(address(receiver), amount);
        
        // 执行回调 - 关键安全点：借款人可执行任意代码
        // 重入保护由 nonReentrant 修饰符提供
        require(
            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,
            "Callback failed"
        );
        
        // 验证还款 - 必须在回调后立即检查
        uint256 balanceAfter = IERC20(token).balanceOf(address(this));
        require(
            balanceAfter >= balanceBefore + fee,
            "Flash loan not repaid"
        );
        
        emit FlashLoan(address(receiver), token, amount, fee);
        return true;
    }
    
    // 批量闪电贷 - Gas优化
    function flashLoanMultiple(
        IERC3156FlashBorrower receiver,
        address[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata data
    ) external returns (bool) {
        require(tokens.length == amounts.length, "Array length mismatch");
        
        uint256[] memory fees = new uint256[](tokens.length);
        uint256[] memory balancesBefore = new uint256[](tokens.length);
        
        // 批量转出
        for (uint256 i = 0; i < tokens.length; i++) {
            require(supportedTokens[tokens[i]], "Token not supported");
            fees[i] = _flashFee(amounts[i]);
            balancesBefore[i] = IERC20(tokens[i]).balanceOf(address(this));
            IERC20(tokens[i]).safeTransfer(address(receiver), amounts[i]);
        }
        
        // 执行回调
        require(
            IFlashLoanReceiverMultiple(receiver).onFlashLoanMultiple(
                msg.sender,
                tokens,
                amounts,
                fees,
                data
            ) == CALLBACK_SUCCESS,
            "Callback failed"
        );
        
        // 批量验证还款
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 balanceAfter = IERC20(tokens[i]).balanceOf(address(this));
            require(
                balanceAfter >= balancesBefore[i] + fees[i],
                "Flash loan not repaid"
            );
        }
        
        return true;
    }
    
    function _flashFee(uint256 amount) internal pure returns (uint256) {
        return amount * FLASH_LOAN_FEE / 10000;
    }
}</code></pre>
        </div>

        <h4>7.3.2 闪电贷攻击防御的深度分析</h4>
        
        <div class="info-box">
            <h4>TWAP（时间加权平均价格）防御原理</h4>
            <p><strong>核心机制：</strong>TWAP基于多个区块的价格计算，而闪电贷只能在单个区块内操纵价格</p>
            <div class="formula">
                <p>TWAP = Σ(Price_i × Time_i) / Σ(Time_i)</p>
                <p>其中：Time_i 是价格 Price_i 持续的时间</p>
            </div>
            <p><strong>关键参数 - 窗口大小：</strong></p>
            <ul>
                <li>短窗口（5-15分钟）：响应快但易受攻击</li>
                <li>长窗口（30分钟-1小时）：安全但响应慢</li>
                <li>权衡：安全性 vs 价格新鲜度</li>
            </ul>
        </div>

        <div class="example-box">
            <h4>2024年新型防御机制</h4>
            <ul>
                <li><strong>Chainlink Data Streams：</strong>推式预言机，亚秒级更新，缩小攻击窗口</li>
                <li><strong>Pyth Network：</strong>高频价格更新，支持置信区间</li>
                <li><strong>Chronicle Protocol：</strong>基于阈值签名的去中心化预言机</li>
            </ul>
        </div>
        <div class="code-block">
            <pre><code class="language-solidity">// 防御闪电贷攻击的措施
contract FlashLoanProtectedVault {
    using ReentrancyGuard for uint256;
    
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    uint256 private _status;
    
    // 闪电贷检测
    modifier noFlashLoan() {
        require(!_isFlashLoan(), "Flash loan detected");
        _;
    }
    
    // 延迟更新机制
    struct PriceSnapshot {
        uint256 price;
        uint256 timestamp;
        uint256 blockNumber;
    }
    
    mapping(address => PriceSnapshot) public priceSnapshots;
    uint256 public constant PRICE_DELAY = 1 hours;
    
    function _isFlashLoan() internal view returns (bool) {
        // 检查是否在同一区块内有大额借贷
        // 实际实现需要追踪借贷历史
        return false;
    }
    
    // 时间加权价格
    function getSecurePrice(address token) public view returns (uint256) {
        PriceSnapshot memory snapshot = priceSnapshots[token];
        require(
            block.timestamp >= snapshot.timestamp + PRICE_DELAY,
            "Price not yet valid"
        );
        return snapshot.price;
    }
    
    // 闪电贷保护的清算函数
    function liquidate(
        address borrower,
        address collateralAsset,
        address debtAsset,
        uint256 debtToCover
    ) external noFlashLoan nonReentrant {
        // 使用延迟价格
        uint256 collateralPrice = getSecurePrice(collateralAsset);
        uint256 debtPrice = getSecurePrice(debtAsset);
        
        // 计算清算
        uint256 collateralAmount = _calculateLiquidation(
            debtToCover,
            debtPrice,
            collateralPrice
        );
        
        // 执行清算
        _executeLiquidation(borrower, collateralAsset, debtAsset, collateralAmount);
    }
    
    // 多重签名延迟执行
    mapping(bytes32 => TimelockTransaction) public timelockTransactions;
    
    struct TimelockTransaction {
        address target;
        bytes data;
        uint256 executeTime;
        bool executed;
    }
    
    function scheduleTransaction(
        address target,
        bytes memory data,
        uint256 delay
    ) external onlyOwner returns (bytes32) {
        bytes32 txHash = keccak256(abi.encode(target, data, block.timestamp));
        
        timelockTransactions[txHash] = TimelockTransaction({
            target: target,
            data: data,
            executeTime: block.timestamp + delay,
            executed: false
        });
        
        emit TransactionScheduled(txHash, target, delay);
        return txHash;
    }
}</code></pre>
        </div>

        <h3>7.4 实践：构建稳定币借贷池</h3>
        
        <h4>7.4.1 完整的借贷池实现</h4>
        <div class="code-block">
            <pre><code class="language-solidity">// 稳定币借贷池完整实现
contract StablecoinLendingPool is 
    ReentrancyGuard, 
    Pausable, 
    AccessControl,
    IERC3156FlashLender 
{
    using SafeERC20 for IERC20;
    using WadRayMath for uint256;
    
    // 角色定义
    bytes32 public constant CONFIGURATOR_ROLE = keccak256("CONFIGURATOR_ROLE");
    bytes32 public constant RISK_ADMIN_ROLE = keccak256("RISK_ADMIN_ROLE");
    
    // 核心状态变量
    struct Reserve {
        uint256 liquidityIndex;
        uint256 variableBorrowIndex;
        uint256 currentLiquidityRate;
        uint256 currentVariableBorrowRate;
        uint40 lastUpdateTimestamp;
        address aTokenAddress;
        address debtTokenAddress;
        address interestRateStrategyAddress;
        uint256 accruedToTreasury;
        ReserveConfiguration configuration;
    }
    
    struct ReserveConfiguration {
        uint256 ltv;  // 贷款价值比
        uint256 liquidationThreshold;  // 清算阈值
        uint256 liquidationBonus;  // 清算奖励
        uint256 reserveFactor;  // 准备金率
        bool borrowingEnabled;
        bool stableBorrowRateEnabled;
        bool isActive;
        bool isFrozen;
    }
    
    mapping(address => Reserve) public reserves;
    mapping(address => mapping(address => uint256)) public userCollateral;
    mapping(address => mapping(address => uint256)) public userDebt;
    
    // 事件
    event Deposit(address indexed user, address indexed asset, uint256 amount);
    event Withdraw(address indexed user, address indexed asset, uint256 amount);
    event Borrow(address indexed user, address indexed asset, uint256 amount);
    event Repay(address indexed user, address indexed asset, uint256 amount);
    event Liquidation(
        address indexed liquidator,
        address indexed borrower,
        address indexed asset,
        uint256 debtCovered,
        uint256 collateralLiquidated
    );
    
    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CONFIGURATOR_ROLE, msg.sender);
        _setupRole(RISK_ADMIN_ROLE, msg.sender);
    }
    
    // 初始化储备
    function initReserve(
        address asset,
        address aTokenAddress,
        address debtTokenAddress,
        address interestRateStrategy
    ) external onlyRole(CONFIGURATOR_ROLE) {
        reserves[asset] = Reserve({
            liquidityIndex: WadRayMath.ray(),
            variableBorrowIndex: WadRayMath.ray(),
            currentLiquidityRate: 0,
            currentVariableBorrowRate: 0,
            lastUpdateTimestamp: uint40(block.timestamp),
            aTokenAddress: aTokenAddress,
            debtTokenAddress: debtTokenAddress,
            interestRateStrategyAddress: interestRateStrategy,
            accruedToTreasury: 0,
            configuration: ReserveConfiguration({
                ltv: 8000,  // 80%
                liquidationThreshold: 8500,  // 85%
                liquidationBonus: 10500,  // 105%
                reserveFactor: 1000,  // 10%
                borrowingEnabled: true,
                stableBorrowRateEnabled: false,
                isActive: true,
                isFrozen: false
            })
        });
    }
    
    // 存款
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf
    ) external nonReentrant whenNotPaused {
        Reserve storage reserve = reserves[asset];
        require(reserve.configuration.isActive, "Reserve not active");
        require(!reserve.configuration.isFrozen, "Reserve frozen");
        
        // 更新储备状态
        _updateIndexes(reserve);
        
        // 转入资产
        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);
        
        // 更新用户余额
        userCollateral[onBehalfOf][asset] += amount;
        
        // 铸造aToken
        IAToken(reserve.aTokenAddress).mint(onBehalfOf, amount, reserve.liquidityIndex);
        
        // 更新利率
        _updateInterestRates(reserve, asset, amount, 0);
        
        emit Deposit(onBehalfOf, asset, amount);
    }
    
    // 借款
    function borrow(
        address asset,
        uint256 amount,
        address onBehalfOf
    ) external nonReentrant whenNotPaused {
        Reserve storage reserve = reserves[asset];
        require(reserve.configuration.isActive, "Reserve not active");
        require(reserve.configuration.borrowingEnabled, "Borrowing not enabled");
        
        // 更新储备状态
        _updateIndexes(reserve);
        
        // 检查健康因子
        (, , , , uint256 healthFactor) = _calculateUserAccountData(onBehalfOf);
        require(healthFactor > WadRayMath.ray(), "Health factor too low");
        
        // 更新债务
        userDebt[onBehalfOf][asset] += amount;
        
        // 铸造债务代币
        IDebtToken(reserve.debtTokenAddress).mint(
            onBehalfOf,
            amount,
            reserve.variableBorrowIndex
        );
        
        // 转出资产
        IERC20(asset).safeTransfer(onBehalfOf, amount);
        
        // 更新利率
        _updateInterestRates(reserve, asset, 0, amount);
        
        emit Borrow(onBehalfOf, asset, amount);
    }
    
    // 清算
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover
    ) external nonReentrant whenNotPaused {
        Reserve storage collateralReserve = reserves[collateralAsset];
        Reserve storage debtReserve = reserves[debtAsset];
        
        // 更新储备状态
        _updateIndexes(collateralReserve);
        _updateIndexes(debtReserve);
        
        // 检查健康因子
        (, , , , uint256 healthFactor) = _calculateUserAccountData(user);
        require(healthFactor < WadRayMath.ray(), "Health factor not below 1");
        
        // 计算清算金额
        uint256 collateralAmount = _calculateAvailableCollateralToLiquidate(
            collateralReserve,
            debtReserve,
            collateralAsset,
            debtAsset,
            debtToCover,
            userCollateral[user][collateralAsset]
        );
        
        // 执行清算
        userDebt[user][debtAsset] -= debtToCover;
        userCollateral[user][collateralAsset] -= collateralAmount;
        
        // 转移债务
        IERC20(debtAsset).safeTransferFrom(msg.sender, address(this), debtToCover);
        
        // 转移抵押品（包含奖励）
        uint256 liquidationBonus = collateralAmount
            .wadMul(collateralReserve.configuration.liquidationBonus)
            .wadDiv(10000);
        IERC20(collateralAsset).safeTransfer(msg.sender, collateralAmount + liquidationBonus);
        
        emit Liquidation(msg.sender, user, debtAsset, debtToCover, collateralAmount);
    }
    
    // 辅助函数：更新指数
    function _updateIndexes(Reserve storage reserve) internal {
        uint256 scaledTotalSupply = IAToken(reserve.aTokenAddress).scaledTotalSupply();
        uint256 scaledTotalDebt = IDebtToken(reserve.debtTokenAddress).scaledTotalSupply();
        
        if (scaledTotalSupply == 0 && scaledTotalDebt == 0) {
            return;
        }
        
        uint256 cumulatedLiquidityInterest = _calculateLinearInterest(
            reserve.currentLiquidityRate,
            reserve.lastUpdateTimestamp
        );
        
        uint256 cumulatedVariableBorrowInterest = _calculateCompoundedInterest(
            reserve.currentVariableBorrowRate,
            reserve.lastUpdateTimestamp
        );
        
        reserve.liquidityIndex = cumulatedLiquidityInterest.rayMul(reserve.liquidityIndex);
        reserve.variableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(
            reserve.variableBorrowIndex
        );
        
        reserve.lastUpdateTimestamp = uint40(block.timestamp);
    }
    
    // 计算用户账户数据
    function _calculateUserAccountData(address user)
        internal
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 healthFactor
        )
    {
        // 实现省略，需要遍历所有用户的抵押品和债务
        // 使用预言机价格转换为ETH计价
        // 计算加权平均清算阈值
        // 计算健康因子 = (totalCollateral * liquidationThreshold) / totalDebt
    }
}</code></pre>
        </div>

        <h3>7.5 高级主题</h3>
        
        <h4>7.5.1 跨链借贷</h4>
        <div class="info-box">
            <p><strong>跨链借贷架构：</strong></p>
            <ul>
                <li>Hub-Spoke模型：中心化流动性管理</li>
                <li>点对点模型：直接跨链交互</li>
                <li>流动性聚合：跨链收益优化</li>
            </ul>
        </div>

        <h4>7.5.2 信用借贷探索</h4>
        <div class="concept">
            <p><strong>无抵押借贷创新：</strong></p>
            <ul>
                <li>链上信用评分系统</li>
                <li>社交恢复机制</li>
                <li>收入代币化模型</li>
                <li>保险池风险分担</li>
            </ul>
        </div>

        <h3 id="risk-management">7.4 风险管理与清算机制</h3>
        
        <h4>7.4.1 清算的核心机制</h4>
        <div class="formula">
            <h4>关键参数定义</h4>
            <ul>
                <li><strong>LTV (Loan-to-Value)：</strong>最大借款价值比 = 借款金额 / 抵押品价值</li>
                <li><strong>清算阈值（Liquidation Threshold）：</strong>触发清算的抵押率</li>
                <li><strong>清算罚金（Liquidation Penalty/Bonus）：</strong>清算者的激励</li>
            </ul>
            
            <p><strong>健康因子（Health Factor）计算：</strong></p>
            <pre>
HF = (Σ Collateral_i × Price_i × LiquidationThreshold_i) / Total Debt Value

当 HF < 1 时，头寸可被清算
            </pre>
        </div>

        <div class="code-block">
            <pre><code class="language-solidity">// 高级清算引擎实现
contract AdvancedLiquidationEngine {
    using SafeMath for uint256;
    
    struct LiquidationParams {
        uint256 debtToCover;        // 需要清算的债务
        uint256 maxCollateralToLiquidate;  // 最大可清算抵押品
        uint256 userCollateralBalance;     // 用户抵押品余额
        uint256 userDebtBalance;           // 用户债务余额
        uint256 liquidationBonus;          // 清算奖励
        uint256 liquidationProtocolFee;    // 协议费用
        uint256 healthFactor;              // 健康因子
    }
    
    // 部分清算实现 - 2024年最佳实践
    function executeLiquidation(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external nonReentrant {
        LiquidationParams memory params = _calculateLiquidationParams(
            collateralAsset,
            debtAsset,
            user,
            debtToCover
        );
        
        // 验证清算条件
        require(params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD, "Health factor not below threshold");
        
        // 计算实际清算金额
        uint256 actualDebtToLiquidate = Math.min(
            params.debtToCover,
            params.maxCollateralToLiquidate.percentMul(LIQUIDATION_CLOSE_FACTOR_PERCENT)
        );
        
        // 执行清算
        _burnDebtTokens(debtAsset, user, actualDebtToLiquidate);
        _transferCollateral(collateralAsset, user, msg.sender, 
            actualDebtToLiquidate.mul(params.liquidationBonus).div(100)
        );
        
        emit LiquidationCall(
            collateralAsset,
            debtAsset,
            user,
            actualDebtToLiquidate,
            params.liquidationBonus,
            msg.sender,
            receiveAToken
        );
    }
}</code></pre>
        </div>

        <h4>7.4.2 预言机风险：DeFi的阿喀琉斯之踵</h4>
        
        <div class="warning-box">
            <h4>预言机类型对比</h4>
            <table style="width: 100%; border-collapse: collapse;">
                <tr>
                    <th style="border: 1px solid #ddd; padding: 8px;">类型</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">延迟</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">成本</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">抗操纵性</th>
                    <th style="border: 1px solid #ddd; padding: 8px;">适用场景</th>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">Chainlink (Pull)</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">1-10分钟</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">中</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">高</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">主流资产</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">Pyth (Push)</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">&lt;1秒</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">低</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">中</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">高频交易</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px;">Uniswap V3 TWAP</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">实时</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">极低</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">依赖流动性</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">链上资产</td>
                </tr>
            </table>
        </div>

        <div class="info-box">
            <h4>案例研究：2020年3月12日 MakerDAO黑色星期四</h4>
            <ul>
                <li><strong>事件：</strong>ETH价格在24小时内下跌50%</li>
                <li><strong>问题：</strong>
                    <ul>
                        <li>预言机延迟导致清算不及时</li>
                        <li>网络拥堵导致Keeper无法参与清算</li>
                        <li>0 DAI拍卖导致400万美元损失</li>
                    </ul>
                </li>
                <li><strong>改进措施：</strong>
                    <ul>
                        <li>引入清算2.0（英式拍卖）</li>
                        <li>增加预言机数量和更新频率</li>
                        <li>实施熔断机制</li>
                    </ul>
                </li>
            </ul>
        </div>

        <h4>7.4.3 坏账处理与协议偿付能力</h4>
        
        <div class="concept">
            <p><strong>坏账定义：</strong>当抵押品价值 < 债务价值时产生的协议损失</p>
            <p><strong>处理机制对比：</strong></p>
        </div>

        <div class="example-box">
            <h4>主流协议的坏账处理机制</h4>
            <ol>
                <li><strong>Aave安全模块（Safety Module）</strong>
                    <ul>
                        <li>用户质押AAVE代币获得收益</li>
                        <li>发生坏账时，最多30%的质押资产被削减（Slashing）</li>
                        <li>提供最后一道防线</li>
                    </ul>
                </li>
                <li><strong>MakerDAO债务拍卖（Debt Auction）</strong>
                    <ul>
                        <li>系统坏账超过盈余缓冲时触发</li>
                        <li>增发MKR代币换取DAI偿还坏账</li>
                        <li>稀释MKR持有者权益作为风险承担</li>
                    </ul>
                </li>
                <li><strong>Compound储备金（Reserves）</strong>
                    <ul>
                        <li>每个市场收取利息的一部分作为储备</li>
                        <li>用于覆盖潜在损失</li>
                        <li>由治理决定储备率</li>
                    </ul>
                </li>
            </ol>
        </div>

        <h4>7.4.4 预言机清算机制深度解析</h4>
        
        <div class="theory-section">
            <h5>预言机在清算中的核心作用</h5>
            <p>预言机是连接链上合约与真实世界价格的桥梁，其准确性和及时性直接决定了清算系统的有效性。</p>
            
            <div class="info-box">
                <h6>清算流程中的预言机交互</h6>
                <ol>
                    <li><strong>价格获取</strong>：合约从预言机读取最新价格</li>
                    <li><strong>健康度计算</strong>：基于预言机价格计算用户仓位健康度</li>
                    <li><strong>清算触发</strong>：健康度低于阈值时允许清算</li>
                    <li><strong>清算定价</strong>：使用预言机价格确定清算资产价值</li>
                    <li><strong>滑点保护</strong>：通过多个预言机源防止价格操纵</li>
                </ol>
            </div>
            
            <h5>预言机攻击向量与防护</h5>
            <div class="warning">
                <h6>主要攻击方式</h6>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr>
                        <th style="border: 1px solid #ddd; padding: 8px;">攻击类型</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">描述</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">防护措施</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">案例</th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">闪电贷操纵</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">在单个交易内操纵DEX价格影响预言机</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">TWAP、多源聚合、延迟生效</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Harvest Finance ($24M)</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">三明治攻击</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">在清算交易前后操纵价格获利</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">MEV保护、私有内存池</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">多个小型协议</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">预言机延迟套利</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">利用链上/链下价格差异</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">快速更新、熔断机制</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Venus Protocol</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">多链攻击</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">在一条链操纵价格影响另一条链</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">独立预言机、跨链验证</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">Multichain事件</td>
                    </tr>
                </table>
            </div>
            
            <h5>高级预言机架构设计</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">多层预言机聚合器实现 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-solidity">// 高级预言机聚合器 - 用于清算系统
contract AdvancedOracleAggregator {
    using SafeMath for uint256;
    
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;  // 价格置信度 0-10000 (100%)
        uint8 decimals;
    }
    
    struct OracleSource {
        address oracle;
        uint256 weight;      // 权重
        uint256 maxDeviation; // 最大偏差容忍度
        bool isActive;
        OracleType oracleType;
    }
    
    enum OracleType {
        CHAINLINK,
        PYTH,
        UNISWAP_TWAP,
        BAND,
        CUSTOM
    }
    
    mapping(address => OracleSource[]) public assetOracles;
    mapping(address => PriceData) public cachedPrices;
    
    uint256 public constant STALENESS_PERIOD = 3600; // 1小时
    uint256 public constant MIN_SOURCES = 3;         // 最少3个源
    uint256 public constant DEVIATION_THRESHOLD = 500; // 5%偏差阈值
    
    // 获取清算价格 - 保守估值
    function getLiquidationPrice(address asset) external view returns (uint256) {
        PriceData[] memory prices = _fetchAllPrices(asset);
        require(prices.length >= MIN_SOURCES, "Insufficient oracle sources");
        
        // 检查价格时效性
        _validateFreshness(prices);
        
        // 检测异常值
        uint256[] memory validPrices = _filterOutliers(prices);
        
        // 使用加权中位数而非平均数（更抗操纵）
        uint256 medianPrice = _calculateWeightedMedian(validPrices);
        
        // 对于清算，使用保守估值（减少5%）
        return medianPrice.mul(9500).div(10000);
    }
    
    // 检测价格异常
    function _filterOutliers(PriceData[] memory prices) 
        private 
        pure 
        returns (uint256[] memory) 
    {
        uint256 avgPrice = _calculateAverage(prices);
        uint256[] memory validPrices = new uint256[](prices.length);
        uint256 validCount = 0;
        
        for (uint i = 0; i < prices.length; i++) {
            uint256 deviation = _calculateDeviation(prices[i].price, avgPrice);
            
            // 剔除偏差超过阈值的价格
            if (deviation <= DEVIATION_THRESHOLD) {
                validPrices[validCount] = prices[i].price;
                validCount++;
            }
        }
        
        // 至少需要2/3的价格源有效
        require(validCount >= prices.length.mul(2).div(3), "Too many outliers");
        
        return validPrices;
    }
    
    // 紧急熔断机制
    function emergencyPause(address asset) external onlyGuardian {
        // 当检测到价格异常波动时暂停该资产的清算
        emit OraclePaused(asset, block.timestamp);
    }
}

// 清算引擎集成预言机
contract OracleIntegratedLiquidationEngine {
    IAdvancedOracleAggregator public oracleAggregator;
    
    struct LiquidationConfig {
        uint256 liquidationThreshold;   // 清算阈值
        uint256 liquidationPenalty;     // 清算罚金
        uint256 minHealthFactor;        // 最小健康因子
        uint256 priceBuffer;            // 价格缓冲（防止预言机小幅波动）
    }
    
    mapping(address => LiquidationConfig) public configs;
    
    // 计算健康因子时的预言机使用
    function calculateHealthFactor(address user, address[] memory assets) 
        public 
        view 
        returns (uint256) 
    {
        uint256 totalCollateralValue = 0;
        uint256 totalDebtValue = 0;
        
        for (uint i = 0; i < assets.length; i++) {
            // 获取保守的清算价格
            uint256 price = oracleAggregator.getLiquidationPrice(assets[i]);
            
            // 应用额外的价格缓冲
            price = price.mul(10000 - configs[assets[i]].priceBuffer).div(10000);
            
            uint256 userBalance = getUserBalance(user, assets[i]);
            
            if (isCollateral[assets[i]]) {
                totalCollateralValue = totalCollateralValue.add(
                    userBalance.mul(price).div(10**assetDecimals[assets[i]])
                );
            } else {
                totalDebtValue = totalDebtValue.add(
                    userBalance.mul(price).div(10**assetDecimals[assets[i]])
                );
            }
        }
        
        if (totalDebtValue == 0) return type(uint256).max;
        
        return totalCollateralValue.mul(100).div(totalDebtValue);
    }
    
    // 防MEV清算执行
    function executeLiquidationWithMEVProtection(
        address targetUser,
        address collateralAsset,
        address debtAsset,
        uint256 debtToCover
    ) external {
        // 1. 验证清算者资格（白名单/质押要求）
        require(isApprovedLiquidator(msg.sender), "Not approved liquidator");
        
        // 2. 使用commit-reveal防止抢跑
        bytes32 commitHash = keccak256(
            abi.encodePacked(targetUser, collateralAsset, debtAsset, debtToCover, nonce)
        );
        require(liquidationCommits[commitHash] + REVEAL_DELAY < block.timestamp, 
                "Reveal too early");
        
        // 3. 执行清算时再次验证价格
        uint256 currentPrice = oracleAggregator.getLiquidationPrice(collateralAsset);
        uint256 healthFactor = calculateHealthFactor(targetUser, getActiveAssets());
        
        require(healthFactor < configs[collateralAsset].liquidationThreshold, 
                "Position healthy");
        
        // 4. 执行清算
        _performLiquidation(targetUser, collateralAsset, debtAsset, debtToCover);
    }
}</code></pre>
                </div>
            </div>
            
            <h5>预言机故障应急响应</h5>
            <div class="theory-box">
                <h6>分级响应机制</h6>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr>
                        <th style="border: 1px solid #ddd; padding: 8px;">故障等级</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">触发条件</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">自动响应</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">影响范围</th>
                    </tr>
                    <tr style="background: #fffbeb;">
                        <td style="border: 1px solid #ddd; padding: 8px;">⚠️ 黄色警报</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">单个预言机延迟>5分钟</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">切换备用源</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">无影响</td>
                    </tr>
                    <tr style="background: #fef3c7;">
                        <td style="border: 1px solid #ddd; padding: 8px;">🟠 橙色警报</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">价格偏差>5%或2个源失效</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">提高清算阈值5%</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">新开仓限制</td>
                    </tr>
                    <tr style="background: #fee2e2;">
                        <td style="border: 1px solid #ddd; padding: 8px;">🔴 红色警报</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">价格偏差>10%或多数源失效</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">暂停清算15分钟</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">全面限制</td>
                    </tr>
                    <tr style="background: #1f2937; color: white;">
                        <td style="border: 1px solid #ddd; padding: 8px;">⚫ 黑色警报</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">所有预言机失效</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">紧急关停模式</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">协议冻结</td>
                    </tr>
                </table>
            </div>
            
            <h5>实战案例：预言机清算优化</h5>
            <div class="code-block">
                <div class="code-header" onclick="toggleCode(this)">动态清算参数调整系统 <span class="toggle-icon">▼</span></div>
                <div class="code-content" style="display: none;">
                    <pre><code class="language-python"># 基于市场条件的动态清算参数调整
import numpy as np
from typing import Dict, List, Tuple

class DynamicLiquidationOptimizer:
    """根据市场波动性和预言机状态动态调整清算参数"""
    
    def __init__(self):
        self.base_params = {
            'liquidation_threshold': 0.8,    # 80%基础清算阈值
            'liquidation_penalty': 0.05,     # 5%基础清算罚金
            'close_factor': 0.5,             # 50%最大清算比例
            'price_buffer': 0.02             # 2%价格缓冲
        }
        
        # 历史数据窗口
        self.volatility_window = 24 * 7  # 7天
        self.oracle_health_window = 1    # 1小时
        
    def calculate_market_risk_score(
        self, 
        price_history: List[float],
        volume_history: List[float],
        liquidation_history: List[Dict]
    ) -> float:
        """计算当前市场风险评分（0-100）"""
        
        # 1. 价格波动性评分（权重40%）
        volatility = np.std(price_history) / np.mean(price_history)
        volatility_score = min(volatility * 200, 40)  # 标准化到0-40
        
        # 2. 流动性评分（权重30%）
        avg_volume = np.mean(volume_history)
        recent_volume = np.mean(volume_history[-24:])  # 最近24小时
        liquidity_score = 30 * (1 - min(recent_volume / avg_volume, 1))
        
        # 3. 清算压力评分（权重30%）
        recent_liquidations = sum(1 for l in liquidation_history 
                                 if l['timestamp'] > time.time() - 3600)
        liquidation_score = min(recent_liquidations * 3, 30)
        
        return volatility_score + liquidity_score + liquidation_score
    
    def assess_oracle_reliability(
        self,
        oracle_responses: List[Dict]
    ) -> Dict[str, float]:
        """评估预言机可靠性"""
        
        reliability_metrics = {
            'response_time': [],
            'price_deviation': [],
            'update_frequency': []
        }
        
        for response in oracle_responses:
            # 响应时间
            reliability_metrics['response_time'].append(
                response['response_time']
            )
            
            # 价格偏差（与其他源比较）
            reliability_metrics['price_deviation'].append(
                response['deviation_from_median']
            )
            
            # 更新频率
            reliability_metrics['update_frequency'].append(
                response['updates_per_hour']
            )
        
        # 计算可靠性分数
        reliability_score = (
            (1 - np.mean(reliability_metrics['response_time']) / 1000) * 0.3 +
            (1 - np.mean(reliability_metrics['price_deviation'])) * 0.5 +
            min(np.mean(reliability_metrics['update_frequency']) / 60, 1) * 0.2
        )
        
        return {
            'score': reliability_score,
            'metrics': reliability_metrics
        }
    
    def optimize_liquidation_params(
        self,
        market_risk_score: float,
        oracle_reliability: float
    ) -> Dict[str, float]:
        """基于风险评分优化清算参数"""
        
        # 风险调整因子
        risk_multiplier = 1 + (market_risk_score / 100) * 0.5
        oracle_multiplier = 2 - oracle_reliability  # 可靠性越低，参数越保守
        
        optimized_params = {
            'liquidation_threshold': max(
                self.base_params['liquidation_threshold'] / 
                (risk_multiplier * oracle_multiplier),
                0.5  # 最低50%
            ),
            'liquidation_penalty': min(
                self.base_params['liquidation_penalty'] * 
                (1 + market_risk_score / 200),
                0.15  # 最高15%
            ),
            'close_factor': max(
                self.base_params['close_factor'] / risk_multiplier,
                0.25  # 最低25%
            ),
            'price_buffer': min(
                self.base_params['price_buffer'] * 
                (risk_multiplier * oracle_multiplier),
                0.1  # 最高10%
            )
        }
        
        return optimized_params
    
    def simulate_liquidation_cascade(
        self,
        initial_liquidation: float,
        market_depth: float,
        correlation_matrix: np.ndarray
    ) -> List[Dict]:
        """模拟清算级联效应"""
        
        cascade_events = []
        current_impact = initial_liquidation
        
        while current_impact > market_depth * 0.01:  # 影响超过1%深度
            # 计算价格影响
            price_impact = current_impact / market_depth
            
            # 计算连带清算
            correlated_liquidations = 0
            for i, correlation in enumerate(correlation_matrix):
                threshold_breach = price_impact * correlation[0]
                if threshold_breach > 0.2:  # 20%阈值
                    correlated_liquidations += threshold_breach * market_depth
            
            cascade_events.append({
                'round': len(cascade_events) + 1,
                'liquidation_volume': current_impact,
                'price_impact': price_impact,
                'correlated_liquidations': correlated_liquidations
            })
            
            current_impact = correlated_liquidations
            
            # 防止无限循环
            if len(cascade_events) > 10:
                break
        
        return cascade_events

# 实时监控和预警系统
class OracleMonitoringSystem:
    """预言机健康度实时监控"""
    
    def __init__(self):
        self.alert_thresholds = {
            'price_deviation': 0.05,      # 5%偏差
            'response_delay': 60,         # 60秒延迟
            'consecutive_failures': 3,    # 连续3次失败
            'stale_price_age': 300       # 5分钟陈旧
        }
        
        self.alert_handlers = {
            'low': self.handle_low_severity,
            'medium': self.handle_medium_severity,
            'high': self.handle_high_severity,
            'critical': self.handle_critical
        }
    
    def check_oracle_health(self, oracle_data: Dict) -> Dict:
        """全面健康检查"""
        health_report = {
            'status': 'healthy',
            'issues': [],
            'severity': 'none',
            'recommended_actions': []
        }
        
        # 检查各项指标
        checks = [
            self.check_price_deviation(oracle_data),
            self.check_response_time(oracle_data),
            self.check_data_freshness(oracle_data),
            self.check_consensus(oracle_data)
        ]
        
        # 汇总问题
        for check in checks:
            if check['issue']:
                health_report['issues'].append(check)
                health_report['severity'] = max(
                    health_report['severity'], 
                    check['severity'],
                    key=lambda x: ['none', 'low', 'medium', 'high', 'critical'].index(x)
                )
        
        if health_report['severity'] != 'none':
            health_report['status'] = 'unhealthy'
            health_report['recommended_actions'] = self.generate_recommendations(
                health_report['issues']
            )
        
        return health_report
</code></pre>
                </div>
            </div>
            
            <div class="warning">
                <h6>⚠️ 关键教训：预言机设计原则</h6>
                <ol>
                    <li><strong>冗余性</strong>：永远不要依赖单一预言机源</li>
                    <li><strong>时效性</strong>：设置合理的价格过期时间</li>
                    <li><strong>异常检测</strong>：实施价格偏差和操纵检测</li>
                    <li><strong>熔断机制</strong>：极端情况下的自动暂停</li>
                    <li><strong>激励对齐</strong>：确保预言机提供者的长期激励</li>
                </ol>
            </div>
        </div>
        
        <h4>7.4.5 量化风险建模（AI科学家专题）</h4>
        
        <div class="info-box">
            <h4>基于智能体的风险仿真</h4>
            <p>Gauntlet、Chaos Labs等公司为DeFi协议提供的服务：</p>
            <ul>
                <li><strong>蒙特卡洛模拟：</strong>模拟数万种市场情景</li>
                <li><strong>智能体建模：</strong>模拟不同类型参与者行为</li>
                <li><strong>参数优化：</strong>使用机器学习优化风险参数</li>
            </ul>
        </div>

        <div class="code-block">
            <pre><code class="language-python"># 风险参数优化示例（Python）
import numpy as np
from scipy.optimize import minimize
import pandas as pd

class DeFiRiskOptimizer:
    """
    基于历史数据和市场模拟的风险参数优化器
    """
    def __init__(self, historical_data, protocol_params):
        self.data = historical_data
        self.params = protocol_params
        
    def simulate_liquidations(self, ltv, liquidation_threshold, volatility_scenario):
        """模拟不同参数下的清算情况"""
        simulated_prices = self.generate_price_paths(volatility_scenario)
        liquidations = []
        
        for price_path in simulated_prices:
            health_factors = self.calculate_health_factors(
                price_path, ltv, liquidation_threshold
            )
            liquidation_events = (health_factors < 1.0).sum()
            liquidations.append(liquidation_events)
            
        return np.array(liquidations)
    
    def objective_function(self, params):
        """
        优化目标：最大化资本效率，同时控制坏账风险
        """
        ltv, liquidation_threshold = params
        
        # 资本效率得分
        capital_efficiency = ltv
        
        # 风险得分（坏账概率）
        bad_debt_prob = self.calculate_bad_debt_probability(
            ltv, liquidation_threshold
        )
        
        # 综合目标函数
        return -(capital_efficiency * (1 - bad_debt_prob))
    
    def optimize_parameters(self):
        """使用约束优化找到最优参数"""
        constraints = [
            {'type': 'ineq', 'fun': lambda x: x[1] - x[0] - 0.05},  # 清算阈值 > LTV + 5%
            {'type': 'ineq', 'fun': lambda x: 0.95 - x[0]},        # LTV < 95%
            {'type': 'ineq', 'fun': lambda x: x[0] - 0.5},         # LTV > 50%
        ]
        
        result = minimize(
            self.objective_function,
            x0=[0.75, 0.85],  # 初始值：LTV=75%, 清算阈值=85%
            method='SLSQP',
            constraints=constraints
        )
        
        return result.x

# 使用示例
optimizer = DeFiRiskOptimizer(historical_data, protocol_params)
optimal_ltv, optimal_threshold = optimizer.optimize_parameters()
print(f"优化后的LTV: {optimal_ltv:.2%}")
print(f"优化后的清算阈值: {optimal_threshold:.2%}")</code></pre>
        </div>

        <div class="example-box">
            <h4>思考题：AI驱动的动态风险管理</h4>
            <p>设计一个AI模型，根据以下输入实时调整协议的风险参数：</p>
            <ul>
                <li>市场波动性（实时和历史）</li>
                <li>资产相关性矩阵</li>
                <li>链上流动性深度</li>
                <li>宏观经济指标</li>
                <li>社交媒体情绪分析</li>
            </ul>
            <p>考虑：如何平衡模型复杂度与链上执行成本？如何确保模型的可解释性？</p>
        </div>

        <h3 id="stablecoin-considerations">7.5 稳定币在借贷协议中的特殊考虑</h3>
        
        <div class="info-box">
            <h4>稳定币的独特风险特征</h4>
            <ul>
                <li><strong>脱锚风险（Depeg Risk）：</strong>
                    <ul>
                        <li>算法稳定币：高风险，可能完全崩溃（如UST）</li>
                        <li>法币抵押稳定币：中低风险，但存在监管风险</li>
                        <li>超额抵押稳定币：依赖于抵押品和清算机制</li>
                    </ul>
                </li>
                <li><strong>流动性集中：</strong>稳定币往往是借贷需求最大的资产</li>
                <li><strong>系统性风险传导：</strong>一个稳定币的问题可能影响整个生态</li>
            </ul>
        </div>

        <div class="code-block">
            <pre><code class="language-solidity">// 稳定币风险隔离机制
contract StablecoinRiskIsolation {
    // 稳定币特殊参数
    mapping(address => StablecoinConfig) public stablecoinConfigs;
    
    struct StablecoinConfig {
        uint256 supplyCap;           // 供应上限
        uint256 borrowCap;           // 借款上限
        uint256 maxExposure;         // 最大敞口（占总TVL百分比）
        uint256 pegDeviationThreshold; // 脱锚阈值
        address[] acceptedCollaterals; // 可接受的抵押品
        bool emergencyPaused;        // 紧急暂停
    }
    
    // 稳定币健康度监控
    function checkStablecoinHealth(address stablecoin) public view returns (bool) {
        uint256 currentPrice = oracle.getPrice(stablecoin);
        uint256 pegDeviation = abs(int256(currentPrice) - int256(1e18)) * 100 / 1e18;
        
        if (pegDeviation > stablecoinConfigs[stablecoin].pegDeviationThreshold) {
            return false; // 触发风险控制
        }
        
        uint256 currentExposure = getProtocolExposure(stablecoin);
        if (currentExposure > stablecoinConfigs[stablecoin].maxExposure) {
            return false; // 敞口过大
        }
        
        return true;
    }
    
    // 自动风险响应
    function autoRiskResponse(address stablecoin) external {
        if (!checkStablecoinHealth(stablecoin)) {
            // 1. 提高该稳定币的借款利率
            _adjustInterestRate(stablecoin, 150); // +50%
            
            // 2. 降低LTV
            _adjustLTV(stablecoin, 50); // -50%
            
            // 3. 如果严重脱锚，暂停借贷
            uint256 currentPrice = oracle.getPrice(stablecoin);
            if (currentPrice < 0.95e18 || currentPrice > 1.05e18) {
                stablecoinConfigs[stablecoin].emergencyPaused = true;
                emit EmergencyPause(stablecoin, currentPrice);
            }
        }
    }
}</code></pre>
        </div>

        <h3>练习题</h3>
        
        <div class="exercise">
            <h4>练习 7.1：实现高级闪电贷套利机器人（Foundry框架）</h4>
            <p>使用Foundry框架实现一个能在Uniswap V2和Curve之间执行套利的闪电贷机器人。要求：</p>
            <ul>
                <li>实现价差检测逻辑</li>
                <li>计算最优套利金额（考虑滑点和手续费）</li>
                <li>实现原子性套利执行</li>
                <li>添加利润验证和安全检查</li>
                <li>包含完整的Foundry测试套件</li>
                <li>考虑极端市场条件的断路器</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-1')">查看参考答案</button>
            <div id="answer7-1" class="answer">
                <pre><code class="language-solidity">contract DynamicRateModel {
    using SafeMath for uint256;
    
    // PID控制器参数
    uint256 public constant Kp = 1e16;  // 比例系数
    uint256 public constant Ki = 1e15;  // 积分系数
    uint256 public constant Kd = 5e15;  // 微分系数
    
    // 市场数据
    IPriceOracle public marketDataOracle;
    uint256 public targetUtilization = 0.85e18;
    
    // 状态变量
    uint256 public lastError;
    uint256 public integral;
    uint256 public lastUpdateTime;
    
    // 速率限制
    uint256 public constant MAX_RATE_CHANGE = 0.001e18;  // 每次最多0.1%
    uint256 public constant UPDATE_INTERVAL = 1 hours;
    
    function updateInterestRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) external returns (uint256) {
        require(
            block.timestamp >= lastUpdateTime + UPDATE_INTERVAL,
            "Too soon to update"
        );
        
        uint256 utilization = borrows.mul(1e18).div(
            cash.add(borrows).sub(reserves)
        );
        
        // PID计算
        int256 error = int256(targetUtilization) - int256(utilization);
        integral = integral.add(uint256(error > 0 ? error : -error));
        int256 derivative = error - int256(lastError);
        
        int256 output = int256(Kp).mul(error).div(1e18)
            .add(int256(Ki).mul(int256(integral)).div(1e18))
            .add(int256(Kd).mul(derivative).div(1e18));
        
        // 获取市场基准利率
        uint256 marketRate = marketDataOracle.getMarketRate();
        uint256 newRate = uint256(int256(marketRate) + output);
        
        // 应用速率限制
        uint256 currentRate = getCurrentRate();
        if (newRate > currentRate) {
            newRate = Math.min(
                newRate,
                currentRate.add(MAX_RATE_CHANGE)
            );
        } else {
            newRate = Math.max(
                newRate,
                currentRate.sub(MAX_RATE_CHANGE)
            );
        }
        
        // 更新状态
        lastError = uint256(error > 0 ? error : -error);
        lastUpdateTime = block.timestamp;
        
        return newRate;
    }
}</code></pre>
            </div>
        </div>

        <div class="exercise">
            <h4>练习 7.2：防御闪电贷攻击</h4>
            <p>实现一个能够抵御闪电贷价格操纵的借贷协议：</p>
            <ul>
                <li>使用TWAP（时间加权平均价格）</li>
                <li>实现延迟价格更新机制</li>
                <li>添加异常检测逻辑</li>
                <li>设计紧急暂停机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-2')">查看参考答案</button>
            <div id="answer7-2" class="answer">
                <pre><code class="language-solidity">contract FlashLoanResistantLending {
    using FixedPoint for *;
    
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 cumulativePrice;
        uint256 priceCount;
    }
    
    mapping(address => PriceData) public priceHistory;
    uint256 public constant TWAP_PERIOD = 30 minutes;
    uint256 public constant PRICE_DEVIATION_THRESHOLD = 0.1e18;  // 10%
    
    modifier checkPriceManipulation(address asset) {
        uint256 currentPrice = IPriceOracle(oracle).getPrice(asset);
        uint256 twapPrice = getTWAPPrice(asset);
        
        uint256 deviation = currentPrice > twapPrice
            ? currentPrice.sub(twapPrice).mul(1e18).div(twapPrice)
            : twapPrice.sub(currentPrice).mul(1e18).div(twapPrice);
            
        require(
            deviation < PRICE_DEVIATION_THRESHOLD,
            "Price manipulation detected"
        );
        _;
    }
    
    function getTWAPPrice(address asset) public view returns (uint256) {
        PriceData memory data = priceHistory[asset];
        require(data.priceCount > 0, "No price history");
        
        uint256 timeElapsed = block.timestamp - data.timestamp;
        if (timeElapsed < TWAP_PERIOD) {
            return data.price;  // Not enough time passed
        }
        
        return data.cumulativePrice.div(data.priceCount);
    }
    
    function updatePrice(address asset) external {
        uint256 currentPrice = IPriceOracle(oracle).getPrice(asset);
        PriceData storage data = priceHistory[asset];
        
        // 累积价格用于TWAP计算
        data.cumulativePrice = data.cumulativePrice.add(currentPrice);
        data.priceCount = data.priceCount.add(1);
        
        // 重置TWAP窗口
        if (block.timestamp - data.timestamp > TWAP_PERIOD) {
            data.price = data.cumulativePrice.div(data.priceCount);
            data.cumulativePrice = currentPrice;
            data.priceCount = 1;
            data.timestamp = block.timestamp;
        }
    }
    
    function liquidate(
        address borrower,
        address collateralAsset,
        address debtAsset
    ) external checkPriceManipulation(collateralAsset) {
        // 使用TWAP价格进行清算计算
        uint256 collateralPrice = getTWAPPrice(collateralAsset);
        uint256 debtPrice = getTWAPPrice(debtAsset);
        
        // 清算逻辑...
    }
}</code></pre>
            </div>
        </div>

        <div class="exercise">
            <h4>练习 7.3：实现隔离池机制</h4>
            <p>设计一个隔离池系统，将高风险资产与主池隔离：</p>
            <ul>
                <li>实现多池架构</li>
                <li>设计跨池借贷限制</li>
                <li>实现风险评级系统</li>
                <li>添加池间资金调配机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-3')">查看参考答案</button>
            <div id="answer7-3" class="answer">
                <pre><code class="language-solidity">contract IsolatedLendingPools {
    enum RiskTier { STABLE, MEDIUM, HIGH, ISOLATED }
    
    struct Pool {
        mapping(address => uint256) reserves;
        mapping(address => RiskTier) assetRiskTier;
        uint256 totalLiquidity;
        uint256 totalBorrowed;
        bool crossPoolBorrowingEnabled;
    }
    
    mapping(uint256 => Pool) public pools;
    mapping(address => uint256) public userPrimaryPool;
    mapping(address => mapping(uint256 => bool)) public userPoolAccess;
    
    // 风险参数
    mapping(RiskTier => uint256) public maxLTV;
    mapping(RiskTier => uint256) public liquidationThreshold;
    
    constructor() {
        maxLTV[RiskTier.STABLE] = 0.9e18;  // 90%
        maxLTV[RiskTier.MEDIUM] = 0.75e18;  // 75%
        maxLTV[RiskTier.HIGH] = 0.5e18;  // 50%
        maxLTV[RiskTier.ISOLATED] = 0.3e18;  // 30%
        
        liquidationThreshold[RiskTier.STABLE] = 0.95e18;
        liquidationThreshold[RiskTier.MEDIUM] = 0.85e18;
        liquidationThreshold[RiskTier.HIGH] = 0.7e18;
        liquidationThreshold[RiskTier.ISOLATED] = 0.5e18;
    }
    
    function createIsolatedPool(
        address asset,
        RiskTier riskTier
    ) external onlyOwner returns (uint256 poolId) {
        poolId = uint256(keccak256(abi.encodePacked(asset, block.timestamp)));
        Pool storage pool = pools[poolId];
        pool.assetRiskTier[asset] = riskTier;
        pool.crossPoolBorrowingEnabled = (riskTier != RiskTier.ISOLATED);
    }
    
    function depositToPool(
        uint256 poolId,
        address asset,
        uint256 amount
    ) external {
        Pool storage pool = pools[poolId];
        require(pool.assetRiskTier[asset] != RiskTier(0), "Asset not in pool");
        
        IERC20(asset).transferFrom(msg.sender, address(this), amount);
        pool.reserves[asset] += amount;
        pool.totalLiquidity += amount;
        
        userPoolAccess[msg.sender][poolId] = true;
    }
    
    function borrowFromPool(
        uint256 poolId,
        address asset,
        uint256 amount
    ) external {
        Pool storage pool = pools[poolId];
        require(userPoolAccess[msg.sender][poolId], "No pool access");
        
        // 检查隔离池限制
        if (pool.assetRiskTier[asset] == RiskTier.ISOLATED) {
            require(
                userPrimaryPool[msg.sender] == 0 || 
                userPrimaryPool[msg.sender] == poolId,
                "Cannot borrow from multiple isolated pools"
            );
            userPrimaryPool[msg.sender] = poolId;
        }
        
        // 计算允许借款额度
        uint256 collateralValue = getUserCollateralValue(msg.sender, poolId);
        uint256 maxBorrow = collateralValue.mul(
            maxLTV[pool.assetRiskTier[asset]]
        ).div(1e18);
        
        require(amount <= maxBorrow, "Exceeds borrow limit");
        
        pool.reserves[asset] -= amount;
        pool.totalBorrowed += amount;
        IERC20(asset).transfer(msg.sender, amount);
    }
    
    // 跨池资金调配
    function rebalancePools(
        uint256 fromPoolId,
        uint256 toPoolId,
        address asset,
        uint256 amount
    ) external onlyOwner {
        Pool storage fromPool = pools[fromPoolId];
        Pool storage toPool = pools[toPoolId];
        
        require(
            fromPool.assetRiskTier[asset] <= toPool.assetRiskTier[asset],
            "Cannot move to higher risk pool"
        );
        
        fromPool.reserves[asset] -= amount;
        toPool.reserves[asset] += amount;
    }
}</code></pre>
            </div>
        </div>

        <div class="exercise">
            <h4>练习 7.4：实现收益率优化器</h4>
            <p>创建一个自动优化稳定币收益的策略合约：</p>
            <ul>
                <li>比较多个借贷协议的利率</li>
                <li>自动迁移资金到最高收益协议</li>
                <li>考虑Gas成本和滑点</li>
                <li>实现紧急撤出机制</li>
            </ul>
            
            <button onclick="toggleAnswer('answer7-4')">查看参考答案</button>
            <div id="answer7-4" class="answer">
                <pre><code class="language-solidity">contract YieldOptimizer {
    using SafeERC20 for IERC20;
    
    struct Strategy {
        address protocol;
        uint256 allocation;
        uint256 lastAPY;
        bool active;
    }
    
    IERC20 public stablecoin;
    Strategy[] public strategies;
    uint256 public rebalanceThreshold = 0.005e18;  // 0.5%
    uint256 public minRebalanceInterval = 6 hours;
    uint256 public lastRebalanceTime;
    
    // Gas成本考虑
    uint256 public gasPrice = 20 gwei;
    uint256 public estimatedGasPerStrategy = 200000;
    
    function findOptimalAllocation() public view returns (
        uint256[] memory allocations,
        uint256 expectedAPY
    ) {
        uint256 strategyCount = strategies.length;
        allocations = new uint256[](strategyCount);
        
        // 获取当前APY
        uint256[] memory apys = new uint256[](strategyCount);
        for (uint256 i = 0; i < strategyCount; i++) {
            if (strategies[i].active) {
                apys[i] = ILendingProtocol(strategies[i].protocol).getAPY();
            }
        }
        
        // 简单策略：分配到最高APY
        uint256 maxAPY = 0;
        uint256 maxIndex = 0;
        for (uint256 i = 0; i < strategyCount; i++) {
            if (apys[i] > maxAPY) {
                maxAPY = apys[i];
                maxIndex = i;
            }
        }
        
        // 考虑Gas成本
        uint256 totalBalance = stablecoin.balanceOf(address(this));
        uint256 rebalanceCost = gasPrice.mul(estimatedGasPerStrategy).mul(2);
        uint256 minProfitableAmount = rebalanceCost.mul(365 days).div(maxAPY);
        
        if (totalBalance > minProfitableAmount) {
            allocations[maxIndex] = totalBalance;
            expectedAPY = maxAPY;
        }
        
        return (allocations, expectedAPY);
    }
    
    function rebalance() external {
        require(
            block.timestamp >= lastRebalanceTime + minRebalanceInterval,
            "Too soon to rebalance"
        );
        
        (uint256[] memory newAllocations, uint256 newAPY) = findOptimalAllocation();
        
        // 检查是否值得重新平衡
        uint256 currentAPY = calculateCurrentAPY();
        uint256 improvement = newAPY > currentAPY
            ? newAPY.sub(currentAPY).mul(1e18).div(currentAPY)
            : 0;
            
        require(improvement > rebalanceThreshold, "Not worth rebalancing");
        
        // 执行重新平衡
        _executeRebalance(newAllocations);
        lastRebalanceTime = block.timestamp;
    }
    
    function _executeRebalance(uint256[] memory newAllocations) internal {
        // 1. 撤出所有资金
        for (uint256 i = 0; i < strategies.length; i++) {
            if (strategies[i].allocation > 0) {
                ILendingProtocol(strategies[i].protocol).withdrawAll();
                strategies[i].allocation = 0;
            }
        }
        
        // 2. 重新分配
        uint256 balance = stablecoin.balanceOf(address(this));
        for (uint256 i = 0; i < strategies.length; i++) {
            if (newAllocations[i] > 0) {
                uint256 amount = balance.mul(newAllocations[i]).div(balance);
                stablecoin.safeApprove(strategies[i].protocol, amount);
                ILendingProtocol(strategies[i].protocol).deposit(amount);
                strategies[i].allocation = amount;
            }
        }
    }
    
    // 紧急撤出
    function emergencyWithdraw() external onlyOwner {
        for (uint256 i = 0; i < strategies.length; i++) {
            if (strategies[i].allocation > 0) {
                try ILendingProtocol(strategies[i].protocol).withdrawAll() {
                    strategies[i].allocation = 0;
                } catch {
                    // 记录失败但继续
                    emit WithdrawFailed(strategies[i].protocol);
                }
            }
        }
        
        uint256 balance = stablecoin.balanceOf(address(this));
        stablecoin.safeTransfer(owner(), balance);
    }
}</code></pre>
            </div>
        </div>

        <h3>术语表</h3>
        <table class="reference-table">
            <tr>
                <th>术语</th>
                <th>定义</th>
                <th>重要性</th>
            </tr>
            <tr>
                <td>cToken</td>
                <td>Compound协议的计息代币，代表在协议中的存款份额</td>
                <td>核心机制，实现利息自动累积</td>
            </tr>
            <tr>
                <td>利用率（Utilization Rate）</td>
                <td>借出资金占总资金池的比例</td>
                <td>决定利率的关键参数</td>
            </tr>
            <tr>
                <td>跳跃率模型（Jump Rate Model）</td>
                <td>在特定利用率阈值后利率急剧上升的模型</td>
                <td>防止流动性枯竭</td>
            </tr>
            <tr>
                <td>闪电贷（Flash Loan）</td>
                <td>在同一交易内借入和归还的无抵押贷款</td>
                <td>套利和清算的重要工具</td>
            </tr>
            <tr>
                <td>健康因子（Health Factor）</td>
                <td>抵押品价值与债务价值的加权比率</td>
                <td>触发清算的关键指标</td>
            </tr>
            <tr>
                <td>准备金率（Reserve Factor）</td>
                <td>利息收入中分配给协议金库的比例</td>
                <td>协议可持续性的保障</td>
            </tr>
            <tr>
                <td>E-Mode</td>
                <td>Aave的效率模式，为相关资产提供更高的资本效率</td>
                <td>稳定币对的优化机制</td>
            </tr>
            <tr>
                <td>隔离模式（Isolation Mode）</td>
                <td>将高风险资产隔离，限制其作为抵押品的使用</td>
                <td>风险管理创新</td>
            </tr>
            <tr>
                <td>TWAP</td>
                <td>时间加权平均价格，抵御价格操纵</td>
                <td>闪电贷攻击防御</td>
            </tr>
            <tr>
                <td>收益聚合器（Yield Aggregator）</td>
                <td>自动在不同协议间优化收益的智能合约</td>
                <td>DeFi组合性的体现</td>
            </tr>
        </table>
    
            
            <!-- 章节导航 -->
            <div class="chapter-nav">
                <a href="chapter6.html">← 第6章</a>
                <a href="chapter8.html">第8章 →</a>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="script.js"></script>
</body>
</html>